<!--                                                                      -->
<!--                                                                      -->
<!-- Generated by Semifore, Inc. csrCompile                               -->
<!--    HTML output                                                       -->
<html>
 <head>
  <title>Addressmap Information for 'DW_apb_ssi'</title>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
  <meta http-equiv="Expires" content="0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
   /*
    * Copyright (c) SEMIFORE, INC. 2006-2015. All rights reserved.
    *
    * This software and documentation constitute an unpublished work and
    * contain valuable trade secrets and proprietary information belonging
    * to Semifore, Inc.  None of the foregoing material may be copied,
    * duplicated or disclosed without the express written permission of
    * Semifore, Inc.
    * SEMIFORE, INC. EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING
    * THIS SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF
    * MERCHANTABILITY AND/OR FITNESS FOR ANY PARTICULAR PURPOSE,
    * AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY THAT
    * MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
    * TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT
    * TO THE USE OF THE SOFTWARE OR DOCUMENTATION.
    * Under no circumstances shall Semifore, Inc. be liable for incidental,
    * special, indirect, direct or consequential damages or loss of profits,
    * interruption of business, or related expenses which may arise from use
    * of this software or documentation, including but not limited to those
    * resulting from defects in software and/or documentation, or loss or
    * inaccuracy of data of any kind.
   */
   
   /*
    * csrStyles.css
    *
    * $Revision: 1.20 $
    * $Date: 2015/09/06 01:23:08 $
    *
    * @(#)$Id: csrStyles.css,v 1.20 2015/09/06 01:23:08 weber Exp $
    *
    * These are the CSS Styles attributes for the HTML pages
    *
   */
   
   body {
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   	margin: 0px;
           text-align: left;
           padding: 0px;
   	color: #4f6b72;
   	background-color: #e7e7e7;
   }
   
   a {
   	color: #c75f3e;
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   
   
   
   }
   
   div {
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   }
   
   table {
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   	background-color: #fff;
   
   
   	border-collapse: collapse;
   	margin-top: 2px;
   	margin-bottom: 2px;
   }
   
   
   th {
   	font: bold 7pt  Arial, Helvetica, sans-serif;
   	color: #4f6b72;
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   
   	letter-spacing: 1px;
   	text-align: left;
   	padding: 6px 6px 6px 12px;
   	background-color: #CAE8EA;
   }
   
   th.component {
           background-color: #FFCCFF;
   }
   
   th.addressmap {
           background-color: #CAE8EA;
   }
   
   th.register {
   	background-color: #CCFFCC;
   }
   
   th.group {
   	background-color: #FFFFCC;
   }
   
   th.union {
   	background-color: #CCCC00;
   }
   
   th.wideregister {
   	background-color: #FFCCCC;
   }
   
   th.memory {
   	background-color: #CCCCFF;
   }
   
   th.widememory {
   	background-color: #FF88FF;
   }
   
   th.submemory {
   	background-color: #CCCCFF;
   }
   
   th.field {
   	background-color: #CCFFFF;
   }
   
   
   td {
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   	background-color: #fff;
   	padding: 6px 6px 6px 12px;
   	color: #4f6b72;
   	text-align: left;
   }
   
   td.noborder {
   	border-right: 0px none #C1DAD7;
   	border-left: 0px none #C1DAD7;
   	border-bottom: 0px none #C1DAD7;
   	border-top: 0px none #C1DAD7;
   	background-color: #FFF;
   	text-align: left;
   }
   
   .addrMapClass
   {
   }
   
   
   .addrMapContent
   {
   }
   
   .frdiv {
   	float: right;
   }
   
   .fldiv {
   	float: left;
   	margin-right: 10px;
   }
   
   .window 
   {
     background-color: white; 
     border-color:  #7BA7E1;
     border-style: solid; 
     border-width: 1px;
     margin: 0px;
     padding: 0px;
     position: absolute;
     visibility: hidden;
   }
   
   .windowTitleBar 
   {
     background-color: #7BA7E1;
     border-style: none;
     color: white;
     font: bold 11pt auto  Arial, Helvetica, sans-serif;	
     margin-left: 6px;
     margin-right: 6px;
   }
   
   .windowList 
   {
     background-color: white;
     border-style: none; 
     border-width: 0px;
     margin: 0px;
     padding: 2px;
     position: absolute;
     left: 10px;
     top: 100px;
     width: 100px;
     height: 200px;
     visibility: hidden;
   }
   
   .windowListArea 
   {
     background-color: white;
     border-style: none; 
     border-width: 0px;
     text-align: center;
     margin: 0px 0px 0px 0px;
     overflow: auto;
     
   }
  </style>
  <script type="text/javascript">
   /*
    * Copyright (c) SEMIFORE, INC. 2006-2018. All rights reserved.
    *
    * This software and documentation constitute an unpublished work and
    * contain valuable trade secrets and proprietary information belonging
    * to Semifore, Inc.  None of the foregoing material may be copied,
    * duplicated or disclosed without the express written permission of
    * Semifore, Inc.
    * SEMIFORE, INC. EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING
    * THIS SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF
    * MERCHANTABILITY AND/OR FITNESS FOR ANY PARTICULAR PURPOSE,
    * AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY THAT
    * MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
    * TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT
    * TO THE USE OF THE SOFTWARE OR DOCUMENTATION.
    * Under no circumstances shall Semifore, Inc. be liable for incidental,
    * special, indirect, direct or consequential damages or loss of profits,
    * interruption of business, or related expenses which may arise from use
    * of this software or documentation, including but not limited to those
    * resulting from defects in software and/or documentation, or loss or
    * inaccuracy of data of any kind.
   */
   
   /*
    * csrJava.js
    *
    * $Revision: 1.75 $
    * $Date: 2018/02/22 02:35:02 $
    *
    * @(#)$Id: csrJava.js,v 1.75 2018/02/22 02:35:02 weber Exp $
    *
    * These are the Java Script functions for the HTML pages.
    *
   */
   
   var xmlDoc                   = 0;
   var debug                    = 0;
   var def_lookup_table         = new Array();
   var object_array             = new Array();
   var topDefinition_array      = new Array();
   var topObjectRefNames_array  = new Array();
   var definitions_array        = new Array();
   var csrNode_array            = new Array();
   var globalShowFileInfo       = false;
   var globalShowHeaderFileInfo = false;
   var globalShowEnumInfo       = false;
   var fileInfoDiv              = null;
   
   function csrNode() {
     this.referenceType = 0;
     this.referenceName = 0;
     this.definitionPtr = 0;
     this.objectIndex   = 0;
     this.divParent     = 0;
     this.divChild      = 0;
     this.visibility    = 0;
     this.addressMapWindow = 0;
     
     this.click = function() {
       if ( this.visibility == 0 )
       {
         //      alert('open ' + this.referenceName);
         printDefinition(this);
         this.visibility = 1;
         
         // window.location.hash = this.referenceName + 'Link';
         // if (mouseposy > 700 ) scrollBy(0,100);
       } else
       {
         //      alert('close' +  this.referenceName);
         this.divParent.removeChild(this.divChild);
         this.visibility = 0;
   
         //window.location.hash = this.referenceName + 'Link';
         
       }
     }
   
     this.expand = function() {
       if ( this.visibility == 0 )
       this.click();
     }
   
     this.collapse = function() {
       if (this.visibility == 1 )
       this.click();
     }
   
     this.showFileInfo = function () {
        return globalShowFileInfo;
     }
   
     this.showHeaderFileInfo = function () {
        return globalShowHeaderFileInfo;
     }
   
     this.showEnumInfo = function () {
        return globalShowEnumInfo;
     }
   }
   
   //debug alrets
   function alertd( msg ) 
   {
     if (debug) 
       alert(msg);
   }
   
   var mouseposx = 0;
   var mouseposy = 0;
   
   function getMousePos(e) {
     
   	if (!e) var e = window.event;
   	
   	if (e.pageX || e.pageY) 	{
   		mouseposx = e.pageX;
   		mouseposy = e.pageY;
   	}
   	else if (e.clientX || e.clientY) 	{
   		mouseposx = e.clientX + document.body.scrollLeft
   			+ document.documentElement.scrollLeft;
   		mouseposy = e.clientY + document.body.scrollTop
   			+ document.documentElement.scrollTop;
   	}
   }
   
   function redrawAll ()
   {
      var topObject;
   
      for (var i=0; i < topObjectRefNames_array.length; i++) {
         topObject = csrNodeLookup(i,topObjectRefNames_array[i]);
         if (topObject != null) {
            topObject.click();
            topObject.click();
         }
      }
   }
   
   function globalFileInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalFileInfoCheckBox');
   
      if (checkbox != null) {
         globalShowFileInfo = checkbox.checked;
   
         if (globalShowFileInfo) {
            printFileInfo();
         }
         else {
            var docinfo = document.getElementById('docinfo');
            if ((docinfo != null) && (fileInfoDiv != null)) {
               docinfo.removeChild(fileInfoDiv);
            }
         }
         redrawAll();
      }
   }
   
   function globalHeaderFileInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalHeaderFileInfoCheckBox');
   
      if (checkbox != null) {
         globalShowHeaderFileInfo = checkbox.checked;
         redrawAll();
      }
   }
   
   function globalEnumInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalEnumInfoCheckBox');
   
      if (checkbox != null) {
         globalShowEnumInfo = checkbox.checked;
         redrawAll();
      }
   }
   
   //import XML
   function importXML(xmlId)
   {
      xmlDoc = document.getElementById(xmlId);
      if (xmlDoc) {
         init();
      }
   }
   
   
   //parser helpers
   function getNodes_tag(node, tag)
   {
      return node.getElementsByTagName('csr:' + tag);
   }
   
   function getNodeValue_tag(node, tag)
   {
      var nodelist;
   
      nodelist = node.getElementsByTagName('csr:' + tag);
      if (nodelist.length > 0) {
         if (nodelist[0].firstChild) {
            return nodelist[0].firstChild.nodeValue;
         }
         else {
            return '';
         }
      }
      else {
         return '';
      }
   }
   
   function getNodeValue(node)
   {
     for (var i=0; node[0].childNodes.length; i++ )
       {
         
         if (node[0].childNodes[i].nodeType != 1) continue;
         return node[0].childNodes[i].firstChild.nodeValue
   
       }
   }
   
   function getNodeValue_description(node) 
   {
     var description = getNodes_tag(node,'description');
   
     if (description.length < 1)
       return '';
   
     var ptags = getNodes_tag(description[0],'p');
     var ret_string = '';
     
     for (var i=0; i < ptags.length; i++) {
        if (ptags[i].firstChild) {
           ret_string += '<p>' + ptags[i].firstChild.nodeValue + '</p>';
        }
        else {
           ret_string += '<p></p>';
        }
     }
     
     return ret_string;
   }
   
   function getNodeValue_attributes(node)
   {
      var attributesTag = getNodes_tag(node,'attributes');
   
      if (attributesTag.length < 1)
         return '';
      var attributeTags = getNodes_tag(attributesTag[0],'attribute');
      var result = '';
      var i;
   
      for (i=0; i < attributeTags.length; i++) {
         if (attributeTags[i].firstChild) {
            result += attributeTags[i].firstChild.nodeValue + '<br>';
         }
      }
   
      return result;
   }
   
   function getNodeValue_fieldAttributes(node)
   {
      var attributesTag = getNodes_tag(node,'fieldAttributes');
   
      if (attributesTag.length < 1)
         return '';
      var attributeTags = getNodes_tag(attributesTag[0],'attribute');
      var result = '';
      var i;
   
      for (i=0; i < attributeTags.length; i++) {
         if (attributeTags[i].firstChild) {
            result += attributeTags[i].firstChild.nodeValue + '<br>';
         }
      }
   
      return result;
   }
   
   function init() 
   {
     setGlobals();
   
     if (globalShowFileInfo) {
        printFileInfo();
     }
     
     printTopObjects();
     
   }
   
   function printHeader() 
   {
     header = document.getElementById('docheader');
     //header.innerHTML = "Header Text Goes Here";
   }
   
   
   function printFooter() 
   {
     footer = document.getElementById('docfooter');
     //footer.innerHTML = "Footer Text Goes Here";
   }
   
   
   function setGlobals() 
   {
     var checkbox;
   
     alertd(xmlDoc);
   
     checkbox = document.getElementById('globalFileInfoCheckBox');
     if (checkbox != null) {
        globalShowFileInfo = checkbox.checked;
     }
     checkbox = document.getElementById('globalHeaderFileInfoCheckBox');
     if (checkbox != null) {
        globalShowHeaderFileInfo = checkbox.checked;
     }
     checkbox = document.getElementById('globalEnumInfoCheckBox');
     if (checkbox != null) {
        globalShowEnumInfo = checkbox.checked;
     }
   
     // get the object elements
     object_array = getNodes_tag(xmlDoc,'csrObject');
     alertd('number of object_array elements=' + object_array.length);
   
     // create 2D lookup table array
     for (var i=0; i < object_array.length; i++)
       {
         def_lookup_table[i] = new Object();
         csrNode_array[i] = new Object();
       }
   
     // get the top definition elements
     for (var i=0; i < object_array.length; i++ )
       {
         topDefinition_array[i] = getNodes_tag(object_array[i],'topDefinition'); 
       }
     alertd('number of topDefinition_array elements=' + topDefinition_array.length);
   
     // get the referenece names of the top level modules
     for (var i=0; i < topDefinition_array.length; i++)
       {
         topObjectRefNames_array[i] = getNodeValue(topDefinition_array[i]);
         alertd('topObjectRefNames_array[' + i + ']=' + topObjectRefNames_array[i]);
       }
     
      
     // get definition elements
     for (var i=0; i < object_array.length; i++) 
       {
         definitions_array[i] = getNodes_tag(object_array[i],'definition');
       }
     alertd('number of definitions_array element=' + definitions_array.length);
     //alertd('definitions_array[0] =' + definitions_array[0].length + ' elements');
   
     // populate the definitions lookup table
     for ( var i=0; i < object_array.length; i++) 
       {
         for (var j=0; j < definitions_array[i].length; j++)
   	{
   	  referenceName = getNodeValue_tag(definitions_array[i][j], "referenceName");
   	  referenceType = getNodeValue_tag(definitions_array[i][j], "referenceType");
   	  def_lookup_table[i][referenceName] = definitions_array[i][j];
   	  
   	  var csrNode_obj = new csrNode();
   
   	  csrNode_obj.referenceName = referenceName;
   	  csrNode_obj.referenceType = referenceType;
   	  csrNode_obj.definitionPtr = definitions_array[i][j];
   	  csrNode_obj.objectIndex   = i;
   	  
   	  csrNode_array[i][referenceName] = csrNode_obj;
   	}
       
       }
   }
   
   
   function printFileInfo()
   {
      var docinfo = document.getElementById('docinfo');
   
      if (docinfo != null) {
         var inputFilesNodes = getNodes_tag(xmlDoc,'inputFiles');
         var includedFilesNodes = getNodes_tag(xmlDoc,'includedFiles');
         var configurationFilesNodes = getNodes_tag(xmlDoc,'configurationFiles');
         var fileNodes;
         var filename;
         var fileversionNodes;
         var table;
         var body;
         var row;
         var cell;
   
         fileInfoDiv = document.createElement('DIV');
   
         if (inputFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Input Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(inputFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         if (includedFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Included Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(includedFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         if (configurationFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Configuration Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(configurationFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         docinfo.appendChild(fileInfoDiv);
      }
   }
   
   function printTopObjects()
   {
     var csrNode;
     //print top level modules
     for ( var i=0; i < topObjectRefNames_array.length; i++)
       {
         csrNode = csrNodeLookup(i,topObjectRefNames_array[i]);
         if (csrNode.referenceType == 'component') {
            printTopComponentTable(csrNode);
         }
         else {
            printTopAddressmapTable(csrNode);
         }
         csrNode.expand();
       }
   }
   
   function csrNodeLookup(objectIndex, referenceName)
   {
      return csrNode_array[objectIndex][referenceName];
   }
   
   function printDefinition(csrNode)
   {
     
     referenceType = csrNode.referenceType;
   
     //case  
     switch (referenceType) 
       {
       case "component":
         printComponentDefinition(csrNode);
         break;
       case "addressmap":
         printAddressmapDefinition(csrNode);
         break;
       case "group":
         printGroupDefinition(csrNode);
         break;
       case "union":
         printUnionDefinition(csrNode);
         break;
       case "register":
         printRegisterDefinition(csrNode);
         break;
       case "wideregister":
         printWideRegisterDefinition(csrNode);
         break;
       case "memory":
         printMemoryDefinition(csrNode);
         break;
       case "widememory":
         printWideMemoryDefinition(csrNode);
         break;
       default:
         alertd('No default referenceType!');
       }
   }
   
   function printLeafDefinition(csrNode) 
   {
     referenceName_array = csrNode.referenceName.split(".");
   
     //print the def top down
     var parent_ref = '';
     for( var i = 0; i < referenceName_array.length; i++ )
       {
         var refName    = parent_ref + referenceName_array[i];
         var csrNode = csrNodeLookup(csrNode.objectIndex, refName);
         //if ( csrNodeObj.visibility == 0 )
         csrNode.expand();
         parent_ref = refName + '.';
       }
   
     //jump the window the the leaf link
     window.location.hash = '#' + csrNode.referenceName + 'Link';
   
     //move the address map so it remains onscreen
     var parent_ref = '';
     for( var i = 0; i < referenceName_array.length; i++ )
       {
         var refName    = parent_ref + referenceName_array[i];
         var csrNode = csrNodeLookup(csrNode.objectIndex, refName);
         //if ( csrNodeObj.visibility == 0 )
         if (csrNode.addressMapWindow) {
            csrNode.addressMapWindow.window.style.top =
               document.body.scrollTop + 25; 
         }
         parent_ref = refName + '.';
       }
   
   
     //highlight the div
     //highLightDiv(csrNode.referenceName);
     unhighLightDiv(csrNode.referenceName);
   
   }
   
   
   function printTopComponentTable(csrNode)
   {
   
     var xmlNode = csrNode.definitionPtr;
     //div to enclose module
     var moduleDiv     = document.createElement('DIV');
     var referenceName = csrNode.referenceName;
     var referenceType = csrNode.referenceType;
     var identifier    = getNodeValue_tag(xmlNode,"identifier");
   
     //set the div ID to the referenceName
     moduleDiv.id      = referenceName;
   
     csrNode.divParent = moduleDiv;
   
   
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
     var row = document.createElement('TR');
   
     var container     = document.createElement('TH');
     var theData       = document.createElement("div");
     theData.innerHTML = referenceType; 
     container.appendChild(theData);
     container.className = referenceType;
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'Link';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'ExpandAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'ExpandAllLink" onclick="expandAllNodes(' + csrNode.objectIndex + ');">' + 'expand all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   	
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'CollapseAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'CollapseAllLink" onclick="collapseAllNodes(' + csrNode.objectIndex + ');">' + 'collapse all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     tmp.appendChild(row);
   
     //add elements to DOM
     moduleDiv.appendChild(tableEl);
     document.getElementById('docroot').appendChild(moduleDiv);
   }
   
   
   function printTopAddressmapTable(csrNode)
   {
   
     var xmlNode = csrNode.definitionPtr;
     //div to enclose module
     var moduleDiv     = document.createElement('DIV');
     var referenceName = csrNode.referenceName;
     var referenceType = csrNode.referenceType;
     var identifier    = getNodeValue_tag(xmlNode,"identifier");
   
     //set the div ID to the referenceName
     moduleDiv.id      = referenceName;
   
     csrNode.divParent = moduleDiv;
   
   
     var tableEl = document.createElement('TABLE');
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
     var row = document.createElement('TR');
   
     var container     = document.createElement('TH');
     var theData       = document.createElement("div");
     theData.innerHTML = referenceType; 
     container.appendChild(theData);
     container.className = csrNode.referenceType;
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'Link';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'AddrMapLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'AddrMapLink" onclick="printAddressMap(' + csrNode.objectIndex + ',\'' + referenceName + '\');">' + 'address map' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
     
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'ExpandAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'ExpandAllLink" onclick="expandAllNodes(' + csrNode.objectIndex + ');">' + 'expand all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   	
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'CollapseAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'CollapseAllLink" onclick="collapseAllNodes(' + csrNode.objectIndex + ');">' + 'collapse all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     tmp.appendChild(row);
   
     //add elements to DOM
     moduleDiv.appendChild(tableEl);
     document.getElementById('docroot').appendChild(moduleDiv);
   }
   
   
   function printComponentDefinition(csrNode) 
   {
     var xmlNode = csrNode.definitionPtr;
     var componentDefContentDiv = document.createElement('DIV');
     componentDefContentDiv.style.marginLeft = "25px";
     componentDefContentDiv.id = csrNode.divParent.id+ 'DefContentDiv';
   
     csrNode.divChild = componentDefContentDiv;
   
     var identifier          = getNodeValue_tag(xmlNode,"identifier");
     var title               = getNodeValue_tag(xmlNode,"title");
     var description         = getNodeValue_description(xmlNode);
     var filename            = getNodeValue_tag(xmlNode,"filename");
     var linenumber          = getNodeValue_tag(xmlNode,"linenumber");
     var attributes          = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        if (filename != '') {
           tableData_array['Filename'] = filename;
        }
        if (linenumber != '') {
           tableData_array['Linenumber'] = linenumber;
        }
     }
     printRefInfoTable( tableData_array, componentDefContentDiv, csrNode);
     
     csrNode.divParent.appendChild( componentDefContentDiv );
   
     printComponentReference_links( csrNode );
   
   }
   
   function printAddressmapDefinition(csrNode) 
   {
     var xmlNode = csrNode.definitionPtr;
     var moduleDefContentDiv = document.createElement('DIV');
     moduleDefContentDiv.style.marginLeft = "25px";
     //moduleDefContentDiv.id = domParentNode.id + 'DefContentDiv';
     moduleDefContentDiv.id = csrNode.divParent.id+ 'DefContentDiv';
   
     csrNode.divChild = moduleDefContentDiv;
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var addressmapReference =
                           getNodeValue_tag(xmlNode,"addressmapReference");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (addressmapReference != '') {
        tableData_array['Reference']  = addressmapReference;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        if (filename != '') {
           tableData_array['Filename'] = filename;
        }
        if (linenumber != '') {
           tableData_array['Linenumber'] = linenumber;
        }
     }
     if (csrNode.showHeaderFileInfo()) {
        if (addressMacro != '') {
           tableData_array['Address Macro'] = addressMacro;
        }
        if (offsetMacro != '') {
           tableData_array['Offset Macro'] = offsetMacro;
        }
        if (typeName != '') {
           tableData_array['Type Name'] = typeName;
        }
     }
   
     printRefInfoTable( tableData_array, moduleDefContentDiv, csrNode);
     
     csrNode.divParent.appendChild( moduleDefContentDiv );
   
     printReference_links( csrNode );
   
   }
   
   
   function printReference_links(csrNode) {
   
    
     var objectIndex = csrNode.objectIndex;
     xmlNode         = csrNode.definitionPtr;
   
     var references = getNodes_tag(xmlNode,'reference');
   
     for (var i=0; i < references.length; i++ )
       {
         
         var referenceType = getNodeValue_tag(references[i],"referenceType");
         var referenceName = getNodeValue_tag(references[i],"referenceName");
   
         referencedCsrNode = csrNodeLookup(objectIndex, referenceName);
         var identifier    =
             getNodeValue_tag(referencedCsrNode.definitionPtr,"identifier");
   
         var referenceDiv  = document.createElement('DIV');
         referenceDiv.id = referenceName;
         var tableData_array = new Array();
   
         tableData_array[referenceType] = '<a id="' + referenceName + 'Link" name="'+ referenceName + 'Link" ' + 'href="javascript:void(0);" onclick="csrNodeLookup(' + objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
   
         //set parent of referenced node
         referencedCsrNode.divParent = referenceDiv;
   
         printRefInfoTable( tableData_array, referenceDiv, referencedCsrNode);
   
         csrNode.divChild.appendChild(referenceDiv);
     
         if ( referencedCsrNode.visibility == 1 )
   	printDefinition(referencedCsrNode);
       }
   }
   
   
   function printComponentReference_links(csrNode) {
   
    
     var objectIndex = csrNode.objectIndex;
     xmlNode         = csrNode.definitionPtr;
     var table;
     var body;
     var row;
     var cell;
     var theData;
     var theLink;
   
     var references = getNodes_tag(xmlNode,'reference');
   
     for (var i=0; i < references.length; i++ )
       {
         
         var referenceType = getNodeValue_tag(references[i],"referenceType");
         var referenceName = getNodeValue_tag(references[i],"referenceName");
   
         referencedCsrNode = csrNodeLookup(objectIndex, referenceName);
         var identifier    =
             getNodeValue_tag(referencedCsrNode.definitionPtr,"identifier");
   
         var referenceDiv  = document.createElement('DIV');
         referenceDiv.id = referenceName;
         var tableData_array = new Array();
   
         table = document.createElement('TABLE');
         body = document.createElement('TBODY');
         row = document.createElement('TR');
   
         cell              = document.createElement('TH');
         theData           = document.createElement("div");
         theData.innerHTML = referenceType; 
         cell.appendChild(theData);
         cell.className = referenceType;
         row.appendChild(cell);
   
         cell              = document.createElement('TD');
         theLink           = document.createElement("div");
         theLink.id        = referenceName + 'Link';
         theLink.innerHTML = '<a id="' + referenceName + 'Link" href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
         cell.appendChild(theLink) 
         row.appendChild(cell);
   
         cell              = document.createElement('TD');
         theLink           = document.createElement("div");
         theLink.id        = referenceName + 'AddrMapLink';
         theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'AddrMapLink" onclick="printAddressMap(' + csrNode.objectIndex + ',\'' + referenceName + '\');">' + 'address map' + '</a>';
         cell.appendChild(theLink) 
         row.appendChild(cell);
   
         body.appendChild(row);
         table.appendChild(body);
         referenceDiv.appendChild(table);
   
         //set parent of referenced node
         referencedCsrNode.divParent = referenceDiv;
   
         csrNode.divChild.appendChild(referenceDiv);
     
         if ( referencedCsrNode.visibility == 1 )
   	printDefinition(referencedCsrNode);
       }
   }
   
   function printGroupDefinition(csrNode)
   {
   
     var groupReferenceName        = csrNode.referenceName;
     var groupParentDiv            = document.getElementById(groupReferenceName);
     
     csrNode.divParent = groupParentDiv;
     var xmlNode = csrNode.definitionPtr;
   
     var groupDiv                  = document.createElement('DIV');
     groupDiv.id               = groupParentDiv.id + "child";
     groupDiv.style.marginLeft = "25px";
     
     csrNode.divChild = groupDiv;
   
     groupParentDiv.appendChild(groupDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayMax        = getNodeValue_tag(xmlNode,"arrayMax");
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']   = filename;
        tableData_array['Linenumber'] = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, groupDiv, csrNode);
   
   
     printReference_links(csrNode);
   
   }
   
   function printUnionDefinition(csrNode)
   {
   
     var unionReferenceName        = csrNode.referenceName;
     var unionParentDiv            = document.getElementById(unionReferenceName);
     
     csrNode.divParent = unionParentDiv;
     var xmlNode = csrNode.definitionPtr;
   
     var unionDiv                  = document.createElement('DIV');
     unionDiv.id               = unionParentDiv.id + "child";
     unionDiv.style.marginLeft = "25px";
     
     csrNode.divChild = unionDiv;
   
     unionParentDiv.appendChild(unionDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayMax        = getNodeValue_tag(xmlNode,"arrayMax");
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
       tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']   = filename;
        tableData_array['Linenumber'] = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, unionDiv, csrNode);
   
     printReference_links(csrNode);
   
   }
   
   function printRegisterDefinition(csrNode) 
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var aliasOf         = getNodeValue_tag(xmlNode,"aliasOf");
     var aliases         = getNodes_tag(xmlNode,'aliases');
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"registerResetValue");
     var resetMask       = getNodeValue_tag(xmlNode,"registerResetMask");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var isVolatile      = getNodeValue_tag(xmlNode,"volatile");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (aliasOf != '') {
        tableData_array['Alias Of'] = '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasOf + '\'));">' + aliasOf + '</a>';
     }
     if (aliases.length > 0) {
        var aliasList = getNodes_tag(aliases[0],'alias');
        var aliasesString = '';
        var aliasValue;
        if (aliasList[0].firstChild) {
              aliasValue = aliasList[0].firstChild.nodeValue;
              aliasesString += '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasValue + '\'));">' + aliasValue + '</a>';
        }
        for ( var i=1; i < aliasList.length; i++ ) {
           if (aliasList[i].firstChild) {
              aliasValue = aliasList[i].firstChild.nodeValue;
              aliasesString += '<br>';
              aliasesString += '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasValue + '\'));">' + aliasValue + '</a>';
           }
        }
        tableData_array['Aliases'] = aliasesString;
     }
     if (isVolatile != '') {
        tableData_array['Volatile'] = ((isVolatile == 'true') ? '1': '0');
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if ((resetValue != '') && (resetMask != '')) {
        tableData_array['Reset Mask'] = resetMask;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printCsrBitFields( csrNode );
   
   }
   
   function printCsrBitFields( csrNode )
   {
     var xmlNode = csrNode.definitionPtr;
    
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
     var fieldsHaveClockDomains =
        (getNodeValue_tag(xmlNode, "clockDomains") == 'true');
     var fieldsHaveSynchronizer =
        (getNodeValue_tag(xmlNode, "synchronizers") == 'true');
     var fieldsHaveAttributes =
        (getNodeValue_tag(xmlNode, "fieldsHaveAttributes") == 'true');
     var headers;
   
   //Header Row
     headers = ['Identifier', 'Title', 'Bit', 'Access', 'Reset'];
     if (fieldsHaveClockDomains) {
        headers.push('Clock Domain');
     }
     if (fieldsHaveSynchronizer) {
        headers.push('Synchronizer');
     }
     if (fieldsHaveAttributes) {
        headers.push('Attributes');
     }
     headers.push('Description');
   
     var row           = document.createElement('TR');
     for ( var i=0; i<headers.length; i++ ) 
       {
        
         var container     = document.createElement('TH');
         var theData       = document.createElement('DIV');
         theData.innerHTML = headers[i];
         container.className = csrNode.referenceType;
         container.appendChild(theData);
         row.appendChild(container);
       }
     tmp.appendChild(row);
   
     var bitfields = getNodes_tag(xmlNode,'bitfield');
   
     
   
     for ( var i=0; i < bitfields.length; i++ )
       {
         var identifier  = getNodeValue_tag(bitfields[i],"identifier");
         var title       = getNodeValue_tag(bitfields[i],"title");
         var msb         = getNodeValue_tag(bitfields[i],"msb");
         var lsb         = getNodeValue_tag(bitfields[i],"lsb");
   
         if (msb == lsb) 
   	var bit         = '[' + msb + ']';
         else 
   	var bit         = '[' + msb + ':' + lsb +']';
         
   
         var access      = getNodeValue_tag(bitfields[i],"access");
         var reset       = getNodeValue_tag(bitfields[i],"resetValue");
         var description = getNodeValue_description(bitfields[i]);
         var attributes  = getNodeValue_fieldAttributes(bitfields[i]);
   
         var clockDomain    = getNodeValue_tag(bitfields[i],"clockDomain");
         var synchronizer   = getNodeValue_tag(bitfields[i],"synchronizer");
   
         var widthMacro     = getNodeValue_tag(bitfields[i],"widthMacro");
         var msbMacro       = getNodeValue_tag(bitfields[i],"msbMacro");
         var lsbMacro       = getNodeValue_tag(bitfields[i],"lsbMacro");
         var rangeMacro     = getNodeValue_tag(bitfields[i],"rangeMacro");
         var resetMacro     = getNodeValue_tag(bitfields[i],"resetMacro");
         var getMacro       = getNodeValue_tag(bitfields[i],"getMacro");
         var setMacro       = getNodeValue_tag(bitfields[i],"setMacro");
   
         var filename       = getNodeValue_tag(bitfields[i],"filename");
         var linenumber     = getNodeValue_tag(bitfields[i],"linenumber");
         var enums          = getNodes_tag(bitfields[i], "enumeration");
   
         var row_data;
   
         row_data = [identifier, title, bit, access.toUpperCase(), reset];
         if (fieldsHaveClockDomains) {
            row_data.push(clockDomain);
         }
         if (fieldsHaveSynchronizer) {
            row_data.push(synchronizer);
         }
         if (fieldsHaveAttributes) {
            row_data.push(attributes);
         }
         row_data.push(description);
         row         = document.createElement('TR');
         
         for ( var j=0; j<row_data.length; j++ ) {
            var container     = document.createElement('TD');
            var theData       = document.createElement('DIV');
            theData.innerHTML = row_data[j];
            container.appendChild(theData);
            row.appendChild(container);
         }
         tmp.appendChild(row);
   
         //FIX ME SNPS title check not cool (there for reserved fields)
         if (
            (
               csrNode.showFileInfo() ||
               csrNode.showHeaderFileInfo() ||
               (csrNode.showEnumInfo() && enums && (enums.length > 0))
               ) &&
            (title != "-") &&
            (csrNode.referenceType != 'wideregister')
            ) {
            row         = document.createElement('TR');
            var container     = document.createElement('TD');
            container.colSpan = row_data.length;
            container.style.backgroundColor = "#e7e7e7";
           
            if (csrNode.showFileInfo()) {
              var tableData_array = new Array();
              var theData       = document.createElement('DIV');
              theData.className = "fldiv";
              tableData_array['Filename']   = filename;
              tableData_array['Linenumber'] = linenumber;
              printRefInfoTable(tableData_array, theData, csrNode);
              container.appendChild(theData);
            }
   
            if (csrNode.showHeaderFileInfo()) {
              var tableData_array = new Array();
              var theData       = document.createElement('DIV');
              theData.className = "fldiv";
              tableData_array['Width Macro']   = widthMacro;
              tableData_array['Range Macro']   = rangeMacro;
              tableData_array['Msb Macro']     = msbMacro;
              tableData_array['Lsb Macro']     = lsbMacro;
              tableData_array['Reset Macro']   = resetMacro;
              tableData_array['Set Macro']     = setMacro;
              tableData_array['Get Macro']     = getMacro;
              printRefInfoTable(tableData_array, theData, csrNode);
              container.appendChild(theData);
            }
   
            if (csrNode.showEnumInfo() && enums && (enums.length > 0)) {
              var enumDiv = printFieldEnumTable(csrNode, enums);
              container.appendChild(enumDiv);
            }
   
            row.appendChild(container);
   
            tmp.appendChild(row);
         }
         
   
         
       }
     
     csrNode.divChild.appendChild(tableEl);
     
   }
   
   function printFieldEnumTable( csrNode, enums )
   {
     var enumDiv       = document.createElement('DIV');
     enumDiv.className = "fldiv";
     var table = document.createElement('TABLE');
     var body = document.createElement('TBODY');
   
     var titles = (getNodeValue_tag(enums[0], "titles") == 'true');
     var descriptions = (getNodeValue_tag(enums[0], "descriptions") == 'true');
     var hasPartialAccess =
        (getNodeValue_tag(enums[0], "enumeratorsHavePartialAccess") == 'true');
   
     var headerCells = [];
     if (titles) {
        headerCells.push('Title');
     }
     headerCells.push('Identifier');
     headerCells.push('Value');
     if (hasPartialAccess) {
        headerCells.push('Access')
     }
     if (descriptions) {
        headerCells.push('Description')
     }
   
     var headerRow = document.createElement('TR');
     for ( var i=0; i < headerCells.length; i++ ) {
       var container     = document.createElement('TH');
       var theData       = document.createElement('DIV');
       theData.innerHTML = headerCells[i];
       container.appendChild(theData);
       container.className = csrNode.referenceType;
       container.className = 'field';
       headerRow.appendChild(container);
     }
     body.appendChild(headerRow);
   
     var enumerators = getNodes_tag(enums[0], "enumerator");
     for (var e=0; e < enumerators.length; e++) {
       var row = document.createElement('TR');
       var identifier = getNodeValue_tag(enumerators[e], "identifier");
       var value = getNodeValue_tag(enumerators[e], "value");
       var title;
       var description;
       var access;
       var cells = [];
       if (titles) {
         title = getNodeValue_tag(enumerators[e], "title");
         cells.push(title);
       }
       cells.push(identifier);
       cells.push(value);
       if (hasPartialAccess) {
         access = getNodeValue_tag(enumerators[e], "enumeratorAccess");
         cells.push(access);
       }
       if (descriptions) {
         description = getNodeValue_tag(enumerators[e], "description");
         cells.push(description);
       }
         
       for ( var i=0; i < cells.length; i++ ) {
         var container     = document.createElement('TD');
         var theData       = document.createElement('DIV');
         theData.innerHTML = cells[i];
         container.appendChild(theData);
         row.appendChild(container);
       }
       body.appendChild(row);
     }
   
     table.appendChild(body);
     enumDiv.appendChild(table);
     return enumDiv;
   }
   
   function printWideRegisterDefinition( csrNode )
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"resetValue");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var isVolatile      = getNodeValue_tag(xmlNode,"volatile");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier'] = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions']     = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (isVolatile != '') {
        tableData_array['Volatile'] = ((isVolatile == 'true') ? "1": "0");
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printCsrBitFields( csrNode );
   
     printReference_links( csrNode );
     
   
   }
   
   function printMemoryDefinition(csrNode) 
   {
     var memoryReferenceName = csrNode.referenceName;
     var memoryParentDiv     = document.getElementById(memoryReferenceName);
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = memoryParentDiv;
   
     var memoryDiv              = document.createElement('DIV');
   
     memoryDiv.id               = memoryParentDiv.id + "child";
     memoryDiv.style.marginLeft = "25px";
     csrNode.divChild = memoryDiv;
     memoryParentDiv.appendChild(memoryDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"resetValue");
     var resetMask       = getNodeValue_tag(xmlNode,"resetMask");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var memoryWidth     = getNodeValue_tag(xmlNode,"memoryWidth");
     var memoryWordCount = getNodeValue_tag(xmlNode,"memoryWordCount");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (memoryWidth != '') {
        tableData_array['Width'] = memoryWidth;
     }
     if (memoryWordCount != '') {
        tableData_array['Word Count'] = memoryWordCount;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if ((resetValue != '') && (resetMask != '')) {
        tableData_array['Reset Mask'] = resetMask;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, memoryDiv, csrNode);
   
     printReference_links(csrNode);
   }
   
   function printWideMemoryDefinition( csrNode )
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var memoryWidth     = getNodeValue_tag(xmlNode,"memoryWidth");
     var memoryWordCount = getNodeValue_tag(xmlNode,"memoryWordCount");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier'] = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions']     = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (memoryWidth != '') {
        tableData_array['Width'] = memoryWidth;
     }
     if (memoryWordCount != '') {
        tableData_array['Word Count'] = memoryWordCount;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printReference_links( csrNode );
   
   }
   
   
   function printRefInfoTable( refArray, domParentNode, csrNode ) 
   {
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
   
     for ( var type in refArray )
       {
         var row = document.createElement('TR');
         
         //headings
         var container = document.createElement('TH');
         //     var theData   = document.createTextNode(node);
         var theData = document.createElement('DIV');
         theData.innerHTML = type;
   
         container.className = csrNode.referenceType;
   
         container.appendChild(theData);
         row.appendChild(container);
         
         //values
         container     = document.createElement('TD');
         container.className = "noborder";
         //      theData       = document.createTextNode(refArray[type]);
         var theData = document.createElement('DIV');
         theData.innerHTML = refArray[type];
   
         container.appendChild(theData);
         row.appendChild(container);
         
         tmp.appendChild(row);
       }
     
     domParentNode.appendChild(tableEl);
   }
   
   function printAddressMap(objectIndex, referenceName)
   {
     var csrNode;
    
     csrNode = csrNodeLookup(objectIndex, referenceName);
   
     //if window is already open, close it
     if (csrNode.addressMapWindow) {
       if (csrNode.addressMapWindow.opened)
         return;
       else csrNode.addressMapWindow.open()
     }
   
     csrNode.addressMapWindow = new Window( document.body.clientWidth - 625, 25, 600, 400, 'AddrMap' + objectIndex );
   
     var addrMapDiv       = document.createElement('DIV');
     addrMapDiv.id        = 'AddrMap' + objectIndex;
     addrMapDiv.style.marginLeft = "10px";
     addrMapDiv.style.marginRight = "10px";
     addrMapDiv.style.marginTop = "10px";
     addrMapDiv.style.marginBottom = "10px";
   
     
     csrNode.addressMapWindow.changeTitle( 'Address Map for ' + referenceName );
   
     addressMapEntries = getNodes_tag(csrNode.definitionPtr,'addressMapEntry');
   
     alertd('addressMapEntries=' + addressMapEntries.length);
   
     var tableEl = document.createElement('TABLE');
     tableEl.width = "550px";
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
     var headers = ['Address', 'Instance Name'];
   
      var row           = document.createElement('TR');
     for ( var i=0; i<headers.length; i++ ) 
       {
         var container        = document.createElement('TH');
         var theData          = document.createElement('DIV');
         theData.innerHTML    = headers[i];
         container.appendChild(theData);
         row.appendChild(container);
       }
     tmp.appendChild(row);
   
   
     for ( var i=0; i < addressMapEntries.length; i++)
       {
         var print = false;
         var referenceName = getNodeValue_tag(addressMapEntries[i],"referenceName");
         var instanceName  = getNodeValue_tag(addressMapEntries[i],"instanceName");
         var referencedObj = csrNodeLookup(objectIndex, referenceName);
   
   
         var addressLow    = getNodeValue_tag(addressMapEntries[i],"addressLow");
         var addressHigh   = getNodeValue_tag(addressMapEntries[i],"addressHigh");
         
         if (addressLow == addressHigh) 
   	var addressRange = addressHigh;
         else
   	var addressRange = addressLow + ' - ' + addressHigh;
         
         if ( referencedObj ) 
   	{
   	  if (
                (referencedObj.referenceType == "register") ||
                (referencedObj.referenceType == "wideregister") ||
                (referencedObj.referenceType == "memory") ||
                (referencedObj.referenceType == "widememory")
             )
   	    {
   	      print = true;
   	      referenceName = '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + objectIndex + ',\'' + referenceName + '\'));">' + instanceName + '</a>';
   	    }
   	}
         else if ( referenceName == '' )
   	{
   	print = true;
   	referenceName = 'reserved';
   	}
   
         if ( print ) 
   	{
   	  var row_data = [ addressRange, referenceName];
   	  row          = document.createElement('TR');
   	  
   	  for ( var j=0; j<row_data.length; j++ ) 
   	    {
   	      var container     = document.createElement('TD');
   	      var theData       = document.createElement('DIV');
   	      theData.innerHTML = row_data[j];
   	      container.appendChild(theData);
   	      row.appendChild(container);
   	    }
   	  tmp.appendChild(row);
   	}
       }
   
     addrMapDiv.appendChild(tableEl);
   
     csrNode.addressMapWindow.appendDomEl(addrMapDiv);
     csrNode.addressMapWindow.open();
   }
   
   
   //expand nodes
   function expandAllNodes( objectIndex )
   {
     for ( var obj in csrNode_array[objectIndex] )
       {  
         var csrNodeObj = csrNodeLookup(objectIndex,obj);
         csrNodeObj.expand();
       }
   }
   
   function collapseAllNodes( objectIndex )
   {
      for ( var obj in csrNode_array[objectIndex] )
       {  
         var csrNodeObj = csrNodeLookup(objectIndex,obj);
         csrNodeObj.collapse();
       }
   }
   
   // Graphics Functions
   
   function highLightDiv( id )
   {
     fade(0xe7, 0xe7, 0xe7, 0xff, 0xff, 0x33, 100, id);  
   }
   
   function unhighLightDiv( id )
   {
     fade(0xff, 0xff, 0x33, 0xe7, 0xe7, 0xe7, 100, id);
   }
   
   function makearray(n)
   {
     this.length = n;
     for(var i = 1; i <= n; i++)
       this[i] = 0;
     return this;
   }
   
   hexa = new makearray(16);
   
   for(var i = 0; i < 10; i++) 
        hexa[i] = i;
   hexa[10]="a"; hexa[11]="b"; hexa[12]="c";
   hexa[13]="d"; hexa[14]="e"; hexa[15]="f";
   
   function hex(i)
   {
     if (i < 0) return "00";
     else if (i >255) return "ff";
     else return "" + hexa[Math.floor(i/16)] + hexa[i%16];
   }
   
   var fade_timer = 100;
   function setbgColor(r, g, b, id)
   {
     var hr = hex(r); var hg = hex(g); var hb = hex(b);
     document.getElementById(id).style.backgroundColor = "#"+hr+hg+hb;
     var timeOutString = 'document.getElementById("' + id + '").style.backgroundColor=' +  '"#'+hr+hg+hb +'"';
     fade_timer = fade_timer + 25;
     setTimeout(timeOutString, fade_timer);
   
   }
   
   function fade(sr, sg, sb, er, eg, eb, step, id)
   {
     fade_timer = 100;
     for(var i = 0; i <= step; i++){
       setbgColor(Math.floor(sr * ((step-i)/step) + er * (i/step)),Math.floor(sg * ((step-i)/step) + eg * (i/step)),Math.floor(sb * ((step-i)/step) + eb * (i/step)),id);
     }
   }
   
   // Browser Detect
   
   // Determine browser and version.
   
   function Browser() 
   {
   
     var ua, s, i;
   
     this.isIE    = false;
     this.isNS    = false;
     this.version = null;
   
     ua = navigator.userAgent;
   
     s = "MSIE";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isIE = true;
       this.version = parseFloat(ua.substr(i + s.length));
       return;
     }
   
     s = "Netscape6/";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isNS = true;
       this.version = parseFloat(ua.substr(i + s.length));
       return;
     }
   
     // Treat any other "Gecko" browser as NS 6.1.
   
     s = "Gecko";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isNS = true;
       this.version = 6.1;
       return;
     }
   }
   
   var browser = new Browser();
   
   //DHTML Windows Below
   
   var myWindow = new Object();
   var globalWindowZIndex = 500;
   
   // Window Class
   function Window(x,y,w,h,dom_id) 
   {
     
     // CLASS TAG ELEMENT VARAIBLES
     this.window             = 0;
     this.title              = 0;
     this.titleBar           = 0;
     this.titleBarText       = 0;
     this.titleBarButtons    = 0;
     this.clientArea         = 0;
     this.titleBarMap        = 0;
     this.left               = x;
     this.top                = y;
     this.width              = w;
     this.height             = h;
     this.opened             = false; 
     this.dom_id             = dom_id;
   
     if (browser.isNS) 
       {
         this.ca_width       = this.width - 2;
         this.ca_height      = this.height - 40;
       }
     if (browser.isIE) 
       {
         this.ca_width       = this.width - 2;
         this.ca_height      = this.height - 40;
     }
     this.inMoveDrag   = false;
   
     // CLASS METHOD FUNCTIONS
     this.create        = windowCreate;
     this.init          = windowInit;
     this.open          = windowOpen;
     this.makeActive    = windowMakeActive;
     this.insertHTML    = windowInsertHTML; 
     this.appendHTML    = windowAppendHTML;
     this.appendDomEl   = windowAppendDomEl;
     this.close         = windowClose;
     this.windowColor   = windowChangeColor;
   
     this.changeTitle = function(title) {
       this.title.innerHTML = title;
     }
   
     this.wallpaper = function(img) {
        this.windowArea.style.backgroundImage    = img;
        this.windowArea.style.backgroundPosition = "center";
        this.windowArea.style.backgroundRepeat   = "no-repeat";
     }
   
     this.create();
     this.init();
   }
   
   //
   // Create WINDOW DOM object Tree
   //
   // body
   //  |
   //  | -- div ( window )
   //        |
   //        | -- div ( titlebar )
   //              |
   //              | -- span ( title )
   //              |
   //        | -- div ( text window area )
   //
   
   function windowCreate() 
   {
     // Find the main Body Tag.  Only one should exist in page 
     var bodyEl = document.getElementsByTagName("body");
   
     //WINDOW DIV
     var windowEl          = document.createElement("div");
     windowEl.className    = "window";
     windowEl.style.left   = this.left + "px";
     windowEl.style.top    = this.top + "px";
     windowEl.style.width  = this.width + "px"; 
     windowEl.style.height = this.height + "px";
     windowEl.id           = "window" + this.dom_id;
     windowEl.parent       = this;
   
   
     //TOP TITLE DIV
   
     var titleBarEl         = document.createElement("div");
     //  titleBarEl.className   = "windowTitleBar";
     titleBarEl.id          = "titleBar"; 
     titleBarEl.onmousedown = windowMove;
     titleBarEl.parent      = this;
   
     // Put the title into a table
   
     var tableTitleEl       = document.createElement("table");
     tableTitleEl.width     = "100%";
     var tbodyTitleEl       = document.createElement("tbody");
     var trTitleEl          = document.createElement("tr");
     var tdTitlePinIconEl   = document.createElement("td");
     tdTitlePinIconEl.width = "10%";
     tdTitlePinIconEl.algin = "right";
     tdTitlePinIconEl.className = "windowTitleBar";
     var tdTitleTitleEl     = document.createElement("td");
     tdTitleTitleEl.width   = "90%";
     tdTitleTitleEl.algin   = "right";
     tdTitleTitleEl.className = "windowTitleBar";
     tdTitleTitleEl.innerHTML   = 'WINDOW TITLE';
     tdTitleTitleEl.parent      = this;
     tdTitleTitleEl.onmouseover = windowMoveCursorSet;
     tdTitleTitleEl.onmouseout  = windowDefaultCursorSet;
     
     this.title  = tdTitleTitleEl;
     
     // CLOSE DIV
     var closeLink       = document.createElement("a");
     closeLink.setAttribute('href', 'javascript:void(0);');
     closeLink.onclick    = this.close;
     closeLink.parent    = this;
     var linkText = document.createTextNode('close');
     closeLink.appendChild(linkText);
     closeLink.style.color = "white";
   
   
     // Window List Area
     var windowAreaEl = document.createElement("div");
     windowAreaEl.className    = "windowListArea";
     
     windowAreaEl.style.width  = this.ca_width + "px";
     windowAreaEl.style.height = this.ca_height + "px";
     
     // Build DOM
     tdTitlePinIconEl.appendChild(closeLink);
   
     trTitleEl.appendChild(tdTitleTitleEl);
     trTitleEl.appendChild(tdTitlePinIconEl);
     tbodyTitleEl.appendChild(trTitleEl);
     tableTitleEl.appendChild(tbodyTitleEl);
     titleBarEl.appendChild(tableTitleEl);
     
     windowEl.appendChild(titleBarEl);
     
     windowEl.appendChild(windowAreaEl);
     document.body.appendChild(windowEl);
     
     this.window           = windowEl;
     this.windowArea       = windowAreaEl; 
     this.title            = tdTitleTitleEl;
   
   }
   
   function windowInit() 
   {
   
   }
   
   function windowChangeColor(color) 
   {
     this.window.style.backgroundColor = color;
     this.windowArea.style.backgroundColor = color;
   }
   
   function windowInsertHTML(html) 
   {
     this.windowArea.innerHTML = html;
   }
   
   function windowAppendHTML(html) 
   {
     this.windowArea.innerHTML = this.windowArea.innerHTML + html;
   }
   
   function windowAppendDomEl(el)
   {
     this.windowArea.appendChild(el);
   }
   
   function windowOpen() 
   {
     if (this.isOpen)
       return;
   
     this.opened = true;
   
     // Restore the Window and make it visible.
     this.makeActive();
     this.isOpen = true;
     this.window.style.visibility = "visible";
   }
   
   
   function windowMakeActive() 
   {
     if (myWindow == this)
       return;
   
     this.window.style.zIndex = globalWindowZIndex;
     globalWindowZIndex++;
     myWindow = this;
   
   }
   
   //
   // Event handlers.
   //
   
   
   function windowClientAreaClick(event) 
   {
   
     // Make this Window the active one.
   
      myWindow.makeActive();
   }
   
   function windowMove(event) 
   {
     var target;
     var x, y;
   
     if (browser.isIE)
       target = window.event.srcElement.tagName;
     if (browser.isNS)
       target = event.target.tagName;
   
     if (target == "AREA")
       return;
   
     p = this.parent;
     p.makeActive();
     // Get cursor offset from Window window.
   
     if (browser.isIE) {
       x = window.event.x;
       y = window.event.y;
     }
     if (browser.isNS) {
       x = event.pageX;
       y = event.pageY;
     }
     myWindow.xOffset = myWindow.window.offsetLeft - x;
     myWindow.yOffset = myWindow.window.offsetTop  - y;
   
     // Set document to capture mousemove and mouseup events.
   
     if (browser.isIE) {
       document.onmousemove = windowMoveDragStart;
       document.onmouseup   = windowMoveDragStop;
     }
     if (browser.isNS) {
       document.addEventListener("mousemove", windowMoveDragStart,   true);
       document.addEventListener("mouseup",   windowMoveDragStop, true);
       event.preventDefault();
     }
     myWindow.inMoveDrag = true;
     
   }
   
   
   
   function windowClose() 
   {
     this.parent.opened = false;
     document.body.removeChild(this.parent.window);
   }
   
   
   function windowMoveDragStart(event) 
   {
   
     var x, y;
   
     if (!myWindow.inMoveDrag)
       return;
   
     // Get cursor position.
   
     if (browser.isIE) {
       x = window.event.x;
       y = window.event.y;
       window.event.cancelBubble = true;
       window.event.returnValue = false;
     }
     if (browser.isNS) {
       x = event.pageX;
       y = event.pageY;
       event.preventDefault();
     }
   
     // Move Window window based on offset from cursor.
    
     nx = ( x + myWindow.xOffset );
     ny = ( y + myWindow.yOffset );
   
     if ( (nx<0) || (ny<0) ) {
   
     } else {
       myWindow.window.style.left = (x + myWindow.xOffset) + "px";
       myWindow.window.style.top  = (y + myWindow.yOffset) + "px";
     }
   }
   
   
   function windowMoveDragStop(event) 
   {
     myWindow.inMoveDrag = false;
   
     // Remove mousemove and mouseup event captures on document.
   
     if (browser.isIE) {
       document.onmousemove = null;
       document.onmouseup   = null;
     }
     if (browser.isNS) {
       document.removeEventListener("mousemove", windowMoveDragStart,   true);
       document.removeEventListener("mouseup",   windowMoveDragStop, true);
     }
   }
   
   
   function windowMoveCursorSet(event) 
   {
      this.style.cursor = "move";
   }
   
   function windowDefaultCursorSet(event) 
   {
      this.style.cursor = "move";
   }
   
   // End of Java Script
  </script>
  <noscript>
   <div class="noscript">
    <h2>JavaScript required</h2>
    <p>csrCompiler HTML pages require JavaScript.</p>
    <p>Your web browser does not support JavaScript or it has been disabled.</p>
   <div>
  </noscript>
 </head>
 <body onload="importXML('xmlData')">
  <xml id="xmlData" style="display:none;">
   <?xml version="1.0" encoding="UTF-8" ?>
   <csr:csrData
    xmlns:csr="http://www.semifore.com/schema/csrXmlHtml"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.semifore.com/schema/csrXmlHtml http://www.semifore.com/schema/csrXmlHtml.xsd"
    >
    <csr:fileInfo>
     <csr:inputFiles>
      <csr:file>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
      </csr:file>
     </csr:inputFiles>
     <csr:configurationFiles>
       <csr:file>
       <csr:filename>/project/jenkins/workspace/Esperanto_DV/soc_hal/esperanto-soc/dv/common/scripts/semifore_css/etsoc_esr.css</csr:filename>
      </csr:file>
     </csr:configurationFiles>
    </csr:fileInfo>
    <csr:csrObject>
     <csr:topDefinition>
      <csr:referenceName>ssi</csr:referenceName>
     </csr:topDefinition>
     <csr:definitions>
      <csr:definition>
       <csr:referenceType>addressmap</csr:referenceType>
       <csr:referenceName>ssi</csr:referenceName>
       <csr:identifier>ssi</csr:identifier>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>3268</csr:linenumber>
       <csr:title></csr:title>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Ssi</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.CTRLR0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.CTRLR1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.SSIENR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.MWCR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.SER</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.BAUDR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.TXFTLR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.RXFTLR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.TXFLR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.RXFLR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.SR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.IMR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.ISR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.RISR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.TXOICR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.RXOICR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.RXUICR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.MSTICR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.ICR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.IDR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.SSI_VERSION_ID</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR3</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR4</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR5</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR6</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR7</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR8</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR9</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR10</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR11</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR12</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR13</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR14</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR15</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR16</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR17</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR18</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR19</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR20</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR21</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR22</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR23</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR24</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR25</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR26</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR27</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR28</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR29</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR30</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR31</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR32</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR33</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR34</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.DR35</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ssi.RSVD</csr:referenceName>
        </csr:reference>
       </csr:references>
       <csr:addressMap>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0xFF</csr:addressHigh>
         <csr:instanceName>ssi</csr:instanceName>
         <csr:referenceName>ssi</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0x0</csr:addressHigh>
         <csr:instanceName>ssi.CTRLR0</csr:instanceName>
         <csr:referenceName>ssi.CTRLR0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4</csr:addressLow>
         <csr:addressHigh>0x4</csr:addressHigh>
         <csr:instanceName>ssi.CTRLR1</csr:instanceName>
         <csr:referenceName>ssi.CTRLR1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x8</csr:addressLow>
         <csr:addressHigh>0x8</csr:addressHigh>
         <csr:instanceName>ssi.SSIENR</csr:instanceName>
         <csr:referenceName>ssi.SSIENR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC</csr:addressLow>
         <csr:addressHigh>0xC</csr:addressHigh>
         <csr:instanceName>ssi.MWCR</csr:instanceName>
         <csr:referenceName>ssi.MWCR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x10</csr:addressLow>
         <csr:addressHigh>0x10</csr:addressHigh>
         <csr:instanceName>ssi.SER</csr:instanceName>
         <csr:referenceName>ssi.SER</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x14</csr:addressLow>
         <csr:addressHigh>0x14</csr:addressHigh>
         <csr:instanceName>ssi.BAUDR</csr:instanceName>
         <csr:referenceName>ssi.BAUDR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x18</csr:addressLow>
         <csr:addressHigh>0x18</csr:addressHigh>
         <csr:instanceName>ssi.TXFTLR</csr:instanceName>
         <csr:referenceName>ssi.TXFTLR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1C</csr:addressLow>
         <csr:addressHigh>0x1C</csr:addressHigh>
         <csr:instanceName>ssi.RXFTLR</csr:instanceName>
         <csr:referenceName>ssi.RXFTLR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x20</csr:addressLow>
         <csr:addressHigh>0x20</csr:addressHigh>
         <csr:instanceName>ssi.TXFLR</csr:instanceName>
         <csr:referenceName>ssi.TXFLR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x24</csr:addressLow>
         <csr:addressHigh>0x24</csr:addressHigh>
         <csr:instanceName>ssi.RXFLR</csr:instanceName>
         <csr:referenceName>ssi.RXFLR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x28</csr:addressLow>
         <csr:addressHigh>0x28</csr:addressHigh>
         <csr:instanceName>ssi.SR</csr:instanceName>
         <csr:referenceName>ssi.SR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x2C</csr:addressLow>
         <csr:addressHigh>0x2C</csr:addressHigh>
         <csr:instanceName>ssi.IMR</csr:instanceName>
         <csr:referenceName>ssi.IMR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x30</csr:addressLow>
         <csr:addressHigh>0x30</csr:addressHigh>
         <csr:instanceName>ssi.ISR</csr:instanceName>
         <csr:referenceName>ssi.ISR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x34</csr:addressLow>
         <csr:addressHigh>0x34</csr:addressHigh>
         <csr:instanceName>ssi.RISR</csr:instanceName>
         <csr:referenceName>ssi.RISR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x38</csr:addressLow>
         <csr:addressHigh>0x38</csr:addressHigh>
         <csr:instanceName>ssi.TXOICR</csr:instanceName>
         <csr:referenceName>ssi.TXOICR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x3C</csr:addressLow>
         <csr:addressHigh>0x3C</csr:addressHigh>
         <csr:instanceName>ssi.RXOICR</csr:instanceName>
         <csr:referenceName>ssi.RXOICR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x40</csr:addressLow>
         <csr:addressHigh>0x40</csr:addressHigh>
         <csr:instanceName>ssi.RXUICR</csr:instanceName>
         <csr:referenceName>ssi.RXUICR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x44</csr:addressLow>
         <csr:addressHigh>0x44</csr:addressHigh>
         <csr:instanceName>ssi.MSTICR</csr:instanceName>
         <csr:referenceName>ssi.MSTICR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x48</csr:addressLow>
         <csr:addressHigh>0x48</csr:addressHigh>
         <csr:instanceName>ssi.ICR</csr:instanceName>
         <csr:referenceName>ssi.ICR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4C</csr:addressLow>
         <csr:addressHigh>0x57</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x58</csr:addressLow>
         <csr:addressHigh>0x58</csr:addressHigh>
         <csr:instanceName>ssi.IDR</csr:instanceName>
         <csr:referenceName>ssi.IDR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x5C</csr:addressLow>
         <csr:addressHigh>0x5C</csr:addressHigh>
         <csr:instanceName>ssi.SSI_VERSION_ID</csr:instanceName>
         <csr:referenceName>ssi.SSI_VERSION_ID</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x60</csr:addressLow>
         <csr:addressHigh>0x60</csr:addressHigh>
         <csr:instanceName>ssi.DR0</csr:instanceName>
         <csr:referenceName>ssi.DR0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x64</csr:addressLow>
         <csr:addressHigh>0x64</csr:addressHigh>
         <csr:instanceName>ssi.DR1</csr:instanceName>
         <csr:referenceName>ssi.DR1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x68</csr:addressLow>
         <csr:addressHigh>0x68</csr:addressHigh>
         <csr:instanceName>ssi.DR2</csr:instanceName>
         <csr:referenceName>ssi.DR2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x6C</csr:addressLow>
         <csr:addressHigh>0x6C</csr:addressHigh>
         <csr:instanceName>ssi.DR3</csr:instanceName>
         <csr:referenceName>ssi.DR3</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x70</csr:addressLow>
         <csr:addressHigh>0x70</csr:addressHigh>
         <csr:instanceName>ssi.DR4</csr:instanceName>
         <csr:referenceName>ssi.DR4</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x74</csr:addressLow>
         <csr:addressHigh>0x74</csr:addressHigh>
         <csr:instanceName>ssi.DR5</csr:instanceName>
         <csr:referenceName>ssi.DR5</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x78</csr:addressLow>
         <csr:addressHigh>0x78</csr:addressHigh>
         <csr:instanceName>ssi.DR6</csr:instanceName>
         <csr:referenceName>ssi.DR6</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x7C</csr:addressLow>
         <csr:addressHigh>0x7C</csr:addressHigh>
         <csr:instanceName>ssi.DR7</csr:instanceName>
         <csr:referenceName>ssi.DR7</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x80</csr:addressLow>
         <csr:addressHigh>0x80</csr:addressHigh>
         <csr:instanceName>ssi.DR8</csr:instanceName>
         <csr:referenceName>ssi.DR8</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x84</csr:addressLow>
         <csr:addressHigh>0x84</csr:addressHigh>
         <csr:instanceName>ssi.DR9</csr:instanceName>
         <csr:referenceName>ssi.DR9</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x88</csr:addressLow>
         <csr:addressHigh>0x88</csr:addressHigh>
         <csr:instanceName>ssi.DR10</csr:instanceName>
         <csr:referenceName>ssi.DR10</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x8C</csr:addressLow>
         <csr:addressHigh>0x8C</csr:addressHigh>
         <csr:instanceName>ssi.DR11</csr:instanceName>
         <csr:referenceName>ssi.DR11</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x90</csr:addressLow>
         <csr:addressHigh>0x90</csr:addressHigh>
         <csr:instanceName>ssi.DR12</csr:instanceName>
         <csr:referenceName>ssi.DR12</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x94</csr:addressLow>
         <csr:addressHigh>0x94</csr:addressHigh>
         <csr:instanceName>ssi.DR13</csr:instanceName>
         <csr:referenceName>ssi.DR13</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x98</csr:addressLow>
         <csr:addressHigh>0x98</csr:addressHigh>
         <csr:instanceName>ssi.DR14</csr:instanceName>
         <csr:referenceName>ssi.DR14</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x9C</csr:addressLow>
         <csr:addressHigh>0x9C</csr:addressHigh>
         <csr:instanceName>ssi.DR15</csr:instanceName>
         <csr:referenceName>ssi.DR15</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xA0</csr:addressLow>
         <csr:addressHigh>0xA0</csr:addressHigh>
         <csr:instanceName>ssi.DR16</csr:instanceName>
         <csr:referenceName>ssi.DR16</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xA4</csr:addressLow>
         <csr:addressHigh>0xA4</csr:addressHigh>
         <csr:instanceName>ssi.DR17</csr:instanceName>
         <csr:referenceName>ssi.DR17</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xA8</csr:addressLow>
         <csr:addressHigh>0xA8</csr:addressHigh>
         <csr:instanceName>ssi.DR18</csr:instanceName>
         <csr:referenceName>ssi.DR18</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xAC</csr:addressLow>
         <csr:addressHigh>0xAC</csr:addressHigh>
         <csr:instanceName>ssi.DR19</csr:instanceName>
         <csr:referenceName>ssi.DR19</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xB0</csr:addressLow>
         <csr:addressHigh>0xB0</csr:addressHigh>
         <csr:instanceName>ssi.DR20</csr:instanceName>
         <csr:referenceName>ssi.DR20</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xB4</csr:addressLow>
         <csr:addressHigh>0xB4</csr:addressHigh>
         <csr:instanceName>ssi.DR21</csr:instanceName>
         <csr:referenceName>ssi.DR21</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xB8</csr:addressLow>
         <csr:addressHigh>0xB8</csr:addressHigh>
         <csr:instanceName>ssi.DR22</csr:instanceName>
         <csr:referenceName>ssi.DR22</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xBC</csr:addressLow>
         <csr:addressHigh>0xBC</csr:addressHigh>
         <csr:instanceName>ssi.DR23</csr:instanceName>
         <csr:referenceName>ssi.DR23</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC0</csr:addressLow>
         <csr:addressHigh>0xC0</csr:addressHigh>
         <csr:instanceName>ssi.DR24</csr:instanceName>
         <csr:referenceName>ssi.DR24</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC4</csr:addressLow>
         <csr:addressHigh>0xC4</csr:addressHigh>
         <csr:instanceName>ssi.DR25</csr:instanceName>
         <csr:referenceName>ssi.DR25</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC8</csr:addressLow>
         <csr:addressHigh>0xC8</csr:addressHigh>
         <csr:instanceName>ssi.DR26</csr:instanceName>
         <csr:referenceName>ssi.DR26</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xCC</csr:addressLow>
         <csr:addressHigh>0xCC</csr:addressHigh>
         <csr:instanceName>ssi.DR27</csr:instanceName>
         <csr:referenceName>ssi.DR27</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD0</csr:addressLow>
         <csr:addressHigh>0xD0</csr:addressHigh>
         <csr:instanceName>ssi.DR28</csr:instanceName>
         <csr:referenceName>ssi.DR28</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD4</csr:addressLow>
         <csr:addressHigh>0xD4</csr:addressHigh>
         <csr:instanceName>ssi.DR29</csr:instanceName>
         <csr:referenceName>ssi.DR29</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD8</csr:addressLow>
         <csr:addressHigh>0xD8</csr:addressHigh>
         <csr:instanceName>ssi.DR30</csr:instanceName>
         <csr:referenceName>ssi.DR30</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xDC</csr:addressLow>
         <csr:addressHigh>0xDC</csr:addressHigh>
         <csr:instanceName>ssi.DR31</csr:instanceName>
         <csr:referenceName>ssi.DR31</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xE0</csr:addressLow>
         <csr:addressHigh>0xE0</csr:addressHigh>
         <csr:instanceName>ssi.DR32</csr:instanceName>
         <csr:referenceName>ssi.DR32</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xE4</csr:addressLow>
         <csr:addressHigh>0xE4</csr:addressHigh>
         <csr:instanceName>ssi.DR33</csr:instanceName>
         <csr:referenceName>ssi.DR33</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xE8</csr:addressLow>
         <csr:addressHigh>0xE8</csr:addressHigh>
         <csr:instanceName>ssi.DR34</csr:instanceName>
         <csr:referenceName>ssi.DR34</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xEC</csr:addressLow>
         <csr:addressHigh>0xEC</csr:addressHigh>
         <csr:instanceName>ssi.DR35</csr:instanceName>
         <csr:referenceName>ssi.DR35</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xF0</csr:addressLow>
         <csr:addressHigh>0xFB</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xFC</csr:addressLow>
         <csr:addressHigh>0xFC</csr:addressHigh>
         <csr:instanceName>ssi.RSVD</csr:instanceName>
         <csr:referenceName>ssi.RSVD</csr:referenceName>
        </csr:addressMapEntry>
       </csr:addressMap>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.CTRLR0</csr:referenceName>
       <csr:identifier>CTRLR0</csr:identifier>
       <csr:addressMacro>SSI_CTRLR0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_CTRLR0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_CTRLR0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_CTRLR0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>616</csr:linenumber>
       <csr:title>Control Register 0</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x01070000</csr:registerResetValue>
       <csr:typeName>Ssi_CTRLR0</csr:typeName>
        <csr:description>
         <csr:p>This register controls the serial data transfer. It is impossible to</csr:p>
         <csr:p>write to this register when the DW_apb_ssi is enabled. The DW_apb_ssi</csr:p>
         <csr:p>is enabled and disabled by writing to the SSIENR register.</csr:p>
         <csr:p>Reset Value: SSI_CTRLR0_RST</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DFS</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_DFS_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_DFS_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_DFS_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_DFS_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_DFS_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_DFS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_DFS_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_DFS_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>119</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Frame Size. </csr:p>
         <csr:p>This register field is only valid when SSI_MAX_XFER_SIZE is</csr:p>
         <csr:p>configured to 16. If SSI_MAX_XFER_SIZE is configured to 32, then writing to this field</csr:p>
         <csr:p>will not have any effect.</csr:p>
         <csr:p></csr:p>
         <csr:p>Selects the data frame length. When the data frame size is programmed to be less than</csr:p>
         <csr:p>16 bits, the receive data are automatically right-justified by the receive logic, with the</csr:p>
         <csr:p>upper bits of the receive FIFO zero-padded.</csr:p>
         <csr:p></csr:p>
         <csr:p>You must right-justify transmit data before writing into the transmit FIFO. The transmit</csr:p>
         <csr:p>logic ignores the upper unused bits when transmitting the data </csr:p>
         <csr:p></csr:p>
         <csr:p>Note: When SSI_SPI_MODE is either set to "Dual" or "Quad" or "Octal" mode and  SPI_FRF  is not set to 2'b00.</csr:p>
         <csr:p></csr:p>
         <csr:p>- DFS value should be multiple of 2 if SPI_FRF = 01,</csr:p>
         <csr:p></csr:p>
         <csr:p>- DFS value should be multiple of 4 if SPI_FRF = 10,</csr:p>
         <csr:p></csr:p>
         <csr:p>- DFS value should be multiple of 8 if SPI_FRF = 11.</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FRAME_04BITS</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>4-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_05BITS</csr:identifier>
           <csr:value>0x4</csr:value>
           <csr:title>5-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_06BITS</csr:identifier>
           <csr:value>0x5</csr:value>
           <csr:title>6-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_07BITS</csr:identifier>
           <csr:value>0x6</csr:value>
           <csr:title>7-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_08BITS</csr:identifier>
           <csr:value>0x7</csr:value>
           <csr:title>8-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_09BITS</csr:identifier>
           <csr:value>0x8</csr:value>
           <csr:title>9-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_10BITS</csr:identifier>
           <csr:value>0x9</csr:value>
           <csr:title>10-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_11BITS</csr:identifier>
           <csr:value>0xa</csr:value>
           <csr:title>11-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_12BITS</csr:identifier>
           <csr:value>0xb</csr:value>
           <csr:title>12-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_13BITS</csr:identifier>
           <csr:value>0xc</csr:value>
           <csr:title>13-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_14BITS</csr:identifier>
           <csr:value>0xd</csr:value>
           <csr:title>14-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_15BITS</csr:identifier>
           <csr:value>0xe</csr:value>
           <csr:title>15-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_16BITS</csr:identifier>
           <csr:value>0xf</csr:value>
           <csr:title>16-bit serial data transfer</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>FRF</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_FRF_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_FRF_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_FRF_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_FRF_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_FRF_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_FRF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_FRF_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_FRF_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>147</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Frame Format.</csr:p>
         <csr:p>Selects which serial protocol transfers the data. </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>MOTOROLA_SPI</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Motorolla SPI Frame Format</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NS_MICROWIRE</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>National Microwire Frame Format</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>RESERVED</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>Reserved value</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>TEXAS_SSP</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Texas Instruments SSP Frame Format</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SCPH</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_SCPH_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_SCPH_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_SCPH_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_SCPH_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_SCPH_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_SCPH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_SCPH_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_SCPH_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>178</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Serial Clock Phase.</csr:p>
         <csr:p></csr:p>
         <csr:p>Valid when the frame format (FRF) is set to Motorola SPI. The serial</csr:p>
         <csr:p>clock phase selects the relationship of the serial clock with the slave</csr:p>
         <csr:p>select signal. </csr:p>
         <csr:p>When SCPH = 0, data are captured on the first edge of</csr:p>
         <csr:p>the serial clock. When SCPH = 1, the serial clock starts toggling one</csr:p>
         <csr:p>cycle after the slave select line is activated, and data are captured</csr:p>
         <csr:p>on the second edge of the serial clock. </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>SCPH_MIDDLE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Serial clock toggles in middle of first data bit</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SCPH_START</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Serial clock toggles at start of first data bit</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SCPOL</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_SCPOL_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_SCPOL_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_SCPOL_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_SCPOL_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_SCPOL_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_SCPOL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_SCPOL_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_SCPOL_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>204</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Serial Clock Polarity.</csr:p>
         <csr:p></csr:p>
         <csr:p>Valid when the frame format (FRF) is set to Motorola SPI. Used to select</csr:p>
         <csr:p>the polarity of the inactive serial clock, which is held inactive when</csr:p>
         <csr:p>the DW_apb_ssi master is not actively transferring data on the serial bus. </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>SCLK_HIGH</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Inactive state of serial clock is high</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SCLK_LOW</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Inactive state of serial clock is low</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TMOD</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_TMOD_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_TMOD_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_TMOD_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_TMOD_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_TMOD_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_TMOD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_TMOD_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_TMOD_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>277</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transfer Mode.</csr:p>
         <csr:p></csr:p>
         <csr:p>Selects the mode of transfer for serial communication. This field does</csr:p>
         <csr:p>not affect the transfer duplicity. Only indicates whether the receive or</csr:p>
         <csr:p>transmit data are valid.</csr:p>
         <csr:p> In transmit-only mode, data received from the</csr:p>
         <csr:p>external device is not valid and is not stored in the receive FIFO memory;</csr:p>
         <csr:p>it is overwritten on the next transfer.</csr:p>
         <csr:p> In receive-only mode, transmitted</csr:p>
         <csr:p>data are not valid. After the first write to the transmit FIFO, the same</csr:p>
         <csr:p>word is retransmitted for the duration of the transfer.</csr:p>
         <csr:p> In</csr:p>
         <csr:p>transmit-and-receive mode, both transmit and receive data are valid.</csr:p>
         <csr:p>The transfer continues until the transmit FIFO is empty. Data received</csr:p>
         <csr:p>from the external device are stored into the receive FIFO memory, where</csr:p>
         <csr:p>it can be accessed by the host processor. </csr:p>
         <csr:p> In eeprom-read mode, receive data</csr:p>
         <csr:p>is not valid while control data is being transmitted.  When all control data is sent</csr:p>
         <csr:p>to the EEPROM, receive data becomes valid and transmit data becomes invalid.  All </csr:p>
         <csr:p>data in the transmit FIFO is considered control data in this mode.  This transfer</csr:p>
         <csr:p>mode is only valid when the DW_apb_ssi is configured as master device.</csr:p>
         <csr:p></csr:p>
         <csr:p>00 - Transmit &amp; Receive </csr:p>
         <csr:p></csr:p>
         <csr:p>01 - Transmit Only </csr:p>
         <csr:p></csr:p>
         <csr:p>10 - Receive Only </csr:p>
         <csr:p></csr:p>
         <csr:p>11 - EEPROM Read </csr:p>
         <csr:p></csr:p>
         <csr:p>When SSI_SPI_MODE is either set to "Dual" or "Quad" or "Octal" mode and  SPI_FRF  is not set to 2'b00. </csr:p>
         <csr:p>There are only two valid combinations: </csr:p>
         <csr:p></csr:p>
         <csr:p>10 - Read </csr:p>
         <csr:p></csr:p>
         <csr:p>01 - Write</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>EEPROM_READ</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>EEPROM  Read  mode</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>RX_ONLY</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>Receive  only mode or Read (SPI_FRF != 2'b00)</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>TX_AND_RX</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Transmit &amp; receive</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>TX_ONLY</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Transmit only mode or Write (SPI_FRF != 2'b00)</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SLV_OE</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_RSVD_SLV_OE_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_RSVD_SLV_OE_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_RSVD_SLV_OE_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_RSVD_SLV_OE_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_RSVD_SLV_OE_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_RSVD_SLV_OE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_RSVD_SLV_OE_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_RSVD_SLV_OE_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>285</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SLV_OE Reserved field - Read-only</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SRL</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_SRL_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_SRL_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_SRL_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_SRL_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_SRL_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_SRL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_SRL_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_SRL_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>314</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Shift Register Loop.</csr:p>
         <csr:p>Used for testing purposes only. When internally</csr:p>
         <csr:p>active, connects the transmit shift register output to the receive shift register input. </csr:p>
         <csr:p></csr:p>
         <csr:p>Can be used in both serial-slave and serial-master modes. </csr:p>
         <csr:p></csr:p>
         <csr:p>When the DW_apb_ssi is configured as a slave in loopback mode, the ss_in_n and ssi_clk signals </csr:p>
         <csr:p>must be provided by an external source.  In this mode, the slave cannot generate these signals</csr:p>
         <csr:p>because there is nothing to which to loop back</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>NORMAL_MODE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Normal mode operation</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>TESTING_MODE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Test mode: Tx &amp; Rx shift reg connected</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CFS</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_CFS_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_CFS_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_CFS_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_CFS_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_CFS_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_CFS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_CFS_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_CFS_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>390</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Control Frame Size. Selects the length of the control word for the</csr:p>
         <csr:p>Microwire frame format.</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>SIZE_01_BIT</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>1-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_02_BIT</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>2-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_03_BIT</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>3-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_04_BIT</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>4-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_05_BIT</csr:identifier>
           <csr:value>0x4</csr:value>
           <csr:title>5-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_06_BIT</csr:identifier>
           <csr:value>0x5</csr:value>
           <csr:title>6-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_07_BIT</csr:identifier>
           <csr:value>0x6</csr:value>
           <csr:title>7-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_08_BIT</csr:identifier>
           <csr:value>0x7</csr:value>
           <csr:title>8-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_09_BIT</csr:identifier>
           <csr:value>0x8</csr:value>
           <csr:title>9-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_10_BIT</csr:identifier>
           <csr:value>0x9</csr:value>
           <csr:title>10-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_11_BIT</csr:identifier>
           <csr:value>0xa</csr:value>
           <csr:title>11-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_12_BIT</csr:identifier>
           <csr:value>0xb</csr:value>
           <csr:title>12-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_13_BIT</csr:identifier>
           <csr:value>0xc</csr:value>
           <csr:title>13-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_14_BIT</csr:identifier>
           <csr:value>0xd</csr:value>
           <csr:title>14-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_15_BIT</csr:identifier>
           <csr:value>0xe</csr:value>
           <csr:title>15-bit Control Word</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SIZE_16_BIT</csr:identifier>
           <csr:value>0xf</csr:value>
           <csr:title>16-bit Control Word</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DFS_32</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_DFS_32_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_DFS_32_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_DFS_32_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_DFS_32_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_DFS_32_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_DFS_32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_DFS_32_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_DFS_32_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>541</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Frame Size in 32-bit transfer size mode.</csr:p>
         <csr:p>Used to select the data frame size in 32-bit transfer mode. These bits are only valid when</csr:p>
         <csr:p>SSI_MAX_XFER_SIZE is configured to 32.  When the data frame size is programmed</csr:p>
         <csr:p>to be less than 32 bits, the receive data are automatically</csr:p>
         <csr:p>right-justified by the receive logic, with the upper bits of the receive</csr:p>
         <csr:p>FIFO zero-padded.  You are responsible for making sure that transmit data is right-justified</csr:p>
         <csr:p>before writing into the transmit FIFO. The transmit logic ignores the upper unused</csr:p>
         <csr:p>bits when transmitting the data.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Note: When SSI_SPI_MODE is either set to "Dual" or "Quad" or "Octal" mode and  SPI_FRF  is not set to 2'b00.</csr:p>
         <csr:p></csr:p>
         <csr:p>- DFS value should be multiple of 2 if SPI_FRF = 0x01,</csr:p>
         <csr:p></csr:p>
         <csr:p>- DFS value should be multiple of 4 if SPI_FRF = 0x10,</csr:p>
         <csr:p></csr:p>
         <csr:p>- DFS value should be multiple of 8 if SPI_FRF = 0x11.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>20</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x07</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FRAME_04BITS</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>4-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_05BITS</csr:identifier>
           <csr:value>0x4</csr:value>
           <csr:title>5-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_06BITS</csr:identifier>
           <csr:value>0x5</csr:value>
           <csr:title>6-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_07BITS</csr:identifier>
           <csr:value>0x6</csr:value>
           <csr:title>7-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_08BITS</csr:identifier>
           <csr:value>0x7</csr:value>
           <csr:title>8-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_09BITS</csr:identifier>
           <csr:value>0x8</csr:value>
           <csr:title>9-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_10BITS</csr:identifier>
           <csr:value>0x9</csr:value>
           <csr:title>10-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_11BITS</csr:identifier>
           <csr:value>0xa</csr:value>
           <csr:title>11-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_12BITS</csr:identifier>
           <csr:value>0xb</csr:value>
           <csr:title>12-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_13BITS</csr:identifier>
           <csr:value>0xc</csr:value>
           <csr:title>13-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_14BITS</csr:identifier>
           <csr:value>0xd</csr:value>
           <csr:title>14-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_15BITS</csr:identifier>
           <csr:value>0xe</csr:value>
           <csr:title>15-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_16BITS</csr:identifier>
           <csr:value>0xf</csr:value>
           <csr:title>16-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_17BITS</csr:identifier>
           <csr:value>0x10</csr:value>
           <csr:title>17-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_18BITS</csr:identifier>
           <csr:value>0x11</csr:value>
           <csr:title>18-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_19BITS</csr:identifier>
           <csr:value>0x12</csr:value>
           <csr:title>19-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_20BITS</csr:identifier>
           <csr:value>0x13</csr:value>
           <csr:title>20-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_21BITS</csr:identifier>
           <csr:value>0x14</csr:value>
           <csr:title>21-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_22BITS</csr:identifier>
           <csr:value>0x15</csr:value>
           <csr:title>22-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_23BITS</csr:identifier>
           <csr:value>0x16</csr:value>
           <csr:title>23-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_24BITS</csr:identifier>
           <csr:value>0x17</csr:value>
           <csr:title>24-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_25BITS</csr:identifier>
           <csr:value>0x18</csr:value>
           <csr:title>25-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_26BITS</csr:identifier>
           <csr:value>0x19</csr:value>
           <csr:title>26-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_27BITS</csr:identifier>
           <csr:value>0x1a</csr:value>
           <csr:title>27-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_28BITS</csr:identifier>
           <csr:value>0x1b</csr:value>
           <csr:title>28-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_29BITS</csr:identifier>
           <csr:value>0x1c</csr:value>
           <csr:title>29-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_30BITS</csr:identifier>
           <csr:value>0x1d</csr:value>
           <csr:title>30-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_31BITS</csr:identifier>
           <csr:value>0x1e</csr:value>
           <csr:title>31-bit serial data transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FRAME_32BITS</csr:identifier>
           <csr:value>0x1f</csr:value>
           <csr:title>32-bit serial data transfer</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SPI_FRF</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_SPI_FRF_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_SPI_FRF_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_SPI_FRF_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_SPI_FRF_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_SPI_FRF_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_SPI_FRF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_SPI_FRF_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_SPI_FRF_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>581</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SPI Frame Format: </csr:p>
         <csr:p></csr:p>
         <csr:p>Selects data frame format for Transmitting/Receiving the data </csr:p>
         <csr:p></csr:p>
         <csr:p>Bits only valid when SSI_SPI_MODE is either set to "Dual" or "Quad" or "Octal" mode. </csr:p>
         <csr:p></csr:p>
         <csr:p>When SSI_SPI_MODE is configured for "Dual Mode", 10/11 combination is reserved. </csr:p>
         <csr:p></csr:p>
         <csr:p>When SSI_SPI_MODE is configured for "Quad Mode", 11 combination is reserved.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>22</csr:msb>
         <csr:lsb>21</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DUAL_SPI_FRF</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Dual SPI Frame Format</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>OCTAL_SPI_FRF</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>Octal SPI Frame Format</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>QUAD_SPI_FRF</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>Quad SPI Frame Format</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>STD_SPI_FRF</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Standard SPI Frame Format</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CTRLR0_23</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_RSVD_CTRLR0_23_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_RSVD_CTRLR0_23_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_RSVD_CTRLR0_23_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_RSVD_CTRLR0_23_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_RSVD_CTRLR0_23_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_RSVD_CTRLR0_23_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_RSVD_CTRLR0_23_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_RSVD_CTRLR0_23_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>589</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CTRLR0_23 Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>23</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SSTE</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_SSTE_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_SSTE_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_SSTE_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_SSTE_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_SSTE_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_SSTE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_SSTE_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_SSTE_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>607</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Slave Select Toggle Enable.</csr:p>
         <csr:p>When operating in SPI mode with clock phase (SCPH) set to 0, this register controls the behavior of the slave select line (ss_*_n) between data frames. If this register field is set to 1 the ss_*_n line will toggle between consecutive data frames, with the serial clock (sclk) being held to its default value while ss_*_n is high; if this register field is set to 0 the ss_*_n will stay low and sclk will run continuously for the duration of the transfer.</csr:p>
         <csr:p>Note: This register is only valid when SSI_SCPH0_SSTOGGLE is set to 1.</csr:p>
        </csr:description>
         <csr:msb>24</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CTRLR0</csr:identifier>
         <csr:widthMacro>SSI_CTRLR0_RSVD_CTRLR0_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR0_RSVD_CTRLR0_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR0_RSVD_CTRLR0_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR0_RSVD_CTRLR0_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR0_RSVD_CTRLR0_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR0_RSVD_CTRLR0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR0_RSVD_CTRLR0_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR0_RSVD_CTRLR0_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>615</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SSTE Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>25</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.CTRLR1</csr:referenceName>
       <csr:identifier>CTRLR1</csr:identifier>
       <csr:addressMacro>SSI_CTRLR1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_CTRLR1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_CTRLR1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_CTRLR1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>666</csr:linenumber>
       <csr:title>Control Register 1</csr:title>
       <csr:offset>0x4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_CTRLR1</csr:typeName>
        <csr:description>
         <csr:p>This register exists only when the DW_apb_ssi is configured as a</csr:p>
         <csr:p>master device. When the DW_apb_ssi is configured as a serial slave,</csr:p>
         <csr:p>writing to this location has no effect; reading from this location</csr:p>
         <csr:p>returns 0. Control register 1 controls the end of serial transfers</csr:p>
         <csr:p>when in receive-only mode. It is impossible to write to this</csr:p>
         <csr:p>register when the DW_apb_ssi is enabled. The DW_apb_ssi is enabled</csr:p>
         <csr:p>and disabled by writing to the SSIENR register.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>NDF</csr:identifier>
         <csr:widthMacro>SSI_CTRLR1_NDF_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR1_NDF_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR1_NDF_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR1_NDF_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR1_NDF_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR1_NDF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR1_NDF_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR1_NDF_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>657</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Number of Data Frames.</csr:p>
         <csr:p></csr:p>
         <csr:p>When TMOD = 10 or TMOD = 11 , this register field sets the number of data frames to</csr:p>
         <csr:p>be continuously received by the DW_apb_ssi. The DW_apb_ssi continues</csr:p>
         <csr:p>to receive serial data until the number of data frames received is</csr:p>
         <csr:p>equal to this register value plus 1, which enables you to receive up</csr:p>
         <csr:p>to 64 KB of data in a continuous transfer. </csr:p>
         <csr:p>When the DW_apb_ssi is</csr:p>
         <csr:p>configured as a serial slave, the transfer continues for as long as</csr:p>
         <csr:p>the slave is selected. Therefore, this register serves no purpose and</csr:p>
         <csr:p>is not present when the DW_apb_ssi is configured as a serial slave.</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CTRLR1</csr:identifier>
         <csr:widthMacro>SSI_CTRLR1_RSVD_CTRLR1_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_CTRLR1_RSVD_CTRLR1_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_CTRLR1_RSVD_CTRLR1_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_CTRLR1_RSVD_CTRLR1_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_CTRLR1_RSVD_CTRLR1_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_CTRLR1_RSVD_CTRLR1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_CTRLR1_RSVD_CTRLR1_GET</csr:getMacro>
         <csr:setMacro>SSI_CTRLR1_RSVD_CTRLR1_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>665</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CTRLR1 Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.SSIENR</csr:referenceName>
       <csr:identifier>SSIENR</csr:identifier>
       <csr:addressMacro>SSI_SSIENR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_SSIENR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_SSIENR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_SSIENR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>711</csr:linenumber>
       <csr:title>SSI Enable Register</csr:title>
       <csr:offset>0x8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_SSIENR</csr:typeName>
        <csr:description>
         <csr:p>This register enables and disables the DW_apb_ssi.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SSI_EN</csr:identifier>
         <csr:widthMacro>SSI_SSIENR_SSI_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SSIENR_SSI_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SSIENR_SSI_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SSIENR_SSI_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SSIENR_SSI_EN_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SSIENR_SSI_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SSIENR_SSI_EN_GET</csr:getMacro>
         <csr:setMacro>SSI_SSIENR_SSI_EN_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>702</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SSI Enable.</csr:p>
         <csr:p> Enables and disables all DW_apb_ssi operations. When</csr:p>
         <csr:p>disabled, all serial transfers are halted immediately. Transmit and</csr:p>
         <csr:p>receive FIFO buffers are cleared when the device is disabled. It is</csr:p>
         <csr:p>impossible to program some of the DW_apb_ssi control registers when</csr:p>
         <csr:p>enabled. When disabled, the ssi_sleep output is set (after delay) to</csr:p>
         <csr:p>inform the system that it is safe to remove the ssi_clk, thus saving</csr:p>
         <csr:p>power consumption in the system.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Disables Serial Transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Enables  Serial Transfer</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SSIENR</csr:identifier>
         <csr:widthMacro>SSI_SSIENR_RSVD_SSIENR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SSIENR_RSVD_SSIENR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SSIENR_RSVD_SSIENR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SSIENR_RSVD_SSIENR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SSIENR_RSVD_SSIENR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SSIENR_RSVD_SSIENR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SSIENR_RSVD_SSIENR_GET</csr:getMacro>
         <csr:setMacro>SSI_SSIENR_RSVD_SSIENR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>710</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SSIENR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.MWCR</csr:referenceName>
       <csr:identifier>MWCR</csr:identifier>
       <csr:addressMacro>SSI_MWCR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_MWCR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_MWCR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_MWCR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>819</csr:linenumber>
       <csr:title>Microwire Control Register</csr:title>
       <csr:offset>0xC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_MWCR</csr:typeName>
        <csr:description>
         <csr:p>This register controls the direction of the data word for the half-duplex</csr:p>
         <csr:p>Microwire serial protocol. It is impossible to write to this register</csr:p>
         <csr:p>when the DW_apb_ssi is enabled. The DW_apb_ssi is enabled and disabled by</csr:p>
         <csr:p>writing to the SSIENR register.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>MWMOD</csr:identifier>
         <csr:widthMacro>SSI_MWCR_MWMOD_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_MWCR_MWMOD_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_MWCR_MWMOD_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_MWCR_MWMOD_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_MWCR_MWMOD_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_MWCR_MWMOD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_MWCR_MWMOD_GET</csr:getMacro>
         <csr:setMacro>SSI_MWCR_MWMOD_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>751</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Microwire Transfer Mode.</csr:p>
         <csr:p></csr:p>
         <csr:p>Defines whether the Microwire transfer is sequential or non-sequential.</csr:p>
         <csr:p>When sequential mode is used, only one control word is needed to</csr:p>
         <csr:p>transmit or receive a block of data words. When non-sequential mode is</csr:p>
         <csr:p>used, there must be a control word for each data word that is</csr:p>
         <csr:p>transmitted or received.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>NON_SEQUENTIAL</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Non-Sequential Microwire Transfer</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SEQUENTIAL</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Sequential Microwire Transfer</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>MDD</csr:identifier>
         <csr:widthMacro>SSI_MWCR_MDD_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_MWCR_MDD_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_MWCR_MDD_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_MWCR_MDD_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_MWCR_MDD_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_MWCR_MDD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_MWCR_MDD_GET</csr:getMacro>
         <csr:setMacro>SSI_MWCR_MDD_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>779</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Microwire Control.</csr:p>
         <csr:p></csr:p>
         <csr:p>Defines the direction of the data word when the Microwire serial protocol</csr:p>
         <csr:p>is used. When this bit is set to 0, the data word is received by the</csr:p>
         <csr:p>DW_apb_ssi MacroCell from the external serial device. When this bit is</csr:p>
         <csr:p>set to 1, the data word is transmitted from the DW_apb_ssi MacroCell to</csr:p>
         <csr:p>the external serial device.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>RECEIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>SSI receives data</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>TRANSMIT</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>SSI transmits data</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>MHS</csr:identifier>
         <csr:widthMacro>SSI_MWCR_MHS_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_MWCR_MHS_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_MWCR_MHS_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_MWCR_MHS_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_MWCR_MHS_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_MWCR_MHS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_MWCR_MHS_GET</csr:getMacro>
         <csr:setMacro>SSI_MWCR_MHS_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>810</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Microwire Handshaking.</csr:p>
         <csr:p></csr:p>
         <csr:p>Relevant only when the DW_apb_ssi is configured as a serial-master device.</csr:p>
         <csr:p>When configured as a serial slave, this bit field has no functionality.</csr:p>
         <csr:p>Used to enable and disable the busy/ready handshaking interface for the</csr:p>
         <csr:p>Microwire protocol. When enabled, the DW_apb_ssi checks for a ready status</csr:p>
         <csr:p>from the target slave, after the transfer of the last data/control bit,</csr:p>
         <csr:p>before clearing the BUSY status in the SR register. </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Handshaking interface is disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Handshaking interface is enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_MWCR</csr:identifier>
         <csr:widthMacro>SSI_MWCR_RSVD_MWCR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_MWCR_RSVD_MWCR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_MWCR_RSVD_MWCR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_MWCR_RSVD_MWCR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_MWCR_RSVD_MWCR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_MWCR_RSVD_MWCR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_MWCR_RSVD_MWCR_GET</csr:getMacro>
         <csr:setMacro>SSI_MWCR_RSVD_MWCR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>818</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>MWCR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.SER</csr:referenceName>
       <csr:identifier>SER</csr:identifier>
       <csr:addressMacro>SSI_SER_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_SER_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_SER_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_SER_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>885</csr:linenumber>
       <csr:title>Slave Enable Register</csr:title>
       <csr:offset>0x10</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_SER</csr:typeName>
        <csr:description>
         <csr:p>This register is valid only when the DW_apb_ssi is configured as a master</csr:p>
         <csr:p>device. When the DW_apb_ssi is configured as a serial slave, writing to</csr:p>
         <csr:p>this location has no effect; reading from this location returns 0. The</csr:p>
         <csr:p>register enables the individual slave select output lines from the</csr:p>
         <csr:p>DW_apb_ssi master. Up to 16 slave-select output pins are available on the</csr:p>
         <csr:p>DW_apb_ssi master. Register bits can be set or cleared when SSI_EN=0. </csr:p>
         <csr:p></csr:p>
         <csr:p>If SSI_EN=1, then register bits can be set (to delay the slave select assertion while TX FIFO is getting filled) but cannot be cleared.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SER</csr:identifier>
         <csr:widthMacro>SSI_SER_SER_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SER_SER_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SER_SER_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SER_SER_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SER_SER_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SER_SER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SER_SER_GET</csr:getMacro>
         <csr:setMacro>SSI_SER_SER_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>876</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Slave Select Enable Flag.</csr:p>
         <csr:p></csr:p>
         <csr:p>Each bit in this register corresponds to a slave select line (ss_x_n)</csr:p>
         <csr:p>from the DW_apb_ssi master. When a bit in this register is set (1), the</csr:p>
         <csr:p>corresponding slave select line from the master is activated when a</csr:p>
         <csr:p>serial transfer begins. It should be noted that setting or clearing bits</csr:p>
         <csr:p>in this register have no effect on the corresponding slave select outputs</csr:p>
         <csr:p>until a transfer is started. Before beginning a transfer, you should</csr:p>
         <csr:p>enable the bit in this register that corresponds to the slave device</csr:p>
         <csr:p>with which the master wants to communicate. When not operating in</csr:p>
         <csr:p>broadcast mode, only one bit in this field should be set.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>NOT_SELECTED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>No slave selected</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SELECTED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Slave is selected</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SER</csr:identifier>
         <csr:widthMacro>SSI_SER_RSVD_SER_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SER_RSVD_SER_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SER_RSVD_SER_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SER_RSVD_SER_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SER_RSVD_SER_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SER_RSVD_SER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SER_RSVD_SER_GET</csr:getMacro>
         <csr:setMacro>SSI_SER_RSVD_SER_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>884</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SER Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.BAUDR</csr:referenceName>
       <csr:identifier>BAUDR</csr:identifier>
       <csr:addressMacro>SSI_BAUDR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_BAUDR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_BAUDR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_BAUDR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>939</csr:linenumber>
       <csr:title>Baud Rate Select</csr:title>
       <csr:offset>0x14</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_BAUDR</csr:typeName>
        <csr:description>
         <csr:p>This register is valid only when the DW_apb_ssi is configured as a master</csr:p>
         <csr:p>device. When the DW_apb_ssi is configured as a serial slave, writing to</csr:p>
         <csr:p>this location has no effect; reading from this location returns 0. The</csr:p>
         <csr:p>register derives the frequency of the serial clock that regulates the data</csr:p>
         <csr:p>transfer. The 16-bit field in this register defines the ssi_clk divider</csr:p>
         <csr:p>value. It is impossible to write to this register when the DW_apb_ssi is</csr:p>
         <csr:p>enabled. The DW_apb_ssi is enabled and disabled by writing to the SSIENR</csr:p>
         <csr:p>register.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SCKDV</csr:identifier>
         <csr:widthMacro>SSI_BAUDR_SCKDV_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_BAUDR_SCKDV_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_BAUDR_SCKDV_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_BAUDR_SCKDV_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_BAUDR_SCKDV_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_BAUDR_SCKDV_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_BAUDR_SCKDV_GET</csr:getMacro>
         <csr:setMacro>SSI_BAUDR_SCKDV_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>930</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SSI Clock Divider.</csr:p>
         <csr:p></csr:p>
         <csr:p>The LSB for this field is always set to 0 and is unaffected by a write</csr:p>
         <csr:p>operation, which ensures an even value is held in this register. If the</csr:p>
         <csr:p>value is 0, the serial output clock (sclk_out) is disabled. The frequency</csr:p>
         <csr:p>of the sclk_out is derived from the following equation:</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>        Fsclk_out = Fssi_clk/SCKDV</csr:p>
         <csr:p></csr:p>
         <csr:p>where SCKDV is any even value between 2 and 65534. For example: </csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>for Fssi_clk = 3.6864MHz and SCKDV =2</csr:p>
         <csr:p>Fsclk_out = 3.6864/2 = 1.8432MHz</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_BAUDR</csr:identifier>
         <csr:widthMacro>SSI_BAUDR_RSVD_BAUDR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_BAUDR_RSVD_BAUDR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_BAUDR_RSVD_BAUDR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_BAUDR_RSVD_BAUDR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_BAUDR_RSVD_BAUDR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_BAUDR_RSVD_BAUDR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_BAUDR_RSVD_BAUDR_GET</csr:getMacro>
         <csr:setMacro>SSI_BAUDR_RSVD_BAUDR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>938</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>BAUDR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.TXFTLR</csr:referenceName>
       <csr:identifier>TXFTLR</csr:identifier>
       <csr:addressMacro>SSI_TXFTLR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_TXFTLR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_TXFTLR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_TXFTLR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>984</csr:linenumber>
       <csr:title>Transmit FIFO Threshold Level</csr:title>
       <csr:offset>0x18</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_TXFTLR</csr:typeName>
        <csr:description>
         <csr:p>This register controls the threshold value for the transmit FIFO memory.</csr:p>
         <csr:p>The DW_apb_ssi is enabled and disabled by writing to the SSIENR register.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TFT</csr:identifier>
         <csr:widthMacro>SSI_TXFTLR_TFT_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_TXFTLR_TFT_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_TXFTLR_TFT_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_TXFTLR_TFT_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_TXFTLR_TFT_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_TXFTLR_TFT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_TXFTLR_TFT_GET</csr:getMacro>
         <csr:setMacro>SSI_TXFTLR_TFT_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>975</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Threshold.</csr:p>
         <csr:p></csr:p>
         <csr:p>Controls the level of entries (or below) at which the transmit FIFO controller</csr:p>
         <csr:p>triggers an interrupt. The FIFO depth is configurable in the range 2-256;</csr:p>
         <csr:p>this register is sized to the number of address bits needed to access the</csr:p>
         <csr:p>FIFO. If you attempt to set this value greater than or equal to the depth</csr:p>
         <csr:p>of the FIFO, this field is not written and retains its current value. When</csr:p>
         <csr:p>the number of transmit FIFO entries is less than or equal to this value,</csr:p>
         <csr:p>the transmit FIFO empty interrupt is triggered. For information on the Transmit FIFO Threshold values, see the "Master SPI and SSP Serial Transfers" in the DW_apb_ssi Databook.</csr:p>
         <csr:p></csr:p>
         <csr:p>ssi_txe_intr is asserted when TFT or less data entries are present in transmit FIFO</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_TXFTLR</csr:identifier>
         <csr:widthMacro>SSI_TXFTLR_RSVD_TXFTLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_TXFTLR_RSVD_TXFTLR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_TXFTLR_RSVD_TXFTLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_TXFTLR_RSVD_TXFTLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_TXFTLR_RSVD_TXFTLR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_TXFTLR_RSVD_TXFTLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_TXFTLR_RSVD_TXFTLR_GET</csr:getMacro>
         <csr:setMacro>SSI_TXFTLR_RSVD_TXFTLR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>983</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>TXFTLR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.RXFTLR</csr:referenceName>
       <csr:identifier>RXFTLR</csr:identifier>
       <csr:addressMacro>SSI_RXFTLR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_RXFTLR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_RXFTLR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_RXFTLR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1025</csr:linenumber>
       <csr:title>Receive FIFO Threshold Level</csr:title>
       <csr:offset>0x1C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_RXFTLR</csr:typeName>
        <csr:description>
         <csr:p>This register controls the threshold value for the receive FIFO memory.</csr:p>
         <csr:p>The DW_apb_ssi is enabled and disabled by writing to the SSIENR register.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RFT</csr:identifier>
         <csr:widthMacro>SSI_RXFTLR_RFT_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RXFTLR_RFT_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RXFTLR_RFT_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RXFTLR_RFT_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RXFTLR_RFT_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RXFTLR_RFT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RXFTLR_RFT_GET</csr:getMacro>
         <csr:setMacro>SSI_RXFTLR_RFT_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1016</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Threshold.</csr:p>
         <csr:p></csr:p>
         <csr:p>Controls the level of entries (or above) at which the receive FIFO controller triggers an interrupt. The FIFO depth is configurable in the range 2-256. This register is sized to the number of address</csr:p>
         <csr:p>bits needed to access the FIFO. If you attempt to set this value greater than the depth of the FIFO, this field is not written and retains its current value. When the number of receive FIFO entries is</csr:p>
         <csr:p>greater than or equal to this value + 1, the receive FIFO full interrupt is triggered. For information on the Receive FIFO Threshold values, see the "Master SPI and SSP Serial Transfers" in the</csr:p>
         <csr:p>DW_apb_ssi Databook.</csr:p>
         <csr:p>ssi_rxf_intr is asserted when RFT or more data entries are present in receive FIFO.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_RXFTLR</csr:identifier>
         <csr:widthMacro>SSI_RXFTLR_RSVD_RXFTLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RXFTLR_RSVD_RXFTLR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RXFTLR_RSVD_RXFTLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RXFTLR_RSVD_RXFTLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RXFTLR_RSVD_RXFTLR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RXFTLR_RSVD_RXFTLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RXFTLR_RSVD_RXFTLR_GET</csr:getMacro>
         <csr:setMacro>SSI_RXFTLR_RSVD_RXFTLR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1024</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RXFTLR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.TXFLR</csr:referenceName>
       <csr:identifier>TXFLR</csr:identifier>
       <csr:addressMacro>SSI_TXFLR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_TXFLR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_TXFLR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_TXFLR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1051</csr:linenumber>
       <csr:title>Transmit FIFO Level Register</csr:title>
       <csr:offset>0x20</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_TXFLR</csr:typeName>
        <csr:description>
         <csr:p>This register contains the number of valid data entries in the transmit FIFO memory.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TXTFL</csr:identifier>
         <csr:widthMacro>SSI_TXFLR_TXTFL_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_TXFLR_TXTFL_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_TXFLR_TXTFL_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_TXFLR_TXTFL_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_TXFLR_TXTFL_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_TXFLR_TXTFL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_TXFLR_TXTFL_GET</csr:getMacro>
         <csr:setMacro>SSI_TXFLR_TXTFL_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1043</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Level.</csr:p>
         <csr:p></csr:p>
         <csr:p>Contains the number of valid data entries in the transmit FIFO.</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_TXFLR</csr:identifier>
         <csr:widthMacro>SSI_TXFLR_RSVD_TXFLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_TXFLR_RSVD_TXFLR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_TXFLR_RSVD_TXFLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_TXFLR_RSVD_TXFLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_TXFLR_RSVD_TXFLR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_TXFLR_RSVD_TXFLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_TXFLR_RSVD_TXFLR_GET</csr:getMacro>
         <csr:setMacro>SSI_TXFLR_RSVD_TXFLR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1050</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>TXFLR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.RXFLR</csr:referenceName>
       <csr:identifier>RXFLR</csr:identifier>
       <csr:addressMacro>SSI_RXFLR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_RXFLR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_RXFLR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_RXFLR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1078</csr:linenumber>
       <csr:title>Receive FIFO Level Register</csr:title>
       <csr:offset>0x24</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_RXFLR</csr:typeName>
        <csr:description>
         <csr:p>This register contains the number of valid data entries in the receive FIFO memory.  This register can be ready at any time.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RXTFL</csr:identifier>
         <csr:widthMacro>SSI_RXFLR_RXTFL_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RXFLR_RXTFL_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RXFLR_RXTFL_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RXFLR_RXTFL_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RXFLR_RXTFL_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RXFLR_RXTFL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RXFLR_RXTFL_GET</csr:getMacro>
         <csr:setMacro>SSI_RXFLR_RXTFL_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1070</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Level.</csr:p>
         <csr:p></csr:p>
         <csr:p>Contains the number of valid data entries in the receive FIFO.</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_RXFLR</csr:identifier>
         <csr:widthMacro>SSI_RXFLR_RSVD_RXFLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RXFLR_RSVD_RXFLR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RXFLR_RSVD_RXFLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RXFLR_RSVD_RXFLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RXFLR_RSVD_RXFLR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RXFLR_RSVD_RXFLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RXFLR_RSVD_RXFLR_GET</csr:getMacro>
         <csr:setMacro>SSI_RXFLR_RSVD_RXFLR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1077</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RXFLR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.SR</csr:referenceName>
       <csr:identifier>SR</csr:identifier>
       <csr:addressMacro>SSI_SR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_SR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_SR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_SR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1247</csr:linenumber>
       <csr:title>Status Register</csr:title>
       <csr:offset>0x28</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000006</csr:registerResetValue>
       <csr:typeName>Ssi_SR</csr:typeName>
        <csr:description>
         <csr:p>This is a read-only register used to indicate the current transfer status,</csr:p>
         <csr:p>FIFO status, and any transmission/reception errors that may have occurred.</csr:p>
         <csr:p>The status register may be read at any time. None of the bits in this</csr:p>
         <csr:p>register request an interrupt.</csr:p>
         <csr:p>Reset Value: 0x6</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>BUSY</csr:identifier>
         <csr:widthMacro>SSI_SR_BUSY_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SR_BUSY_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SR_BUSY_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SR_BUSY_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SR_BUSY_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SR_BUSY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SR_BUSY_GET</csr:getMacro>
         <csr:setMacro>SSI_SR_BUSY_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1113</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SSI Busy Flag.</csr:p>
         <csr:p></csr:p>
         <csr:p>When set, indicates that a serial transfer is in progress; when cleared</csr:p>
         <csr:p>indicates that the DW_apb_ssi is idle or disabled.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>DW_apb_ssi is actively transferring data</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>DW_apb_ssi is idle or disabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TFNF</csr:identifier>
         <csr:widthMacro>SSI_SR_TFNF_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SR_TFNF_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SR_TFNF_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SR_TFNF_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SR_TFNF_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SR_TFNF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SR_TFNF_GET</csr:getMacro>
         <csr:setMacro>SSI_SR_TFNF_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1133</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Not Full.</csr:p>
         <csr:p> Set when the transmit FIFO contains one or more</csr:p>
         <csr:p>empty locations, and is cleared when the FIFO is full.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FULL</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Transmit FIFO is full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_FULL</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Transmit FIFO is not Full</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TFE</csr:identifier>
         <csr:widthMacro>SSI_SR_TFE_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SR_TFE_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SR_TFE_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SR_TFE_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SR_TFE_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SR_TFE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SR_TFE_GET</csr:getMacro>
         <csr:setMacro>SSI_SR_TFE_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1157</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Empty.</csr:p>
         <csr:p></csr:p>
         <csr:p>When the transmit FIFO is completely empty, this bit is set. When the</csr:p>
         <csr:p>transmit FIFO contains one or more valid entries, this bit is cleared.</csr:p>
         <csr:p>This bit field does not request an interrupt.</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>EMPTY</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Transmit FIFO is empty</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_EMPTY</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Transmit FIFO is not empty</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RFNE</csr:identifier>
         <csr:widthMacro>SSI_SR_RFNE_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SR_RFNE_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SR_RFNE_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SR_RFNE_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SR_RFNE_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SR_RFNE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SR_RFNE_GET</csr:getMacro>
         <csr:setMacro>SSI_SR_RFNE_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1181</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Not Empty.</csr:p>
         <csr:p></csr:p>
         <csr:p>Set when the receive FIFO contains one or more entries and is cleared</csr:p>
         <csr:p>when the receive FIFO is empty. This bit can be polled by software to</csr:p>
         <csr:p>completely empty the receive FIFO.</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>EMPTY</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Receive FIFO is empty</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_EMPTY</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Receive FIFO is not empty</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RFF</csr:identifier>
         <csr:widthMacro>SSI_SR_RFF_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SR_RFF_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SR_RFF_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SR_RFF_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SR_RFF_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SR_RFF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SR_RFF_GET</csr:getMacro>
         <csr:setMacro>SSI_SR_RFF_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1204</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Full.</csr:p>
         <csr:p></csr:p>
         <csr:p>When the receive FIFO is completely full, this bit</csr:p>
         <csr:p>is set. When the receive FIFO contains one or more empty location, this</csr:p>
         <csr:p>bit is cleared.</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FULL</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Receive FIFO is full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_FULL</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Receive FIFO is not full</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_TXE</csr:identifier>
         <csr:widthMacro>SSI_SR_RSVD_TXE_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SR_RSVD_TXE_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SR_RSVD_TXE_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SR_RSVD_TXE_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SR_RSVD_TXE_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SR_RSVD_TXE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SR_RSVD_TXE_GET</csr:getMacro>
         <csr:setMacro>SSI_SR_RSVD_TXE_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1211</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>TXE Reserved field - read-only</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DCOL</csr:identifier>
         <csr:widthMacro>SSI_SR_DCOL_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SR_DCOL_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SR_DCOL_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SR_DCOL_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SR_DCOL_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SR_DCOL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SR_DCOL_GET</csr:getMacro>
         <csr:setMacro>SSI_SR_DCOL_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1239</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Collision Error.</csr:p>
         <csr:p></csr:p>
         <csr:p>Relevant only when the DW_apb_ssi is configured as a master device.</csr:p>
         <csr:p>This bit will be set if ss_in_n input is asserted by other master,</csr:p>
         <csr:p>when the DW_apb_ssi master is in the middle of the transfer. This informs the processor that the</csr:p>
         <csr:p>last data transfer was halted before completion. This bit is cleared</csr:p>
         <csr:p>when read.</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>NO_ERROR_CONDITION</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>No Error</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>TX_COLLISION_ERROR</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Transmit Data Collision Error</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SR</csr:identifier>
         <csr:widthMacro>SSI_SR_RSVD_SR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SR_RSVD_SR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SR_RSVD_SR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SR_RSVD_SR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SR_RSVD_SR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SR_RSVD_SR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SR_RSVD_SR_GET</csr:getMacro>
         <csr:setMacro>SSI_SR_RSVD_SR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1246</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.IMR</csr:referenceName>
       <csr:identifier>IMR</csr:identifier>
       <csr:addressMacro>SSI_IMR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_IMR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_IMR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_IMR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1378</csr:linenumber>
       <csr:title>Interrupt Mask Register</csr:title>
       <csr:offset>0x2C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0000003f</csr:registerResetValue>
       <csr:typeName>Ssi_IMR</csr:typeName>
        <csr:description>
         <csr:p>This read/write reigster masks or enables all interrupts generated by the DW_apb_ssi.</csr:p>
         <csr:p>When the DW_apb_ssi is configured as a slave device, the MSTIM bit field is not present. </csr:p>
         <csr:p>This changes the reset value from 0x3F for serial-master configurations to 0x1F for serial-slave</csr:p>
         <csr:p>configurations.</csr:p>
         <csr:p>Reset Value: (SSI_IS_MASTER == 1) ? 0x3F : 0x1F</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TXEIM</csr:identifier>
         <csr:widthMacro>SSI_IMR_TXEIM_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_IMR_TXEIM_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_IMR_TXEIM_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_IMR_TXEIM_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_IMR_TXEIM_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_IMR_TXEIM_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_IMR_TXEIM_GET</csr:getMacro>
         <csr:setMacro>SSI_IMR_TXEIM_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1277</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Empty Interrupt Mask</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>MASKED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_txe_intr interrupt is masked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>UNMASKED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_txe_intr interrupt is not masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TXOIM</csr:identifier>
         <csr:widthMacro>SSI_IMR_TXOIM_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_IMR_TXOIM_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_IMR_TXOIM_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_IMR_TXOIM_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_IMR_TXOIM_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_IMR_TXOIM_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_IMR_TXOIM_GET</csr:getMacro>
         <csr:setMacro>SSI_IMR_TXOIM_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1295</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Overflow Interrupt Mask</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>MASKED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_txo_intr interrupt is masked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>UNMASKED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_txo_intr interrupt is not masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RXUIM</csr:identifier>
         <csr:widthMacro>SSI_IMR_RXUIM_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_IMR_RXUIM_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_IMR_RXUIM_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_IMR_RXUIM_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_IMR_RXUIM_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_IMR_RXUIM_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_IMR_RXUIM_GET</csr:getMacro>
         <csr:setMacro>SSI_IMR_RXUIM_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1313</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Underflow Interrupt Mask</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>MASKED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_rxu_intr interrupt is masked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>UNMASKED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_rxu_intr interrupt is not masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RXOIM</csr:identifier>
         <csr:widthMacro>SSI_IMR_RXOIM_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_IMR_RXOIM_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_IMR_RXOIM_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_IMR_RXOIM_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_IMR_RXOIM_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_IMR_RXOIM_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_IMR_RXOIM_GET</csr:getMacro>
         <csr:setMacro>SSI_IMR_RXOIM_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1331</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Overflow Interrupt Mask</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>MASKED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_rxo_intr interrupt is masked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>UNMASKED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_rxo_intr interrupt is not masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RXFIM</csr:identifier>
         <csr:widthMacro>SSI_IMR_RXFIM_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_IMR_RXFIM_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_IMR_RXFIM_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_IMR_RXFIM_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_IMR_RXFIM_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_IMR_RXFIM_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_IMR_RXFIM_GET</csr:getMacro>
         <csr:setMacro>SSI_IMR_RXFIM_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1349</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Full Interrupt Mask</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>MASKED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_rxf_intr interrupt is masked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>UNMASKED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_rxf_intr interrupt is not masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>MSTIM</csr:identifier>
         <csr:widthMacro>SSI_IMR_MSTIM_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_IMR_MSTIM_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_IMR_MSTIM_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_IMR_MSTIM_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_IMR_MSTIM_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_IMR_MSTIM_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_IMR_MSTIM_GET</csr:getMacro>
         <csr:setMacro>SSI_IMR_MSTIM_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1369</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Multi-Master Contention Interrupt Mask. This bit field is not present if</csr:p>
         <csr:p>the DW_apb_ssi is configured as a serial-slave device.</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>MASKED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_mst_intr interrupt is masked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>UNMASKED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_mst_intr interrupt is not masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IMR</csr:identifier>
         <csr:widthMacro>SSI_IMR_RSVD_IMR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_IMR_RSVD_IMR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_IMR_RSVD_IMR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_IMR_RSVD_IMR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_IMR_RSVD_IMR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_IMR_RSVD_IMR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_IMR_RSVD_IMR_GET</csr:getMacro>
         <csr:setMacro>SSI_IMR_RSVD_IMR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1377</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IMR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.ISR</csr:referenceName>
       <csr:identifier>ISR</csr:identifier>
       <csr:addressMacro>SSI_ISR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_ISR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_ISR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_ISR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1504</csr:linenumber>
       <csr:title>Interrupt Status Register</csr:title>
       <csr:offset>0x30</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_ISR</csr:typeName>
        <csr:description>
         <csr:p>This register reports the status of the DW_apb_ssi interrupts after they have been masked.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TXEIS</csr:identifier>
         <csr:widthMacro>SSI_ISR_TXEIS_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_ISR_TXEIS_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_ISR_TXEIS_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_ISR_TXEIS_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_ISR_TXEIS_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_ISR_TXEIS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_ISR_TXEIS_GET</csr:getMacro>
         <csr:setMacro>SSI_ISR_TXEIS_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1404</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Empty Interrupt Status</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_txe_intr interrupt is active after masking</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_txe_intr interrupt is not active after masking</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TXOIS</csr:identifier>
         <csr:widthMacro>SSI_ISR_TXOIS_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_ISR_TXOIS_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_ISR_TXOIS_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_ISR_TXOIS_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_ISR_TXOIS_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_ISR_TXOIS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_ISR_TXOIS_GET</csr:getMacro>
         <csr:setMacro>SSI_ISR_TXOIS_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1422</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Overflow Interrupt Status</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_txo_intr interrupt is active after masking</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_txo_intr interrupt is not active after masking</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RXUIS</csr:identifier>
         <csr:widthMacro>SSI_ISR_RXUIS_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_ISR_RXUIS_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_ISR_RXUIS_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_ISR_RXUIS_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_ISR_RXUIS_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_ISR_RXUIS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_ISR_RXUIS_GET</csr:getMacro>
         <csr:setMacro>SSI_ISR_RXUIS_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1440</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Underflow Interrupt Status</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_rxu_intr interrupt is active after masking</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_rxu_intr interrupt is not active after masking</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RXOIS</csr:identifier>
         <csr:widthMacro>SSI_ISR_RXOIS_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_ISR_RXOIS_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_ISR_RXOIS_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_ISR_RXOIS_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_ISR_RXOIS_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_ISR_RXOIS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_ISR_RXOIS_GET</csr:getMacro>
         <csr:setMacro>SSI_ISR_RXOIS_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1458</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Overflow Interrupt Status</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_rxo_intr interrupt is active after masking</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_rxo_intr interrupt is not active after masking</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RXFIS</csr:identifier>
         <csr:widthMacro>SSI_ISR_RXFIS_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_ISR_RXFIS_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_ISR_RXFIS_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_ISR_RXFIS_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_ISR_RXFIS_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_ISR_RXFIS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_ISR_RXFIS_GET</csr:getMacro>
         <csr:setMacro>SSI_ISR_RXFIS_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1476</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Full Interrupt Status</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_rxf_intr interrupt is full after masking</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_rxf_intr interrupt is not active after masking</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>MSTIS</csr:identifier>
         <csr:widthMacro>SSI_ISR_MSTIS_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_ISR_MSTIS_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_ISR_MSTIS_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_ISR_MSTIS_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_ISR_MSTIS_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_ISR_MSTIS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_ISR_MSTIS_GET</csr:getMacro>
         <csr:setMacro>SSI_ISR_MSTIS_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1496</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Multi-Master Contention Interrupt Status. This bit field is not present</csr:p>
         <csr:p>if the DW_apb_ssi is configured as a serial-slave device.</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_mst_intr interrupt is active after masking</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_mst_intr interrupt not active after masking</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_ISR</csr:identifier>
         <csr:widthMacro>SSI_ISR_RSVD_ISR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_ISR_RSVD_ISR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_ISR_RSVD_ISR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_ISR_RSVD_ISR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_ISR_RSVD_ISR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_ISR_RSVD_ISR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_ISR_RSVD_ISR_GET</csr:getMacro>
         <csr:setMacro>SSI_ISR_RSVD_ISR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1503</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ISR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.RISR</csr:referenceName>
       <csr:identifier>RISR</csr:identifier>
       <csr:addressMacro>SSI_RISR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_RISR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_RISR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_RISR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1637</csr:linenumber>
       <csr:title>Raw Interrupt Status Register</csr:title>
       <csr:offset>0x34</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_RISR</csr:typeName>
        <csr:description>
         <csr:p>This read-only register reports the status of the DW_apb_ssi interrupts prior to masking.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TXEIR</csr:identifier>
         <csr:widthMacro>SSI_RISR_TXEIR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RISR_TXEIR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RISR_TXEIR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RISR_TXEIR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RISR_TXEIR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RISR_TXEIR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RISR_TXEIR_GET</csr:getMacro>
         <csr:setMacro>SSI_RISR_TXEIR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1531</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Empty Raw Interrupt Status</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_txe_intr interrupt is active prior masking</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_txe_intr interrupt is not active prior to masking</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TXOIR</csr:identifier>
         <csr:widthMacro>SSI_RISR_TXOIR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RISR_TXOIR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RISR_TXOIR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RISR_TXOIR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RISR_TXOIR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RISR_TXOIR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RISR_TXOIR_GET</csr:getMacro>
         <csr:setMacro>SSI_RISR_TXOIR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1550</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Overflow Raw Interrupt Status</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_txo_intr interrupt is active prior masking</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_txo_intr interrupt is not active prior to masking</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RXUIR</csr:identifier>
         <csr:widthMacro>SSI_RISR_RXUIR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RISR_RXUIR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RISR_RXUIR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RISR_RXUIR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RISR_RXUIR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RISR_RXUIR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RISR_RXUIR_GET</csr:getMacro>
         <csr:setMacro>SSI_RISR_RXUIR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1569</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Underflow Raw Interrupt Status</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_rxu_intr interrupt is active prior to masking</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_rxu_intr interrupt is not active prior to masking</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RXOIR</csr:identifier>
         <csr:widthMacro>SSI_RISR_RXOIR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RISR_RXOIR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RISR_RXOIR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RISR_RXOIR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RISR_RXOIR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RISR_RXOIR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RISR_RXOIR_GET</csr:getMacro>
         <csr:setMacro>SSI_RISR_RXOIR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1588</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Overflow Raw Interrupt Status</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_rxo_intr interrupt is not active prior to masking</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_rxo_intr interrupt is active prior masking</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RXFIR</csr:identifier>
         <csr:widthMacro>SSI_RISR_RXFIR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RISR_RXFIR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RISR_RXFIR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RISR_RXFIR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RISR_RXFIR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RISR_RXFIR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RISR_RXFIR_GET</csr:getMacro>
         <csr:setMacro>SSI_RISR_RXFIR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1607</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Full Raw Interrupt Status</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_rxf_intr interrupt is active prior to masking</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_rxf_intr interrupt is not active prior to masking</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>MSTIR</csr:identifier>
         <csr:widthMacro>SSI_RISR_MSTIR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RISR_MSTIR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RISR_MSTIR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RISR_MSTIR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RISR_MSTIR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RISR_MSTIR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RISR_MSTIR_GET</csr:getMacro>
         <csr:setMacro>SSI_RISR_MSTIR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1629</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Multi-Master Contention Raw Interrupt Status.</csr:p>
         <csr:p>This bit field is not present if the DW_apb_ssi is configured as a</csr:p>
         <csr:p>serial-slave device.</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ssi_mst_intr interrupt is active prior masking</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ssi_mst_intr interrupt is not active prior to masking</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_RISR</csr:identifier>
         <csr:widthMacro>SSI_RISR_RSVD_RISR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RISR_RSVD_RISR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RISR_RSVD_RISR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RISR_RSVD_RISR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RISR_RSVD_RISR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RISR_RSVD_RISR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RISR_RSVD_RISR_GET</csr:getMacro>
         <csr:setMacro>SSI_RISR_RSVD_RISR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1636</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RISR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.TXOICR</csr:referenceName>
       <csr:identifier>TXOICR</csr:identifier>
       <csr:addressMacro>SSI_TXOICR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_TXOICR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_TXOICR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_TXOICR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1664</csr:linenumber>
       <csr:title>Transmit FIFO Overflow Interrupt Clear Register Register</csr:title>
       <csr:offset>0x38</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_TXOICR</csr:typeName>
        <csr:description>
         <csr:p>Transmit FIFO Overflow Interrupt Clear Register.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TXOICR</csr:identifier>
         <csr:widthMacro>SSI_TXOICR_TXOICR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_TXOICR_TXOICR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_TXOICR_TXOICR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_TXOICR_TXOICR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_TXOICR_TXOICR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_TXOICR_TXOICR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_TXOICR_TXOICR_GET</csr:getMacro>
         <csr:setMacro>SSI_TXOICR_TXOICR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1656</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Clear Transmit FIFO Overflow Interrupt.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register reflects the status of the interrupt. A read from this</csr:p>
         <csr:p>register clears the ssi_txo_intr interrupt; writing has no effect.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_TXOICR</csr:identifier>
         <csr:widthMacro>SSI_TXOICR_RSVD_TXOICR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_TXOICR_RSVD_TXOICR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_TXOICR_RSVD_TXOICR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_TXOICR_RSVD_TXOICR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_TXOICR_RSVD_TXOICR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_TXOICR_RSVD_TXOICR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_TXOICR_RSVD_TXOICR_GET</csr:getMacro>
         <csr:setMacro>SSI_TXOICR_RSVD_TXOICR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1663</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>TXOICR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.RXOICR</csr:referenceName>
       <csr:identifier>RXOICR</csr:identifier>
       <csr:addressMacro>SSI_RXOICR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_RXOICR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_RXOICR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_RXOICR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1691</csr:linenumber>
       <csr:title>Receive FIFO Overflow Interrupt Clear Register</csr:title>
       <csr:offset>0x3C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_RXOICR</csr:typeName>
        <csr:description>
         <csr:p>Receive FIFO Overflow Interrupt Clear Register.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RXOICR</csr:identifier>
         <csr:widthMacro>SSI_RXOICR_RXOICR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RXOICR_RXOICR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RXOICR_RXOICR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RXOICR_RXOICR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RXOICR_RXOICR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RXOICR_RXOICR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RXOICR_RXOICR_GET</csr:getMacro>
         <csr:setMacro>SSI_RXOICR_RXOICR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1683</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Clear Receive FIFO Overflow Interrupt.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register reflects the status of the interrupt. A read from this</csr:p>
         <csr:p>register clears the ssi_rxo_intr interrupt; writing has no effect.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_RXOICR</csr:identifier>
         <csr:widthMacro>SSI_RXOICR_RSVD_RXOICR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RXOICR_RSVD_RXOICR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RXOICR_RSVD_RXOICR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RXOICR_RSVD_RXOICR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RXOICR_RSVD_RXOICR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RXOICR_RSVD_RXOICR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RXOICR_RSVD_RXOICR_GET</csr:getMacro>
         <csr:setMacro>SSI_RXOICR_RSVD_RXOICR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1690</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RXOICR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.RXUICR</csr:referenceName>
       <csr:identifier>RXUICR</csr:identifier>
       <csr:addressMacro>SSI_RXUICR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_RXUICR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_RXUICR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_RXUICR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1718</csr:linenumber>
       <csr:title>Receive FIFO Underflow Interrupt Clear Register</csr:title>
       <csr:offset>0x40</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_RXUICR</csr:typeName>
        <csr:description>
         <csr:p>Receive FIFO Underflow Interrupt Clear Register.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RXUICR</csr:identifier>
         <csr:widthMacro>SSI_RXUICR_RXUICR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RXUICR_RXUICR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RXUICR_RXUICR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RXUICR_RXUICR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RXUICR_RXUICR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RXUICR_RXUICR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RXUICR_RXUICR_GET</csr:getMacro>
         <csr:setMacro>SSI_RXUICR_RXUICR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1710</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Clear Receive FIFO Underflow Interrupt.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register reflects the status of the interrupt. A read from this</csr:p>
         <csr:p>register clears the ssi_rxu_intr interrupt; writing has no effect.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_RXUICR</csr:identifier>
         <csr:widthMacro>SSI_RXUICR_RSVD_RXUICR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RXUICR_RSVD_RXUICR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RXUICR_RSVD_RXUICR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RXUICR_RSVD_RXUICR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RXUICR_RSVD_RXUICR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RXUICR_RSVD_RXUICR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RXUICR_RSVD_RXUICR_GET</csr:getMacro>
         <csr:setMacro>SSI_RXUICR_RSVD_RXUICR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1717</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RXUICR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.MSTICR</csr:referenceName>
       <csr:identifier>MSTICR</csr:identifier>
       <csr:addressMacro>SSI_MSTICR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_MSTICR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_MSTICR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_MSTICR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1745</csr:linenumber>
       <csr:title>Multi-Master Interrupt Clear Register</csr:title>
       <csr:offset>0x44</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_MSTICR</csr:typeName>
        <csr:description>
         <csr:p>Multi-Master Interrupt Clear Register.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>MSTICR</csr:identifier>
         <csr:widthMacro>SSI_MSTICR_MSTICR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_MSTICR_MSTICR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_MSTICR_MSTICR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_MSTICR_MSTICR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_MSTICR_MSTICR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_MSTICR_MSTICR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_MSTICR_MSTICR_GET</csr:getMacro>
         <csr:setMacro>SSI_MSTICR_MSTICR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1737</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Clear Multi-Master Contention Interrupt.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register reflects the status of the interrupt. A read from this</csr:p>
         <csr:p>register clears the ssi_mst_intr interrupt; writing has no effect.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_MSTICR</csr:identifier>
         <csr:widthMacro>SSI_MSTICR_RSVD_MSTICR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_MSTICR_RSVD_MSTICR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_MSTICR_RSVD_MSTICR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_MSTICR_RSVD_MSTICR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_MSTICR_RSVD_MSTICR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_MSTICR_RSVD_MSTICR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_MSTICR_RSVD_MSTICR_GET</csr:getMacro>
         <csr:setMacro>SSI_MSTICR_RSVD_MSTICR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1744</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>MSTICR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.ICR</csr:referenceName>
       <csr:identifier>ICR</csr:identifier>
       <csr:addressMacro>SSI_ICR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_ICR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_ICR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_ICR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1773</csr:linenumber>
       <csr:title>Interrupt Clear Register</csr:title>
       <csr:offset>0x48</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_ICR</csr:typeName>
        <csr:description>
         <csr:p>Interrupt Clear Register.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ICR</csr:identifier>
         <csr:widthMacro>SSI_ICR_ICR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_ICR_ICR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_ICR_ICR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_ICR_ICR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_ICR_ICR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_ICR_ICR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_ICR_ICR_GET</csr:getMacro>
         <csr:setMacro>SSI_ICR_ICR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1765</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Clear Interrupts.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is set if any of the interrupts below are active. A read</csr:p>
         <csr:p>clears the ssi_txo_intr, ssi_rxu_intr, ssi_rxo_intr, and the ssi_mst_intr</csr:p>
         <csr:p>interrupts. Writing to this register has no effect.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_ICR</csr:identifier>
         <csr:widthMacro>SSI_ICR_RSVD_ICR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_ICR_RSVD_ICR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_ICR_RSVD_ICR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_ICR_RSVD_ICR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_ICR_RSVD_ICR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_ICR_RSVD_ICR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_ICR_RSVD_ICR_GET</csr:getMacro>
         <csr:setMacro>SSI_ICR_RSVD_ICR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1772</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ICR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.IDR</csr:referenceName>
       <csr:identifier>IDR</csr:identifier>
       <csr:addressMacro>SSI_IDR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_IDR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_IDR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_IDR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1794</csr:linenumber>
       <csr:title>Identification Register</csr:title>
       <csr:offset>0x58</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0xffffffff</csr:registerResetValue>
       <csr:typeName>Ssi_IDR</csr:typeName>
        <csr:description>
         <csr:p>This register contains the peripherals identification code, which is</csr:p>
         <csr:p>written into the register at configuration time using coreConsultant.</csr:p>
         <csr:p>Reset Value: SSI_ID</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IDCODE</csr:identifier>
         <csr:widthMacro>SSI_IDR_IDCODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_IDR_IDCODE_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_IDR_IDCODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_IDR_IDCODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_IDR_IDCODE_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_IDR_IDCODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_IDR_IDCODE_GET</csr:getMacro>
         <csr:setMacro>SSI_IDR_IDCODE_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1793</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Identification code.</csr:p>
         <csr:p> The register contains the peripheral's identification code, which is written into the register at configuration time using CoreConsultant.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0xffffffff</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.SSI_VERSION_ID</csr:referenceName>
       <csr:identifier>SSI_VERSION_ID</csr:identifier>
       <csr:addressMacro>SSI_SSI_VERSION_ID_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_SSI_VERSION_ID_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_SSI_VERSION_ID_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_SSI_VERSION_ID_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1813</csr:linenumber>
       <csr:title>coreKit version ID Register</csr:title>
       <csr:offset>0x5C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x3430322a</csr:registerResetValue>
       <csr:typeName>Ssi_SSI_VERSION_ID</csr:typeName>
        <csr:description>
         <csr:p>This read-only register stores the specific DW_apb_ssi component version.</csr:p>
         <csr:p>Reset Value: SSI_VERSION_ID</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SSI_COMP_VERSION</csr:identifier>
         <csr:widthMacro>SSI_SSI_VERSION_ID_SSI_COMP_VERSION_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_SSI_VERSION_ID_SSI_COMP_VERSION_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_SSI_VERSION_ID_SSI_COMP_VERSION_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_SSI_VERSION_ID_SSI_COMP_VERSION_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_SSI_VERSION_ID_SSI_COMP_VERSION_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_SSI_VERSION_ID_SSI_COMP_VERSION_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_SSI_VERSION_ID_SSI_COMP_VERSION_GET</csr:getMacro>
         <csr:setMacro>SSI_SSI_VERSION_ID_SSI_COMP_VERSION_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1812</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Contains the hex representation of the Synopsys component version. Consists of ASCII value for each number in the version, followed by *. For example 32_30_31_2A represents the version 2.01*.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x3430322a</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR0</csr:referenceName>
       <csr:identifier>DR0</csr:identifier>
       <csr:addressMacro>SSI_DR0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1853</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x60</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR0</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR0_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR0_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR0_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR0_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR0_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR0_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR0_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR0_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1852</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR1</csr:referenceName>
       <csr:identifier>DR1</csr:identifier>
       <csr:addressMacro>SSI_DR1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1893</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x64</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR1</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR1_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR1_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR1_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR1_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR1_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR1_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR1_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR1_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1892</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR2</csr:referenceName>
       <csr:identifier>DR2</csr:identifier>
       <csr:addressMacro>SSI_DR2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1933</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x68</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR2</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR2_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR2_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR2_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR2_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR2_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR2_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR2_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR2_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1932</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR3</csr:referenceName>
       <csr:identifier>DR3</csr:identifier>
       <csr:addressMacro>SSI_DR3_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR3_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR3_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR3_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>1973</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x6C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR3</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR3_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR3_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR3_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR3_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR3_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR3_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR3_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR3_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>1972</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR4</csr:referenceName>
       <csr:identifier>DR4</csr:identifier>
       <csr:addressMacro>SSI_DR4_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR4_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR4_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR4_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2013</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x70</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR4</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR4_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR4_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR4_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR4_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR4_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR4_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR4_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR4_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2012</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR5</csr:referenceName>
       <csr:identifier>DR5</csr:identifier>
       <csr:addressMacro>SSI_DR5_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR5_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR5_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR5_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2053</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x74</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR5</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR5_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR5_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR5_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR5_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR5_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR5_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR5_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR5_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2052</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR6</csr:referenceName>
       <csr:identifier>DR6</csr:identifier>
       <csr:addressMacro>SSI_DR6_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR6_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR6_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR6_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2093</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x78</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR6</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR6_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR6_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR6_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR6_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR6_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR6_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR6_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR6_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2092</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR7</csr:referenceName>
       <csr:identifier>DR7</csr:identifier>
       <csr:addressMacro>SSI_DR7_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR7_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR7_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR7_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2133</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x7C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR7</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR7_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR7_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR7_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR7_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR7_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR7_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR7_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR7_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2132</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR8</csr:referenceName>
       <csr:identifier>DR8</csr:identifier>
       <csr:addressMacro>SSI_DR8_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR8_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR8_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR8_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2173</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x80</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR8</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR8_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR8_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR8_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR8_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR8_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR8_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR8_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR8_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2172</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR9</csr:referenceName>
       <csr:identifier>DR9</csr:identifier>
       <csr:addressMacro>SSI_DR9_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR9_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR9_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR9_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2213</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x84</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR9</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR9_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR9_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR9_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR9_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR9_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR9_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR9_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR9_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2212</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR10</csr:referenceName>
       <csr:identifier>DR10</csr:identifier>
       <csr:addressMacro>SSI_DR10_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR10_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR10_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR10_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2253</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x88</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR10</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR10_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR10_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR10_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR10_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR10_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR10_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR10_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR10_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2252</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR11</csr:referenceName>
       <csr:identifier>DR11</csr:identifier>
       <csr:addressMacro>SSI_DR11_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR11_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR11_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR11_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2293</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x8C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR11</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR11_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR11_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR11_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR11_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR11_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR11_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR11_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR11_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2292</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR12</csr:referenceName>
       <csr:identifier>DR12</csr:identifier>
       <csr:addressMacro>SSI_DR12_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR12_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR12_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR12_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2333</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x90</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR12</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR12_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR12_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR12_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR12_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR12_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR12_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR12_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR12_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2332</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR13</csr:referenceName>
       <csr:identifier>DR13</csr:identifier>
       <csr:addressMacro>SSI_DR13_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR13_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR13_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR13_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2373</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x94</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR13</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR13_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR13_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR13_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR13_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR13_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR13_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR13_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR13_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2372</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR14</csr:referenceName>
       <csr:identifier>DR14</csr:identifier>
       <csr:addressMacro>SSI_DR14_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR14_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR14_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR14_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2413</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x98</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR14</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR14_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR14_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR14_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR14_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR14_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR14_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR14_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR14_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2412</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR15</csr:referenceName>
       <csr:identifier>DR15</csr:identifier>
       <csr:addressMacro>SSI_DR15_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR15_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR15_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR15_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2453</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0x9C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR15</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR15_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR15_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR15_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR15_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR15_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR15_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR15_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR15_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2452</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR16</csr:referenceName>
       <csr:identifier>DR16</csr:identifier>
       <csr:addressMacro>SSI_DR16_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR16_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR16_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR16_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2493</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xA0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR16</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR16_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR16_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR16_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR16_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR16_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR16_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR16_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR16_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2492</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR17</csr:referenceName>
       <csr:identifier>DR17</csr:identifier>
       <csr:addressMacro>SSI_DR17_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR17_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR17_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR17_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2533</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xA4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR17</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR17_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR17_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR17_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR17_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR17_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR17_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR17_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR17_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2532</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR18</csr:referenceName>
       <csr:identifier>DR18</csr:identifier>
       <csr:addressMacro>SSI_DR18_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR18_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR18_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR18_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2573</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xA8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR18</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR18_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR18_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR18_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR18_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR18_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR18_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR18_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR18_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2572</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR19</csr:referenceName>
       <csr:identifier>DR19</csr:identifier>
       <csr:addressMacro>SSI_DR19_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR19_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR19_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR19_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2613</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xAC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR19</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR19_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR19_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR19_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR19_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR19_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR19_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR19_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR19_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2612</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR20</csr:referenceName>
       <csr:identifier>DR20</csr:identifier>
       <csr:addressMacro>SSI_DR20_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR20_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR20_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR20_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2653</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xB0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR20</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR20_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR20_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR20_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR20_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR20_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR20_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR20_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR20_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2652</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR21</csr:referenceName>
       <csr:identifier>DR21</csr:identifier>
       <csr:addressMacro>SSI_DR21_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR21_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR21_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR21_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2693</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xB4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR21</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR21_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR21_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR21_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR21_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR21_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR21_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR21_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR21_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2692</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR22</csr:referenceName>
       <csr:identifier>DR22</csr:identifier>
       <csr:addressMacro>SSI_DR22_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR22_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR22_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR22_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2733</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xB8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR22</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR22_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR22_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR22_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR22_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR22_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR22_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR22_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR22_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2732</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR23</csr:referenceName>
       <csr:identifier>DR23</csr:identifier>
       <csr:addressMacro>SSI_DR23_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR23_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR23_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR23_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2773</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xBC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR23</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR23_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR23_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR23_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR23_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR23_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR23_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR23_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR23_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2772</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR24</csr:referenceName>
       <csr:identifier>DR24</csr:identifier>
       <csr:addressMacro>SSI_DR24_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR24_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR24_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR24_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2813</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xC0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR24</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR24_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR24_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR24_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR24_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR24_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR24_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR24_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR24_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2812</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR25</csr:referenceName>
       <csr:identifier>DR25</csr:identifier>
       <csr:addressMacro>SSI_DR25_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR25_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR25_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR25_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2853</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xC4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR25</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR25_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR25_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR25_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR25_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR25_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR25_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR25_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR25_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2852</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR26</csr:referenceName>
       <csr:identifier>DR26</csr:identifier>
       <csr:addressMacro>SSI_DR26_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR26_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR26_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR26_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2893</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xC8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR26</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR26_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR26_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR26_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR26_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR26_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR26_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR26_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR26_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2892</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR27</csr:referenceName>
       <csr:identifier>DR27</csr:identifier>
       <csr:addressMacro>SSI_DR27_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR27_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR27_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR27_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2933</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xCC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR27</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR27_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR27_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR27_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR27_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR27_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR27_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR27_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR27_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2932</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR28</csr:referenceName>
       <csr:identifier>DR28</csr:identifier>
       <csr:addressMacro>SSI_DR28_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR28_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR28_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR28_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>2973</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xD0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR28</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR28_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR28_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR28_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR28_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR28_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR28_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR28_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR28_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>2972</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR29</csr:referenceName>
       <csr:identifier>DR29</csr:identifier>
       <csr:addressMacro>SSI_DR29_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR29_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR29_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR29_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>3013</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xD4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR29</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR29_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR29_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR29_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR29_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR29_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR29_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR29_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR29_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>3012</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR30</csr:referenceName>
       <csr:identifier>DR30</csr:identifier>
       <csr:addressMacro>SSI_DR30_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR30_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR30_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR30_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>3053</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xD8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR30</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR30_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR30_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR30_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR30_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR30_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR30_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR30_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR30_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>3052</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR31</csr:referenceName>
       <csr:identifier>DR31</csr:identifier>
       <csr:addressMacro>SSI_DR31_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR31_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR31_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR31_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>3093</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xDC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR31</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR31_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR31_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR31_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR31_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR31_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR31_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR31_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR31_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>3092</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR32</csr:referenceName>
       <csr:identifier>DR32</csr:identifier>
       <csr:addressMacro>SSI_DR32_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR32_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR32_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR32_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>3133</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xE0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR32</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR32_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR32_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR32_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR32_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR32_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR32_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR32_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR32_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>3132</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR33</csr:referenceName>
       <csr:identifier>DR33</csr:identifier>
       <csr:addressMacro>SSI_DR33_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR33_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR33_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR33_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>3173</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xE4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR33</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR33_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR33_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR33_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR33_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR33_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR33_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR33_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR33_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>3172</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR34</csr:referenceName>
       <csr:identifier>DR34</csr:identifier>
       <csr:addressMacro>SSI_DR34_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR34_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR34_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR34_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>3213</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xE8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR34</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR34_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR34_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR34_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR34_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR34_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR34_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR34_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR34_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>3212</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.DR35</csr:referenceName>
       <csr:identifier>DR35</csr:identifier>
       <csr:addressMacro>SSI_DR35_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_DR35_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_DR35_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_DR35_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>3253</csr:linenumber>
       <csr:title>Data Register x</csr:title>
       <csr:offset>0xEC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_DR35</csr:typeName>
        <csr:description>
         <csr:p>The DW_apb_ssi data register is a 16/32-bit (depending on SSI_MAX_XFER_SIZE) read/write buffer for</csr:p>
         <csr:p>the transmit/receive FIFOs. If the configuration parameter SSI_MAX_XFER_SIZE is set to 32, then all 32 bits</csr:p>
         <csr:p>are valid, otherwise, only 16 bits ([15:0]) of the register are valid. When the register is read, data in the</csr:p>
         <csr:p>receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write</csr:p>
         <csr:p>can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.</csr:p>
         <csr:p>NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit address locations of the memory</csr:p>
         <csr:p>map to facilitate AHB burst transfers. Writing to any of these address locations has the same</csr:p>
         <csr:p>effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of</csr:p>
         <csr:p>these locations has the same effect as popping data from the receive FIFO onto the prdata</csr:p>
         <csr:p>bus. The FIFO buffers on the DW_apb_ssi are not addressable.</csr:p>
         <csr:p>Reset Value: 0x0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>SSI_DR35_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_DR35_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_DR35_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_DR35_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_DR35_DR_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_DR35_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_DR35_DR_GET</csr:getMacro>
         <csr:setMacro>SSI_DR35_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>3252</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Register. When writing to this register, you must right-justify the data. Read</csr:p>
         <csr:p>data are automatically right-justified. If SSI_MAX_XFER_SIZE configuration</csr:p>
         <csr:p>parameter is set to 32, all 32 bits are valid. Otherwise, only 16 bits ([15:0]) of the</csr:p>
         <csr:p>register are valid.</csr:p>
         <csr:p>Read = Receive FIFO buffer</csr:p>
         <csr:p>Write = Transmit FIFO buffer.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ssi.RSVD</csr:referenceName>
       <csr:identifier>RSVD</csr:identifier>
       <csr:addressMacro>SSI_RSVD_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>SSI_RSVD_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>SSI_RSVD_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>SSI_RSVD_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_ssi.csr</csr:filename>
       <csr:linenumber>3267</csr:linenumber>
       <csr:title>RSVD - Reserved address location</csr:title>
       <csr:offset>0xFC</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Ssi_RSVD</csr:typeName>
        <csr:description>
         <csr:p>RSVD - Reserved address location.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RSVD</csr:identifier>
         <csr:widthMacro>SSI_RSVD_RSVD_WIDTH</csr:widthMacro>
         <csr:msbMacro>SSI_RSVD_RSVD_MSB</csr:msbMacro>
         <csr:lsbMacro>SSI_RSVD_RSVD_LSB</csr:lsbMacro>
         <csr:rangeMacro>SSI_RSVD_RSVD_RANGE</csr:rangeMacro>
         <csr:resetMacro>SSI_RSVD_RSVD_RESET</csr:resetMacro>
         <csr:maskMacro>SSI_RSVD_RSVD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>SSI_RSVD_RSVD_GET</csr:getMacro>
         <csr:setMacro>SSI_RSVD_RSVD_SET</csr:setMacro>
         <csr:filename>DW_apb_ssi.csr</csr:filename>
         <csr:linenumber>3266</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RSVD 31to0 Reserved address location</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
     </csr:definitions>
    </csr:csrObject>
   </csr:csrData>
  </xml>
  <div id="docheader">
   <h2>Addressmap Information for 'DW_apb_ssi'</h2>
   <table id="optiontable" border="1" cellpadding="1">
    <tr>
     <td>
      <div id="globalFileInfoCheckBoxDiv">
       <label for="globalFileInfoCheckBox">Input File Information</label>
       <input id="globalFileInfoCheckBox" type="checkbox" onclick="globalFileInfoCheckBox_click();"/>
      </div>
     </td>
     <td>
      <div id="globalHeaderFileInfoCheckBoxDiv">
       <label for="globalHeaderFileInfoCheckBox">Header File Information</label>
       <input id="globalHeaderFileInfoCheckBox" type="checkbox" onclick="globalHeaderFileInfoCheckBox_click();"/>
      </div>
     </td>
     <td>
      <div id="globalEnumInfoCheckBoxDiv">
       <label for="globalEnumInfoCheckBox">Enum Information</label>
       <input id="globalEnumInfoCheckBox" type="checkbox" onclick="globalEnumInfoCheckBox_click();"/>
      </div>
     </td>
    </tr>
   </table>
  </div>
  <div id="docinfo"></div>
  <div id="docroot"></div>
  <div id="docfooter"></div>
 </body>
</html>
