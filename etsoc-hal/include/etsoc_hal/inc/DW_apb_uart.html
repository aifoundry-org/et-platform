<!--                                                                      -->
<!--                                                                      -->
<!-- Generated by Semifore, Inc. csrCompile                               -->
<!--    HTML output                                                       -->
<html>
 <head>
  <title>Addressmap Information for 'DW_apb_uart'</title>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
  <meta http-equiv="Expires" content="0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
   /*
    * Copyright (c) SEMIFORE, INC. 2006-2015. All rights reserved.
    *
    * This software and documentation constitute an unpublished work and
    * contain valuable trade secrets and proprietary information belonging
    * to Semifore, Inc.  None of the foregoing material may be copied,
    * duplicated or disclosed without the express written permission of
    * Semifore, Inc.
    * SEMIFORE, INC. EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING
    * THIS SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF
    * MERCHANTABILITY AND/OR FITNESS FOR ANY PARTICULAR PURPOSE,
    * AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY THAT
    * MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
    * TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT
    * TO THE USE OF THE SOFTWARE OR DOCUMENTATION.
    * Under no circumstances shall Semifore, Inc. be liable for incidental,
    * special, indirect, direct or consequential damages or loss of profits,
    * interruption of business, or related expenses which may arise from use
    * of this software or documentation, including but not limited to those
    * resulting from defects in software and/or documentation, or loss or
    * inaccuracy of data of any kind.
   */
   
   /*
    * csrStyles.css
    *
    * $Revision: 1.20 $
    * $Date: 2015/09/06 01:23:08 $
    *
    * @(#)$Id: csrStyles.css,v 1.20 2015/09/06 01:23:08 weber Exp $
    *
    * These are the CSS Styles attributes for the HTML pages
    *
   */
   
   body {
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   	margin: 0px;
           text-align: left;
           padding: 0px;
   	color: #4f6b72;
   	background-color: #e7e7e7;
   }
   
   a {
   	color: #c75f3e;
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   
   
   
   }
   
   div {
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   }
   
   table {
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   	background-color: #fff;
   
   
   	border-collapse: collapse;
   	margin-top: 2px;
   	margin-bottom: 2px;
   }
   
   
   th {
   	font: bold 7pt  Arial, Helvetica, sans-serif;
   	color: #4f6b72;
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   
   	letter-spacing: 1px;
   	text-align: left;
   	padding: 6px 6px 6px 12px;
   	background-color: #CAE8EA;
   }
   
   th.component {
           background-color: #FFCCFF;
   }
   
   th.addressmap {
           background-color: #CAE8EA;
   }
   
   th.register {
   	background-color: #CCFFCC;
   }
   
   th.group {
   	background-color: #FFFFCC;
   }
   
   th.union {
   	background-color: #CCCC00;
   }
   
   th.wideregister {
   	background-color: #FFCCCC;
   }
   
   th.memory {
   	background-color: #CCCCFF;
   }
   
   th.widememory {
   	background-color: #FF88FF;
   }
   
   th.submemory {
   	background-color: #CCCCFF;
   }
   
   th.field {
   	background-color: #CCFFFF;
   }
   
   
   td {
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   	background-color: #fff;
   	padding: 6px 6px 6px 12px;
   	color: #4f6b72;
   	text-align: left;
   }
   
   td.noborder {
   	border-right: 0px none #C1DAD7;
   	border-left: 0px none #C1DAD7;
   	border-bottom: 0px none #C1DAD7;
   	border-top: 0px none #C1DAD7;
   	background-color: #FFF;
   	text-align: left;
   }
   
   .addrMapClass
   {
   }
   
   
   .addrMapContent
   {
   }
   
   .frdiv {
   	float: right;
   }
   
   .fldiv {
   	float: left;
   	margin-right: 10px;
   }
   
   .window 
   {
     background-color: white; 
     border-color:  #7BA7E1;
     border-style: solid; 
     border-width: 1px;
     margin: 0px;
     padding: 0px;
     position: absolute;
     visibility: hidden;
   }
   
   .windowTitleBar 
   {
     background-color: #7BA7E1;
     border-style: none;
     color: white;
     font: bold 11pt auto  Arial, Helvetica, sans-serif;	
     margin-left: 6px;
     margin-right: 6px;
   }
   
   .windowList 
   {
     background-color: white;
     border-style: none; 
     border-width: 0px;
     margin: 0px;
     padding: 2px;
     position: absolute;
     left: 10px;
     top: 100px;
     width: 100px;
     height: 200px;
     visibility: hidden;
   }
   
   .windowListArea 
   {
     background-color: white;
     border-style: none; 
     border-width: 0px;
     text-align: center;
     margin: 0px 0px 0px 0px;
     overflow: auto;
     
   }
  </style>
  <script type="text/javascript">
   /*
    * Copyright (c) SEMIFORE, INC. 2006-2018. All rights reserved.
    *
    * This software and documentation constitute an unpublished work and
    * contain valuable trade secrets and proprietary information belonging
    * to Semifore, Inc.  None of the foregoing material may be copied,
    * duplicated or disclosed without the express written permission of
    * Semifore, Inc.
    * SEMIFORE, INC. EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING
    * THIS SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF
    * MERCHANTABILITY AND/OR FITNESS FOR ANY PARTICULAR PURPOSE,
    * AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY THAT
    * MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
    * TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT
    * TO THE USE OF THE SOFTWARE OR DOCUMENTATION.
    * Under no circumstances shall Semifore, Inc. be liable for incidental,
    * special, indirect, direct or consequential damages or loss of profits,
    * interruption of business, or related expenses which may arise from use
    * of this software or documentation, including but not limited to those
    * resulting from defects in software and/or documentation, or loss or
    * inaccuracy of data of any kind.
   */
   
   /*
    * csrJava.js
    *
    * $Revision: 1.75 $
    * $Date: 2018/02/22 02:35:02 $
    *
    * @(#)$Id: csrJava.js,v 1.75 2018/02/22 02:35:02 weber Exp $
    *
    * These are the Java Script functions for the HTML pages.
    *
   */
   
   var xmlDoc                   = 0;
   var debug                    = 0;
   var def_lookup_table         = new Array();
   var object_array             = new Array();
   var topDefinition_array      = new Array();
   var topObjectRefNames_array  = new Array();
   var definitions_array        = new Array();
   var csrNode_array            = new Array();
   var globalShowFileInfo       = false;
   var globalShowHeaderFileInfo = false;
   var globalShowEnumInfo       = false;
   var fileInfoDiv              = null;
   
   function csrNode() {
     this.referenceType = 0;
     this.referenceName = 0;
     this.definitionPtr = 0;
     this.objectIndex   = 0;
     this.divParent     = 0;
     this.divChild      = 0;
     this.visibility    = 0;
     this.addressMapWindow = 0;
     
     this.click = function() {
       if ( this.visibility == 0 )
       {
         //      alert('open ' + this.referenceName);
         printDefinition(this);
         this.visibility = 1;
         
         // window.location.hash = this.referenceName + 'Link';
         // if (mouseposy > 700 ) scrollBy(0,100);
       } else
       {
         //      alert('close' +  this.referenceName);
         this.divParent.removeChild(this.divChild);
         this.visibility = 0;
   
         //window.location.hash = this.referenceName + 'Link';
         
       }
     }
   
     this.expand = function() {
       if ( this.visibility == 0 )
       this.click();
     }
   
     this.collapse = function() {
       if (this.visibility == 1 )
       this.click();
     }
   
     this.showFileInfo = function () {
        return globalShowFileInfo;
     }
   
     this.showHeaderFileInfo = function () {
        return globalShowHeaderFileInfo;
     }
   
     this.showEnumInfo = function () {
        return globalShowEnumInfo;
     }
   }
   
   //debug alrets
   function alertd( msg ) 
   {
     if (debug) 
       alert(msg);
   }
   
   var mouseposx = 0;
   var mouseposy = 0;
   
   function getMousePos(e) {
     
   	if (!e) var e = window.event;
   	
   	if (e.pageX || e.pageY) 	{
   		mouseposx = e.pageX;
   		mouseposy = e.pageY;
   	}
   	else if (e.clientX || e.clientY) 	{
   		mouseposx = e.clientX + document.body.scrollLeft
   			+ document.documentElement.scrollLeft;
   		mouseposy = e.clientY + document.body.scrollTop
   			+ document.documentElement.scrollTop;
   	}
   }
   
   function redrawAll ()
   {
      var topObject;
   
      for (var i=0; i < topObjectRefNames_array.length; i++) {
         topObject = csrNodeLookup(i,topObjectRefNames_array[i]);
         if (topObject != null) {
            topObject.click();
            topObject.click();
         }
      }
   }
   
   function globalFileInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalFileInfoCheckBox');
   
      if (checkbox != null) {
         globalShowFileInfo = checkbox.checked;
   
         if (globalShowFileInfo) {
            printFileInfo();
         }
         else {
            var docinfo = document.getElementById('docinfo');
            if ((docinfo != null) && (fileInfoDiv != null)) {
               docinfo.removeChild(fileInfoDiv);
            }
         }
         redrawAll();
      }
   }
   
   function globalHeaderFileInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalHeaderFileInfoCheckBox');
   
      if (checkbox != null) {
         globalShowHeaderFileInfo = checkbox.checked;
         redrawAll();
      }
   }
   
   function globalEnumInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalEnumInfoCheckBox');
   
      if (checkbox != null) {
         globalShowEnumInfo = checkbox.checked;
         redrawAll();
      }
   }
   
   //import XML
   function importXML(xmlId)
   {
      xmlDoc = document.getElementById(xmlId);
      if (xmlDoc) {
         init();
      }
   }
   
   
   //parser helpers
   function getNodes_tag(node, tag)
   {
      return node.getElementsByTagName('csr:' + tag);
   }
   
   function getNodeValue_tag(node, tag)
   {
      var nodelist;
   
      nodelist = node.getElementsByTagName('csr:' + tag);
      if (nodelist.length > 0) {
         if (nodelist[0].firstChild) {
            return nodelist[0].firstChild.nodeValue;
         }
         else {
            return '';
         }
      }
      else {
         return '';
      }
   }
   
   function getNodeValue(node)
   {
     for (var i=0; node[0].childNodes.length; i++ )
       {
         
         if (node[0].childNodes[i].nodeType != 1) continue;
         return node[0].childNodes[i].firstChild.nodeValue
   
       }
   }
   
   function getNodeValue_description(node) 
   {
     var description = getNodes_tag(node,'description');
   
     if (description.length < 1)
       return '';
   
     var ptags = getNodes_tag(description[0],'p');
     var ret_string = '';
     
     for (var i=0; i < ptags.length; i++) {
        if (ptags[i].firstChild) {
           ret_string += '<p>' + ptags[i].firstChild.nodeValue + '</p>';
        }
        else {
           ret_string += '<p></p>';
        }
     }
     
     return ret_string;
   }
   
   function getNodeValue_attributes(node)
   {
      var attributesTag = getNodes_tag(node,'attributes');
   
      if (attributesTag.length < 1)
         return '';
      var attributeTags = getNodes_tag(attributesTag[0],'attribute');
      var result = '';
      var i;
   
      for (i=0; i < attributeTags.length; i++) {
         if (attributeTags[i].firstChild) {
            result += attributeTags[i].firstChild.nodeValue + '<br>';
         }
      }
   
      return result;
   }
   
   function getNodeValue_fieldAttributes(node)
   {
      var attributesTag = getNodes_tag(node,'fieldAttributes');
   
      if (attributesTag.length < 1)
         return '';
      var attributeTags = getNodes_tag(attributesTag[0],'attribute');
      var result = '';
      var i;
   
      for (i=0; i < attributeTags.length; i++) {
         if (attributeTags[i].firstChild) {
            result += attributeTags[i].firstChild.nodeValue + '<br>';
         }
      }
   
      return result;
   }
   
   function init() 
   {
     setGlobals();
   
     if (globalShowFileInfo) {
        printFileInfo();
     }
     
     printTopObjects();
     
   }
   
   function printHeader() 
   {
     header = document.getElementById('docheader');
     //header.innerHTML = "Header Text Goes Here";
   }
   
   
   function printFooter() 
   {
     footer = document.getElementById('docfooter');
     //footer.innerHTML = "Footer Text Goes Here";
   }
   
   
   function setGlobals() 
   {
     var checkbox;
   
     alertd(xmlDoc);
   
     checkbox = document.getElementById('globalFileInfoCheckBox');
     if (checkbox != null) {
        globalShowFileInfo = checkbox.checked;
     }
     checkbox = document.getElementById('globalHeaderFileInfoCheckBox');
     if (checkbox != null) {
        globalShowHeaderFileInfo = checkbox.checked;
     }
     checkbox = document.getElementById('globalEnumInfoCheckBox');
     if (checkbox != null) {
        globalShowEnumInfo = checkbox.checked;
     }
   
     // get the object elements
     object_array = getNodes_tag(xmlDoc,'csrObject');
     alertd('number of object_array elements=' + object_array.length);
   
     // create 2D lookup table array
     for (var i=0; i < object_array.length; i++)
       {
         def_lookup_table[i] = new Object();
         csrNode_array[i] = new Object();
       }
   
     // get the top definition elements
     for (var i=0; i < object_array.length; i++ )
       {
         topDefinition_array[i] = getNodes_tag(object_array[i],'topDefinition'); 
       }
     alertd('number of topDefinition_array elements=' + topDefinition_array.length);
   
     // get the referenece names of the top level modules
     for (var i=0; i < topDefinition_array.length; i++)
       {
         topObjectRefNames_array[i] = getNodeValue(topDefinition_array[i]);
         alertd('topObjectRefNames_array[' + i + ']=' + topObjectRefNames_array[i]);
       }
     
      
     // get definition elements
     for (var i=0; i < object_array.length; i++) 
       {
         definitions_array[i] = getNodes_tag(object_array[i],'definition');
       }
     alertd('number of definitions_array element=' + definitions_array.length);
     //alertd('definitions_array[0] =' + definitions_array[0].length + ' elements');
   
     // populate the definitions lookup table
     for ( var i=0; i < object_array.length; i++) 
       {
         for (var j=0; j < definitions_array[i].length; j++)
   	{
   	  referenceName = getNodeValue_tag(definitions_array[i][j], "referenceName");
   	  referenceType = getNodeValue_tag(definitions_array[i][j], "referenceType");
   	  def_lookup_table[i][referenceName] = definitions_array[i][j];
   	  
   	  var csrNode_obj = new csrNode();
   
   	  csrNode_obj.referenceName = referenceName;
   	  csrNode_obj.referenceType = referenceType;
   	  csrNode_obj.definitionPtr = definitions_array[i][j];
   	  csrNode_obj.objectIndex   = i;
   	  
   	  csrNode_array[i][referenceName] = csrNode_obj;
   	}
       
       }
   }
   
   
   function printFileInfo()
   {
      var docinfo = document.getElementById('docinfo');
   
      if (docinfo != null) {
         var inputFilesNodes = getNodes_tag(xmlDoc,'inputFiles');
         var includedFilesNodes = getNodes_tag(xmlDoc,'includedFiles');
         var configurationFilesNodes = getNodes_tag(xmlDoc,'configurationFiles');
         var fileNodes;
         var filename;
         var fileversionNodes;
         var table;
         var body;
         var row;
         var cell;
   
         fileInfoDiv = document.createElement('DIV');
   
         if (inputFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Input Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(inputFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         if (includedFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Included Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(includedFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         if (configurationFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Configuration Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(configurationFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         docinfo.appendChild(fileInfoDiv);
      }
   }
   
   function printTopObjects()
   {
     var csrNode;
     //print top level modules
     for ( var i=0; i < topObjectRefNames_array.length; i++)
       {
         csrNode = csrNodeLookup(i,topObjectRefNames_array[i]);
         if (csrNode.referenceType == 'component') {
            printTopComponentTable(csrNode);
         }
         else {
            printTopAddressmapTable(csrNode);
         }
         csrNode.expand();
       }
   }
   
   function csrNodeLookup(objectIndex, referenceName)
   {
      return csrNode_array[objectIndex][referenceName];
   }
   
   function printDefinition(csrNode)
   {
     
     referenceType = csrNode.referenceType;
   
     //case  
     switch (referenceType) 
       {
       case "component":
         printComponentDefinition(csrNode);
         break;
       case "addressmap":
         printAddressmapDefinition(csrNode);
         break;
       case "group":
         printGroupDefinition(csrNode);
         break;
       case "union":
         printUnionDefinition(csrNode);
         break;
       case "register":
         printRegisterDefinition(csrNode);
         break;
       case "wideregister":
         printWideRegisterDefinition(csrNode);
         break;
       case "memory":
         printMemoryDefinition(csrNode);
         break;
       case "widememory":
         printWideMemoryDefinition(csrNode);
         break;
       default:
         alertd('No default referenceType!');
       }
   }
   
   function printLeafDefinition(csrNode) 
   {
     referenceName_array = csrNode.referenceName.split(".");
   
     //print the def top down
     var parent_ref = '';
     for( var i = 0; i < referenceName_array.length; i++ )
       {
         var refName    = parent_ref + referenceName_array[i];
         var csrNode = csrNodeLookup(csrNode.objectIndex, refName);
         //if ( csrNodeObj.visibility == 0 )
         csrNode.expand();
         parent_ref = refName + '.';
       }
   
     //jump the window the the leaf link
     window.location.hash = '#' + csrNode.referenceName + 'Link';
   
     //move the address map so it remains onscreen
     var parent_ref = '';
     for( var i = 0; i < referenceName_array.length; i++ )
       {
         var refName    = parent_ref + referenceName_array[i];
         var csrNode = csrNodeLookup(csrNode.objectIndex, refName);
         //if ( csrNodeObj.visibility == 0 )
         if (csrNode.addressMapWindow) {
            csrNode.addressMapWindow.window.style.top =
               document.body.scrollTop + 25; 
         }
         parent_ref = refName + '.';
       }
   
   
     //highlight the div
     //highLightDiv(csrNode.referenceName);
     unhighLightDiv(csrNode.referenceName);
   
   }
   
   
   function printTopComponentTable(csrNode)
   {
   
     var xmlNode = csrNode.definitionPtr;
     //div to enclose module
     var moduleDiv     = document.createElement('DIV');
     var referenceName = csrNode.referenceName;
     var referenceType = csrNode.referenceType;
     var identifier    = getNodeValue_tag(xmlNode,"identifier");
   
     //set the div ID to the referenceName
     moduleDiv.id      = referenceName;
   
     csrNode.divParent = moduleDiv;
   
   
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
     var row = document.createElement('TR');
   
     var container     = document.createElement('TH');
     var theData       = document.createElement("div");
     theData.innerHTML = referenceType; 
     container.appendChild(theData);
     container.className = referenceType;
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'Link';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'ExpandAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'ExpandAllLink" onclick="expandAllNodes(' + csrNode.objectIndex + ');">' + 'expand all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   	
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'CollapseAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'CollapseAllLink" onclick="collapseAllNodes(' + csrNode.objectIndex + ');">' + 'collapse all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     tmp.appendChild(row);
   
     //add elements to DOM
     moduleDiv.appendChild(tableEl);
     document.getElementById('docroot').appendChild(moduleDiv);
   }
   
   
   function printTopAddressmapTable(csrNode)
   {
   
     var xmlNode = csrNode.definitionPtr;
     //div to enclose module
     var moduleDiv     = document.createElement('DIV');
     var referenceName = csrNode.referenceName;
     var referenceType = csrNode.referenceType;
     var identifier    = getNodeValue_tag(xmlNode,"identifier");
   
     //set the div ID to the referenceName
     moduleDiv.id      = referenceName;
   
     csrNode.divParent = moduleDiv;
   
   
     var tableEl = document.createElement('TABLE');
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
     var row = document.createElement('TR');
   
     var container     = document.createElement('TH');
     var theData       = document.createElement("div");
     theData.innerHTML = referenceType; 
     container.appendChild(theData);
     container.className = csrNode.referenceType;
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'Link';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'AddrMapLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'AddrMapLink" onclick="printAddressMap(' + csrNode.objectIndex + ',\'' + referenceName + '\');">' + 'address map' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
     
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'ExpandAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'ExpandAllLink" onclick="expandAllNodes(' + csrNode.objectIndex + ');">' + 'expand all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   	
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'CollapseAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'CollapseAllLink" onclick="collapseAllNodes(' + csrNode.objectIndex + ');">' + 'collapse all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     tmp.appendChild(row);
   
     //add elements to DOM
     moduleDiv.appendChild(tableEl);
     document.getElementById('docroot').appendChild(moduleDiv);
   }
   
   
   function printComponentDefinition(csrNode) 
   {
     var xmlNode = csrNode.definitionPtr;
     var componentDefContentDiv = document.createElement('DIV');
     componentDefContentDiv.style.marginLeft = "25px";
     componentDefContentDiv.id = csrNode.divParent.id+ 'DefContentDiv';
   
     csrNode.divChild = componentDefContentDiv;
   
     var identifier          = getNodeValue_tag(xmlNode,"identifier");
     var title               = getNodeValue_tag(xmlNode,"title");
     var description         = getNodeValue_description(xmlNode);
     var filename            = getNodeValue_tag(xmlNode,"filename");
     var linenumber          = getNodeValue_tag(xmlNode,"linenumber");
     var attributes          = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        if (filename != '') {
           tableData_array['Filename'] = filename;
        }
        if (linenumber != '') {
           tableData_array['Linenumber'] = linenumber;
        }
     }
     printRefInfoTable( tableData_array, componentDefContentDiv, csrNode);
     
     csrNode.divParent.appendChild( componentDefContentDiv );
   
     printComponentReference_links( csrNode );
   
   }
   
   function printAddressmapDefinition(csrNode) 
   {
     var xmlNode = csrNode.definitionPtr;
     var moduleDefContentDiv = document.createElement('DIV');
     moduleDefContentDiv.style.marginLeft = "25px";
     //moduleDefContentDiv.id = domParentNode.id + 'DefContentDiv';
     moduleDefContentDiv.id = csrNode.divParent.id+ 'DefContentDiv';
   
     csrNode.divChild = moduleDefContentDiv;
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var addressmapReference =
                           getNodeValue_tag(xmlNode,"addressmapReference");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (addressmapReference != '') {
        tableData_array['Reference']  = addressmapReference;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        if (filename != '') {
           tableData_array['Filename'] = filename;
        }
        if (linenumber != '') {
           tableData_array['Linenumber'] = linenumber;
        }
     }
     if (csrNode.showHeaderFileInfo()) {
        if (addressMacro != '') {
           tableData_array['Address Macro'] = addressMacro;
        }
        if (offsetMacro != '') {
           tableData_array['Offset Macro'] = offsetMacro;
        }
        if (typeName != '') {
           tableData_array['Type Name'] = typeName;
        }
     }
   
     printRefInfoTable( tableData_array, moduleDefContentDiv, csrNode);
     
     csrNode.divParent.appendChild( moduleDefContentDiv );
   
     printReference_links( csrNode );
   
   }
   
   
   function printReference_links(csrNode) {
   
    
     var objectIndex = csrNode.objectIndex;
     xmlNode         = csrNode.definitionPtr;
   
     var references = getNodes_tag(xmlNode,'reference');
   
     for (var i=0; i < references.length; i++ )
       {
         
         var referenceType = getNodeValue_tag(references[i],"referenceType");
         var referenceName = getNodeValue_tag(references[i],"referenceName");
   
         referencedCsrNode = csrNodeLookup(objectIndex, referenceName);
         var identifier    =
             getNodeValue_tag(referencedCsrNode.definitionPtr,"identifier");
   
         var referenceDiv  = document.createElement('DIV');
         referenceDiv.id = referenceName;
         var tableData_array = new Array();
   
         tableData_array[referenceType] = '<a id="' + referenceName + 'Link" name="'+ referenceName + 'Link" ' + 'href="javascript:void(0);" onclick="csrNodeLookup(' + objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
   
         //set parent of referenced node
         referencedCsrNode.divParent = referenceDiv;
   
         printRefInfoTable( tableData_array, referenceDiv, referencedCsrNode);
   
         csrNode.divChild.appendChild(referenceDiv);
     
         if ( referencedCsrNode.visibility == 1 )
   	printDefinition(referencedCsrNode);
       }
   }
   
   
   function printComponentReference_links(csrNode) {
   
    
     var objectIndex = csrNode.objectIndex;
     xmlNode         = csrNode.definitionPtr;
     var table;
     var body;
     var row;
     var cell;
     var theData;
     var theLink;
   
     var references = getNodes_tag(xmlNode,'reference');
   
     for (var i=0; i < references.length; i++ )
       {
         
         var referenceType = getNodeValue_tag(references[i],"referenceType");
         var referenceName = getNodeValue_tag(references[i],"referenceName");
   
         referencedCsrNode = csrNodeLookup(objectIndex, referenceName);
         var identifier    =
             getNodeValue_tag(referencedCsrNode.definitionPtr,"identifier");
   
         var referenceDiv  = document.createElement('DIV');
         referenceDiv.id = referenceName;
         var tableData_array = new Array();
   
         table = document.createElement('TABLE');
         body = document.createElement('TBODY');
         row = document.createElement('TR');
   
         cell              = document.createElement('TH');
         theData           = document.createElement("div");
         theData.innerHTML = referenceType; 
         cell.appendChild(theData);
         cell.className = referenceType;
         row.appendChild(cell);
   
         cell              = document.createElement('TD');
         theLink           = document.createElement("div");
         theLink.id        = referenceName + 'Link';
         theLink.innerHTML = '<a id="' + referenceName + 'Link" href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
         cell.appendChild(theLink) 
         row.appendChild(cell);
   
         cell              = document.createElement('TD');
         theLink           = document.createElement("div");
         theLink.id        = referenceName + 'AddrMapLink';
         theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'AddrMapLink" onclick="printAddressMap(' + csrNode.objectIndex + ',\'' + referenceName + '\');">' + 'address map' + '</a>';
         cell.appendChild(theLink) 
         row.appendChild(cell);
   
         body.appendChild(row);
         table.appendChild(body);
         referenceDiv.appendChild(table);
   
         //set parent of referenced node
         referencedCsrNode.divParent = referenceDiv;
   
         csrNode.divChild.appendChild(referenceDiv);
     
         if ( referencedCsrNode.visibility == 1 )
   	printDefinition(referencedCsrNode);
       }
   }
   
   function printGroupDefinition(csrNode)
   {
   
     var groupReferenceName        = csrNode.referenceName;
     var groupParentDiv            = document.getElementById(groupReferenceName);
     
     csrNode.divParent = groupParentDiv;
     var xmlNode = csrNode.definitionPtr;
   
     var groupDiv                  = document.createElement('DIV');
     groupDiv.id               = groupParentDiv.id + "child";
     groupDiv.style.marginLeft = "25px";
     
     csrNode.divChild = groupDiv;
   
     groupParentDiv.appendChild(groupDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayMax        = getNodeValue_tag(xmlNode,"arrayMax");
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']   = filename;
        tableData_array['Linenumber'] = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, groupDiv, csrNode);
   
   
     printReference_links(csrNode);
   
   }
   
   function printUnionDefinition(csrNode)
   {
   
     var unionReferenceName        = csrNode.referenceName;
     var unionParentDiv            = document.getElementById(unionReferenceName);
     
     csrNode.divParent = unionParentDiv;
     var xmlNode = csrNode.definitionPtr;
   
     var unionDiv                  = document.createElement('DIV');
     unionDiv.id               = unionParentDiv.id + "child";
     unionDiv.style.marginLeft = "25px";
     
     csrNode.divChild = unionDiv;
   
     unionParentDiv.appendChild(unionDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayMax        = getNodeValue_tag(xmlNode,"arrayMax");
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
       tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']   = filename;
        tableData_array['Linenumber'] = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, unionDiv, csrNode);
   
     printReference_links(csrNode);
   
   }
   
   function printRegisterDefinition(csrNode) 
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var aliasOf         = getNodeValue_tag(xmlNode,"aliasOf");
     var aliases         = getNodes_tag(xmlNode,'aliases');
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"registerResetValue");
     var resetMask       = getNodeValue_tag(xmlNode,"registerResetMask");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var isVolatile      = getNodeValue_tag(xmlNode,"volatile");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (aliasOf != '') {
        tableData_array['Alias Of'] = '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasOf + '\'));">' + aliasOf + '</a>';
     }
     if (aliases.length > 0) {
        var aliasList = getNodes_tag(aliases[0],'alias');
        var aliasesString = '';
        var aliasValue;
        if (aliasList[0].firstChild) {
              aliasValue = aliasList[0].firstChild.nodeValue;
              aliasesString += '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasValue + '\'));">' + aliasValue + '</a>';
        }
        for ( var i=1; i < aliasList.length; i++ ) {
           if (aliasList[i].firstChild) {
              aliasValue = aliasList[i].firstChild.nodeValue;
              aliasesString += '<br>';
              aliasesString += '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasValue + '\'));">' + aliasValue + '</a>';
           }
        }
        tableData_array['Aliases'] = aliasesString;
     }
     if (isVolatile != '') {
        tableData_array['Volatile'] = ((isVolatile == 'true') ? '1': '0');
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if ((resetValue != '') && (resetMask != '')) {
        tableData_array['Reset Mask'] = resetMask;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printCsrBitFields( csrNode );
   
   }
   
   function printCsrBitFields( csrNode )
   {
     var xmlNode = csrNode.definitionPtr;
    
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
     var fieldsHaveClockDomains =
        (getNodeValue_tag(xmlNode, "clockDomains") == 'true');
     var fieldsHaveSynchronizer =
        (getNodeValue_tag(xmlNode, "synchronizers") == 'true');
     var fieldsHaveAttributes =
        (getNodeValue_tag(xmlNode, "fieldsHaveAttributes") == 'true');
     var headers;
   
   //Header Row
     headers = ['Identifier', 'Title', 'Bit', 'Access', 'Reset'];
     if (fieldsHaveClockDomains) {
        headers.push('Clock Domain');
     }
     if (fieldsHaveSynchronizer) {
        headers.push('Synchronizer');
     }
     if (fieldsHaveAttributes) {
        headers.push('Attributes');
     }
     headers.push('Description');
   
     var row           = document.createElement('TR');
     for ( var i=0; i<headers.length; i++ ) 
       {
        
         var container     = document.createElement('TH');
         var theData       = document.createElement('DIV');
         theData.innerHTML = headers[i];
         container.className = csrNode.referenceType;
         container.appendChild(theData);
         row.appendChild(container);
       }
     tmp.appendChild(row);
   
     var bitfields = getNodes_tag(xmlNode,'bitfield');
   
     
   
     for ( var i=0; i < bitfields.length; i++ )
       {
         var identifier  = getNodeValue_tag(bitfields[i],"identifier");
         var title       = getNodeValue_tag(bitfields[i],"title");
         var msb         = getNodeValue_tag(bitfields[i],"msb");
         var lsb         = getNodeValue_tag(bitfields[i],"lsb");
   
         if (msb == lsb) 
   	var bit         = '[' + msb + ']';
         else 
   	var bit         = '[' + msb + ':' + lsb +']';
         
   
         var access      = getNodeValue_tag(bitfields[i],"access");
         var reset       = getNodeValue_tag(bitfields[i],"resetValue");
         var description = getNodeValue_description(bitfields[i]);
         var attributes  = getNodeValue_fieldAttributes(bitfields[i]);
   
         var clockDomain    = getNodeValue_tag(bitfields[i],"clockDomain");
         var synchronizer   = getNodeValue_tag(bitfields[i],"synchronizer");
   
         var widthMacro     = getNodeValue_tag(bitfields[i],"widthMacro");
         var msbMacro       = getNodeValue_tag(bitfields[i],"msbMacro");
         var lsbMacro       = getNodeValue_tag(bitfields[i],"lsbMacro");
         var rangeMacro     = getNodeValue_tag(bitfields[i],"rangeMacro");
         var resetMacro     = getNodeValue_tag(bitfields[i],"resetMacro");
         var getMacro       = getNodeValue_tag(bitfields[i],"getMacro");
         var setMacro       = getNodeValue_tag(bitfields[i],"setMacro");
   
         var filename       = getNodeValue_tag(bitfields[i],"filename");
         var linenumber     = getNodeValue_tag(bitfields[i],"linenumber");
         var enums          = getNodes_tag(bitfields[i], "enumeration");
   
         var row_data;
   
         row_data = [identifier, title, bit, access.toUpperCase(), reset];
         if (fieldsHaveClockDomains) {
            row_data.push(clockDomain);
         }
         if (fieldsHaveSynchronizer) {
            row_data.push(synchronizer);
         }
         if (fieldsHaveAttributes) {
            row_data.push(attributes);
         }
         row_data.push(description);
         row         = document.createElement('TR');
         
         for ( var j=0; j<row_data.length; j++ ) {
            var container     = document.createElement('TD');
            var theData       = document.createElement('DIV');
            theData.innerHTML = row_data[j];
            container.appendChild(theData);
            row.appendChild(container);
         }
         tmp.appendChild(row);
   
         //FIX ME SNPS title check not cool (there for reserved fields)
         if (
            (
               csrNode.showFileInfo() ||
               csrNode.showHeaderFileInfo() ||
               (csrNode.showEnumInfo() && enums && (enums.length > 0))
               ) &&
            (title != "-") &&
            (csrNode.referenceType != 'wideregister')
            ) {
            row         = document.createElement('TR');
            var container     = document.createElement('TD');
            container.colSpan = row_data.length;
            container.style.backgroundColor = "#e7e7e7";
           
            if (csrNode.showFileInfo()) {
              var tableData_array = new Array();
              var theData       = document.createElement('DIV');
              theData.className = "fldiv";
              tableData_array['Filename']   = filename;
              tableData_array['Linenumber'] = linenumber;
              printRefInfoTable(tableData_array, theData, csrNode);
              container.appendChild(theData);
            }
   
            if (csrNode.showHeaderFileInfo()) {
              var tableData_array = new Array();
              var theData       = document.createElement('DIV');
              theData.className = "fldiv";
              tableData_array['Width Macro']   = widthMacro;
              tableData_array['Range Macro']   = rangeMacro;
              tableData_array['Msb Macro']     = msbMacro;
              tableData_array['Lsb Macro']     = lsbMacro;
              tableData_array['Reset Macro']   = resetMacro;
              tableData_array['Set Macro']     = setMacro;
              tableData_array['Get Macro']     = getMacro;
              printRefInfoTable(tableData_array, theData, csrNode);
              container.appendChild(theData);
            }
   
            if (csrNode.showEnumInfo() && enums && (enums.length > 0)) {
              var enumDiv = printFieldEnumTable(csrNode, enums);
              container.appendChild(enumDiv);
            }
   
            row.appendChild(container);
   
            tmp.appendChild(row);
         }
         
   
         
       }
     
     csrNode.divChild.appendChild(tableEl);
     
   }
   
   function printFieldEnumTable( csrNode, enums )
   {
     var enumDiv       = document.createElement('DIV');
     enumDiv.className = "fldiv";
     var table = document.createElement('TABLE');
     var body = document.createElement('TBODY');
   
     var titles = (getNodeValue_tag(enums[0], "titles") == 'true');
     var descriptions = (getNodeValue_tag(enums[0], "descriptions") == 'true');
     var hasPartialAccess =
        (getNodeValue_tag(enums[0], "enumeratorsHavePartialAccess") == 'true');
   
     var headerCells = [];
     if (titles) {
        headerCells.push('Title');
     }
     headerCells.push('Identifier');
     headerCells.push('Value');
     if (hasPartialAccess) {
        headerCells.push('Access')
     }
     if (descriptions) {
        headerCells.push('Description')
     }
   
     var headerRow = document.createElement('TR');
     for ( var i=0; i < headerCells.length; i++ ) {
       var container     = document.createElement('TH');
       var theData       = document.createElement('DIV');
       theData.innerHTML = headerCells[i];
       container.appendChild(theData);
       container.className = csrNode.referenceType;
       container.className = 'field';
       headerRow.appendChild(container);
     }
     body.appendChild(headerRow);
   
     var enumerators = getNodes_tag(enums[0], "enumerator");
     for (var e=0; e < enumerators.length; e++) {
       var row = document.createElement('TR');
       var identifier = getNodeValue_tag(enumerators[e], "identifier");
       var value = getNodeValue_tag(enumerators[e], "value");
       var title;
       var description;
       var access;
       var cells = [];
       if (titles) {
         title = getNodeValue_tag(enumerators[e], "title");
         cells.push(title);
       }
       cells.push(identifier);
       cells.push(value);
       if (hasPartialAccess) {
         access = getNodeValue_tag(enumerators[e], "enumeratorAccess");
         cells.push(access);
       }
       if (descriptions) {
         description = getNodeValue_tag(enumerators[e], "description");
         cells.push(description);
       }
         
       for ( var i=0; i < cells.length; i++ ) {
         var container     = document.createElement('TD');
         var theData       = document.createElement('DIV');
         theData.innerHTML = cells[i];
         container.appendChild(theData);
         row.appendChild(container);
       }
       body.appendChild(row);
     }
   
     table.appendChild(body);
     enumDiv.appendChild(table);
     return enumDiv;
   }
   
   function printWideRegisterDefinition( csrNode )
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"resetValue");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var isVolatile      = getNodeValue_tag(xmlNode,"volatile");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier'] = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions']     = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (isVolatile != '') {
        tableData_array['Volatile'] = ((isVolatile == 'true') ? "1": "0");
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printCsrBitFields( csrNode );
   
     printReference_links( csrNode );
     
   
   }
   
   function printMemoryDefinition(csrNode) 
   {
     var memoryReferenceName = csrNode.referenceName;
     var memoryParentDiv     = document.getElementById(memoryReferenceName);
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = memoryParentDiv;
   
     var memoryDiv              = document.createElement('DIV');
   
     memoryDiv.id               = memoryParentDiv.id + "child";
     memoryDiv.style.marginLeft = "25px";
     csrNode.divChild = memoryDiv;
     memoryParentDiv.appendChild(memoryDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"resetValue");
     var resetMask       = getNodeValue_tag(xmlNode,"resetMask");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var memoryWidth     = getNodeValue_tag(xmlNode,"memoryWidth");
     var memoryWordCount = getNodeValue_tag(xmlNode,"memoryWordCount");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (memoryWidth != '') {
        tableData_array['Width'] = memoryWidth;
     }
     if (memoryWordCount != '') {
        tableData_array['Word Count'] = memoryWordCount;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if ((resetValue != '') && (resetMask != '')) {
        tableData_array['Reset Mask'] = resetMask;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, memoryDiv, csrNode);
   
     printReference_links(csrNode);
   }
   
   function printWideMemoryDefinition( csrNode )
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var memoryWidth     = getNodeValue_tag(xmlNode,"memoryWidth");
     var memoryWordCount = getNodeValue_tag(xmlNode,"memoryWordCount");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier'] = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions']     = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (memoryWidth != '') {
        tableData_array['Width'] = memoryWidth;
     }
     if (memoryWordCount != '') {
        tableData_array['Word Count'] = memoryWordCount;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printReference_links( csrNode );
   
   }
   
   
   function printRefInfoTable( refArray, domParentNode, csrNode ) 
   {
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
   
     for ( var type in refArray )
       {
         var row = document.createElement('TR');
         
         //headings
         var container = document.createElement('TH');
         //     var theData   = document.createTextNode(node);
         var theData = document.createElement('DIV');
         theData.innerHTML = type;
   
         container.className = csrNode.referenceType;
   
         container.appendChild(theData);
         row.appendChild(container);
         
         //values
         container     = document.createElement('TD');
         container.className = "noborder";
         //      theData       = document.createTextNode(refArray[type]);
         var theData = document.createElement('DIV');
         theData.innerHTML = refArray[type];
   
         container.appendChild(theData);
         row.appendChild(container);
         
         tmp.appendChild(row);
       }
     
     domParentNode.appendChild(tableEl);
   }
   
   function printAddressMap(objectIndex, referenceName)
   {
     var csrNode;
    
     csrNode = csrNodeLookup(objectIndex, referenceName);
   
     //if window is already open, close it
     if (csrNode.addressMapWindow) {
       if (csrNode.addressMapWindow.opened)
         return;
       else csrNode.addressMapWindow.open()
     }
   
     csrNode.addressMapWindow = new Window( document.body.clientWidth - 625, 25, 600, 400, 'AddrMap' + objectIndex );
   
     var addrMapDiv       = document.createElement('DIV');
     addrMapDiv.id        = 'AddrMap' + objectIndex;
     addrMapDiv.style.marginLeft = "10px";
     addrMapDiv.style.marginRight = "10px";
     addrMapDiv.style.marginTop = "10px";
     addrMapDiv.style.marginBottom = "10px";
   
     
     csrNode.addressMapWindow.changeTitle( 'Address Map for ' + referenceName );
   
     addressMapEntries = getNodes_tag(csrNode.definitionPtr,'addressMapEntry');
   
     alertd('addressMapEntries=' + addressMapEntries.length);
   
     var tableEl = document.createElement('TABLE');
     tableEl.width = "550px";
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
     var headers = ['Address', 'Instance Name'];
   
      var row           = document.createElement('TR');
     for ( var i=0; i<headers.length; i++ ) 
       {
         var container        = document.createElement('TH');
         var theData          = document.createElement('DIV');
         theData.innerHTML    = headers[i];
         container.appendChild(theData);
         row.appendChild(container);
       }
     tmp.appendChild(row);
   
   
     for ( var i=0; i < addressMapEntries.length; i++)
       {
         var print = false;
         var referenceName = getNodeValue_tag(addressMapEntries[i],"referenceName");
         var instanceName  = getNodeValue_tag(addressMapEntries[i],"instanceName");
         var referencedObj = csrNodeLookup(objectIndex, referenceName);
   
   
         var addressLow    = getNodeValue_tag(addressMapEntries[i],"addressLow");
         var addressHigh   = getNodeValue_tag(addressMapEntries[i],"addressHigh");
         
         if (addressLow == addressHigh) 
   	var addressRange = addressHigh;
         else
   	var addressRange = addressLow + ' - ' + addressHigh;
         
         if ( referencedObj ) 
   	{
   	  if (
                (referencedObj.referenceType == "register") ||
                (referencedObj.referenceType == "wideregister") ||
                (referencedObj.referenceType == "memory") ||
                (referencedObj.referenceType == "widememory")
             )
   	    {
   	      print = true;
   	      referenceName = '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + objectIndex + ',\'' + referenceName + '\'));">' + instanceName + '</a>';
   	    }
   	}
         else if ( referenceName == '' )
   	{
   	print = true;
   	referenceName = 'reserved';
   	}
   
         if ( print ) 
   	{
   	  var row_data = [ addressRange, referenceName];
   	  row          = document.createElement('TR');
   	  
   	  for ( var j=0; j<row_data.length; j++ ) 
   	    {
   	      var container     = document.createElement('TD');
   	      var theData       = document.createElement('DIV');
   	      theData.innerHTML = row_data[j];
   	      container.appendChild(theData);
   	      row.appendChild(container);
   	    }
   	  tmp.appendChild(row);
   	}
       }
   
     addrMapDiv.appendChild(tableEl);
   
     csrNode.addressMapWindow.appendDomEl(addrMapDiv);
     csrNode.addressMapWindow.open();
   }
   
   
   //expand nodes
   function expandAllNodes( objectIndex )
   {
     for ( var obj in csrNode_array[objectIndex] )
       {  
         var csrNodeObj = csrNodeLookup(objectIndex,obj);
         csrNodeObj.expand();
       }
   }
   
   function collapseAllNodes( objectIndex )
   {
      for ( var obj in csrNode_array[objectIndex] )
       {  
         var csrNodeObj = csrNodeLookup(objectIndex,obj);
         csrNodeObj.collapse();
       }
   }
   
   // Graphics Functions
   
   function highLightDiv( id )
   {
     fade(0xe7, 0xe7, 0xe7, 0xff, 0xff, 0x33, 100, id);  
   }
   
   function unhighLightDiv( id )
   {
     fade(0xff, 0xff, 0x33, 0xe7, 0xe7, 0xe7, 100, id);
   }
   
   function makearray(n)
   {
     this.length = n;
     for(var i = 1; i <= n; i++)
       this[i] = 0;
     return this;
   }
   
   hexa = new makearray(16);
   
   for(var i = 0; i < 10; i++) 
        hexa[i] = i;
   hexa[10]="a"; hexa[11]="b"; hexa[12]="c";
   hexa[13]="d"; hexa[14]="e"; hexa[15]="f";
   
   function hex(i)
   {
     if (i < 0) return "00";
     else if (i >255) return "ff";
     else return "" + hexa[Math.floor(i/16)] + hexa[i%16];
   }
   
   var fade_timer = 100;
   function setbgColor(r, g, b, id)
   {
     var hr = hex(r); var hg = hex(g); var hb = hex(b);
     document.getElementById(id).style.backgroundColor = "#"+hr+hg+hb;
     var timeOutString = 'document.getElementById("' + id + '").style.backgroundColor=' +  '"#'+hr+hg+hb +'"';
     fade_timer = fade_timer + 25;
     setTimeout(timeOutString, fade_timer);
   
   }
   
   function fade(sr, sg, sb, er, eg, eb, step, id)
   {
     fade_timer = 100;
     for(var i = 0; i <= step; i++){
       setbgColor(Math.floor(sr * ((step-i)/step) + er * (i/step)),Math.floor(sg * ((step-i)/step) + eg * (i/step)),Math.floor(sb * ((step-i)/step) + eb * (i/step)),id);
     }
   }
   
   // Browser Detect
   
   // Determine browser and version.
   
   function Browser() 
   {
   
     var ua, s, i;
   
     this.isIE    = false;
     this.isNS    = false;
     this.version = null;
   
     ua = navigator.userAgent;
   
     s = "MSIE";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isIE = true;
       this.version = parseFloat(ua.substr(i + s.length));
       return;
     }
   
     s = "Netscape6/";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isNS = true;
       this.version = parseFloat(ua.substr(i + s.length));
       return;
     }
   
     // Treat any other "Gecko" browser as NS 6.1.
   
     s = "Gecko";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isNS = true;
       this.version = 6.1;
       return;
     }
   }
   
   var browser = new Browser();
   
   //DHTML Windows Below
   
   var myWindow = new Object();
   var globalWindowZIndex = 500;
   
   // Window Class
   function Window(x,y,w,h,dom_id) 
   {
     
     // CLASS TAG ELEMENT VARAIBLES
     this.window             = 0;
     this.title              = 0;
     this.titleBar           = 0;
     this.titleBarText       = 0;
     this.titleBarButtons    = 0;
     this.clientArea         = 0;
     this.titleBarMap        = 0;
     this.left               = x;
     this.top                = y;
     this.width              = w;
     this.height             = h;
     this.opened             = false; 
     this.dom_id             = dom_id;
   
     if (browser.isNS) 
       {
         this.ca_width       = this.width - 2;
         this.ca_height      = this.height - 40;
       }
     if (browser.isIE) 
       {
         this.ca_width       = this.width - 2;
         this.ca_height      = this.height - 40;
     }
     this.inMoveDrag   = false;
   
     // CLASS METHOD FUNCTIONS
     this.create        = windowCreate;
     this.init          = windowInit;
     this.open          = windowOpen;
     this.makeActive    = windowMakeActive;
     this.insertHTML    = windowInsertHTML; 
     this.appendHTML    = windowAppendHTML;
     this.appendDomEl   = windowAppendDomEl;
     this.close         = windowClose;
     this.windowColor   = windowChangeColor;
   
     this.changeTitle = function(title) {
       this.title.innerHTML = title;
     }
   
     this.wallpaper = function(img) {
        this.windowArea.style.backgroundImage    = img;
        this.windowArea.style.backgroundPosition = "center";
        this.windowArea.style.backgroundRepeat   = "no-repeat";
     }
   
     this.create();
     this.init();
   }
   
   //
   // Create WINDOW DOM object Tree
   //
   // body
   //  |
   //  | -- div ( window )
   //        |
   //        | -- div ( titlebar )
   //              |
   //              | -- span ( title )
   //              |
   //        | -- div ( text window area )
   //
   
   function windowCreate() 
   {
     // Find the main Body Tag.  Only one should exist in page 
     var bodyEl = document.getElementsByTagName("body");
   
     //WINDOW DIV
     var windowEl          = document.createElement("div");
     windowEl.className    = "window";
     windowEl.style.left   = this.left + "px";
     windowEl.style.top    = this.top + "px";
     windowEl.style.width  = this.width + "px"; 
     windowEl.style.height = this.height + "px";
     windowEl.id           = "window" + this.dom_id;
     windowEl.parent       = this;
   
   
     //TOP TITLE DIV
   
     var titleBarEl         = document.createElement("div");
     //  titleBarEl.className   = "windowTitleBar";
     titleBarEl.id          = "titleBar"; 
     titleBarEl.onmousedown = windowMove;
     titleBarEl.parent      = this;
   
     // Put the title into a table
   
     var tableTitleEl       = document.createElement("table");
     tableTitleEl.width     = "100%";
     var tbodyTitleEl       = document.createElement("tbody");
     var trTitleEl          = document.createElement("tr");
     var tdTitlePinIconEl   = document.createElement("td");
     tdTitlePinIconEl.width = "10%";
     tdTitlePinIconEl.algin = "right";
     tdTitlePinIconEl.className = "windowTitleBar";
     var tdTitleTitleEl     = document.createElement("td");
     tdTitleTitleEl.width   = "90%";
     tdTitleTitleEl.algin   = "right";
     tdTitleTitleEl.className = "windowTitleBar";
     tdTitleTitleEl.innerHTML   = 'WINDOW TITLE';
     tdTitleTitleEl.parent      = this;
     tdTitleTitleEl.onmouseover = windowMoveCursorSet;
     tdTitleTitleEl.onmouseout  = windowDefaultCursorSet;
     
     this.title  = tdTitleTitleEl;
     
     // CLOSE DIV
     var closeLink       = document.createElement("a");
     closeLink.setAttribute('href', 'javascript:void(0);');
     closeLink.onclick    = this.close;
     closeLink.parent    = this;
     var linkText = document.createTextNode('close');
     closeLink.appendChild(linkText);
     closeLink.style.color = "white";
   
   
     // Window List Area
     var windowAreaEl = document.createElement("div");
     windowAreaEl.className    = "windowListArea";
     
     windowAreaEl.style.width  = this.ca_width + "px";
     windowAreaEl.style.height = this.ca_height + "px";
     
     // Build DOM
     tdTitlePinIconEl.appendChild(closeLink);
   
     trTitleEl.appendChild(tdTitleTitleEl);
     trTitleEl.appendChild(tdTitlePinIconEl);
     tbodyTitleEl.appendChild(trTitleEl);
     tableTitleEl.appendChild(tbodyTitleEl);
     titleBarEl.appendChild(tableTitleEl);
     
     windowEl.appendChild(titleBarEl);
     
     windowEl.appendChild(windowAreaEl);
     document.body.appendChild(windowEl);
     
     this.window           = windowEl;
     this.windowArea       = windowAreaEl; 
     this.title            = tdTitleTitleEl;
   
   }
   
   function windowInit() 
   {
   
   }
   
   function windowChangeColor(color) 
   {
     this.window.style.backgroundColor = color;
     this.windowArea.style.backgroundColor = color;
   }
   
   function windowInsertHTML(html) 
   {
     this.windowArea.innerHTML = html;
   }
   
   function windowAppendHTML(html) 
   {
     this.windowArea.innerHTML = this.windowArea.innerHTML + html;
   }
   
   function windowAppendDomEl(el)
   {
     this.windowArea.appendChild(el);
   }
   
   function windowOpen() 
   {
     if (this.isOpen)
       return;
   
     this.opened = true;
   
     // Restore the Window and make it visible.
     this.makeActive();
     this.isOpen = true;
     this.window.style.visibility = "visible";
   }
   
   
   function windowMakeActive() 
   {
     if (myWindow == this)
       return;
   
     this.window.style.zIndex = globalWindowZIndex;
     globalWindowZIndex++;
     myWindow = this;
   
   }
   
   //
   // Event handlers.
   //
   
   
   function windowClientAreaClick(event) 
   {
   
     // Make this Window the active one.
   
      myWindow.makeActive();
   }
   
   function windowMove(event) 
   {
     var target;
     var x, y;
   
     if (browser.isIE)
       target = window.event.srcElement.tagName;
     if (browser.isNS)
       target = event.target.tagName;
   
     if (target == "AREA")
       return;
   
     p = this.parent;
     p.makeActive();
     // Get cursor offset from Window window.
   
     if (browser.isIE) {
       x = window.event.x;
       y = window.event.y;
     }
     if (browser.isNS) {
       x = event.pageX;
       y = event.pageY;
     }
     myWindow.xOffset = myWindow.window.offsetLeft - x;
     myWindow.yOffset = myWindow.window.offsetTop  - y;
   
     // Set document to capture mousemove and mouseup events.
   
     if (browser.isIE) {
       document.onmousemove = windowMoveDragStart;
       document.onmouseup   = windowMoveDragStop;
     }
     if (browser.isNS) {
       document.addEventListener("mousemove", windowMoveDragStart,   true);
       document.addEventListener("mouseup",   windowMoveDragStop, true);
       event.preventDefault();
     }
     myWindow.inMoveDrag = true;
     
   }
   
   
   
   function windowClose() 
   {
     this.parent.opened = false;
     document.body.removeChild(this.parent.window);
   }
   
   
   function windowMoveDragStart(event) 
   {
   
     var x, y;
   
     if (!myWindow.inMoveDrag)
       return;
   
     // Get cursor position.
   
     if (browser.isIE) {
       x = window.event.x;
       y = window.event.y;
       window.event.cancelBubble = true;
       window.event.returnValue = false;
     }
     if (browser.isNS) {
       x = event.pageX;
       y = event.pageY;
       event.preventDefault();
     }
   
     // Move Window window based on offset from cursor.
    
     nx = ( x + myWindow.xOffset );
     ny = ( y + myWindow.yOffset );
   
     if ( (nx<0) || (ny<0) ) {
   
     } else {
       myWindow.window.style.left = (x + myWindow.xOffset) + "px";
       myWindow.window.style.top  = (y + myWindow.yOffset) + "px";
     }
   }
   
   
   function windowMoveDragStop(event) 
   {
     myWindow.inMoveDrag = false;
   
     // Remove mousemove and mouseup event captures on document.
   
     if (browser.isIE) {
       document.onmousemove = null;
       document.onmouseup   = null;
     }
     if (browser.isNS) {
       document.removeEventListener("mousemove", windowMoveDragStart,   true);
       document.removeEventListener("mouseup",   windowMoveDragStop, true);
     }
   }
   
   
   function windowMoveCursorSet(event) 
   {
      this.style.cursor = "move";
   }
   
   function windowDefaultCursorSet(event) 
   {
      this.style.cursor = "move";
   }
   
   // End of Java Script
  </script>
  <noscript>
   <div class="noscript">
    <h2>JavaScript required</h2>
    <p>csrCompiler HTML pages require JavaScript.</p>
    <p>Your web browser does not support JavaScript or it has been disabled.</p>
   <div>
  </noscript>
 </head>
 <body onload="importXML('xmlData')">
  <xml id="xmlData" style="display:none;">
   <?xml version="1.0" encoding="UTF-8" ?>
   <csr:csrData
    xmlns:csr="http://www.semifore.com/schema/csrXmlHtml"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.semifore.com/schema/csrXmlHtml http://www.semifore.com/schema/csrXmlHtml.xsd"
    >
    <csr:fileInfo>
     <csr:inputFiles>
      <csr:file>
       <csr:filename>DW_apb_uart.csr</csr:filename>
      </csr:file>
     </csr:inputFiles>
     <csr:configurationFiles>
       <csr:file>
       <csr:filename>/project/jenkins/workspace/Esperanto_DV/soc_hal/esperanto-soc/dv/common/scripts/semifore_css/etsoc_esr.css</csr:filename>
      </csr:file>
     </csr:configurationFiles>
    </csr:fileInfo>
    <csr:csrObject>
     <csr:topDefinition>
      <csr:referenceName>uart</csr:referenceName>
     </csr:topDefinition>
     <csr:definitions>
      <csr:definition>
       <csr:referenceType>addressmap</csr:referenceType>
       <csr:referenceName>uart</csr:referenceName>
       <csr:identifier>uart</csr:identifier>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3796</csr:linenumber>
       <csr:title></csr:title>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.RBR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.IER</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.IIR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.LCR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.MCR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.LSR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.MSR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SCR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR3</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR4</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR5</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR6</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR7</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR8</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR9</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR10</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR11</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR12</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR13</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR14</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>uart.SRBR15</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.FAR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.TFR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.RFW</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.USR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.TFL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.RFL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRTS</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SBCR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SDMAM</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SFE</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.STET</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.HTX</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.DMASA</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.DLF</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.REG_TIMEOUT_RST</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.CPR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.UCV</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.CTR</csr:referenceName>
        </csr:reference>
       </csr:references>
       <csr:addressMap>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0xFF</csr:addressHigh>
         <csr:instanceName>uart</csr:instanceName>
         <csr:referenceName>uart</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0x0</csr:addressHigh>
         <csr:instanceName>uart.RBR.RBR</csr:instanceName>
         <csr:referenceName>uart.RBR.RBR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0x0</csr:addressHigh>
         <csr:instanceName>uart.RBR.DLL</csr:instanceName>
         <csr:referenceName>uart.RBR.DLL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0x0</csr:addressHigh>
         <csr:instanceName>uart.RBR.THR</csr:instanceName>
         <csr:referenceName>uart.RBR.THR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4</csr:addressLow>
         <csr:addressHigh>0x4</csr:addressHigh>
         <csr:instanceName>uart.IER.IER</csr:instanceName>
         <csr:referenceName>uart.IER.IER</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4</csr:addressLow>
         <csr:addressHigh>0x4</csr:addressHigh>
         <csr:instanceName>uart.IER.DLH</csr:instanceName>
         <csr:referenceName>uart.IER.DLH</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x8</csr:addressLow>
         <csr:addressHigh>0x8</csr:addressHigh>
         <csr:instanceName>uart.IIR.IIR</csr:instanceName>
         <csr:referenceName>uart.IIR.IIR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x8</csr:addressLow>
         <csr:addressHigh>0x8</csr:addressHigh>
         <csr:instanceName>uart.IIR.FCR</csr:instanceName>
         <csr:referenceName>uart.IIR.FCR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC</csr:addressLow>
         <csr:addressHigh>0xC</csr:addressHigh>
         <csr:instanceName>uart.LCR</csr:instanceName>
         <csr:referenceName>uart.LCR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x10</csr:addressLow>
         <csr:addressHigh>0x10</csr:addressHigh>
         <csr:instanceName>uart.MCR</csr:instanceName>
         <csr:referenceName>uart.MCR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x14</csr:addressLow>
         <csr:addressHigh>0x14</csr:addressHigh>
         <csr:instanceName>uart.LSR</csr:instanceName>
         <csr:referenceName>uart.LSR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x18</csr:addressLow>
         <csr:addressHigh>0x18</csr:addressHigh>
         <csr:instanceName>uart.MSR</csr:instanceName>
         <csr:referenceName>uart.MSR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1C</csr:addressLow>
         <csr:addressHigh>0x1C</csr:addressHigh>
         <csr:instanceName>uart.SCR</csr:instanceName>
         <csr:referenceName>uart.SCR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x30</csr:addressLow>
         <csr:addressHigh>0x30</csr:addressHigh>
         <csr:instanceName>uart.SRBR0.SRBR0</csr:instanceName>
         <csr:referenceName>uart.SRBR0.SRBR0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x30</csr:addressLow>
         <csr:addressHigh>0x30</csr:addressHigh>
         <csr:instanceName>uart.SRBR0.STHR0</csr:instanceName>
         <csr:referenceName>uart.SRBR0.STHR0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x34</csr:addressLow>
         <csr:addressHigh>0x34</csr:addressHigh>
         <csr:instanceName>uart.SRBR1.SRBR1</csr:instanceName>
         <csr:referenceName>uart.SRBR1.SRBR1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x34</csr:addressLow>
         <csr:addressHigh>0x34</csr:addressHigh>
         <csr:instanceName>uart.SRBR1.STHR1</csr:instanceName>
         <csr:referenceName>uart.SRBR1.STHR1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x38</csr:addressLow>
         <csr:addressHigh>0x38</csr:addressHigh>
         <csr:instanceName>uart.SRBR2.SRBR2</csr:instanceName>
         <csr:referenceName>uart.SRBR2.SRBR2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x38</csr:addressLow>
         <csr:addressHigh>0x38</csr:addressHigh>
         <csr:instanceName>uart.SRBR2.STHR2</csr:instanceName>
         <csr:referenceName>uart.SRBR2.STHR2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x3C</csr:addressLow>
         <csr:addressHigh>0x3C</csr:addressHigh>
         <csr:instanceName>uart.SRBR3.SRBR3</csr:instanceName>
         <csr:referenceName>uart.SRBR3.SRBR3</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x3C</csr:addressLow>
         <csr:addressHigh>0x3C</csr:addressHigh>
         <csr:instanceName>uart.SRBR3.STHR3</csr:instanceName>
         <csr:referenceName>uart.SRBR3.STHR3</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x40</csr:addressLow>
         <csr:addressHigh>0x40</csr:addressHigh>
         <csr:instanceName>uart.SRBR4.SRBR4</csr:instanceName>
         <csr:referenceName>uart.SRBR4.SRBR4</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x40</csr:addressLow>
         <csr:addressHigh>0x40</csr:addressHigh>
         <csr:instanceName>uart.SRBR4.STHR4</csr:instanceName>
         <csr:referenceName>uart.SRBR4.STHR4</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x44</csr:addressLow>
         <csr:addressHigh>0x44</csr:addressHigh>
         <csr:instanceName>uart.SRBR5.SRBR5</csr:instanceName>
         <csr:referenceName>uart.SRBR5.SRBR5</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x44</csr:addressLow>
         <csr:addressHigh>0x44</csr:addressHigh>
         <csr:instanceName>uart.SRBR5.STHR5</csr:instanceName>
         <csr:referenceName>uart.SRBR5.STHR5</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x48</csr:addressLow>
         <csr:addressHigh>0x48</csr:addressHigh>
         <csr:instanceName>uart.SRBR6.SRBR6</csr:instanceName>
         <csr:referenceName>uart.SRBR6.SRBR6</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x48</csr:addressLow>
         <csr:addressHigh>0x48</csr:addressHigh>
         <csr:instanceName>uart.SRBR6.STHR6</csr:instanceName>
         <csr:referenceName>uart.SRBR6.STHR6</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4C</csr:addressLow>
         <csr:addressHigh>0x4C</csr:addressHigh>
         <csr:instanceName>uart.SRBR7.SRBR7</csr:instanceName>
         <csr:referenceName>uart.SRBR7.SRBR7</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4C</csr:addressLow>
         <csr:addressHigh>0x4C</csr:addressHigh>
         <csr:instanceName>uart.SRBR7.STHR7</csr:instanceName>
         <csr:referenceName>uart.SRBR7.STHR7</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x50</csr:addressLow>
         <csr:addressHigh>0x50</csr:addressHigh>
         <csr:instanceName>uart.SRBR8.SRBR8</csr:instanceName>
         <csr:referenceName>uart.SRBR8.SRBR8</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x50</csr:addressLow>
         <csr:addressHigh>0x50</csr:addressHigh>
         <csr:instanceName>uart.SRBR8.STHR8</csr:instanceName>
         <csr:referenceName>uart.SRBR8.STHR8</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x54</csr:addressLow>
         <csr:addressHigh>0x54</csr:addressHigh>
         <csr:instanceName>uart.SRBR9.SRBR9</csr:instanceName>
         <csr:referenceName>uart.SRBR9.SRBR9</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x54</csr:addressLow>
         <csr:addressHigh>0x54</csr:addressHigh>
         <csr:instanceName>uart.SRBR9.STHR9</csr:instanceName>
         <csr:referenceName>uart.SRBR9.STHR9</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x58</csr:addressLow>
         <csr:addressHigh>0x58</csr:addressHigh>
         <csr:instanceName>uart.SRBR10.SRBR10</csr:instanceName>
         <csr:referenceName>uart.SRBR10.SRBR10</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x58</csr:addressLow>
         <csr:addressHigh>0x58</csr:addressHigh>
         <csr:instanceName>uart.SRBR10.STHR10</csr:instanceName>
         <csr:referenceName>uart.SRBR10.STHR10</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x5C</csr:addressLow>
         <csr:addressHigh>0x5C</csr:addressHigh>
         <csr:instanceName>uart.SRBR11.SRBR11</csr:instanceName>
         <csr:referenceName>uart.SRBR11.SRBR11</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x5C</csr:addressLow>
         <csr:addressHigh>0x5C</csr:addressHigh>
         <csr:instanceName>uart.SRBR11.STHR11</csr:instanceName>
         <csr:referenceName>uart.SRBR11.STHR11</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x60</csr:addressLow>
         <csr:addressHigh>0x60</csr:addressHigh>
         <csr:instanceName>uart.SRBR12.SRBR12</csr:instanceName>
         <csr:referenceName>uart.SRBR12.SRBR12</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x60</csr:addressLow>
         <csr:addressHigh>0x60</csr:addressHigh>
         <csr:instanceName>uart.SRBR12.STHR12</csr:instanceName>
         <csr:referenceName>uart.SRBR12.STHR12</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x64</csr:addressLow>
         <csr:addressHigh>0x64</csr:addressHigh>
         <csr:instanceName>uart.SRBR13.SRBR13</csr:instanceName>
         <csr:referenceName>uart.SRBR13.SRBR13</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x64</csr:addressLow>
         <csr:addressHigh>0x64</csr:addressHigh>
         <csr:instanceName>uart.SRBR13.STHR13</csr:instanceName>
         <csr:referenceName>uart.SRBR13.STHR13</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x68</csr:addressLow>
         <csr:addressHigh>0x68</csr:addressHigh>
         <csr:instanceName>uart.SRBR14.SRBR14</csr:instanceName>
         <csr:referenceName>uart.SRBR14.SRBR14</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x68</csr:addressLow>
         <csr:addressHigh>0x68</csr:addressHigh>
         <csr:instanceName>uart.SRBR14.STHR14</csr:instanceName>
         <csr:referenceName>uart.SRBR14.STHR14</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x6C</csr:addressLow>
         <csr:addressHigh>0x6C</csr:addressHigh>
         <csr:instanceName>uart.SRBR15.SRBR15</csr:instanceName>
         <csr:referenceName>uart.SRBR15.SRBR15</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x6C</csr:addressLow>
         <csr:addressHigh>0x6C</csr:addressHigh>
         <csr:instanceName>uart.SRBR15.STHR15</csr:instanceName>
         <csr:referenceName>uart.SRBR15.STHR15</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x70</csr:addressLow>
         <csr:addressHigh>0x70</csr:addressHigh>
         <csr:instanceName>uart.FAR</csr:instanceName>
         <csr:referenceName>uart.FAR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x74</csr:addressLow>
         <csr:addressHigh>0x74</csr:addressHigh>
         <csr:instanceName>uart.TFR</csr:instanceName>
         <csr:referenceName>uart.TFR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x78</csr:addressLow>
         <csr:addressHigh>0x78</csr:addressHigh>
         <csr:instanceName>uart.RFW</csr:instanceName>
         <csr:referenceName>uart.RFW</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x7C</csr:addressLow>
         <csr:addressHigh>0x7C</csr:addressHigh>
         <csr:instanceName>uart.USR</csr:instanceName>
         <csr:referenceName>uart.USR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x80</csr:addressLow>
         <csr:addressHigh>0x80</csr:addressHigh>
         <csr:instanceName>uart.TFL</csr:instanceName>
         <csr:referenceName>uart.TFL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x84</csr:addressLow>
         <csr:addressHigh>0x84</csr:addressHigh>
         <csr:instanceName>uart.RFL</csr:instanceName>
         <csr:referenceName>uart.RFL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x88</csr:addressLow>
         <csr:addressHigh>0x88</csr:addressHigh>
         <csr:instanceName>uart.SRR</csr:instanceName>
         <csr:referenceName>uart.SRR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x8C</csr:addressLow>
         <csr:addressHigh>0x8C</csr:addressHigh>
         <csr:instanceName>uart.SRTS</csr:instanceName>
         <csr:referenceName>uart.SRTS</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x90</csr:addressLow>
         <csr:addressHigh>0x90</csr:addressHigh>
         <csr:instanceName>uart.SBCR</csr:instanceName>
         <csr:referenceName>uart.SBCR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x94</csr:addressLow>
         <csr:addressHigh>0x94</csr:addressHigh>
         <csr:instanceName>uart.SDMAM</csr:instanceName>
         <csr:referenceName>uart.SDMAM</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x98</csr:addressLow>
         <csr:addressHigh>0x98</csr:addressHigh>
         <csr:instanceName>uart.SFE</csr:instanceName>
         <csr:referenceName>uart.SFE</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x9C</csr:addressLow>
         <csr:addressHigh>0x9C</csr:addressHigh>
         <csr:instanceName>uart.SRT</csr:instanceName>
         <csr:referenceName>uart.SRT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xA0</csr:addressLow>
         <csr:addressHigh>0xA0</csr:addressHigh>
         <csr:instanceName>uart.STET</csr:instanceName>
         <csr:referenceName>uart.STET</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xA4</csr:addressLow>
         <csr:addressHigh>0xA4</csr:addressHigh>
         <csr:instanceName>uart.HTX</csr:instanceName>
         <csr:referenceName>uart.HTX</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xA8</csr:addressLow>
         <csr:addressHigh>0xA8</csr:addressHigh>
         <csr:instanceName>uart.DMASA</csr:instanceName>
         <csr:referenceName>uart.DMASA</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xAC</csr:addressLow>
         <csr:addressHigh>0xBF</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC0</csr:addressLow>
         <csr:addressHigh>0xC0</csr:addressHigh>
         <csr:instanceName>uart.DLF</csr:instanceName>
         <csr:referenceName>uart.DLF</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC4</csr:addressLow>
         <csr:addressHigh>0xD3</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD4</csr:addressLow>
         <csr:addressHigh>0xD4</csr:addressHigh>
         <csr:instanceName>uart.REG_TIMEOUT_RST</csr:instanceName>
         <csr:referenceName>uart.REG_TIMEOUT_RST</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD8</csr:addressLow>
         <csr:addressHigh>0xF3</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xF4</csr:addressLow>
         <csr:addressHigh>0xF4</csr:addressHigh>
         <csr:instanceName>uart.CPR</csr:instanceName>
         <csr:referenceName>uart.CPR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xF8</csr:addressLow>
         <csr:addressHigh>0xF8</csr:addressHigh>
         <csr:instanceName>uart.UCV</csr:instanceName>
         <csr:referenceName>uart.UCV</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xFC</csr:addressLow>
         <csr:addressHigh>0xFC</csr:addressHigh>
         <csr:instanceName>uart.CTR</csr:instanceName>
         <csr:referenceName>uart.CTR</csr:referenceName>
        </csr:addressMapEntry>
       </csr:addressMap>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.RBR</csr:referenceName>
       <csr:identifier>RBR</csr:identifier>
       <csr:addressMacro>UART_RBR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_RBR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_RBR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_RBR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>158</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_RBR</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.RBR.RBR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.RBR.DLL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.RBR.THR</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.RBR.RBR</csr:referenceName>
       <csr:identifier>RBR</csr:identifier>
       <csr:addressMacro>UART_RBR_RBR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_RBR_RBR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_RBR_RBR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_RBR_RBR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>67</csr:linenumber>
       <csr:title>Receive Buffer Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_RBR_RBR</csr:typeName>
        <csr:description>
         <csr:p>Receive Buffer Register.</csr:p>
         <csr:p> This register can be accessed only when the DLAB bit (LCR[7]) is cleared.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RBR</csr:identifier>
         <csr:widthMacro>UART_RBR_RBR_RBR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_RBR_RBR_RBR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_RBR_RBR_RBR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_RBR_RBR_RBR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_RBR_RBR_RBR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_RBR_RBR_RBR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_RBR_RBR_RBR_GET</csr:getMacro>
         <csr:setMacro>UART_RBR_RBR_RBR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>59</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive Buffer Register.</csr:p>
         <csr:p> This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. </csr:p>
         <csr:p> If in non-FIFO mode (FIFO_MODE == NONE) or FIFOs are disabled (FCR[0] set to 0), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an over-run error.</csr:p>
         <csr:p> If in FIFO mode (FIFO_MODE != NONE) and FIFOs are enabled (FCR[0] set to 1), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost and an over-run error occurs.</csr:p>
         <csr:p>Note:</csr:p>
         <csr:p></csr:p>
         <csr:p>          When UART_9BIT_DATA_EN=0, this field width is 8. </csr:p>
         <csr:p></csr:p>
         <csr:p>          When UART_9BIT_DATA_EN=1, this field width is 9.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_RBR</csr:identifier>
         <csr:widthMacro>UART_RBR_RBR_RSVD_RBR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_RBR_RBR_RSVD_RBR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_RBR_RBR_RSVD_RBR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_RBR_RBR_RSVD_RBR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_RBR_RBR_RSVD_RBR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_RBR_RBR_RSVD_RBR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_RBR_RBR_RSVD_RBR_GET</csr:getMacro>
         <csr:setMacro>UART_RBR_RBR_RSVD_RBR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>66</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RBR 31to9or8 Reserved bits and read as zero (0).</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.RBR.DLL</csr:referenceName>
       <csr:identifier>DLL</csr:identifier>
       <csr:addressMacro>UART_RBR_DLL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_RBR_DLL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_RBR_DLL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_RBR_DLL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>108</csr:linenumber>
       <csr:title>Divisor Latch (Low)</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_RBR_DLL</csr:typeName>
        <csr:description>
         <csr:p>Divisor Latch (Low). </csr:p>
         <csr:p> If UART_16550_COMPATIBLE = No, then this register can be accessed only when the DLAB bit (LCR[7]) is set and the UART is not busy - that is, USR[0] is 0; otherwise this register can be accessed only when the DLAB bit (LCR[7]) is set.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DLL</csr:identifier>
         <csr:widthMacro>UART_RBR_DLL_DLL_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_RBR_DLL_DLL_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_RBR_DLL_DLL_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_RBR_DLL_DLL_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_RBR_DLL_DLL_RESET</csr:resetMacro>
         <csr:maskMacro>UART_RBR_DLL_DLL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_RBR_DLL_DLL_GET</csr:getMacro>
         <csr:setMacro>UART_RBR_DLL_DLL_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>99</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Divisor Latch (Low).</csr:p>
         <csr:p> This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART.</csr:p>
         <csr:p> The output baud rate is equal to the serial clock (pclk if one clock design, sclk if two clock design (CLOCK_MODE == Enabled)) frequency divided by sixteen times the value of the baud rate divisor, as follows: baud rate = (serial clock freq) / (16 * divisor).</csr:p>
         <csr:p> Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_DLL_31to8</csr:identifier>
         <csr:widthMacro>UART_RBR_DLL_RSVD_DLL_31TO8_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_RBR_DLL_RSVD_DLL_31TO8_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_RBR_DLL_RSVD_DLL_31TO8_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_RBR_DLL_RSVD_DLL_31TO8_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_RBR_DLL_RSVD_DLL_31TO8_RESET</csr:resetMacro>
         <csr:maskMacro>UART_RBR_DLL_RSVD_DLL_31TO8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_RBR_DLL_RSVD_DLL_31TO8_GET</csr:getMacro>
         <csr:setMacro>UART_RBR_DLL_RSVD_DLL_31TO8_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>107</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DLL 31to8 Reserved bits and read as zero (0).</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.RBR.THR</csr:referenceName>
       <csr:identifier>THR</csr:identifier>
       <csr:addressMacro>UART_RBR_THR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_RBR_THR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_RBR_THR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_RBR_THR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>157</csr:linenumber>
       <csr:title>Transmit Holding Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_RBR_THR</csr:typeName>
        <csr:description>
         <csr:p>Transmit Holding Register.</csr:p>
         <csr:p> This register can be accessed only when the DLAB bit (LCR[7]) is cleared.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>THR</csr:identifier>
         <csr:widthMacro>UART_RBR_THR_THR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_RBR_THR_THR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_RBR_THR_THR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_RBR_THR_THR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_RBR_THR_THR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_RBR_THR_THR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_RBR_THR_THR_GET</csr:getMacro>
         <csr:setMacro>UART_RBR_THR_THR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>148</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit Holding Register.</csr:p>
         <csr:p> This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set.</csr:p>
         <csr:p> If in non-FIFO mode or FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten.</csr:p>
         <csr:p> If in FIFO mode and FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that is set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost.</csr:p>
         <csr:p>Note:</csr:p>
         <csr:p></csr:p>
         <csr:p>          When UART_9BIT_DATA_EN=0, this field width is 8. </csr:p>
         <csr:p></csr:p>
         <csr:p>          When UART_9BIT_DATA_EN=1, this field width is 9. The 9th bit is applicable only when LCR_EXT[3]=1.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_THR</csr:identifier>
         <csr:widthMacro>UART_RBR_THR_RSVD_THR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_RBR_THR_RSVD_THR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_RBR_THR_RSVD_THR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_RBR_THR_RSVD_THR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_RBR_THR_RSVD_THR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_RBR_THR_RSVD_THR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_RBR_THR_RSVD_THR_GET</csr:getMacro>
         <csr:setMacro>UART_RBR_THR_RSVD_THR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>156</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>THR 31to9or8 Reserved bits and read as zero (0).</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.IER</csr:referenceName>
       <csr:identifier>IER</csr:identifier>
       <csr:addressMacro>UART_IER_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_IER_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_IER_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_IER_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>357</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_IER</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.IER.IER</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.IER.DLH</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.IER.IER</csr:referenceName>
       <csr:identifier>IER</csr:identifier>
       <csr:addressMacro>UART_IER_IER_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_IER_IER_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_IER_IER_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_IER_IER_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>317</csr:linenumber>
       <csr:title>Interrupt Enable Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_IER_IER</csr:typeName>
        <csr:description>
         <csr:p>Interrupt Enable Register. </csr:p>
         <csr:p> This register can be accessed only when the DLAB bit (LCR[7]) is cleared.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ERBFI</csr:identifier>
         <csr:widthMacro>UART_IER_IER_ERBFI_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IER_IER_ERBFI_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IER_IER_ERBFI_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IER_IER_ERBFI_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IER_IER_ERBFI_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IER_IER_ERBFI_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IER_IER_ERBFI_GET</csr:getMacro>
         <csr:setMacro>UART_IER_IER_ERBFI_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>188</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Disable Receive data Interrupt</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Enable Receive data Interrupt</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ETBEI</csr:identifier>
         <csr:widthMacro>UART_IER_IER_ETBEI_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IER_IER_ETBEI_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IER_IER_ETBEI_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IER_IER_ETBEI_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IER_IER_ETBEI_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IER_IER_ETBEI_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IER_IER_ETBEI_GET</csr:getMacro>
         <csr:setMacro>UART_IER_IER_ETBEI_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>209</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Disable Transmit empty interrupt</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Enable Transmit empty interrupt</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ELSI</csr:identifier>
         <csr:widthMacro>UART_IER_IER_ELSI_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IER_IER_ELSI_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IER_IER_ELSI_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IER_IER_ELSI_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IER_IER_ELSI_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IER_IER_ELSI_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IER_IER_ELSI_GET</csr:getMacro>
         <csr:setMacro>UART_IER_IER_ELSI_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>229</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt.</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Disable Receiver Line Status Interrupt</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Enable Receiver Line Status Interrupt</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>EDSSI</csr:identifier>
         <csr:widthMacro>UART_IER_IER_EDSSI_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IER_IER_EDSSI_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IER_IER_EDSSI_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IER_IER_EDSSI_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IER_IER_EDSSI_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IER_IER_EDSSI_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IER_IER_EDSSI_GET</csr:getMacro>
         <csr:setMacro>UART_IER_IER_EDSSI_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>250</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enable Modem Status Interrupt. This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt.</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Disable Modem Status Interrupt</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Enable Modem Status Interrupt</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ELCOLR</csr:identifier>
         <csr:widthMacro>UART_IER_IER_ELCOLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IER_IER_ELCOLR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IER_IER_ELCOLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IER_IER_ELCOLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IER_IER_ELCOLR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IER_IER_ELCOLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IER_IER_ELCOLR_GET</csr:getMacro>
         <csr:setMacro>UART_IER_IER_ELCOLR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>279</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt Enable Register: ELCOLR, this bit controls the method for clearing the status in the LSR register.</csr:p>
         <csr:p>This is applicable only for Overrun Error, Parity Error, Framing Error, and Break Interrupt status bits.</csr:p>
         <csr:p>0 = LSR status bits are cleared either on reading Rx FIFO (RBR Read) or On reading LSR register.</csr:p>
         <csr:p>1 = LSR status bits are cleared only on reading LSR register.</csr:p>
         <csr:p>Writeable only when LSR_STATUS_CLEAR == Enabled, always readable.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Disable ALC</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Enable ALC</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IER_6to5</csr:identifier>
         <csr:widthMacro>UART_IER_IER_RSVD_IER_6TO5_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IER_IER_RSVD_IER_6TO5_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IER_IER_RSVD_IER_6TO5_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IER_IER_RSVD_IER_6TO5_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IER_IER_RSVD_IER_6TO5_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IER_IER_RSVD_IER_6TO5_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IER_IER_RSVD_IER_6TO5_GET</csr:getMacro>
         <csr:setMacro>UART_IER_IER_RSVD_IER_6TO5_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>287</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IER 6to5 Reserved bits read as zero (0).</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>PTIME</csr:identifier>
         <csr:widthMacro>UART_IER_IER_PTIME_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IER_IER_PTIME_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IER_IER_PTIME_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IER_IER_PTIME_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IER_IER_PTIME_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IER_IER_PTIME_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IER_IER_PTIME_GET</csr:getMacro>
         <csr:setMacro>UART_IER_IER_PTIME_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>308</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Programmable THRE Interrupt Mode Enable. Writeable only when THRE_MODE_USER == Enabled, always readable.  This is used to enable/disable the generation of THRE Interrupt.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Disable Programmable THRE Interrupt Mode</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Enable Programmable THRE Interrupt Mode</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IER_31to8</csr:identifier>
         <csr:widthMacro>UART_IER_IER_RSVD_IER_31TO8_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IER_IER_RSVD_IER_31TO8_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IER_IER_RSVD_IER_31TO8_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IER_IER_RSVD_IER_31TO8_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IER_IER_RSVD_IER_31TO8_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IER_IER_RSVD_IER_31TO8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IER_IER_RSVD_IER_31TO8_GET</csr:getMacro>
         <csr:setMacro>UART_IER_IER_RSVD_IER_31TO8_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>316</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IER 31to8 Reserved bits and read as zero (0).</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.IER.DLH</csr:referenceName>
       <csr:identifier>DLH</csr:identifier>
       <csr:addressMacro>UART_IER_DLH_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_IER_DLH_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_IER_DLH_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_IER_DLH_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>356</csr:linenumber>
       <csr:title>Divisor Latch High</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_IER_DLH</csr:typeName>
        <csr:description>
         <csr:p>Divisor Latch High (DLH) Register.</csr:p>
         <csr:p> If UART_16550_COMPATIBLE = No, then this register can be accessed only when the DLAB bit (LCR[7]) is set and the UART is not busy, that is, USR[0] is 0; otherwise this register can be accessed only when the DLAB bit (LCR[7]) is set.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dlh</csr:identifier>
         <csr:widthMacro>UART_IER_DLH_DLH_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IER_DLH_DLH_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IER_DLH_DLH_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IER_DLH_DLH_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IER_DLH_DLH_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IER_DLH_DLH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IER_DLH_DLH_GET</csr:getMacro>
         <csr:setMacro>UART_IER_DLH_DLH_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>347</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Upper 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART.</csr:p>
         <csr:p> The output baud rate is equal to the serial clock (pclk if one clock design, sclk if two clock design (CLOCK_MODE == Enabled)) frequency divided by sixteen times the value of the baud rate divisor, as follows: baud rate = (serial clock freq) / (16 * divisor).</csr:p>
         <csr:p> Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLH is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_DLH</csr:identifier>
         <csr:widthMacro>UART_IER_DLH_RSVD_DLH_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IER_DLH_RSVD_DLH_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IER_DLH_RSVD_DLH_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IER_DLH_RSVD_DLH_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IER_DLH_RSVD_DLH_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IER_DLH_RSVD_DLH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IER_DLH_RSVD_DLH_GET</csr:getMacro>
         <csr:setMacro>UART_IER_DLH_RSVD_DLH_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>355</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DLH 31to8 Reserved bits and read as zero (0).</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.IIR</csr:referenceName>
       <csr:identifier>IIR</csr:identifier>
       <csr:addressMacro>UART_IIR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_IIR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_IIR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_IIR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>623</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_IIR</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.IIR.IIR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.IIR.FCR</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.IIR.IIR</csr:referenceName>
       <csr:identifier>IIR</csr:identifier>
       <csr:addressMacro>UART_IIR_IIR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_IIR_IIR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_IIR_IIR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_IIR_IIR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>447</csr:linenumber>
       <csr:title>Interrupt Identification Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000001</csr:registerResetValue>
       <csr:typeName>Uart_IIR_IIR</csr:typeName>
        <csr:description>
         <csr:p>Interrupt Identification Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IID</csr:identifier>
         <csr:widthMacro>UART_IIR_IIR_IID_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IIR_IIR_IID_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IIR_IIR_IID_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IIR_IIR_IID_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IIR_IIR_IID_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IIR_IIR_IID_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IIR_IIR_IID_GET</csr:getMacro>
         <csr:setMacro>UART_IIR_IIR_IID_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>413</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt ID (or IID). This indicates the highest priority pending interrupt which can be one of the following types specified in Values. For information on several levels into which the interrupt priorities are split into, see the 'Interrupts' section in the DW_apb_uart Databook.</csr:p>
         <csr:p>Note: an interrupt of type 0111 (busy detect) will never get indicated if UART_16550_COMPATIBLE == YES in coreConsultant.</csr:p>
         <csr:p>Bit 3 indicates an interrupt can only occur when the FIFOs are enabled and used to distinguish a Character Timeout condition interrupt.</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>BUSY_DETECT</csr:identifier>
           <csr:value>0x7</csr:value>
           <csr:title>busy detect</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>CHARACTER_TIMEOUT</csr:identifier>
           <csr:value>0xc</csr:value>
           <csr:title>character timeout</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>MODEM_STATUS</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>modem status</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NO_INTERRUPT_PENDING</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>no interrupt pending</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>RECEIVED_DATA_AVAILABLE</csr:identifier>
           <csr:value>0x4</csr:value>
           <csr:title>received data available</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>RECEIVER_LINE_STATUS</csr:identifier>
           <csr:value>0x6</csr:value>
           <csr:title>receiver line status</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>THR_EMPTY</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>THR empty</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IIR_5to4</csr:identifier>
         <csr:widthMacro>UART_IIR_IIR_RSVD_IIR_5TO4_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IIR_IIR_RSVD_IIR_5TO4_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IIR_IIR_RSVD_IIR_5TO4_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IIR_IIR_RSVD_IIR_5TO4_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IIR_IIR_RSVD_IIR_5TO4_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IIR_IIR_RSVD_IIR_5TO4_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IIR_IIR_RSVD_IIR_5TO4_GET</csr:getMacro>
         <csr:setMacro>UART_IIR_IIR_RSVD_IIR_5TO4_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>420</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IIR 5to4 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>FIFOSE</csr:identifier>
         <csr:widthMacro>UART_IIR_IIR_FIFOSE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IIR_IIR_FIFOSE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IIR_IIR_FIFOSE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IIR_IIR_FIFOSE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IIR_IIR_FIFOSE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IIR_IIR_FIFOSE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IIR_IIR_FIFOSE_GET</csr:getMacro>
         <csr:setMacro>UART_IIR_IIR_FIFOSE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>439</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>FIFOs Enabled (or FIFOSE). This is used to indicate whether the FIFOs are enabled or disabled.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>FIFOs are disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>FIFOs are enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IIR_31to8</csr:identifier>
         <csr:widthMacro>UART_IIR_IIR_RSVD_IIR_31TO8_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IIR_IIR_RSVD_IIR_31TO8_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IIR_IIR_RSVD_IIR_31TO8_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IIR_IIR_RSVD_IIR_31TO8_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IIR_IIR_RSVD_IIR_31TO8_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IIR_IIR_RSVD_IIR_31TO8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IIR_IIR_RSVD_IIR_31TO8_GET</csr:getMacro>
         <csr:setMacro>UART_IIR_IIR_RSVD_IIR_31TO8_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>446</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IIR 31to8 Reserved bits and read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.IIR.FCR</csr:referenceName>
       <csr:identifier>FCR</csr:identifier>
       <csr:addressMacro>UART_IIR_FCR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_IIR_FCR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_IIR_FCR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_IIR_FCR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>622</csr:linenumber>
       <csr:title>FIFO Control Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_IIR_FCR</csr:typeName>
        <csr:description>
         <csr:p>This register is only valid when the DW_apb_uart is configured to have FIFO's implemented (FIFO_MODE != NONE).  If FIFO's are not implemented, this register does not exist and writing to this register address will have no effect.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>FIFOE</csr:identifier>
         <csr:widthMacro>UART_IIR_FCR_FIFOE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IIR_FCR_FIFOE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IIR_FCR_FIFOE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IIR_FCR_FIFOE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IIR_FCR_FIFOE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IIR_FCR_FIFOE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IIR_FCR_FIFOE_GET</csr:getMacro>
         <csr:setMacro>UART_IIR_FCR_FIFOE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>479</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>FIFO Enable (or FIFOE). This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFOs is reset.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>FIFO disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>FIFO enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RFIFOR</csr:identifier>
         <csr:widthMacro>UART_IIR_FCR_RFIFOR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IIR_FCR_RFIFOR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IIR_FCR_RFIFOR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IIR_FCR_RFIFOR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IIR_FCR_RFIFOR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IIR_FCR_RFIFOR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IIR_FCR_RFIFOR_GET</csr:getMacro>
         <csr:setMacro>UART_IIR_FCR_RFIFOR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>500</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RCVR FIFO Reset (or RFIFOR). This resets the control portion of the receive FIFO and treats the FIFO as empty. This will also de-assert the DMA RX request and single signals when additional DMA handshaking signals are selected (DMA_EXTRA == YES). Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>RESET</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Receive FIFO reset</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>XFIFOR</csr:identifier>
         <csr:widthMacro>UART_IIR_FCR_XFIFOR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IIR_FCR_XFIFOR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IIR_FCR_XFIFOR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IIR_FCR_XFIFOR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IIR_FCR_XFIFOR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IIR_FCR_XFIFOR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IIR_FCR_XFIFOR_GET</csr:getMacro>
         <csr:setMacro>UART_IIR_FCR_XFIFOR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>521</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>XMIT FIFO Reset (or XFIFOR). This resets the control portion of the transmit FIFO and treats the FIFO as empty. This will also de-assert the DMA TX request and single signals when additional DMA handshaking signals are selected (DMA_EXTRA == YES). Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>RESET</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Transmit FIFO reset</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DMAM</csr:identifier>
         <csr:widthMacro>UART_IIR_FCR_DMAM_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IIR_FCR_DMAM_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IIR_FCR_DMAM_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IIR_FCR_DMAM_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IIR_FCR_DMAM_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IIR_FCR_DMAM_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IIR_FCR_DMAM_GET</csr:getMacro>
         <csr:setMacro>UART_IIR_FCR_DMAM_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>544</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DMA Mode (or DMAM). This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals when additional DMA handshaking signals are not selected (DMA_EXTRA == NO). For details on DMA support, refer to 'DMA Support' section of data book.</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>MODE0</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Mode 0</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>MODE1</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Mode 1</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TET</csr:identifier>
         <csr:widthMacro>UART_IIR_FCR_TET_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IIR_FCR_TET_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IIR_FCR_TET_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IIR_FCR_TET_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IIR_FCR_TET_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IIR_FCR_TET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IIR_FCR_TET_GET</csr:getMacro>
         <csr:setMacro>UART_IIR_FCR_TET_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>578</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>TX Empty Trigger (or TET). Writes will have no effect when THRE_MODE_USER == Disabled. This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. For details on DMA support, refer to 'DMA Support' section of data book.</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FIFO_CHAR_2</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>2 characters in FIFO</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_EMPTY</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>FIFO Empty</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_HALF_FULL</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>FIFO 1/2 full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_QUARTER_FULL</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>FIFO 1/4 full</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RT</csr:identifier>
         <csr:widthMacro>UART_IIR_FCR_RT_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IIR_FCR_RT_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IIR_FCR_RT_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IIR_FCR_RT_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IIR_FCR_RT_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IIR_FCR_RT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IIR_FCR_RT_GET</csr:getMacro>
         <csr:setMacro>UART_IIR_FCR_RT_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>613</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RCVR Trigger (or RT). This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode, it is used to determine when the rts_n signal will be de-asserted only when RTC_FCT is disabled. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. For details on DMA support, refer to 'DMA Support' section of data book.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FIFO_CHAR_1</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>1 character in FIFO</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_FULL_2</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>FIFO 2 less than full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_HALF_FULL</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>FIFO 1/2 full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_QUARTER_FULL</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>FIFO 1/4 full</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_FCR_31to8</csr:identifier>
         <csr:widthMacro>UART_IIR_FCR_RSVD_FCR_31TO8_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_IIR_FCR_RSVD_FCR_31TO8_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_IIR_FCR_RSVD_FCR_31TO8_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_IIR_FCR_RSVD_FCR_31TO8_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_IIR_FCR_RSVD_FCR_31TO8_RESET</csr:resetMacro>
         <csr:maskMacro>UART_IIR_FCR_RSVD_FCR_31TO8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_IIR_FCR_RSVD_FCR_31TO8_GET</csr:getMacro>
         <csr:setMacro>UART_IIR_FCR_RSVD_FCR_31TO8_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>621</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>FCR 31to8 Reserved bits and read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.LCR</csr:referenceName>
       <csr:identifier>LCR</csr:identifier>
       <csr:addressMacro>UART_LCR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_LCR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_LCR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_LCR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>856</csr:linenumber>
       <csr:title>Line Control Register</csr:title>
       <csr:offset>0xC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_LCR</csr:typeName>
        <csr:description>
         <csr:p>Line Control Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DLS</csr:identifier>
         <csr:widthMacro>UART_LCR_DLS_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LCR_DLS_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LCR_DLS_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LCR_DLS_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LCR_DLS_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LCR_DLS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LCR_DLS_GET</csr:getMacro>
         <csr:setMacro>UART_LCR_DLS_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>660</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Length Select (or CLS as used in legacy).</csr:p>
         <csr:p> If UART_16550_COMPATIBLE == NO then, writeable only when UART is not busy (USR[0] is zero), otherwise always writable and always readable. When DLS_E in LCR_EXT is set to 0, this register is used to select the number of data bits per character that the peripheral will transmit and receive.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>CHAR_5BITS</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>5 data bits per character</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>CHAR_6BITS</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>6 data bits per character</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>CHAR_7BITS</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>7 data bits per character</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>CHAR_8BITS</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>8 data bits per character</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>STOP</csr:identifier>
         <csr:widthMacro>UART_LCR_STOP_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LCR_STOP_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LCR_STOP_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LCR_STOP_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LCR_STOP_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LCR_STOP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LCR_STOP_GET</csr:getMacro>
         <csr:setMacro>UART_LCR_STOP_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>702</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Number of stop bits.</csr:p>
         <csr:p></csr:p>
         <csr:p>If UART_16550_COMPATIBLE == NO then, writeable only when UART is not busy (USR[0]</csr:p>
         <csr:p>is zero), otherwise always writable and always readable. This is used to select the number</csr:p>
         <csr:p>of stop bits per character that the peripheral will transmit and receive. If set to</csr:p>
         <csr:p>zero, one stop bit is transmitted in the serial data.</csr:p>
         <csr:p> If set to one and the data</csr:p>
         <csr:p>bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted.</csr:p>
         <csr:p>Otherwise, two stop bits are transmitted.</csr:p>
         <csr:p>Note that regardless of the number of stop bits selected the receiver will only</csr:p>
         <csr:p>check the first stop bit.</csr:p>
         <csr:p>Note: NOTE: The STOP bit duration implemented by DW_apb_uart may appear longer</csr:p>
         <csr:p>due to idle time inserted between characters for some configurations and baud</csr:p>
         <csr:p>clock divisor values in the transmit direction; for details on idle time between</csr:p>
         <csr:p>transmitted transfers, refer to 'Back-to-Back Character Stream Transmission' section in data book.</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>STOP_1BIT</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>1 stop bit</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>STOP_1_5BIT_OR_2BIT</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>PEN</csr:identifier>
         <csr:widthMacro>UART_LCR_PEN_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LCR_PEN_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LCR_PEN_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LCR_PEN_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LCR_PEN_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LCR_PEN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LCR_PEN_GET</csr:getMacro>
         <csr:setMacro>UART_LCR_PEN_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>728</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Parity Enable</csr:p>
         <csr:p>.</csr:p>
         <csr:p>If UART_16550_COMPATIBLE == NO then, writeable only when UART is not busy (USR[0]</csr:p>
         <csr:p>is zero), otherwise always writable and always readable. This bit is used to enable</csr:p>
         <csr:p>and disable parity generation and detection in transmitted and received serial</csr:p>
         <csr:p>character respectively.</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>disable parity</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>enable parity</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>EPS</csr:identifier>
         <csr:widthMacro>UART_LCR_EPS_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LCR_EPS_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LCR_EPS_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LCR_EPS_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LCR_EPS_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LCR_EPS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LCR_EPS_GET</csr:getMacro>
         <csr:setMacro>UART_LCR_EPS_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>756</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Even Parity Select.</csr:p>
         <csr:p></csr:p>
         <csr:p>If UART_16550_COMPATIBLE == NO then, writeable only when UART is not busy (USR[0]</csr:p>
         <csr:p>is zero), otherwise always writable and always readable. This is used to select</csr:p>
         <csr:p>between even and odd parity, when parity is enabled (PEN set to one). If set to</csr:p>
         <csr:p>one, an even number of logic '1's is transmitted or checked. If set to zero, an</csr:p>
         <csr:p>odd number of logic '1's is transmitted or checked.</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>EVEN_PARITY</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>an even parity is transmitted or checked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ODD_PARITY</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>an odd parity is transmitted or checked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SP</csr:identifier>
         <csr:widthMacro>UART_LCR_SP_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LCR_SP_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LCR_SP_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LCR_SP_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LCR_SP_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LCR_SP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LCR_SP_GET</csr:getMacro>
         <csr:setMacro>UART_LCR_SP_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>785</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Stick Parity.</csr:p>
         <csr:p> If UART_16550_COMPATIBLE = NO, then writeable only when UART is </csr:p>
         <csr:p>not busy (USR[0] is 0); otherwise always writable and always readable. This bit is used </csr:p>
         <csr:p>to force parity value. When PEN, EPS and Stick Parity are set to 1, the parity bit is </csr:p>
         <csr:p>transmitted and checked as logic 0. If PEN and Stick Parity are set to 1 and EPS is a </csr:p>
         <csr:p>logic 0, then parity bit is transmitted and checked as a logic 1. If this bit is set to 0, </csr:p>
         <csr:p>Stick Parity is disabled.</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Stick parity disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Stick parity enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>BC</csr:identifier>
         <csr:widthMacro>UART_LCR_BC_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LCR_BC_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LCR_BC_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LCR_BC_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LCR_BC_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LCR_BC_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LCR_BC_GET</csr:getMacro>
         <csr:setMacro>UART_LCR_BC_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>817</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Break Control Bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to cause a break condition to be transmitted to the receiving device.</csr:p>
         <csr:p>If set to one the serial output is forced to the spacing (logic 0) state. When</csr:p>
         <csr:p>not in Loopback Mode, as determined by MCR[4], the sout line is forced low until</csr:p>
         <csr:p>the Break bit is cleared. If SIR_MODE == Enabled and active (MCR[6] set to one)</csr:p>
         <csr:p>the sir_out_n line is continuously pulsed. When in Loopback Mode, the break</csr:p>
         <csr:p>condition is internally looped back to the receiver and the sir_out_n line is</csr:p>
         <csr:p>forced low.</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Serial output is released for data transmission</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Serial output is forced to spacing state</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DLAB</csr:identifier>
         <csr:widthMacro>UART_LCR_DLAB_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LCR_DLAB_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LCR_DLAB_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LCR_DLAB_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LCR_DLAB_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LCR_DLAB_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LCR_DLAB_GET</csr:getMacro>
         <csr:setMacro>UART_LCR_DLAB_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>847</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Divisor Latch Access Bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>If UART_16550_COMPATIBLE == NO then, writeable only when UART is not busy (USR[0]</csr:p>
         <csr:p>is zero), otherwise always writable and always readable. This bit is used to enable</csr:p>
         <csr:p>reading and writing of the Divisor Latch register (DLL and DLH/LPDLL and LPDLH) to set the baud</csr:p>
         <csr:p>rate of the UART. This bit must be cleared after initial baud rate setup in order</csr:p>
         <csr:p>to access other registers.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Divisor Latch register is writable only when UART Not BUSY</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Divisor Latch register is always readable and writable</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_LCR_31to8</csr:identifier>
         <csr:widthMacro>UART_LCR_RSVD_LCR_31TO8_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LCR_RSVD_LCR_31TO8_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LCR_RSVD_LCR_31TO8_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LCR_RSVD_LCR_31TO8_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LCR_RSVD_LCR_31TO8_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LCR_RSVD_LCR_31TO8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LCR_RSVD_LCR_31TO8_GET</csr:getMacro>
         <csr:setMacro>UART_LCR_RSVD_LCR_31TO8_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>855</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>LCR 31to8 Reserved bits and read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.MCR</csr:referenceName>
       <csr:identifier>MCR</csr:identifier>
       <csr:addressMacro>UART_MCR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_MCR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_MCR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_MCR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1089</csr:linenumber>
       <csr:title>Modem Control Register</csr:title>
       <csr:offset>0x10</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_MCR</csr:typeName>
        <csr:description>
         <csr:p>Modem Control Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DTR</csr:identifier>
         <csr:widthMacro>UART_MCR_DTR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MCR_DTR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MCR_DTR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MCR_DTR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MCR_DTR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MCR_DTR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MCR_DTR_GET</csr:getMacro>
         <csr:setMacro>UART_MCR_DTR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>892</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Terminal Ready.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to directly control the Data Terminal Ready (dtr_n) output. The value</csr:p>
         <csr:p>written to this location is inverted and driven out on dtr_n.</csr:p>
         <csr:p></csr:p>
         <csr:p>The Data Terminal Ready output is used to inform the modem or data set that the</csr:p>
         <csr:p>UART is ready to establish communications. Note that in Loopback mode (MCR[4]</csr:p>
         <csr:p>set to one), the dtr_n output is held inactive high while the value of this</csr:p>
         <csr:p>location is internally looped back to an input.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>dtr_n asserted (logic 0)</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>dtr_n de-asserted (logic1)</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RTS</csr:identifier>
         <csr:widthMacro>UART_MCR_RTS_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MCR_RTS_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MCR_RTS_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MCR_RTS_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MCR_RTS_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MCR_RTS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MCR_RTS_GET</csr:getMacro>
         <csr:setMacro>UART_MCR_RTS_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>933</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Request to Send.</csr:p>
         <csr:p> </csr:p>
         <csr:p>This is used to directly control the Request to Send (rts_n) output. The Request</csr:p>
         <csr:p>To Send (rts_n) output is used to inform the modem or data set that the UART is</csr:p>
         <csr:p>ready to exchange data.</csr:p>
         <csr:p></csr:p>
         <csr:p>When Auto RTS Flow Control is not enabled (MCR[5] set to zero), the rts_n signal</csr:p>
         <csr:p>is set low by programming MCR[1] (RTS) to a high.</csr:p>
         <csr:p>In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5] set to one) and</csr:p>
         <csr:p>FIFO's enable (FCR[0] set to one), the rts_n output is controlled in the same way,</csr:p>
         <csr:p>but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high</csr:p>
         <csr:p>when above the threshold).</csr:p>
         <csr:p>The rts_n signal will be de-asserted when MCR[1] is set low.</csr:p>
         <csr:p>Note that in Loopback mode (MCR[4] set to one), the rts_n output is held inactive</csr:p>
         <csr:p>high while the value of this location is internally looped back to an input.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Request to Send rts_n asserted (logic 0)</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Request to Send rts_n de-asserted (logic 1)</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>OUT1</csr:identifier>
         <csr:widthMacro>UART_MCR_OUT1_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MCR_OUT1_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MCR_OUT1_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MCR_OUT1_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MCR_OUT1_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MCR_OUT1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MCR_OUT1_GET</csr:getMacro>
         <csr:setMacro>UART_MCR_OUT1_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>960</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>OUT1</csr:p>
         <csr:p>.</csr:p>
         <csr:p>This is used to directly control the user-designated Output1 (out1_n) output. The</csr:p>
         <csr:p>value written to this location is inverted and driven out on out1_n.</csr:p>
         <csr:p>Note that in Loopback mode (MCR[4] set to one), the out1_n output is held inactive high</csr:p>
         <csr:p>while the value of this location is internally looped back to an input.</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>OUT1_0</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>out1_n de-asserted (logic 1)</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>OUT1_1</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>out1_n asserted (logic 0)</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>OUT2</csr:identifier>
         <csr:widthMacro>UART_MCR_OUT2_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MCR_OUT2_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MCR_OUT2_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MCR_OUT2_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MCR_OUT2_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MCR_OUT2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MCR_OUT2_GET</csr:getMacro>
         <csr:setMacro>UART_MCR_OUT2_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>987</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>OUT2</csr:p>
         <csr:p>.</csr:p>
         <csr:p>This is used to directly control the user-designated Output2 (out2_n) output. The</csr:p>
         <csr:p>value written to this location is inverted and driven out on out2_n.</csr:p>
         <csr:p>Note that in Loopback mode (MCR[4] set to one), the out2_n output is held inactive</csr:p>
         <csr:p>high while the value of this location is internally looped back to an input.</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>OUT2_0</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>out2_n de-asserted (logic 1)</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>OUT2_1</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>out2_n asserted (logic 0)</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>LoopBack</csr:identifier>
         <csr:widthMacro>UART_MCR_LOOPBACK_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MCR_LOOPBACK_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MCR_LOOPBACK_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MCR_LOOPBACK_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MCR_LOOPBACK_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MCR_LOOPBACK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MCR_LOOPBACK_GET</csr:getMacro>
         <csr:setMacro>UART_MCR_LOOPBACK_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1025</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>LoopBack Bit</csr:p>
         <csr:p>.</csr:p>
         <csr:p>This is used to put the UART into a diagnostic mode for test purposes.</csr:p>
         <csr:p>If operating in UART mode (SIR_MODE != Enabled OR NOT active, MCR[6] set to zero),</csr:p>
         <csr:p>data on the sout line is held high, while serial data output is looped back to the</csr:p>
         <csr:p>sin line, internally. In this mode all the interrupts are fully functional. Also,</csr:p>
         <csr:p>in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are</csr:p>
         <csr:p>disconnected and the modem control outputs (dtr_n, rts_n, out1_n, out2_n) are looped</csr:p>
         <csr:p>back to the inputs, internally.</csr:p>
         <csr:p></csr:p>
         <csr:p>If operating in infrared mode (SIR_MODE == Enabled AND active, MCR[6] set to one),</csr:p>
         <csr:p>data on the sir_out_n line is held low, while serial data output is inverted and</csr:p>
         <csr:p>looped back to the sir_in line.</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Loopback mode disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Loopback mode enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>AFCE</csr:identifier>
         <csr:widthMacro>UART_MCR_AFCE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MCR_AFCE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MCR_AFCE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MCR_AFCE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MCR_AFCE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MCR_AFCE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MCR_AFCE_GET</csr:getMacro>
         <csr:setMacro>UART_MCR_AFCE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1051</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Auto Flow Control Enable</csr:p>
         <csr:p>.</csr:p>
         <csr:p>Writeable only when AFCE_MODE == Enabled, always readable.  When FIFOs are enabled</csr:p>
         <csr:p>and the Auto Flow Control Enable (AFCE) bit is set, Auto Flow Control features are</csr:p>
         <csr:p>enabled as described in section 'Auto Flow Control' in data book.</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Auto Flow Control Mode disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Auto Flow Control Mode enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SIRE</csr:identifier>
         <csr:widthMacro>UART_MCR_SIRE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MCR_SIRE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MCR_SIRE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MCR_SIRE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MCR_SIRE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MCR_SIRE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MCR_SIRE_GET</csr:getMacro>
         <csr:setMacro>UART_MCR_SIRE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1080</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SIR Mode Enable</csr:p>
         <csr:p>.</csr:p>
         <csr:p>Writeable only when SIR_MODE == Enabled, always readable.  This is used to enable/</csr:p>
         <csr:p>disable the IrDA SIR Mode features as described in section 'IrDA 1.0 SIR Protocol' in the databook.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note: To enable SIR mode, write the appropriate value to the MCR register before writing to the LCR register.</csr:p>
         <csr:p>For details of the recommended programming sequence, refer to 'Programing Examples' section of data book.</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>IrDA SIR Mode disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>IrDA SIR Mode enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_MCR_31to7</csr:identifier>
         <csr:widthMacro>UART_MCR_RSVD_MCR_31TO7_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MCR_RSVD_MCR_31TO7_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MCR_RSVD_MCR_31TO7_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MCR_RSVD_MCR_31TO7_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MCR_RSVD_MCR_31TO7_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MCR_RSVD_MCR_31TO7_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MCR_RSVD_MCR_31TO7_GET</csr:getMacro>
         <csr:setMacro>UART_MCR_RSVD_MCR_31TO7_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1088</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>MCR 31to7 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.LSR</csr:referenceName>
       <csr:identifier>LSR</csr:identifier>
       <csr:addressMacro>UART_LSR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_LSR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_LSR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_LSR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1407</csr:linenumber>
       <csr:title>Line Status Register</csr:title>
       <csr:offset>0x14</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000060</csr:registerResetValue>
       <csr:typeName>Uart_LSR</csr:typeName>
        <csr:description>
         <csr:p>Line Status Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DR</csr:identifier>
         <csr:widthMacro>UART_LSR_DR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LSR_DR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LSR_DR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LSR_DR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LSR_DR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LSR_DR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LSR_DR_GET</csr:getMacro>
         <csr:setMacro>UART_LSR_DR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1120</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Ready bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate that the receiver contains at least one character in the</csr:p>
         <csr:p>RBR or the receiver FIFO.</csr:p>
         <csr:p>This bit is cleared when the RBR is read in the non-FIFO mode, or when the receiver</csr:p>
         <csr:p>FIFO is empty, in the FIFO mode.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>NOT_READY</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>data not ready</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>READY</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>data ready</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>OE</csr:identifier>
         <csr:widthMacro>UART_LSR_OE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LSR_OE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LSR_OE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LSR_OE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LSR_OE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LSR_OE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LSR_OE_GET</csr:getMacro>
         <csr:setMacro>UART_LSR_OE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1156</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Overrun error bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate the occurrence of an overrun error. This occurs if a new data</csr:p>
         <csr:p>character was received before the previous data was read.</csr:p>
         <csr:p> In the non-FIFO mode, the OE</csr:p>
         <csr:p>bit is set when a new character arrives in the receiver before the previous character</csr:p>
         <csr:p>was read from the RBR. When this happens, the data in the RBR is overwritten. In the</csr:p>
         <csr:p>FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at</csr:p>
         <csr:p>the receiver. The data in the FIFO is retained and the data in the receive shift register</csr:p>
         <csr:p>is lost. </csr:p>
         <csr:p>Reading the LSR clears the OE bit (if LSR_STATUS_CLEAR==1) Or </csr:p>
         <csr:p>Reading the LSR or RBR clears the OE bit (if LSR_STATUS_CLEAR==0).</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>NO_OVER_RUN_ERROR</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>no overrun error</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>OVER_RUN_ERROR</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>overrun error</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>PE</csr:identifier>
         <csr:widthMacro>UART_LSR_PE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LSR_PE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LSR_PE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LSR_PE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LSR_PE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LSR_PE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LSR_PE_GET</csr:getMacro>
         <csr:setMacro>UART_LSR_PE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1195</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Parity Error bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate the occurrence of a parity error in the receiver if the</csr:p>
         <csr:p>Parity Enable (PEN) bit (LCR[3]) is set. </csr:p>
         <csr:p> In the FIFO mode, since the parity error is</csr:p>
         <csr:p>associated with a character received, it is revealed when the character with the parity</csr:p>
         <csr:p>error arrives at the top of the FIFO. </csr:p>
         <csr:p></csr:p>
         <csr:p>It should be noted that the Parity Error (PE) bit (LSR[2]) will be set if a break</csr:p>
         <csr:p>interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]). In this situation, the Parity Error</csr:p>
         <csr:p>bit is set if parity generation and detection is enabled (LCR[3]=1) and the parity is set to</csr:p>
         <csr:p>odd (LCR[4]=0).</csr:p>
         <csr:p></csr:p>
         <csr:p>Reading the LSR clears the PE bit (if LSR_STATUS_CLEAR==1) Or </csr:p>
         <csr:p>Reading the LSR or RBR clears the PE bit (if LSR_STATUS_CLEAR==0).</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>NO_PARITY_ERROR</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>no parity error</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>PARITY_ERROR</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>parity error</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>FE</csr:identifier>
         <csr:widthMacro>UART_LSR_FE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LSR_FE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LSR_FE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LSR_FE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LSR_FE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LSR_FE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LSR_FE_GET</csr:getMacro>
         <csr:setMacro>UART_LSR_FE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1241</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Framing Error bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate the occurrence of a framing error in the receiver. A framing</csr:p>
         <csr:p>error occurs when the receiver does not detect a valid STOP bit in the received data.</csr:p>
         <csr:p></csr:p>
         <csr:p>In the FIFO mode, since the framing error is associated with a character received, it</csr:p>
         <csr:p>is revealed when the character with the framing error is at the top of the FIFO. When</csr:p>
         <csr:p>a framing error occurs the UART will try resynchronize. It does this by assuming that</csr:p>
         <csr:p>the error was due to the start bit of the next character and then continues receiving</csr:p>
         <csr:p>the other bit i.e. data, and/or parity and stop.</csr:p>
         <csr:p></csr:p>
         <csr:p>It should be noted that the Framing Error (FE) bit (LSR[3]) will be set if a break</csr:p>
         <csr:p>interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]). This happens because the</csr:p>
         <csr:p>break character implicitly generates a framing error by holding the sin input to logic 0 for</csr:p>
         <csr:p>longer than the duration of a character.</csr:p>
         <csr:p></csr:p>
         <csr:p>Reading the LSR clears the FE bit (if LSR_STATUS_CLEAR==1) Or </csr:p>
         <csr:p>Reading the LSR or RBR clears the FE bit (if LSR_STATUS_CLEAR==0).</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FRAMING_ERROR</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>framing error</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NO_FRAMING_ERROR</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>no framing error</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>BI</csr:identifier>
         <csr:widthMacro>UART_LSR_BI_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LSR_BI_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LSR_BI_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LSR_BI_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LSR_BI_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LSR_BI_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LSR_BI_GET</csr:getMacro>
         <csr:setMacro>UART_LSR_BI_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1296</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Break Interrupt bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate the detection of a break sequence on the serial input data.</csr:p>
         <csr:p></csr:p>
         <csr:p>If in UART mode it is set whenever the serial input, sin, is held in a logic '0'</csr:p>
         <csr:p>state for longer than the sum of start time + data bits + parity + stop bits.</csr:p>
         <csr:p></csr:p>
         <csr:p>If in infrared mode  it is set whenever the serial input, sir_in, is continuously</csr:p>
         <csr:p>pulsed to logic '0' for longer than the sum of start time + data bits + parity + stop</csr:p>
         <csr:p>bits.</csr:p>
         <csr:p>A break condition on serial input causes one and only one character, consisting of</csr:p>
         <csr:p>all zeros, to be received by the UART.</csr:p>
         <csr:p> In the FIFO mode, the character associated</csr:p>
         <csr:p>with the break condition is carried through the FIFO and is revealed when the</csr:p>
         <csr:p>character is at the top of the FIFO. </csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Reading the LSR clears the BI bit (if LSR_STATUS_CLEAR==1) Or </csr:p>
         <csr:p>Reading the LSR or RBR clears the BI bit (if LSR_STATUS_CLEAR==0). </csr:p>
         <csr:p></csr:p>
         <csr:p>In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is</csr:p>
         <csr:p>read. </csr:p>
         <csr:p>Note: If a FIFO is full when a break condition is received, a FIFO overrun occurs. The</csr:p>
         <csr:p>break condition and all the information associated with it-parity and framing errors-is</csr:p>
         <csr:p>discarded; any information that a break character was received is lost.</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>BREAK</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Break sequence detected</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NO_BREAK</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>No break sequence detected</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>THRE</csr:identifier>
         <csr:widthMacro>UART_LSR_THRE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LSR_THRE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LSR_THRE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LSR_THRE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LSR_THRE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LSR_THRE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LSR_THRE_GET</csr:getMacro>
         <csr:setMacro>UART_LSR_THRE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1336</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit Holding Register Empty bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>If THRE_MODE_USER = Disabled or THRE mode is disabled (IER[7] set to zero) and</csr:p>
         <csr:p>regardless of FIFO's being implemented/enabled or not, this bit indicates that</csr:p>
         <csr:p>the THR or TX FIFO is empty.</csr:p>
         <csr:p> This bit is set whenever data is transferred from</csr:p>
         <csr:p>the THR or TX FIFO to the transmitter shift register and no new data has been</csr:p>
         <csr:p>written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the</csr:p>
         <csr:p>THRE Interrupt is enabled.</csr:p>
         <csr:p>If THRE_MODE_USER == Enabled AND FIFO_MODE != NONE and both modes are active</csr:p>
         <csr:p>(IER[7] set to one and FCR[0] set to one respectively), the functionality is switched</csr:p>
         <csr:p>to indicate the transmitter FIFO is full, and no longer controls THRE interrupts,</csr:p>
         <csr:p>which are then controlled by the FCR[5:4] threshold setting. Programmable THRE</csr:p>
         <csr:p>interrupt mode operation is described in detail in section 'Programmable THRE Interrupt' in data book.</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>THRE interrupt control is disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>THRE interrupt control is enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TEMT</csr:identifier>
         <csr:widthMacro>UART_LSR_TEMT_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LSR_TEMT_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LSR_TEMT_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LSR_TEMT_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LSR_TEMT_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LSR_TEMT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LSR_TEMT_GET</csr:getMacro>
         <csr:setMacro>UART_LSR_TEMT_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1363</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmitter Empty bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>If in FIFO mode (FIFO_MODE != NONE) and FIFO's enabled (FCR[0] set to one), this</csr:p>
         <csr:p>bit is set whenever the Transmitter Shift Register and the FIFO are both empty.</csr:p>
         <csr:p>If in the non-FIFO mode or FIFO's are disabled, this bit is set whenever the</csr:p>
         <csr:p>Transmitter Holding Register and the Transmitter Shift Register are both empty.</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Transmitter not empty</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Transmitter empty</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RFE</csr:identifier>
         <csr:widthMacro>UART_LSR_RFE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LSR_RFE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LSR_RFE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LSR_RFE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LSR_RFE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LSR_RFE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LSR_RFE_GET</csr:getMacro>
         <csr:setMacro>UART_LSR_RFE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1392</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receiver FIFO Error bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is only relevant when FIFO_MODE != NONE AND FIFO's are enabled (FCR[0]</csr:p>
         <csr:p>set to one). This is used to indicate if there is at least one parity error, framing</csr:p>
         <csr:p>error, or break indication in the FIFO. </csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is cleared when the LSR is read and the character with the error is at the</csr:p>
         <csr:p>top of the receiver FIFO and there are no subsequent errors in the FIFO.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>NO_RX_FIFO_ERROR</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>No error in RX FIFO</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>RX_FIFO_ERROR</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Error in RX FIFO</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_ADDR_RCVD</csr:identifier>
         <csr:widthMacro>UART_LSR_RSVD_ADDR_RCVD_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LSR_RSVD_ADDR_RCVD_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LSR_RSVD_ADDR_RCVD_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LSR_RSVD_ADDR_RCVD_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LSR_RSVD_ADDR_RCVD_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LSR_RSVD_ADDR_RCVD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LSR_RSVD_ADDR_RCVD_GET</csr:getMacro>
         <csr:setMacro>UART_LSR_RSVD_ADDR_RCVD_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1399</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>lSR 8 Reserved bit for UART_9BIT_DATA_EN</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_LSR_31to9</csr:identifier>
         <csr:widthMacro>UART_LSR_RSVD_LSR_31TO9_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_LSR_RSVD_LSR_31TO9_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_LSR_RSVD_LSR_31TO9_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_LSR_RSVD_LSR_31TO9_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_LSR_RSVD_LSR_31TO9_RESET</csr:resetMacro>
         <csr:maskMacro>UART_LSR_RSVD_LSR_31TO9_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_LSR_RSVD_LSR_31TO9_GET</csr:getMacro>
         <csr:setMacro>UART_LSR_RSVD_LSR_31TO9_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1406</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>LSR 31to9 Reserved bits read as zero.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.MSR</csr:referenceName>
       <csr:identifier>MSR</csr:identifier>
       <csr:addressMacro>UART_MSR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_MSR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_MSR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_MSR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1672</csr:linenumber>
       <csr:title>Modem Status Register</csr:title>
       <csr:offset>0x18</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_MSR</csr:typeName>
        <csr:description>
         <csr:p>Whenever bits 0, 1, 2 or 3 is set to logic one, to indicate</csr:p>
         <csr:p>a change on the modem control inputs, a modem status interrupt will be generated</csr:p>
         <csr:p>if enabled via the IER regardless of when the change occurred. The bits</csr:p>
         <csr:p>(bits 0, 1, 3) can be set after a reset-even though their respective modem signals are</csr:p>
         <csr:p>inactive-because the synchronized version of the modem signals have a reset value of 0 and change to value 1 after reset. To</csr:p>
         <csr:p>prevent unwanted interrupts due to this change, a read of the MSR register can be performed after reset.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DCTS</csr:identifier>
         <csr:widthMacro>UART_MSR_DCTS_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MSR_DCTS_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MSR_DCTS_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MSR_DCTS_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MSR_DCTS_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MSR_DCTS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MSR_DCTS_GET</csr:getMacro>
         <csr:setMacro>UART_MSR_DCTS_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1456</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Delta Clear to Send.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate that the modem control line cts_n has changed since the</csr:p>
         <csr:p>last time the MSR was read.</csr:p>
         <csr:p></csr:p>
         <csr:p>Reading the MSR clears the DCTS bit.</csr:p>
         <csr:p>In Loopback Mode (MCR[4] set to one), DCTS reflects changes on MCR[1] (RTS).</csr:p>
         <csr:p></csr:p>
         <csr:p>Note, if the DCTS bit is not set and the cts_n signal is asserted (low) and a reset</csr:p>
         <csr:p>occurs (software or otherwise), then the DCTS bit will get set when the reset is</csr:p>
         <csr:p>removed if the cts_n signal remains asserted.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>CHANGE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>change on cts_n since last read of MSR</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NO_CHANGE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>no change on cts_n since last read of MSR</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DDSR</csr:identifier>
         <csr:widthMacro>UART_MSR_DDSR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MSR_DDSR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MSR_DDSR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MSR_DDSR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MSR_DDSR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MSR_DDSR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MSR_DDSR_GET</csr:getMacro>
         <csr:setMacro>UART_MSR_DDSR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1488</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Delta Data Set Ready.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate that the modem control line dsr_n has changed since</csr:p>
         <csr:p>the last time the MSR was read. </csr:p>
         <csr:p></csr:p>
         <csr:p>Reading the MSR clears the DDSR bit.</csr:p>
         <csr:p>In Loopback Mode (MCR[4] set to one), DDSR reflects changes on MCR[0] (DTR).</csr:p>
         <csr:p></csr:p>
         <csr:p>Note, if the DDSR bit is not set and the dsr_n signal is asserted (low) and a reset</csr:p>
         <csr:p>occurs (software or otherwise), then the DDSR bit will get set when the reset is</csr:p>
         <csr:p>removed if the dsr_n signal remains asserted.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>CHANGE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>change on dsr_n since last read of MSR</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NO_CHANGE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>no change on dsr_n since last read of MSR</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TERI</csr:identifier>
         <csr:widthMacro>UART_MSR_TERI_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MSR_TERI_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MSR_TERI_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MSR_TERI_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MSR_TERI_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MSR_TERI_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MSR_TERI_GET</csr:getMacro>
         <csr:setMacro>UART_MSR_TERI_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1516</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Trailing Edge of Ring Indicator.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate that a change on the input ri_n (from an active low, to</csr:p>
         <csr:p>an inactive high state) has occurred since the last time the MSR was read.</csr:p>
         <csr:p></csr:p>
         <csr:p>Reading the MSR clears the TERI bit.</csr:p>
         <csr:p>In Loopback Mode (MCR[4] set to one), TERI reflects when MCR[2] (Out1) has changed</csr:p>
         <csr:p>state from a high to a low.</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>CHANGE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>change on ri_n since last read of MSR</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NO_CHANGE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>no change on ri_n since last read of MSR</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DDCD</csr:identifier>
         <csr:widthMacro>UART_MSR_DDCD_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MSR_DDCD_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MSR_DDCD_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MSR_DDCD_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MSR_DDCD_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MSR_DDCD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MSR_DDCD_GET</csr:getMacro>
         <csr:setMacro>UART_MSR_DDCD_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1548</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Delta Data Carrier Detect.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate that the modem control line dcd_n has changed since the last</csr:p>
         <csr:p>time the MSR was read.</csr:p>
         <csr:p></csr:p>
         <csr:p>Reading the MSR clears the DDCD bit.</csr:p>
         <csr:p>In Loopback Mode (MCR[4] set to one), DDCD reflects changes on MCR[3] (Out2).</csr:p>
         <csr:p></csr:p>
         <csr:p>Note, if the DDCD bit is not set and the dcd_n signal is asserted (low) and a reset</csr:p>
         <csr:p>occurs (software or otherwise), then the DDCD bit will get set when the reset is</csr:p>
         <csr:p>removed if the dcd_n signal remains asserted.</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>CHANGE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>change on dcd_n since last read of MSR</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NO_CHANGE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>No change on dcd_n since last read of MSR</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CTS</csr:identifier>
         <csr:widthMacro>UART_MSR_CTS_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MSR_CTS_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MSR_CTS_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MSR_CTS_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MSR_CTS_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MSR_CTS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MSR_CTS_GET</csr:getMacro>
         <csr:setMacro>UART_MSR_CTS_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1577</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Clear to Send.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate the current state of the modem control line cts_n. That is,</csr:p>
         <csr:p>this bit is the complement cts_n. When the Clear to Send input (cts_n) is asserted</csr:p>
         <csr:p>it is an indication that the modem or data set is ready to exchange data with the</csr:p>
         <csr:p>DW_apb_uart.</csr:p>
         <csr:p></csr:p>
         <csr:p>In Loopback Mode (MCR[4] set to one), CTS is the same as MCR[1] (RTS).</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ASSERTED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>cts_n input is asserted (logic 0)</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>DEASSERTED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>cts_n input is de-asserted (logic 1)</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DSR</csr:identifier>
         <csr:widthMacro>UART_MSR_DSR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MSR_DSR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MSR_DSR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MSR_DSR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MSR_DSR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MSR_DSR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MSR_DSR_GET</csr:getMacro>
         <csr:setMacro>UART_MSR_DSR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1606</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Set Ready.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate the current state of the modem control line dsr_n. That is</csr:p>
         <csr:p>this bit is the complement dsr_n. When the Data Set Ready input (dsr_n) is asserted</csr:p>
         <csr:p>it is an indication that the modem or data set is ready to establish communications</csr:p>
         <csr:p>with the DW_apb_uart.</csr:p>
         <csr:p></csr:p>
         <csr:p>In Loopback Mode (MCR[4] set to one), DSR is the same as MCR[0] (DTR).</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ASSERTED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>dsr_n input is asserted (logic 0)</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>DEASSERTED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>dsr_n input is de-asserted (logic 1)</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RI</csr:identifier>
         <csr:widthMacro>UART_MSR_RI_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MSR_RI_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MSR_RI_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MSR_RI_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MSR_RI_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MSR_RI_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MSR_RI_GET</csr:getMacro>
         <csr:setMacro>UART_MSR_RI_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1635</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Ring Indicator.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate the current state of the modem control line ri_n. That is</csr:p>
         <csr:p>this bit is the complement ri_n. When the Ring Indicator input (ri_n) is asserted</csr:p>
         <csr:p>it is an indication that a telephone ringing signal has been received by the modem</csr:p>
         <csr:p>or data set.</csr:p>
         <csr:p></csr:p>
         <csr:p>In Loopback Mode (MCR[4] set to one), RI is the same as MCR[2] (Out1).</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ASSERTED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ri_n input is asserted (logic 0)</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>DEASSERTED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ri_n input is de-asserted (logic 1)</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DCD</csr:identifier>
         <csr:widthMacro>UART_MSR_DCD_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MSR_DCD_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MSR_DCD_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MSR_DCD_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MSR_DCD_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MSR_DCD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MSR_DCD_GET</csr:getMacro>
         <csr:setMacro>UART_MSR_DCD_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1664</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data Carrier Detect.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to indicate the current state of the modem control line dcd_n. That is</csr:p>
         <csr:p>this bit is the complement dcd_n. When the Data Carrier Detect input (dcd_n) is</csr:p>
         <csr:p>asserted it is an indication that the carrier has been detected by the modem or</csr:p>
         <csr:p>data set.</csr:p>
         <csr:p></csr:p>
         <csr:p>In Loopback Mode (MCR[4] set to one), DCD is the same as MCR[3] (Out2).</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ASSERTED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>dcd_n input is asserted (logic 0)</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>DEASSERTED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>dcd_n input is de-asserted (logic 1)</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_MSR_31to8</csr:identifier>
         <csr:widthMacro>UART_MSR_RSVD_MSR_31TO8_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_MSR_RSVD_MSR_31TO8_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_MSR_RSVD_MSR_31TO8_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_MSR_RSVD_MSR_31TO8_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_MSR_RSVD_MSR_31TO8_RESET</csr:resetMacro>
         <csr:maskMacro>UART_MSR_RSVD_MSR_31TO8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_MSR_RSVD_MSR_31TO8_GET</csr:getMacro>
         <csr:setMacro>UART_MSR_RSVD_MSR_31TO8_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1671</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>MSR 31to8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SCR</csr:referenceName>
       <csr:identifier>SCR</csr:identifier>
       <csr:addressMacro>UART_SCR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SCR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SCR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SCR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1695</csr:linenumber>
       <csr:title>Scratchpad Register</csr:title>
       <csr:offset>0x1C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SCR</csr:typeName>
        <csr:description>
         <csr:p>Scratchpad Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SCR</csr:identifier>
         <csr:widthMacro>UART_SCR_SCR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SCR_SCR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SCR_SCR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SCR_SCR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SCR_SCR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SCR_SCR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SCR_SCR_GET</csr:getMacro>
         <csr:setMacro>UART_SCR_SCR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1686</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This register is for programmers to use as a temporary storage space. It has no</csr:p>
         <csr:p>defined purpose in the DW_apb_uart.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SCR_31to8</csr:identifier>
         <csr:widthMacro>UART_SCR_RSVD_SCR_31TO8_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SCR_RSVD_SCR_31TO8_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SCR_RSVD_SCR_31TO8_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SCR_RSVD_SCR_31TO8_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SCR_RSVD_SCR_31TO8_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SCR_RSVD_SCR_31TO8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SCR_RSVD_SCR_31TO8_GET</csr:getMacro>
         <csr:setMacro>UART_SCR_RSVD_SCR_31TO8_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1694</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SCR 31to8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR0</csr:referenceName>
       <csr:identifier>SRBR0</csr:identifier>
       <csr:addressMacro>UART_SRBR0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1815</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x30</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR0</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR0.SRBR0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR0.STHR0</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR0.SRBR0</csr:referenceName>
       <csr:identifier>SRBR0</csr:identifier>
       <csr:addressMacro>UART_SRBR0_SRBR0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR0_SRBR0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR0_SRBR0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR0_SRBR0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1753</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR0_SRBR0</csr:typeName>
        <csr:description>
         <csr:p>This register is valid only when the DW_apb_uart is configured to have additional shadow registers</csr:p>
         <csr:p>implemented (SHADOW = YES). If shadow registers are not implemented, this register does not exist and</csr:p>
         <csr:p>reading from this register address returns 0.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register can be accessed only when the DLAB bit (LCR[7]) is cleared.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBRn</csr:identifier>
         <csr:widthMacro>UART_SRBR0_SRBR0_SRBRN_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR0_SRBR0_SRBRN_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR0_SRBR0_SRBRN_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR0_SRBR0_SRBRN_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR0_SRBR0_SRBRN_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR0_SRBR0_SRBRN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR0_SRBR0_SRBRN_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR0_SRBR0_SRBRN_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1745</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register n.</csr:p>
         <csr:p>This is a shadow register for the RBR and has been allocated sixteen 32-bit locations</csr:p>
         <csr:p>so as to accommodate burst accesses from the master.</csr:p>
         <csr:p>This register contains the data byte received on the serial input port (sin) in UART</csr:p>
         <csr:p>mode or the serial infrared input (sir_in) in infrared mode. The data in this register</csr:p>
         <csr:p>is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set.</csr:p>
         <csr:p></csr:p>
         <csr:p>If in non-FIFO mode (FIFO_MODE == NONE) or FIFOs are disabled (FCR[0] set to zero), the</csr:p>
         <csr:p>data in the RBR must be read before the next data arrives, otherwise it will be</csr:p>
         <csr:p>overwritten, resulting in an overrun error.</csr:p>
         <csr:p></csr:p>
         <csr:p>If in FIFO mode (FIFO_MODE != NONE) and FIFOs are enabled (FCR[0] set to one), this</csr:p>
         <csr:p>register accesses the head of the receive FIFO. If the receive FIFO is full and this</csr:p>
         <csr:p>register is not read before the next data character arrives, then the data already</csr:p>
         <csr:p>in the FIFO will be preserved but any incoming data will be lost. An overrun error</csr:p>
         <csr:p>will also occur.</csr:p>
         <csr:p>Note:</csr:p>
         <csr:p></csr:p>
         <csr:p> - When UART_9BIT_DATA_EN=0, this field width is 8.</csr:p>
         <csr:p> - When UART_9BIT_DATA_EN=1, this field width is 9.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBRn</csr:identifier>
         <csr:widthMacro>UART_SRBR0_SRBR0_RSVD_SRBRN_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR0_SRBR0_RSVD_SRBRN_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR0_SRBR0_RSVD_SRBRN_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR0_SRBR0_RSVD_SRBRN_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR0_SRBR0_RSVD_SRBRN_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR0_SRBR0_RSVD_SRBRN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR0_SRBR0_RSVD_SRBRN_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR0_SRBR0_RSVD_SRBRN_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1752</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR0 31 to SRBRN_REG_SIZE Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR0.STHR0</csr:referenceName>
       <csr:identifier>STHR0</csr:identifier>
       <csr:addressMacro>UART_SRBR0_STHR0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR0_STHR0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR0_STHR0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR0_STHR0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1814</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR0_STHR0</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register. This register is valid only when the DW_apb_uart is configured to have additional shadow registers</csr:p>
         <csr:p>implemented (SHADOW = YES). If shadow registers are not implemented, this register does not exist, and</csr:p>
         <csr:p>reading from this register address returns 0.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register can be accessed only when the DLAB bit (LCR[7]) is cleared.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>STHRn</csr:identifier>
         <csr:widthMacro>UART_SRBR0_STHR0_STHRN_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR0_STHR0_STHRN_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR0_STHR0_STHRN_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR0_STHR0_STHRN_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR0_STHR0_STHRN_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR0_STHR0_STHRN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR0_STHR0_STHRN_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR0_STHR0_STHRN_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1805</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register n.</csr:p>
         <csr:p>This is a shadow register for the THR and has been allocated sixteen 32-bit locations</csr:p>
         <csr:p>so as to accommodate burst accesses from the master.</csr:p>
         <csr:p>This register contains data to be transmitted on the serial output port (sout) in UART</csr:p>
         <csr:p>mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be</csr:p>
         <csr:p>written to the THR when the THR Empty (THRE) bit (LSR[5]) is set.</csr:p>
         <csr:p></csr:p>
         <csr:p>If in non-FIFO mode or FIFO's are disabled (FCR[0] set to zero) and THRE is set,</csr:p>
         <csr:p>writing a single character to the THR clears the THRE. Any additional writes to the</csr:p>
         <csr:p>THR before the THRE is set again causes the THR data to be overwritten.</csr:p>
         <csr:p></csr:p>
         <csr:p>If in FIFO mode and FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of</csr:p>
         <csr:p>characters of data may be written to the THR before the FIFO is full. The number x</csr:p>
         <csr:p>(default=16) is determined by the value of FIFO Depth that you set during configuration.</csr:p>
         <csr:p>Any attempt to write data when the FIFO is full results in the write data being lost.</csr:p>
         <csr:p>Note:</csr:p>
         <csr:p></csr:p>
         <csr:p> - When UART_9BIT_DATA_EN=0, this field width is 8.</csr:p>
         <csr:p> - When UART_9BIT_DATA_EN=1, this field width is 9. The 9th bit is applicable only when LCR_EXT[3]=1.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHRn</csr:identifier>
         <csr:widthMacro>UART_SRBR0_STHR0_RSVD_STHRN_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR0_STHR0_RSVD_STHRN_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR0_STHR0_RSVD_STHRN_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR0_STHR0_RSVD_STHRN_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR0_STHR0_RSVD_STHRN_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR0_STHR0_RSVD_STHRN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR0_STHR0_RSVD_STHRN_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR0_STHR0_RSVD_STHRN_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1813</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHRn 31 to STHRN_REG_SIZE Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR1</csr:referenceName>
       <csr:identifier>SRBR1</csr:identifier>
       <csr:addressMacro>UART_SRBR1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1861</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x34</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR1</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR1.SRBR1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR1.STHR1</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR1.SRBR1</csr:referenceName>
       <csr:identifier>SRBR1</csr:identifier>
       <csr:addressMacro>UART_SRBR1_SRBR1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR1_SRBR1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR1_SRBR1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR1_SRBR1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1837</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 1</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR1_SRBR1</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR1</csr:identifier>
         <csr:widthMacro>UART_SRBR1_SRBR1_SRBR1_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR1_SRBR1_SRBR1_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR1_SRBR1_SRBR1_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR1_SRBR1_SRBR1_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR1_SRBR1_SRBR1_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR1_SRBR1_SRBR1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR1_SRBR1_SRBR1_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR1_SRBR1_SRBR1_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1829</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR1</csr:identifier>
         <csr:widthMacro>UART_SRBR1_SRBR1_RSVD_SRBR1_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR1_SRBR1_RSVD_SRBR1_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR1_SRBR1_RSVD_SRBR1_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR1_SRBR1_RSVD_SRBR1_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR1_SRBR1_RSVD_SRBR1_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR1_SRBR1_RSVD_SRBR1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR1_SRBR1_RSVD_SRBR1_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR1_SRBR1_RSVD_SRBR1_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1836</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR1 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR1.STHR1</csr:referenceName>
       <csr:identifier>STHR1</csr:identifier>
       <csr:addressMacro>UART_SRBR1_STHR1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR1_STHR1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR1_STHR1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR1_STHR1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1860</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 1</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR1_STHR1</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>STHR1</csr:identifier>
         <csr:widthMacro>UART_SRBR1_STHR1_STHR1_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR1_STHR1_STHR1_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR1_STHR1_STHR1_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR1_STHR1_STHR1_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR1_STHR1_STHR1_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR1_STHR1_STHR1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR1_STHR1_STHR1_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR1_STHR1_STHR1_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1851</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR1</csr:identifier>
         <csr:widthMacro>UART_SRBR1_STHR1_RSVD_STHR1_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR1_STHR1_RSVD_STHR1_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR1_STHR1_RSVD_STHR1_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR1_STHR1_RSVD_STHR1_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR1_STHR1_RSVD_STHR1_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR1_STHR1_RSVD_STHR1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR1_STHR1_RSVD_STHR1_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR1_STHR1_RSVD_STHR1_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1859</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR1 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR2</csr:referenceName>
       <csr:identifier>SRBR2</csr:identifier>
       <csr:addressMacro>UART_SRBR2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1907</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x38</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR2</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR2.SRBR2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR2.STHR2</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR2.SRBR2</csr:referenceName>
       <csr:identifier>SRBR2</csr:identifier>
       <csr:addressMacro>UART_SRBR2_SRBR2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR2_SRBR2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR2_SRBR2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR2_SRBR2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1883</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 2</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR2_SRBR2</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 2</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR2</csr:identifier>
         <csr:widthMacro>UART_SRBR2_SRBR2_SRBR2_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR2_SRBR2_SRBR2_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR2_SRBR2_SRBR2_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR2_SRBR2_SRBR2_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR2_SRBR2_SRBR2_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR2_SRBR2_SRBR2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR2_SRBR2_SRBR2_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR2_SRBR2_SRBR2_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1875</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR2</csr:identifier>
         <csr:widthMacro>UART_SRBR2_SRBR2_RSVD_SRBR2_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR2_SRBR2_RSVD_SRBR2_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR2_SRBR2_RSVD_SRBR2_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR2_SRBR2_RSVD_SRBR2_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR2_SRBR2_RSVD_SRBR2_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR2_SRBR2_RSVD_SRBR2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR2_SRBR2_RSVD_SRBR2_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR2_SRBR2_RSVD_SRBR2_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1882</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR2 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR2.STHR2</csr:referenceName>
       <csr:identifier>STHR2</csr:identifier>
       <csr:addressMacro>UART_SRBR2_STHR2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR2_STHR2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR2_STHR2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR2_STHR2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1906</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 2</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR2_STHR2</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 2</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr2</csr:identifier>
         <csr:widthMacro>UART_SRBR2_STHR2_STHR2_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR2_STHR2_STHR2_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR2_STHR2_STHR2_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR2_STHR2_STHR2_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR2_STHR2_STHR2_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR2_STHR2_STHR2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR2_STHR2_STHR2_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR2_STHR2_STHR2_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1897</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR2</csr:identifier>
         <csr:widthMacro>UART_SRBR2_STHR2_RSVD_STHR2_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR2_STHR2_RSVD_STHR2_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR2_STHR2_RSVD_STHR2_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR2_STHR2_RSVD_STHR2_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR2_STHR2_RSVD_STHR2_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR2_STHR2_RSVD_STHR2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR2_STHR2_RSVD_STHR2_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR2_STHR2_RSVD_STHR2_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1905</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR2 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR3</csr:referenceName>
       <csr:identifier>SRBR3</csr:identifier>
       <csr:addressMacro>UART_SRBR3_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR3_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR3_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR3_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1953</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x3C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR3</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR3.SRBR3</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR3.STHR3</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR3.SRBR3</csr:referenceName>
       <csr:identifier>SRBR3</csr:identifier>
       <csr:addressMacro>UART_SRBR3_SRBR3_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR3_SRBR3_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR3_SRBR3_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR3_SRBR3_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1929</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 3</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR3_SRBR3</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 3</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR3</csr:identifier>
         <csr:widthMacro>UART_SRBR3_SRBR3_SRBR3_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR3_SRBR3_SRBR3_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR3_SRBR3_SRBR3_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR3_SRBR3_SRBR3_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR3_SRBR3_SRBR3_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR3_SRBR3_SRBR3_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR3_SRBR3_SRBR3_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR3_SRBR3_SRBR3_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1921</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR3</csr:identifier>
         <csr:widthMacro>UART_SRBR3_SRBR3_RSVD_SRBR3_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR3_SRBR3_RSVD_SRBR3_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR3_SRBR3_RSVD_SRBR3_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR3_SRBR3_RSVD_SRBR3_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR3_SRBR3_RSVD_SRBR3_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR3_SRBR3_RSVD_SRBR3_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR3_SRBR3_RSVD_SRBR3_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR3_SRBR3_RSVD_SRBR3_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1928</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR3 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR3.STHR3</csr:referenceName>
       <csr:identifier>STHR3</csr:identifier>
       <csr:addressMacro>UART_SRBR3_STHR3_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR3_STHR3_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR3_STHR3_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR3_STHR3_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1952</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 3</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR3_STHR3</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 3</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr3</csr:identifier>
         <csr:widthMacro>UART_SRBR3_STHR3_STHR3_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR3_STHR3_STHR3_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR3_STHR3_STHR3_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR3_STHR3_STHR3_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR3_STHR3_STHR3_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR3_STHR3_STHR3_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR3_STHR3_STHR3_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR3_STHR3_STHR3_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1943</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR3</csr:identifier>
         <csr:widthMacro>UART_SRBR3_STHR3_RSVD_STHR3_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR3_STHR3_RSVD_STHR3_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR3_STHR3_RSVD_STHR3_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR3_STHR3_RSVD_STHR3_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR3_STHR3_RSVD_STHR3_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR3_STHR3_RSVD_STHR3_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR3_STHR3_RSVD_STHR3_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR3_STHR3_RSVD_STHR3_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1951</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR3 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR4</csr:referenceName>
       <csr:identifier>SRBR4</csr:identifier>
       <csr:addressMacro>UART_SRBR4_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR4_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR4_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR4_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1999</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x40</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR4</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR4.SRBR4</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR4.STHR4</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR4.SRBR4</csr:referenceName>
       <csr:identifier>SRBR4</csr:identifier>
       <csr:addressMacro>UART_SRBR4_SRBR4_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR4_SRBR4_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR4_SRBR4_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR4_SRBR4_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1975</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 4</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR4_SRBR4</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 4</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR4</csr:identifier>
         <csr:widthMacro>UART_SRBR4_SRBR4_SRBR4_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR4_SRBR4_SRBR4_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR4_SRBR4_SRBR4_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR4_SRBR4_SRBR4_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR4_SRBR4_SRBR4_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR4_SRBR4_SRBR4_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR4_SRBR4_SRBR4_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR4_SRBR4_SRBR4_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1967</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR4</csr:identifier>
         <csr:widthMacro>UART_SRBR4_SRBR4_RSVD_SRBR4_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR4_SRBR4_RSVD_SRBR4_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR4_SRBR4_RSVD_SRBR4_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR4_SRBR4_RSVD_SRBR4_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR4_SRBR4_RSVD_SRBR4_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR4_SRBR4_RSVD_SRBR4_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR4_SRBR4_RSVD_SRBR4_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR4_SRBR4_RSVD_SRBR4_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1974</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR4 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR4.STHR4</csr:referenceName>
       <csr:identifier>STHR4</csr:identifier>
       <csr:addressMacro>UART_SRBR4_STHR4_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR4_STHR4_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR4_STHR4_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR4_STHR4_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>1998</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 4</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR4_STHR4</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 4</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr4</csr:identifier>
         <csr:widthMacro>UART_SRBR4_STHR4_STHR4_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR4_STHR4_STHR4_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR4_STHR4_STHR4_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR4_STHR4_STHR4_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR4_STHR4_STHR4_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR4_STHR4_STHR4_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR4_STHR4_STHR4_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR4_STHR4_STHR4_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1989</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR4</csr:identifier>
         <csr:widthMacro>UART_SRBR4_STHR4_RSVD_STHR4_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR4_STHR4_RSVD_STHR4_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR4_STHR4_RSVD_STHR4_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR4_STHR4_RSVD_STHR4_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR4_STHR4_RSVD_STHR4_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR4_STHR4_RSVD_STHR4_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR4_STHR4_RSVD_STHR4_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR4_STHR4_RSVD_STHR4_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>1997</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR4 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR5</csr:referenceName>
       <csr:identifier>SRBR5</csr:identifier>
       <csr:addressMacro>UART_SRBR5_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR5_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR5_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR5_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2045</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x44</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR5</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR5.SRBR5</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR5.STHR5</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR5.SRBR5</csr:referenceName>
       <csr:identifier>SRBR5</csr:identifier>
       <csr:addressMacro>UART_SRBR5_SRBR5_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR5_SRBR5_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR5_SRBR5_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR5_SRBR5_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2021</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 5</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR5_SRBR5</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 5</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR5</csr:identifier>
         <csr:widthMacro>UART_SRBR5_SRBR5_SRBR5_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR5_SRBR5_SRBR5_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR5_SRBR5_SRBR5_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR5_SRBR5_SRBR5_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR5_SRBR5_SRBR5_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR5_SRBR5_SRBR5_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR5_SRBR5_SRBR5_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR5_SRBR5_SRBR5_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2013</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR5</csr:identifier>
         <csr:widthMacro>UART_SRBR5_SRBR5_RSVD_SRBR5_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR5_SRBR5_RSVD_SRBR5_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR5_SRBR5_RSVD_SRBR5_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR5_SRBR5_RSVD_SRBR5_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR5_SRBR5_RSVD_SRBR5_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR5_SRBR5_RSVD_SRBR5_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR5_SRBR5_RSVD_SRBR5_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR5_SRBR5_RSVD_SRBR5_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2020</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR5 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR5.STHR5</csr:referenceName>
       <csr:identifier>STHR5</csr:identifier>
       <csr:addressMacro>UART_SRBR5_STHR5_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR5_STHR5_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR5_STHR5_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR5_STHR5_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2044</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 5</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR5_STHR5</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 5</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr5</csr:identifier>
         <csr:widthMacro>UART_SRBR5_STHR5_STHR5_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR5_STHR5_STHR5_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR5_STHR5_STHR5_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR5_STHR5_STHR5_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR5_STHR5_STHR5_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR5_STHR5_STHR5_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR5_STHR5_STHR5_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR5_STHR5_STHR5_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2035</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR5</csr:identifier>
         <csr:widthMacro>UART_SRBR5_STHR5_RSVD_STHR5_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR5_STHR5_RSVD_STHR5_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR5_STHR5_RSVD_STHR5_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR5_STHR5_RSVD_STHR5_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR5_STHR5_RSVD_STHR5_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR5_STHR5_RSVD_STHR5_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR5_STHR5_RSVD_STHR5_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR5_STHR5_RSVD_STHR5_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2043</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR5 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR6</csr:referenceName>
       <csr:identifier>SRBR6</csr:identifier>
       <csr:addressMacro>UART_SRBR6_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR6_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR6_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR6_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2091</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x48</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR6</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR6.SRBR6</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR6.STHR6</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR6.SRBR6</csr:referenceName>
       <csr:identifier>SRBR6</csr:identifier>
       <csr:addressMacro>UART_SRBR6_SRBR6_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR6_SRBR6_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR6_SRBR6_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR6_SRBR6_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2067</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 6</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR6_SRBR6</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 6</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR6</csr:identifier>
         <csr:widthMacro>UART_SRBR6_SRBR6_SRBR6_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR6_SRBR6_SRBR6_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR6_SRBR6_SRBR6_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR6_SRBR6_SRBR6_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR6_SRBR6_SRBR6_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR6_SRBR6_SRBR6_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR6_SRBR6_SRBR6_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR6_SRBR6_SRBR6_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2059</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR6</csr:identifier>
         <csr:widthMacro>UART_SRBR6_SRBR6_RSVD_SRBR6_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR6_SRBR6_RSVD_SRBR6_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR6_SRBR6_RSVD_SRBR6_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR6_SRBR6_RSVD_SRBR6_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR6_SRBR6_RSVD_SRBR6_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR6_SRBR6_RSVD_SRBR6_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR6_SRBR6_RSVD_SRBR6_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR6_SRBR6_RSVD_SRBR6_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2066</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR6 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR6.STHR6</csr:referenceName>
       <csr:identifier>STHR6</csr:identifier>
       <csr:addressMacro>UART_SRBR6_STHR6_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR6_STHR6_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR6_STHR6_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR6_STHR6_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2090</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 6</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR6_STHR6</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 6</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr6</csr:identifier>
         <csr:widthMacro>UART_SRBR6_STHR6_STHR6_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR6_STHR6_STHR6_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR6_STHR6_STHR6_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR6_STHR6_STHR6_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR6_STHR6_STHR6_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR6_STHR6_STHR6_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR6_STHR6_STHR6_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR6_STHR6_STHR6_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2081</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR6</csr:identifier>
         <csr:widthMacro>UART_SRBR6_STHR6_RSVD_STHR6_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR6_STHR6_RSVD_STHR6_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR6_STHR6_RSVD_STHR6_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR6_STHR6_RSVD_STHR6_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR6_STHR6_RSVD_STHR6_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR6_STHR6_RSVD_STHR6_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR6_STHR6_RSVD_STHR6_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR6_STHR6_RSVD_STHR6_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2089</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR6 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR7</csr:referenceName>
       <csr:identifier>SRBR7</csr:identifier>
       <csr:addressMacro>UART_SRBR7_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR7_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR7_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR7_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2137</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x4C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR7</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR7.SRBR7</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR7.STHR7</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR7.SRBR7</csr:referenceName>
       <csr:identifier>SRBR7</csr:identifier>
       <csr:addressMacro>UART_SRBR7_SRBR7_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR7_SRBR7_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR7_SRBR7_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR7_SRBR7_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2113</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 7</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR7_SRBR7</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 7</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR7</csr:identifier>
         <csr:widthMacro>UART_SRBR7_SRBR7_SRBR7_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR7_SRBR7_SRBR7_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR7_SRBR7_SRBR7_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR7_SRBR7_SRBR7_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR7_SRBR7_SRBR7_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR7_SRBR7_SRBR7_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR7_SRBR7_SRBR7_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR7_SRBR7_SRBR7_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2105</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR7</csr:identifier>
         <csr:widthMacro>UART_SRBR7_SRBR7_RSVD_SRBR7_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR7_SRBR7_RSVD_SRBR7_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR7_SRBR7_RSVD_SRBR7_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR7_SRBR7_RSVD_SRBR7_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR7_SRBR7_RSVD_SRBR7_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR7_SRBR7_RSVD_SRBR7_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR7_SRBR7_RSVD_SRBR7_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR7_SRBR7_RSVD_SRBR7_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2112</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR7 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR7.STHR7</csr:referenceName>
       <csr:identifier>STHR7</csr:identifier>
       <csr:addressMacro>UART_SRBR7_STHR7_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR7_STHR7_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR7_STHR7_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR7_STHR7_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2136</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 7</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR7_STHR7</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 7</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr7</csr:identifier>
         <csr:widthMacro>UART_SRBR7_STHR7_STHR7_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR7_STHR7_STHR7_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR7_STHR7_STHR7_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR7_STHR7_STHR7_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR7_STHR7_STHR7_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR7_STHR7_STHR7_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR7_STHR7_STHR7_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR7_STHR7_STHR7_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2127</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR7</csr:identifier>
         <csr:widthMacro>UART_SRBR7_STHR7_RSVD_STHR7_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR7_STHR7_RSVD_STHR7_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR7_STHR7_RSVD_STHR7_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR7_STHR7_RSVD_STHR7_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR7_STHR7_RSVD_STHR7_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR7_STHR7_RSVD_STHR7_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR7_STHR7_RSVD_STHR7_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR7_STHR7_RSVD_STHR7_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2135</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR7 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR8</csr:referenceName>
       <csr:identifier>SRBR8</csr:identifier>
       <csr:addressMacro>UART_SRBR8_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR8_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR8_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR8_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2183</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x50</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR8</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR8.SRBR8</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR8.STHR8</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR8.SRBR8</csr:referenceName>
       <csr:identifier>SRBR8</csr:identifier>
       <csr:addressMacro>UART_SRBR8_SRBR8_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR8_SRBR8_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR8_SRBR8_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR8_SRBR8_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2159</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 8</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR8_SRBR8</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 8</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR8</csr:identifier>
         <csr:widthMacro>UART_SRBR8_SRBR8_SRBR8_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR8_SRBR8_SRBR8_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR8_SRBR8_SRBR8_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR8_SRBR8_SRBR8_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR8_SRBR8_SRBR8_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR8_SRBR8_SRBR8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR8_SRBR8_SRBR8_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR8_SRBR8_SRBR8_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2151</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR8</csr:identifier>
         <csr:widthMacro>UART_SRBR8_SRBR8_RSVD_SRBR8_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR8_SRBR8_RSVD_SRBR8_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR8_SRBR8_RSVD_SRBR8_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR8_SRBR8_RSVD_SRBR8_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR8_SRBR8_RSVD_SRBR8_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR8_SRBR8_RSVD_SRBR8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR8_SRBR8_RSVD_SRBR8_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR8_SRBR8_RSVD_SRBR8_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2158</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR8 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR8.STHR8</csr:referenceName>
       <csr:identifier>STHR8</csr:identifier>
       <csr:addressMacro>UART_SRBR8_STHR8_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR8_STHR8_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR8_STHR8_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR8_STHR8_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2182</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 8</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR8_STHR8</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 8</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr8</csr:identifier>
         <csr:widthMacro>UART_SRBR8_STHR8_STHR8_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR8_STHR8_STHR8_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR8_STHR8_STHR8_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR8_STHR8_STHR8_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR8_STHR8_STHR8_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR8_STHR8_STHR8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR8_STHR8_STHR8_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR8_STHR8_STHR8_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2173</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR8</csr:identifier>
         <csr:widthMacro>UART_SRBR8_STHR8_RSVD_STHR8_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR8_STHR8_RSVD_STHR8_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR8_STHR8_RSVD_STHR8_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR8_STHR8_RSVD_STHR8_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR8_STHR8_RSVD_STHR8_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR8_STHR8_RSVD_STHR8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR8_STHR8_RSVD_STHR8_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR8_STHR8_RSVD_STHR8_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2181</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR8 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR9</csr:referenceName>
       <csr:identifier>SRBR9</csr:identifier>
       <csr:addressMacro>UART_SRBR9_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR9_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR9_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR9_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2229</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x54</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR9</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR9.SRBR9</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR9.STHR9</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR9.SRBR9</csr:referenceName>
       <csr:identifier>SRBR9</csr:identifier>
       <csr:addressMacro>UART_SRBR9_SRBR9_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR9_SRBR9_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR9_SRBR9_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR9_SRBR9_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2205</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 9</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR9_SRBR9</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 9</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR9</csr:identifier>
         <csr:widthMacro>UART_SRBR9_SRBR9_SRBR9_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR9_SRBR9_SRBR9_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR9_SRBR9_SRBR9_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR9_SRBR9_SRBR9_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR9_SRBR9_SRBR9_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR9_SRBR9_SRBR9_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR9_SRBR9_SRBR9_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR9_SRBR9_SRBR9_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2197</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR9</csr:identifier>
         <csr:widthMacro>UART_SRBR9_SRBR9_RSVD_SRBR9_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR9_SRBR9_RSVD_SRBR9_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR9_SRBR9_RSVD_SRBR9_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR9_SRBR9_RSVD_SRBR9_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR9_SRBR9_RSVD_SRBR9_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR9_SRBR9_RSVD_SRBR9_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR9_SRBR9_RSVD_SRBR9_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR9_SRBR9_RSVD_SRBR9_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2204</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR9 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR9.STHR9</csr:referenceName>
       <csr:identifier>STHR9</csr:identifier>
       <csr:addressMacro>UART_SRBR9_STHR9_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR9_STHR9_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR9_STHR9_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR9_STHR9_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2228</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 9</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR9_STHR9</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 9</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr9</csr:identifier>
         <csr:widthMacro>UART_SRBR9_STHR9_STHR9_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR9_STHR9_STHR9_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR9_STHR9_STHR9_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR9_STHR9_STHR9_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR9_STHR9_STHR9_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR9_STHR9_STHR9_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR9_STHR9_STHR9_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR9_STHR9_STHR9_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2219</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR9</csr:identifier>
         <csr:widthMacro>UART_SRBR9_STHR9_RSVD_STHR9_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR9_STHR9_RSVD_STHR9_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR9_STHR9_RSVD_STHR9_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR9_STHR9_RSVD_STHR9_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR9_STHR9_RSVD_STHR9_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR9_STHR9_RSVD_STHR9_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR9_STHR9_RSVD_STHR9_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR9_STHR9_RSVD_STHR9_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2227</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR9 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR10</csr:referenceName>
       <csr:identifier>SRBR10</csr:identifier>
       <csr:addressMacro>UART_SRBR10_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR10_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR10_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR10_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2275</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x58</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR10</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR10.SRBR10</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR10.STHR10</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR10.SRBR10</csr:referenceName>
       <csr:identifier>SRBR10</csr:identifier>
       <csr:addressMacro>UART_SRBR10_SRBR10_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR10_SRBR10_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR10_SRBR10_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR10_SRBR10_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2251</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 10</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR10_SRBR10</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 10</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR10</csr:identifier>
         <csr:widthMacro>UART_SRBR10_SRBR10_SRBR10_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR10_SRBR10_SRBR10_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR10_SRBR10_SRBR10_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR10_SRBR10_SRBR10_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR10_SRBR10_SRBR10_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR10_SRBR10_SRBR10_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR10_SRBR10_SRBR10_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR10_SRBR10_SRBR10_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2243</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR10</csr:identifier>
         <csr:widthMacro>UART_SRBR10_SRBR10_RSVD_SRBR10_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR10_SRBR10_RSVD_SRBR10_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR10_SRBR10_RSVD_SRBR10_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR10_SRBR10_RSVD_SRBR10_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR10_SRBR10_RSVD_SRBR10_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR10_SRBR10_RSVD_SRBR10_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR10_SRBR10_RSVD_SRBR10_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR10_SRBR10_RSVD_SRBR10_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2250</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR10 31to9or8 Reserved bi read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR10.STHR10</csr:referenceName>
       <csr:identifier>STHR10</csr:identifier>
       <csr:addressMacro>UART_SRBR10_STHR10_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR10_STHR10_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR10_STHR10_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR10_STHR10_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2274</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 10</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR10_STHR10</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 10</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr10</csr:identifier>
         <csr:widthMacro>UART_SRBR10_STHR10_STHR10_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR10_STHR10_STHR10_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR10_STHR10_STHR10_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR10_STHR10_STHR10_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR10_STHR10_STHR10_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR10_STHR10_STHR10_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR10_STHR10_STHR10_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR10_STHR10_STHR10_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2265</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR10</csr:identifier>
         <csr:widthMacro>UART_SRBR10_STHR10_RSVD_STHR10_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR10_STHR10_RSVD_STHR10_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR10_STHR10_RSVD_STHR10_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR10_STHR10_RSVD_STHR10_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR10_STHR10_RSVD_STHR10_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR10_STHR10_RSVD_STHR10_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR10_STHR10_RSVD_STHR10_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR10_STHR10_RSVD_STHR10_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2273</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR10 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR11</csr:referenceName>
       <csr:identifier>SRBR11</csr:identifier>
       <csr:addressMacro>UART_SRBR11_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR11_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR11_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR11_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2321</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x5C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR11</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR11.SRBR11</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR11.STHR11</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR11.SRBR11</csr:referenceName>
       <csr:identifier>SRBR11</csr:identifier>
       <csr:addressMacro>UART_SRBR11_SRBR11_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR11_SRBR11_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR11_SRBR11_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR11_SRBR11_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2297</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 11</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR11_SRBR11</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 11</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR11</csr:identifier>
         <csr:widthMacro>UART_SRBR11_SRBR11_SRBR11_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR11_SRBR11_SRBR11_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR11_SRBR11_SRBR11_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR11_SRBR11_SRBR11_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR11_SRBR11_SRBR11_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR11_SRBR11_SRBR11_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR11_SRBR11_SRBR11_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR11_SRBR11_SRBR11_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2289</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR11</csr:identifier>
         <csr:widthMacro>UART_SRBR11_SRBR11_RSVD_SRBR11_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR11_SRBR11_RSVD_SRBR11_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR11_SRBR11_RSVD_SRBR11_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR11_SRBR11_RSVD_SRBR11_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR11_SRBR11_RSVD_SRBR11_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR11_SRBR11_RSVD_SRBR11_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR11_SRBR11_RSVD_SRBR11_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR11_SRBR11_RSVD_SRBR11_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2296</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR11 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR11.STHR11</csr:referenceName>
       <csr:identifier>STHR11</csr:identifier>
       <csr:addressMacro>UART_SRBR11_STHR11_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR11_STHR11_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR11_STHR11_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR11_STHR11_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2320</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 11</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR11_STHR11</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 11</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr11</csr:identifier>
         <csr:widthMacro>UART_SRBR11_STHR11_STHR11_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR11_STHR11_STHR11_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR11_STHR11_STHR11_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR11_STHR11_STHR11_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR11_STHR11_STHR11_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR11_STHR11_STHR11_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR11_STHR11_STHR11_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR11_STHR11_STHR11_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2311</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR11</csr:identifier>
         <csr:widthMacro>UART_SRBR11_STHR11_RSVD_STHR11_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR11_STHR11_RSVD_STHR11_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR11_STHR11_RSVD_STHR11_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR11_STHR11_RSVD_STHR11_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR11_STHR11_RSVD_STHR11_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR11_STHR11_RSVD_STHR11_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR11_STHR11_RSVD_STHR11_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR11_STHR11_RSVD_STHR11_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2319</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR11 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR12</csr:referenceName>
       <csr:identifier>SRBR12</csr:identifier>
       <csr:addressMacro>UART_SRBR12_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR12_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR12_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR12_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2367</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x60</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR12</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR12.SRBR12</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR12.STHR12</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR12.SRBR12</csr:referenceName>
       <csr:identifier>SRBR12</csr:identifier>
       <csr:addressMacro>UART_SRBR12_SRBR12_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR12_SRBR12_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR12_SRBR12_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR12_SRBR12_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2343</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 12</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR12_SRBR12</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 12</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR12</csr:identifier>
         <csr:widthMacro>UART_SRBR12_SRBR12_SRBR12_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR12_SRBR12_SRBR12_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR12_SRBR12_SRBR12_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR12_SRBR12_SRBR12_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR12_SRBR12_SRBR12_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR12_SRBR12_SRBR12_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR12_SRBR12_SRBR12_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR12_SRBR12_SRBR12_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2335</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR12</csr:identifier>
         <csr:widthMacro>UART_SRBR12_SRBR12_RSVD_SRBR12_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR12_SRBR12_RSVD_SRBR12_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR12_SRBR12_RSVD_SRBR12_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR12_SRBR12_RSVD_SRBR12_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR12_SRBR12_RSVD_SRBR12_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR12_SRBR12_RSVD_SRBR12_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR12_SRBR12_RSVD_SRBR12_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR12_SRBR12_RSVD_SRBR12_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2342</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR12 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR12.STHR12</csr:referenceName>
       <csr:identifier>STHR12</csr:identifier>
       <csr:addressMacro>UART_SRBR12_STHR12_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR12_STHR12_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR12_STHR12_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR12_STHR12_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2366</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 12</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR12_STHR12</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 12</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr12</csr:identifier>
         <csr:widthMacro>UART_SRBR12_STHR12_STHR12_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR12_STHR12_STHR12_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR12_STHR12_STHR12_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR12_STHR12_STHR12_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR12_STHR12_STHR12_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR12_STHR12_STHR12_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR12_STHR12_STHR12_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR12_STHR12_STHR12_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2357</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR12</csr:identifier>
         <csr:widthMacro>UART_SRBR12_STHR12_RSVD_STHR12_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR12_STHR12_RSVD_STHR12_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR12_STHR12_RSVD_STHR12_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR12_STHR12_RSVD_STHR12_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR12_STHR12_RSVD_STHR12_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR12_STHR12_RSVD_STHR12_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR12_STHR12_RSVD_STHR12_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR12_STHR12_RSVD_STHR12_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2365</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR12 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR13</csr:referenceName>
       <csr:identifier>SRBR13</csr:identifier>
       <csr:addressMacro>UART_SRBR13_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR13_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR13_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR13_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2413</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x64</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR13</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR13.SRBR13</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR13.STHR13</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR13.SRBR13</csr:referenceName>
       <csr:identifier>SRBR13</csr:identifier>
       <csr:addressMacro>UART_SRBR13_SRBR13_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR13_SRBR13_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR13_SRBR13_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR13_SRBR13_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2389</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 13</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR13_SRBR13</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 13</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR13</csr:identifier>
         <csr:widthMacro>UART_SRBR13_SRBR13_SRBR13_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR13_SRBR13_SRBR13_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR13_SRBR13_SRBR13_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR13_SRBR13_SRBR13_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR13_SRBR13_SRBR13_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR13_SRBR13_SRBR13_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR13_SRBR13_SRBR13_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR13_SRBR13_SRBR13_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2381</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR13</csr:identifier>
         <csr:widthMacro>UART_SRBR13_SRBR13_RSVD_SRBR13_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR13_SRBR13_RSVD_SRBR13_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR13_SRBR13_RSVD_SRBR13_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR13_SRBR13_RSVD_SRBR13_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR13_SRBR13_RSVD_SRBR13_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR13_SRBR13_RSVD_SRBR13_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR13_SRBR13_RSVD_SRBR13_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR13_SRBR13_RSVD_SRBR13_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2388</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR13 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR13.STHR13</csr:referenceName>
       <csr:identifier>STHR13</csr:identifier>
       <csr:addressMacro>UART_SRBR13_STHR13_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR13_STHR13_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR13_STHR13_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR13_STHR13_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2412</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 13</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR13_STHR13</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 13</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr13</csr:identifier>
         <csr:widthMacro>UART_SRBR13_STHR13_STHR13_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR13_STHR13_STHR13_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR13_STHR13_STHR13_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR13_STHR13_STHR13_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR13_STHR13_STHR13_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR13_STHR13_STHR13_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR13_STHR13_STHR13_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR13_STHR13_STHR13_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2403</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR13</csr:identifier>
         <csr:widthMacro>UART_SRBR13_STHR13_RSVD_STHR13_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR13_STHR13_RSVD_STHR13_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR13_STHR13_RSVD_STHR13_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR13_STHR13_RSVD_STHR13_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR13_STHR13_RSVD_STHR13_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR13_STHR13_RSVD_STHR13_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR13_STHR13_RSVD_STHR13_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR13_STHR13_RSVD_STHR13_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2411</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR13 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR14</csr:referenceName>
       <csr:identifier>SRBR14</csr:identifier>
       <csr:addressMacro>UART_SRBR14_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR14_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR14_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR14_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2459</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x68</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR14</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR14.SRBR14</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR14.STHR14</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR14.SRBR14</csr:referenceName>
       <csr:identifier>SRBR14</csr:identifier>
       <csr:addressMacro>UART_SRBR14_SRBR14_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR14_SRBR14_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR14_SRBR14_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR14_SRBR14_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2435</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 14</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR14_SRBR14</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 14</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR14</csr:identifier>
         <csr:widthMacro>UART_SRBR14_SRBR14_SRBR14_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR14_SRBR14_SRBR14_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR14_SRBR14_SRBR14_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR14_SRBR14_SRBR14_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR14_SRBR14_SRBR14_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR14_SRBR14_SRBR14_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR14_SRBR14_SRBR14_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR14_SRBR14_SRBR14_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2427</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR14</csr:identifier>
         <csr:widthMacro>UART_SRBR14_SRBR14_RSVD_SRBR14_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR14_SRBR14_RSVD_SRBR14_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR14_SRBR14_RSVD_SRBR14_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR14_SRBR14_RSVD_SRBR14_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR14_SRBR14_RSVD_SRBR14_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR14_SRBR14_RSVD_SRBR14_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR14_SRBR14_RSVD_SRBR14_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR14_SRBR14_RSVD_SRBR14_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2434</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR14 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR14.STHR14</csr:referenceName>
       <csr:identifier>STHR14</csr:identifier>
       <csr:addressMacro>UART_SRBR14_STHR14_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR14_STHR14_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR14_STHR14_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR14_STHR14_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2458</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 14</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR14_STHR14</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 14</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sthr14</csr:identifier>
         <csr:widthMacro>UART_SRBR14_STHR14_STHR14_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR14_STHR14_STHR14_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR14_STHR14_STHR14_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR14_STHR14_STHR14_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR14_STHR14_STHR14_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR14_STHR14_STHR14_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR14_STHR14_STHR14_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR14_STHR14_STHR14_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2449</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR14</csr:identifier>
         <csr:widthMacro>UART_SRBR14_STHR14_RSVD_STHR14_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR14_STHR14_RSVD_STHR14_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR14_STHR14_RSVD_STHR14_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR14_STHR14_RSVD_STHR14_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR14_STHR14_RSVD_STHR14_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR14_STHR14_RSVD_STHR14_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR14_STHR14_RSVD_STHR14_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR14_STHR14_RSVD_STHR14_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2457</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR14 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>uart.SRBR15</csr:referenceName>
       <csr:identifier>SRBR15</csr:identifier>
       <csr:addressMacro>UART_SRBR15_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR15_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR15_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR15_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2505</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x6C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Uart_SRBR15</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR15.SRBR15</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>uart.SRBR15.STHR15</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR15.SRBR15</csr:referenceName>
       <csr:identifier>SRBR15</csr:identifier>
       <csr:addressMacro>UART_SRBR15_SRBR15_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR15_SRBR15_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR15_SRBR15_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR15_SRBR15_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2481</csr:linenumber>
       <csr:title>Shadow Receive Buffer Register 15</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR15_SRBR15</csr:typeName>
        <csr:description>
         <csr:p>Shadow Receive Buffer Register 15</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRBR15</csr:identifier>
         <csr:widthMacro>UART_SRBR15_SRBR15_SRBR15_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR15_SRBR15_SRBR15_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR15_SRBR15_SRBR15_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR15_SRBR15_SRBR15_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR15_SRBR15_SRBR15_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR15_SRBR15_SRBR15_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR15_SRBR15_SRBR15_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR15_SRBR15_SRBR15_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2473</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See SRBR0 description</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRBR15</csr:identifier>
         <csr:widthMacro>UART_SRBR15_SRBR15_RSVD_SRBR15_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR15_SRBR15_RSVD_SRBR15_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR15_SRBR15_RSVD_SRBR15_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR15_SRBR15_RSVD_SRBR15_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR15_SRBR15_RSVD_SRBR15_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR15_SRBR15_RSVD_SRBR15_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR15_SRBR15_RSVD_SRBR15_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR15_SRBR15_RSVD_SRBR15_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2480</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRBR15 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRBR15.STHR15</csr:referenceName>
       <csr:identifier>STHR15</csr:identifier>
       <csr:addressMacro>UART_SRBR15_STHR15_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRBR15_STHR15_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRBR15_STHR15_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRBR15_STHR15_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2504</csr:linenumber>
       <csr:title>Shadow Transmit Holding Register 15</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRBR15_STHR15</csr:typeName>
        <csr:description>
         <csr:p>Shadow Transmit Holding Register 15</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>STHR15</csr:identifier>
         <csr:widthMacro>UART_SRBR15_STHR15_STHR15_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR15_STHR15_STHR15_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR15_STHR15_STHR15_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR15_STHR15_STHR15_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR15_STHR15_STHR15_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR15_STHR15_STHR15_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR15_STHR15_STHR15_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR15_STHR15_STHR15_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2495</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>See STHR0 description.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STHR15</csr:identifier>
         <csr:widthMacro>UART_SRBR15_STHR15_RSVD_STHR15_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRBR15_STHR15_RSVD_STHR15_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRBR15_STHR15_RSVD_STHR15_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRBR15_STHR15_RSVD_STHR15_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRBR15_STHR15_RSVD_STHR15_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRBR15_STHR15_RSVD_STHR15_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRBR15_STHR15_RSVD_STHR15_GET</csr:getMacro>
         <csr:setMacro>UART_SRBR15_STHR15_RSVD_STHR15_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2503</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STHR15 31to9or8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.FAR</csr:referenceName>
       <csr:identifier>FAR</csr:identifier>
       <csr:addressMacro>UART_FAR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_FAR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_FAR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_FAR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2551</csr:linenumber>
       <csr:title>FIFO Access Register</csr:title>
       <csr:offset>0x70</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_FAR</csr:typeName>
        <csr:description>
         <csr:p>FIFO Access Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>FAR</csr:identifier>
         <csr:widthMacro>UART_FAR_FAR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_FAR_FAR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_FAR_FAR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_FAR_FAR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_FAR_FAR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_FAR_FAR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_FAR_FAR_GET</csr:getMacro>
         <csr:setMacro>UART_FAR_FAR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2542</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Writes will have no effect when FIFO_ACCESS == No, always readable.  This register</csr:p>
         <csr:p>is use to enable a FIFO access mode for testing, so that the receive FIFO can be</csr:p>
         <csr:p>written by the master and the transmit FIFO can be read by the master when FIFO's</csr:p>
         <csr:p>are implemented and enabled. When FIFOs are not implemented or not enabled it</csr:p>
         <csr:p>allows the RBR to be written by the master and the THR to be read by the master.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note, that when the FIFO access mode is enabled/disabled, the control portion of</csr:p>
         <csr:p>the receive FIFO and transmit FIFO is reset and the FIFO's are treated as empty.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>FIFO access mode disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>FIFO access mode enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_FAR_31to1</csr:identifier>
         <csr:widthMacro>UART_FAR_RSVD_FAR_31TO1_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_FAR_RSVD_FAR_31TO1_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_FAR_RSVD_FAR_31TO1_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_FAR_RSVD_FAR_31TO1_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_FAR_RSVD_FAR_31TO1_RESET</csr:resetMacro>
         <csr:maskMacro>UART_FAR_RSVD_FAR_31TO1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_FAR_RSVD_FAR_31TO1_GET</csr:getMacro>
         <csr:setMacro>UART_FAR_RSVD_FAR_31TO1_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2550</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>FAR 31to1 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.TFR</csr:referenceName>
       <csr:identifier>TFR</csr:identifier>
       <csr:addressMacro>UART_TFR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_TFR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_TFR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_TFR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2589</csr:linenumber>
       <csr:title>Transmit FIFO Read</csr:title>
       <csr:offset>0x74</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_TFR</csr:typeName>
        <csr:description>
         <csr:p>This register is valid only when the DW_apb_uart is configured to have the FIFO access test mode available</csr:p>
         <csr:p>(FIFO_ACCESS = YES). If not configured, this register does not exist and reading from this register address</csr:p>
         <csr:p>returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TFR</csr:identifier>
         <csr:widthMacro>UART_TFR_TFR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_TFR_TFR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_TFR_TFR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_TFR_TFR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_TFR_TFR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_TFR_TFR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_TFR_TFR_GET</csr:getMacro>
         <csr:setMacro>UART_TFR_TFR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2581</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Read.</csr:p>
         <csr:p></csr:p>
         <csr:p>These bits are only valid when FIFO access mode is enabled (FAR[0] is set to one).</csr:p>
         <csr:p></csr:p>
         <csr:p>When FIFO's are implemented and enabled, reading this register gives the data at the</csr:p>
         <csr:p>top of the transmit FIFO. Each consecutive read pops the transmit FIFO and gives the</csr:p>
         <csr:p>next data value that is currently at the top of the FIFO.</csr:p>
         <csr:p></csr:p>
         <csr:p>When FIFO's are not implemented or not enabled, reading this register gives the data</csr:p>
         <csr:p>in the THR.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_TFR_31to8</csr:identifier>
         <csr:widthMacro>UART_TFR_RSVD_TFR_31TO8_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_TFR_RSVD_TFR_31TO8_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_TFR_RSVD_TFR_31TO8_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_TFR_RSVD_TFR_31TO8_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_TFR_RSVD_TFR_31TO8_RESET</csr:resetMacro>
         <csr:maskMacro>UART_TFR_RSVD_TFR_31TO8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_TFR_RSVD_TFR_31TO8_GET</csr:getMacro>
         <csr:setMacro>UART_TFR_RSVD_TFR_31TO8_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2588</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>TFR 31to8 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.RFW</csr:referenceName>
       <csr:identifier>RFW</csr:identifier>
       <csr:addressMacro>UART_RFW_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_RFW_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_RFW_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_RFW_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2681</csr:linenumber>
       <csr:title>Receive FIFO Write</csr:title>
       <csr:offset>0x78</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_RFW</csr:typeName>
        <csr:description>
         <csr:p>This register is valid only when the DW_apb_uart is configured to have the FIFO access test mode available</csr:p>
         <csr:p>(FIFO_ACCESS = YES). If not configured, this register does not exist and reading from this register address returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RFWD</csr:identifier>
         <csr:widthMacro>UART_RFW_RFWD_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_RFW_RFWD_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_RFW_RFWD_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_RFW_RFWD_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_RFW_RFWD_RESET</csr:resetMacro>
         <csr:maskMacro>UART_RFW_RFWD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_RFW_RFWD_GET</csr:getMacro>
         <csr:setMacro>UART_RFW_RFWD_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2616</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Write Data.</csr:p>
         <csr:p></csr:p>
         <csr:p>These bits are only valid when FIFO access mode is enabled (FAR[0] is set to one).</csr:p>
         <csr:p>When FIFO's are implemented and enabled, the data that is written to the RFWD is pushed</csr:p>
         <csr:p>into the receive FIFO. Each consecutive write pushes the new data to the next write</csr:p>
         <csr:p>location in the receive FIFO.</csr:p>
         <csr:p>When FIFO's are not implemented or not enabled, the data that is written to the RFWD</csr:p>
         <csr:p>is pushed into the RBR.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RFPE</csr:identifier>
         <csr:widthMacro>UART_RFW_RFPE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_RFW_RFPE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_RFW_RFPE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_RFW_RFPE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_RFW_RFPE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_RFW_RFPE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_RFW_RFPE_GET</csr:getMacro>
         <csr:setMacro>UART_RFW_RFPE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2644</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Parity Error.</csr:p>
         <csr:p></csr:p>
         <csr:p>These bits are only valid when FIFO access mode is enabled (FAR[0] is set to one).</csr:p>
         <csr:p>When FIFO's are implemented and enabled, this bit is used to write parity error</csr:p>
         <csr:p>detection information to the receive FIFO.</csr:p>
         <csr:p>When FIFO's are not implemented or not enabled, this bit is used to write parity</csr:p>
         <csr:p>error detection information to the RBR.</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Parity error disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Parity error enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RFFE</csr:identifier>
         <csr:widthMacro>UART_RFW_RFFE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_RFW_RFFE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_RFW_RFFE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_RFW_RFFE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_RFW_RFFE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_RFW_RFFE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_RFW_RFFE_GET</csr:getMacro>
         <csr:setMacro>UART_RFW_RFFE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2672</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Framing Error.</csr:p>
         <csr:p></csr:p>
         <csr:p>These bits are only valid when FIFO access mode is enabled (FAR[0] is set to one).</csr:p>
         <csr:p>When FIFO's are implemented and enabled, this bit is used to write framing error</csr:p>
         <csr:p>detection information to the receive FIFO.</csr:p>
         <csr:p>When FIFO's are not implemented or not enabled, this bit is used to write framing</csr:p>
         <csr:p>error detection information to the RBR.</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Frame error disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Frame error enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_RFW_31to10</csr:identifier>
         <csr:widthMacro>UART_RFW_RSVD_RFW_31TO10_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_RFW_RSVD_RFW_31TO10_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_RFW_RSVD_RFW_31TO10_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_RFW_RSVD_RFW_31TO10_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_RFW_RSVD_RFW_31TO10_RESET</csr:resetMacro>
         <csr:maskMacro>UART_RFW_RSVD_RFW_31TO10_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_RFW_RSVD_RFW_31TO10_GET</csr:getMacro>
         <csr:setMacro>UART_RFW_RSVD_RFW_31TO10_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2680</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RFW 31to10 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.USR</csr:referenceName>
       <csr:identifier>USR</csr:identifier>
       <csr:addressMacro>UART_USR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_USR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_USR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_USR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2842</csr:linenumber>
       <csr:title>UART Status register</csr:title>
       <csr:offset>0x7C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000006</csr:registerResetValue>
       <csr:typeName>Uart_USR</csr:typeName>
        <csr:description>
         <csr:p>UART Status register.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RSVD_BUSY</csr:identifier>
         <csr:widthMacro>UART_USR_RSVD_BUSY_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_USR_RSVD_BUSY_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_USR_RSVD_BUSY_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_USR_RSVD_BUSY_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_USR_RSVD_BUSY_RESET</csr:resetMacro>
         <csr:maskMacro>UART_USR_RSVD_BUSY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_USR_RSVD_BUSY_GET</csr:getMacro>
         <csr:setMacro>UART_USR_RSVD_BUSY_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2742</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>UART Busy.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is only valid when UART_16550_COMPATIBLE == YES. This indicates that a serial</csr:p>
         <csr:p>transfer is in progress, when cleared indicates that the DW_apb_uart is idle or inactive.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit will be set to 1 (busy) under any of the following conditions:</csr:p>
         <csr:p></csr:p>
         <csr:p>- Transmission in progress on serial interface</csr:p>
         <csr:p></csr:p>
         <csr:p>- Transmit data present in THR, when FIFO access mode is not being used (FAR = 0) and the baud divisor is non-zero ({DLH,DLL} does not equal 0) when the divisor latch access bit is 0 (LCR.DLAB = 0)</csr:p>
         <csr:p></csr:p>
         <csr:p>- Reception in progress on the interface</csr:p>
         <csr:p></csr:p>
         <csr:p>- Receive data present in RBR, when FIFO access mode is not being used (FAR = 0)</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Note: It is possible for the UART Busy bit to be cleared even though a new</csr:p>
         <csr:p>character may have been sent from another device. That is, if the DW_apb_uart</csr:p>
         <csr:p>has no data in the THR and RBR and there is no transmission in progress and a start</csr:p>
         <csr:p>bit of a new character has just reached the DW_apb_uart. This is due to the fact</csr:p>
         <csr:p>that a valid start is not seen until the middle of the bit period and this duration</csr:p>
         <csr:p>is dependent on the baud divisor that has been programmed. If a second system clock</csr:p>
         <csr:p>has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be</csr:p>
         <csr:p>delayed by several cycles of the slower clock.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>BUSY</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>DW_apb_uart is busy (actively transferring data)</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>IDLE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>DW_apb_uart is idle or inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TFNF</csr:identifier>
         <csr:widthMacro>UART_USR_TFNF_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_USR_TFNF_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_USR_TFNF_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_USR_TFNF_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_USR_TFNF_RESET</csr:resetMacro>
         <csr:maskMacro>UART_USR_TFNF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_USR_TFNF_GET</csr:getMacro>
         <csr:setMacro>UART_USR_TFNF_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2765</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Not Full.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is only valid when FIFO_STAT == YES. This is used to indicate that the</csr:p>
         <csr:p>transmit FIFO is not full.</csr:p>
         <csr:p>This bit is cleared when the TX FIFO is full.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FULL</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Transmit FIFO is full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_FULL</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Transmit FIFO is not full</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TFE</csr:identifier>
         <csr:widthMacro>UART_USR_TFE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_USR_TFE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_USR_TFE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_USR_TFE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_USR_TFE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_USR_TFE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_USR_TFE_GET</csr:getMacro>
         <csr:setMacro>UART_USR_TFE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2788</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Empty.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is only valid when FIFO_STAT == YES. This is used to indicate that the</csr:p>
         <csr:p>transmit FIFO is completely empty.</csr:p>
         <csr:p>This bit is cleared when the TX FIFO is no longer empty.</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>EMPTY</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Transmit FIFO is empty</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_EMPTY</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Transmit FIFO is not empty</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RFNE</csr:identifier>
         <csr:widthMacro>UART_USR_RFNE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_USR_RFNE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_USR_RFNE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_USR_RFNE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_USR_RFNE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_USR_RFNE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_USR_RFNE_GET</csr:getMacro>
         <csr:setMacro>UART_USR_RFNE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2811</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Not Empty.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is only valid when FIFO_STAT == YES. This is used to indicate that the</csr:p>
         <csr:p>receive FIFO contains one or more entries.</csr:p>
         <csr:p>This bit is cleared when the RX FIFO is empty.</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>EMPTY</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Receive FIFO is empty</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_EMPTY</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Receive FIFO is not empty</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RFF</csr:identifier>
         <csr:widthMacro>UART_USR_RFF_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_USR_RFF_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_USR_RFF_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_USR_RFF_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_USR_RFF_RESET</csr:resetMacro>
         <csr:maskMacro>UART_USR_RFF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_USR_RFF_GET</csr:getMacro>
         <csr:setMacro>UART_USR_RFF_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2834</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Full.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is only valid when FIFO_STAT == YES. This is used to indicate that the</csr:p>
         <csr:p>receive FIFO is completely full. That is:</csr:p>
         <csr:p>This bit is cleared when the RX FIFO is no longer full.</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FULL</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Receive FIFO full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_FULL</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Receive FIFO not full</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_USR_31to5</csr:identifier>
         <csr:widthMacro>UART_USR_RSVD_USR_31TO5_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_USR_RSVD_USR_31TO5_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_USR_RSVD_USR_31TO5_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_USR_RSVD_USR_31TO5_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_USR_RSVD_USR_31TO5_RESET</csr:resetMacro>
         <csr:maskMacro>UART_USR_RSVD_USR_31TO5_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_USR_RSVD_USR_31TO5_GET</csr:getMacro>
         <csr:setMacro>UART_USR_RSVD_USR_31TO5_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2841</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>USR 31to5 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.TFL</csr:referenceName>
       <csr:identifier>TFL</csr:identifier>
       <csr:addressMacro>UART_TFL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_TFL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_TFL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_TFL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2870</csr:linenumber>
       <csr:title>Transmit FIFO Level</csr:title>
       <csr:offset>0x80</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_TFL</csr:typeName>
        <csr:description>
         <csr:p>TFL register is valid only when the DW_apb_uart is configured to have additional FIFO status registers</csr:p>
         <csr:p>implemented (FIFO_STAT = YES). If status registers are not implemented, this register does not exist and</csr:p>
         <csr:p>reading from this register address returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>tfl</csr:identifier>
         <csr:widthMacro>UART_TFL_TFL_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_TFL_TFL_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_TFL_TFL_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_TFL_TFL_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_TFL_TFL_RESET</csr:resetMacro>
         <csr:maskMacro>UART_TFL_TFL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_TFL_TFL_GET</csr:getMacro>
         <csr:setMacro>UART_TFL_TFL_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2862</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Level.</csr:p>
         <csr:p></csr:p>
         <csr:p>This indicates the number of data entries in the transmit FIFO.</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_TFL_31toADDR_WIDTH</csr:identifier>
         <csr:widthMacro>UART_TFL_RSVD_TFL_31TOADDR_WIDTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_TFL_RSVD_TFL_31TOADDR_WIDTH_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_TFL_RSVD_TFL_31TOADDR_WIDTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_TFL_RSVD_TFL_31TOADDR_WIDTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_TFL_RSVD_TFL_31TOADDR_WIDTH_RESET</csr:resetMacro>
         <csr:maskMacro>UART_TFL_RSVD_TFL_31TOADDR_WIDTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_TFL_RSVD_TFL_31TOADDR_WIDTH_GET</csr:getMacro>
         <csr:setMacro>UART_TFL_RSVD_TFL_31TOADDR_WIDTH_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2869</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>TFL 31 to ADDR_WIDTH Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.RFL</csr:referenceName>
       <csr:identifier>RFL</csr:identifier>
       <csr:addressMacro>UART_RFL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_RFL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_RFL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_RFL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2898</csr:linenumber>
       <csr:title>Receive FIFO Level</csr:title>
       <csr:offset>0x84</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_RFL</csr:typeName>
        <csr:description>
         <csr:p>RFL register is valid only when the DW_apb_uart is configured to have additional FIFO status registers</csr:p>
         <csr:p>implemented (FIFO_STAT = YES). If status registers are not implemented, this register does not exist and</csr:p>
         <csr:p>reading from this register address returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>rfl</csr:identifier>
         <csr:widthMacro>UART_RFL_RFL_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_RFL_RFL_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_RFL_RFL_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_RFL_RFL_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_RFL_RFL_RESET</csr:resetMacro>
         <csr:maskMacro>UART_RFL_RFL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_RFL_RFL_GET</csr:getMacro>
         <csr:setMacro>UART_RFL_RFL_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2890</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Level.</csr:p>
         <csr:p></csr:p>
         <csr:p>This indicates the number of data entries in the receive FIFO.</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_RFL_31toADDR_WIDTH</csr:identifier>
         <csr:widthMacro>UART_RFL_RSVD_RFL_31TOADDR_WIDTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_RFL_RSVD_RFL_31TOADDR_WIDTH_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_RFL_RSVD_RFL_31TOADDR_WIDTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_RFL_RSVD_RFL_31TOADDR_WIDTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_RFL_RSVD_RFL_31TOADDR_WIDTH_RESET</csr:resetMacro>
         <csr:maskMacro>UART_RFL_RSVD_RFL_31TOADDR_WIDTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_RFL_RSVD_RFL_31TOADDR_WIDTH_GET</csr:getMacro>
         <csr:setMacro>UART_RFL_RSVD_RFL_31TOADDR_WIDTH_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2897</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RFL 31 to ADDR_WIDTH Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRR</csr:referenceName>
       <csr:identifier>SRR</csr:identifier>
       <csr:addressMacro>UART_SRR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>2992</csr:linenumber>
       <csr:title>Software Reset Register</csr:title>
       <csr:offset>0x88</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRR</csr:typeName>
        <csr:description>
         <csr:p>This register is valid only when the DW_apb_uart is configured to have additional shadow registers</csr:p>
         <csr:p>implemented (SHADOW = YES). If shadow registers are not implemented, this register does not exist and</csr:p>
         <csr:p>reading from this register address returns 0.</csr:p>
         <csr:p></csr:p>
         <csr:p>For more information on the amount of time that serial clock modules need in order to see new register</csr:p>
         <csr:p>values and reset their respective state machines, refer to the 'Clock Support' subsection in the data book.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>UR</csr:identifier>
         <csr:widthMacro>UART_SRR_UR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRR_UR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRR_UR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRR_UR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRR_UR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRR_UR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRR_UR_GET</csr:getMacro>
         <csr:setMacro>UART_SRR_UR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2936</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>UART Reset.</csr:p>
         <csr:p></csr:p>
         <csr:p>This asynchronously resets the DW_apb_uart and synchronously removes the reset</csr:p>
         <csr:p>assertion. For a two clock implementation both pclk and sclk domains will be reset.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>NO_RESET</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>No Uart Reset</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>RESET</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Uart reset</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RFR</csr:identifier>
         <csr:widthMacro>UART_SRR_RFR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRR_RFR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRR_RFR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRR_RFR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRR_RFR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRR_RFR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRR_RFR_GET</csr:getMacro>
         <csr:setMacro>UART_SRR_RFR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2959</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RCVR FIFO Reset.</csr:p>
         <csr:p></csr:p>
         <csr:p>Writes will have no effect when FIFO_MODE == NONE. This is a shadow register for</csr:p>
         <csr:p>the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software</csr:p>
         <csr:p>having to store previously written FCR values (which are pretty static) just to</csr:p>
         <csr:p>reset the reeive FIFO.</csr:p>
         <csr:p>This resets the control portion of the receive FIFO and treats the FIFO as empty.</csr:p>
         <csr:p>This will also de-assert the DMA RX request and single signals when additional DMA</csr:p>
         <csr:p>handshaking signals are selected (DMA_EXTRA == YES). Note that this bit is</csr:p>
         <csr:p>'self-clearing' and it is not necessary to clear this bit.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>XFR</csr:identifier>
         <csr:widthMacro>UART_SRR_XFR_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRR_XFR_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRR_XFR_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRR_XFR_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRR_XFR_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRR_XFR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRR_XFR_GET</csr:getMacro>
         <csr:setMacro>UART_SRR_XFR_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2983</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>XMIT FIFO Reset</csr:p>
         <csr:p>.</csr:p>
         <csr:p>Writes will have no effect when FIFO_MODE == NONE. This is a shadow register for</csr:p>
         <csr:p>the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software</csr:p>
         <csr:p>having to store previously written FCR values (which are pretty static) just to</csr:p>
         <csr:p>reset the transmit FIFO.</csr:p>
         <csr:p>This resets the control portion of the transmit FIFO and treats the FIFO as empty.</csr:p>
         <csr:p>This will also de-assert the DMA TX request and single signals when additional DMA</csr:p>
         <csr:p>handshaking signals are selected (DMA_EXTRA = YES). Note that this bit is 'self-clearing'. It is not necessary to clear this</csr:p>
         <csr:p>bit.</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRR_31to3</csr:identifier>
         <csr:widthMacro>UART_SRR_RSVD_SRR_31TO3_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRR_RSVD_SRR_31TO3_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRR_RSVD_SRR_31TO3_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRR_RSVD_SRR_31TO3_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRR_RSVD_SRR_31TO3_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRR_RSVD_SRR_31TO3_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRR_RSVD_SRR_31TO3_GET</csr:getMacro>
         <csr:setMacro>UART_SRR_RSVD_SRR_31TO3_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>2991</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRR 31to3 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRTS</csr:referenceName>
       <csr:identifier>SRTS</csr:identifier>
       <csr:addressMacro>UART_SRTS_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRTS_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRTS_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRTS_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3060</csr:linenumber>
       <csr:title>Shadow Request to Send</csr:title>
       <csr:offset>0x8C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRTS</csr:typeName>
        <csr:description>
         <csr:p>SRTS register is valid only when the DW_apb_uart is configured to have additional shadow registers</csr:p>
         <csr:p>implemented (SHADOW = YES). If shadow registers are not implemented, this register does not exist and</csr:p>
         <csr:p>reading from this register address returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRTS</csr:identifier>
         <csr:widthMacro>UART_SRTS_SRTS_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRTS_SRTS_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRTS_SRTS_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRTS_SRTS_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRTS_SRTS_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRTS_SRTS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRTS_SRTS_GET</csr:getMacro>
         <csr:setMacro>UART_SRTS_SRTS_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3051</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Shadow Request to Send.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is a shadow register for the RTS bit (MCR[1]), this can be used to remove the</csr:p>
         <csr:p>burden of having to performing a read modify write on the MCR.</csr:p>
         <csr:p>This is used to directly control the Request to Send (rts_n) output. The Request</csr:p>
         <csr:p>To Send (rts_n) output is used to inform the modem or data set that the UART is ready</csr:p>
         <csr:p>to exchange data.</csr:p>
         <csr:p></csr:p>
         <csr:p>When Auto RTS Flow Control is not enabled (MCR[5] set to zero), the rts_n signal is</csr:p>
         <csr:p>set low by programming MCR[1] (RTS) to a high.</csr:p>
         <csr:p></csr:p>
         <csr:p>In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5] set to one) and FIFO's</csr:p>
         <csr:p>enable (FCR[0] set to one), the rts_n output is controlled in the same way, but is</csr:p>
         <csr:p>also gated with the receiver FIFO threshold trigger (rts_n is inactive high when</csr:p>
         <csr:p>above the threshold) only when RTC Flow Trigger is disabled; otherwise it is gated by</csr:p>
         <csr:p>the receiver FIFO almost-full trigger, where 'almost full' refers to two available</csr:p>
         <csr:p>slots in the FIFO (rts_n is inactive high when above the threshold).</csr:p>
         <csr:p></csr:p>
         <csr:p>Note that in Loopback mode (MCR[4] set to one), the rts_n output is held inactive</csr:p>
         <csr:p>high while the value of this location is internally looped back to an input.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ASSERTED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Shadow Request to Send uart_rts_n logic0</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>DEASSERTED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Shadow Request to Send uart_rts_n logic1</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRTS_31to1</csr:identifier>
         <csr:widthMacro>UART_SRTS_RSVD_SRTS_31TO1_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRTS_RSVD_SRTS_31TO1_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRTS_RSVD_SRTS_31TO1_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRTS_RSVD_SRTS_31TO1_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRTS_RSVD_SRTS_31TO1_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRTS_RSVD_SRTS_31TO1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRTS_RSVD_SRTS_31TO1_GET</csr:getMacro>
         <csr:setMacro>UART_SRTS_RSVD_SRTS_31TO1_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3059</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRTS 31to1 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SBCR</csr:referenceName>
       <csr:identifier>SBCR</csr:identifier>
       <csr:addressMacro>UART_SBCR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SBCR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SBCR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SBCR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3112</csr:linenumber>
       <csr:title>Shadow Break Control Register</csr:title>
       <csr:offset>0x90</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SBCR</csr:typeName>
        <csr:description>
         <csr:p>SBCR register is valid only when the DW_apb_uart is configured to have additional shadow registers</csr:p>
         <csr:p>implemented (SHADOW = YES). If shadow registers are not implemented, this register does not exist and</csr:p>
         <csr:p>reading from this register address returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SBCB</csr:identifier>
         <csr:widthMacro>UART_SBCR_SBCB_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SBCR_SBCB_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SBCR_SBCB_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SBCR_SBCB_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SBCR_SBCB_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SBCR_SBCB_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SBCR_SBCB_GET</csr:getMacro>
         <csr:setMacro>UART_SBCR_SBCB_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3103</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Shadow Break Control Bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is a shadow register for the Break bit (LCR[6]), this can be used to remove</csr:p>
         <csr:p>the burden of having to performing a read modify write on the LCR.</csr:p>
         <csr:p>This is used to cause a break condition to be transmitted to the receiving device.</csr:p>
         <csr:p>If set to one the serial output is forced to the spacing (logic 0) state. When not</csr:p>
         <csr:p>in Loopback Mode, as determined by MCR[4], the sout line is forced low until the</csr:p>
         <csr:p>Break bit is cleared.</csr:p>
         <csr:p> If SIR_MODE == Enabled and active (MCR[6] set to one) the</csr:p>
         <csr:p>sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition</csr:p>
         <csr:p>is internally looped back to the receiver.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>BREAK</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Serial output forced to the spacing</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NO_BREAK</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>No spacing on serial output</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SBCR_31to1</csr:identifier>
         <csr:widthMacro>UART_SBCR_RSVD_SBCR_31TO1_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SBCR_RSVD_SBCR_31TO1_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SBCR_RSVD_SBCR_31TO1_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SBCR_RSVD_SBCR_31TO1_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SBCR_RSVD_SBCR_31TO1_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SBCR_RSVD_SBCR_31TO1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SBCR_RSVD_SBCR_31TO1_GET</csr:getMacro>
         <csr:setMacro>UART_SBCR_RSVD_SBCR_31TO1_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3111</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SBCR 31to1 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SDMAM</csr:referenceName>
       <csr:identifier>SDMAM</csr:identifier>
       <csr:addressMacro>UART_SDMAM_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SDMAM_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SDMAM_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SDMAM_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3162</csr:linenumber>
       <csr:title>Shadow DMA Mode Register</csr:title>
       <csr:offset>0x94</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SDMAM</csr:typeName>
        <csr:description>
         <csr:p>This register is valid only when the DW_apb_uart is configured to have additional FIFO registers implemented (FIFO_MODE != None) and additional shadow registers implemented (SHADOW = YES). If these registers are not implemented, this register does not exist and reading from this register address returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SDMAM</csr:identifier>
         <csr:widthMacro>UART_SDMAM_SDMAM_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SDMAM_SDMAM_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SDMAM_SDMAM_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SDMAM_SDMAM_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SDMAM_SDMAM_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SDMAM_SDMAM_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SDMAM_SDMAM_GET</csr:getMacro>
         <csr:setMacro>UART_SDMAM_SDMAM_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3153</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Shadow DMA Mode.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove</csr:p>
         <csr:p>the burden of having to store the previously written value to the FCR in memory and</csr:p>
         <csr:p>having to mask this value so that only the DMA Mode bit gets updated.</csr:p>
         <csr:p>This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n</csr:p>
         <csr:p>output signals when additional DMA handshaking signals are not selected</csr:p>
         <csr:p>(DMA_EXTRA == NO). See section 5.9 on page 54 for details on DMA support.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>MODE_0</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Mode 0</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>MODE_1</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Mode 1</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SDMAM_31to1</csr:identifier>
         <csr:widthMacro>UART_SDMAM_RSVD_SDMAM_31TO1_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SDMAM_RSVD_SDMAM_31TO1_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SDMAM_RSVD_SDMAM_31TO1_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SDMAM_RSVD_SDMAM_31TO1_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SDMAM_RSVD_SDMAM_31TO1_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SDMAM_RSVD_SDMAM_31TO1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SDMAM_RSVD_SDMAM_31TO1_GET</csr:getMacro>
         <csr:setMacro>UART_SDMAM_RSVD_SDMAM_31TO1_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3161</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SDMAM 31to1 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SFE</csr:referenceName>
       <csr:identifier>SFE</csr:identifier>
       <csr:addressMacro>UART_SFE_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SFE_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SFE_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SFE_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3211</csr:linenumber>
       <csr:title>Shadow FIFO Enable Register</csr:title>
       <csr:offset>0x98</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SFE</csr:typeName>
        <csr:description>
         <csr:p>SFE register is valid only when the DW_apb_uart is configured to have additional FIFO registers</csr:p>
         <csr:p>implemented (FIFO_MODE != None) and additional shadow registers implemented (SHADOW = YES). If these registers are not implemented, this register does not exist and reading from this register address returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SFE</csr:identifier>
         <csr:widthMacro>UART_SFE_SFE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SFE_SFE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SFE_SFE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SFE_SFE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SFE_SFE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SFE_SFE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SFE_SFE_GET</csr:getMacro>
         <csr:setMacro>UART_SFE_SFE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3202</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Shadow FIFO Enable.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to</csr:p>
         <csr:p>remove the burden of having to store the previously written value to the FCR in</csr:p>
         <csr:p>memory and having to mask this value so that only the FIFO enable bit gets updated.</csr:p>
         <csr:p>This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. If this</csr:p>
         <csr:p>bit is set to zero (disabled) after being enabled then both the XMIT and RCVR</csr:p>
         <csr:p>controller portion of FIFO's will be reset.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>FIFOs are disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>FIFOs are enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SFE_31to1</csr:identifier>
         <csr:widthMacro>UART_SFE_RSVD_SFE_31TO1_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SFE_RSVD_SFE_31TO1_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SFE_RSVD_SFE_31TO1_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SFE_RSVD_SFE_31TO1_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SFE_RSVD_SFE_31TO1_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SFE_RSVD_SFE_31TO1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SFE_RSVD_SFE_31TO1_GET</csr:getMacro>
         <csr:setMacro>UART_SFE_RSVD_SFE_31TO1_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3210</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SFE 31to1 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.SRT</csr:referenceName>
       <csr:identifier>SRT</csr:identifier>
       <csr:addressMacro>UART_SRT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_SRT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_SRT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_SRT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3270</csr:linenumber>
       <csr:title>Shadow RCVR Trigger Register</csr:title>
       <csr:offset>0x9C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_SRT</csr:typeName>
        <csr:description>
         <csr:p>SRT register is valid only when the DW_apb_uart is configured to have additional FIFO registers</csr:p>
         <csr:p>implemented (FIFO_MODE != None) and additional shadow registers implemented (SHADOW = YES). If these registers are not implemented, this register does not exist and reading from this register address returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SRT</csr:identifier>
         <csr:widthMacro>UART_SRT_SRT_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRT_SRT_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRT_SRT_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRT_SRT_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRT_SRT_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRT_SRT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRT_SRT_GET</csr:getMacro>
         <csr:setMacro>UART_SRT_SRT_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3261</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Shadow RCVR Trigger.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to</csr:p>
         <csr:p>remove the burden of having to store the previously written value to the FCR in</csr:p>
         <csr:p>memory and having to mask this value so that only the RCVR trigger bit gets updated.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is used to select the trigger level in the receiver FIFO at which the Received</csr:p>
         <csr:p>Data Available Interrupt will be generated. It also determines when the dma_rx_req_n</csr:p>
         <csr:p>signal will be asserted when DMA Mode (FCR[3]) is set to one.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FIFO_CHAR_1</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>1 character in FIFO</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_FULL_2</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>FIFO 2 less than full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_HALF_FULL</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>FIFO 1/2 full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_QUARTER_FULL</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>FIFO 1/4 full</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SRT_31to2</csr:identifier>
         <csr:widthMacro>UART_SRT_RSVD_SRT_31TO2_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_SRT_RSVD_SRT_31TO2_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_SRT_RSVD_SRT_31TO2_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_SRT_RSVD_SRT_31TO2_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_SRT_RSVD_SRT_31TO2_RESET</csr:resetMacro>
         <csr:maskMacro>UART_SRT_RSVD_SRT_31TO2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_SRT_RSVD_SRT_31TO2_GET</csr:getMacro>
         <csr:setMacro>UART_SRT_RSVD_SRT_31TO2_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3269</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SRT 31to2 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.STET</csr:referenceName>
       <csr:identifier>STET</csr:identifier>
       <csr:addressMacro>UART_STET_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_STET_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_STET_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_STET_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3330</csr:linenumber>
       <csr:title>Shadow TX Empty Trigger Register</csr:title>
       <csr:offset>0xA0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_STET</csr:typeName>
        <csr:description>
         <csr:p>This register is valid only when the DW_apb_uart is configured to have FIFOs implemented</csr:p>
         <csr:p>(FIFO_MODE != NONE) and THRE interrupt support implemented (THRE_MODE_USER = Enabled) and</csr:p>
         <csr:p>additional shadow registers implemented (SHADOW = YES). If FIFOs are not implemented or THRE interrupt support is not implemented or shadow registers are not implemented, this register does not exist and reading from this register address returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>STET</csr:identifier>
         <csr:widthMacro>UART_STET_STET_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_STET_STET_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_STET_STET_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_STET_STET_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_STET_STET_RESET</csr:resetMacro>
         <csr:maskMacro>UART_STET_STET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_STET_STET_GET</csr:getMacro>
         <csr:setMacro>UART_STET_STET_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3321</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Shadow TX Empty Trigger.</csr:p>
         <csr:p></csr:p>
         <csr:p>This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used</csr:p>
         <csr:p>to remove the burden of having to store the previously written value to the FCR in</csr:p>
         <csr:p>memory and having to mask this value so that only the TX empty trigger bit gets updated.</csr:p>
         <csr:p>Writes will have no effect when THRE_MODE_USER == Disabled. This is used to select the</csr:p>
         <csr:p>empty threshold level at which the THRE Interrupts will be generated when the mode is</csr:p>
         <csr:p>active.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FIFO_CHAR_2</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>2 characters in FIFO</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_EMPTY</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>FIFO empty</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_HALF_FULL</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>FIFO 1/2 full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_QUARTER_FULL</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>FIFO 1/4 full</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_STET_31to2</csr:identifier>
         <csr:widthMacro>UART_STET_RSVD_STET_31TO2_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_STET_RSVD_STET_31TO2_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_STET_RSVD_STET_31TO2_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_STET_RSVD_STET_31TO2_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_STET_RSVD_STET_31TO2_RESET</csr:resetMacro>
         <csr:maskMacro>UART_STET_RSVD_STET_31TO2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_STET_RSVD_STET_31TO2_GET</csr:getMacro>
         <csr:setMacro>UART_STET_RSVD_STET_31TO2_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3329</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>STET 31to2 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.HTX</csr:referenceName>
       <csr:identifier>HTX</csr:identifier>
       <csr:addressMacro>UART_HTX_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_HTX_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_HTX_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_HTX_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3372</csr:linenumber>
       <csr:title>Halt TX</csr:title>
       <csr:offset>0xA4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_HTX</csr:typeName>
        <csr:description>
         <csr:p>Halt TX</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>HTX</csr:identifier>
         <csr:widthMacro>UART_HTX_HTX_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_HTX_HTX_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_HTX_HTX_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_HTX_HTX_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_HTX_HTX_RESET</csr:resetMacro>
         <csr:maskMacro>UART_HTX_HTX_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_HTX_HTX_GET</csr:getMacro>
         <csr:setMacro>UART_HTX_HTX_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3363</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Halt TX.</csr:p>
         <csr:p></csr:p>
         <csr:p>Writes will have no effect when FIFO_MODE == NONE, always readable.  This register</csr:p>
         <csr:p>is use to halt transmissions for testing, so that the transmit FIFO can be filled</csr:p>
         <csr:p>by the master when FIFO's are implemented and enabled.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note, if FIFO's are implemented and not enabled the setting of the halt TX register</csr:p>
         <csr:p>will have no effect on operation.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Halt Transmission disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Halt Transmission enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_HTX_31to1</csr:identifier>
         <csr:widthMacro>UART_HTX_RSVD_HTX_31TO1_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_HTX_RSVD_HTX_31TO1_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_HTX_RSVD_HTX_31TO1_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_HTX_RSVD_HTX_31TO1_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_HTX_RSVD_HTX_31TO1_RESET</csr:resetMacro>
         <csr:maskMacro>UART_HTX_RSVD_HTX_31TO1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_HTX_RSVD_HTX_31TO1_GET</csr:getMacro>
         <csr:setMacro>UART_HTX_RSVD_HTX_31TO1_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3371</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>HTX 31to1 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.DMASA</csr:referenceName>
       <csr:identifier>DMASA</csr:identifier>
       <csr:addressMacro>UART_DMASA_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_DMASA_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_DMASA_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_DMASA_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3412</csr:linenumber>
       <csr:title>DMA Software Acknowledge Register</csr:title>
       <csr:offset>0xA8</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_DMASA</csr:typeName>
        <csr:description>
         <csr:p>DMA Software Acknowledge Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DMASA</csr:identifier>
         <csr:widthMacro>UART_DMASA_DMASA_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_DMASA_DMASA_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_DMASA_DMASA_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_DMASA_DMASA_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_DMASA_DMASA_RESET</csr:resetMacro>
         <csr:maskMacro>UART_DMASA_DMASA_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_DMASA_DMASA_GET</csr:getMacro>
         <csr:setMacro>UART_DMASA_DMASA_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3404</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DMA Software Acknowledge.</csr:p>
         <csr:p></csr:p>
         <csr:p>Writes will have no effect when DMA_EXTRA == No.  This register is use to perform</csr:p>
         <csr:p>DMA software acknowledge if a transfer needs to be terminated due to an error</csr:p>
         <csr:p>condition. For example, if the DMA disables the channel, then the DW_apb_uart should</csr:p>
         <csr:p>clear its request. This will cause the TX request, TX single, RX request and RX</csr:p>
         <csr:p>single signals to de-assert.</csr:p>
         <csr:p>Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>SOFT_ACK</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>DMA software acknowledge</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_DMASA_31to1</csr:identifier>
         <csr:widthMacro>UART_DMASA_RSVD_DMASA_31TO1_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_DMASA_RSVD_DMASA_31TO1_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_DMASA_RSVD_DMASA_31TO1_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_DMASA_RSVD_DMASA_31TO1_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_DMASA_RSVD_DMASA_31TO1_RESET</csr:resetMacro>
         <csr:maskMacro>UART_DMASA_RSVD_DMASA_31TO1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_DMASA_RSVD_DMASA_31TO1_GET</csr:getMacro>
         <csr:setMacro>UART_DMASA_RSVD_DMASA_31TO1_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3411</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DMASA 31to1 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.DLF</csr:referenceName>
       <csr:identifier>DLF</csr:identifier>
       <csr:addressMacro>UART_DLF_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_DLF_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_DLF_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_DLF_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3443</csr:linenumber>
       <csr:title>Divisor Latch Fraction Register</csr:title>
       <csr:offset>0xC0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Uart_DLF</csr:typeName>
        <csr:description>
         <csr:p>This register is only valid when the DW_apb_uart is configured to have Fractional Baud rate Divisor implemented (FRACTIONAL_BAUD_DIVISOR_EN = ENABLED). If Fractional Baud rate divisor is not implemented, this register does not exist and reading from this register address will return zero.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DLF</csr:identifier>
         <csr:widthMacro>UART_DLF_DLF_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_DLF_DLF_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_DLF_DLF_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_DLF_DLF_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_DLF_DLF_RESET</csr:resetMacro>
         <csr:maskMacro>UART_DLF_DLF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_DLF_DLF_GET</csr:getMacro>
         <csr:setMacro>UART_DLF_DLF_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3434</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Fractional part of divisor.</csr:p>
         <csr:p> The fractional value is added to integer value set by DLH, DLL. Fractional value is determined by (Divisor Fraction value)/(2^DLF_SIZE). For information on DLF</csr:p>
         <csr:p>values to be programmed for DLF_SIZE=4, see the 'Fractional Baud Rate Support' section in the DW_apb_uart Databook.</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_DLF</csr:identifier>
         <csr:widthMacro>UART_DLF_RSVD_DLF_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_DLF_RSVD_DLF_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_DLF_RSVD_DLF_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_DLF_RSVD_DLF_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_DLF_RSVD_DLF_RESET</csr:resetMacro>
         <csr:maskMacro>UART_DLF_RSVD_DLF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_DLF_RSVD_DLF_GET</csr:getMacro>
         <csr:setMacro>UART_DLF_RSVD_DLF_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3442</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DLF 31 to DLF_SIZE Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.REG_TIMEOUT_RST</csr:referenceName>
       <csr:identifier>REG_TIMEOUT_RST</csr:identifier>
       <csr:addressMacro>UART_REG_TIMEOUT_RST_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_REG_TIMEOUT_RST_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_REG_TIMEOUT_RST_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_REG_TIMEOUT_RST_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3476</csr:linenumber>
       <csr:title>Register timeout counter reset value</csr:title>
       <csr:offset>0xD4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000008</csr:registerResetValue>
       <csr:typeName>Uart_REG_TIMEOUT_RST</csr:typeName>
        <csr:description>
         <csr:p>Name: Register timeout counter reset register</csr:p>
         <csr:p>This register keeps the reset value of reg_timer counter register.</csr:p>
         <csr:p>The reset value of the register is REG_TIMEOUT_DEFAULT</csr:p>
         <csr:p>The default reset value can be further modified if HC_REG_TIMEOUT_VALUE = 0.</csr:p>
         <csr:p>The final programmed value (or the default reset value if not programmed)</csr:p>
         <csr:p>determines what value the reg_timeout counter register starts counting down </csr:p>
         <csr:p>from. A zero on the counter will break the hung transaction with PSLVERR high</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>REG_TIMEOUT_RST</csr:identifier>
         <csr:widthMacro>UART_REG_TIMEOUT_RST_REG_TIMEOUT_RST_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_REG_TIMEOUT_RST_REG_TIMEOUT_RST_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_REG_TIMEOUT_RST_REG_TIMEOUT_RST_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_REG_TIMEOUT_RST_REG_TIMEOUT_RST_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_REG_TIMEOUT_RST_REG_TIMEOUT_RST_RESET</csr:resetMacro>
         <csr:maskMacro>UART_REG_TIMEOUT_RST_REG_TIMEOUT_RST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_REG_TIMEOUT_RST_REG_TIMEOUT_RST_GET</csr:getMacro>
         <csr:setMacro>UART_REG_TIMEOUT_RST_REG_TIMEOUT_RST_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3467</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field holds reset value of REG_TIMEOUT counter register.</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x8</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_REG_TIMEOUT_RST</csr:identifier>
         <csr:widthMacro>UART_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_RESET</csr:resetMacro>
         <csr:maskMacro>UART_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_GET</csr:getMacro>
         <csr:setMacro>UART_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3475</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.CPR</csr:referenceName>
       <csr:identifier>CPR</csr:identifier>
       <csr:addressMacro>UART_CPR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_CPR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_CPR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_CPR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3757</csr:linenumber>
       <csr:title>Component Parameter Register</csr:title>
       <csr:offset>0xF4</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00041f22</csr:registerResetValue>
       <csr:typeName>Uart_CPR</csr:typeName>
        <csr:description>
         <csr:p>Component Parameter Register.This register is valid only when UART_ADD_ENCODED_PARAMS = 1. If the UART_ADD_ENCODED_PARAMS parameter is not set, this register does not exist and reading from this register address returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>APB_DATA_WIDTH</csr:identifier>
         <csr:widthMacro>UART_CPR_APB_DATA_WIDTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_APB_DATA_WIDTH_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_APB_DATA_WIDTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_APB_DATA_WIDTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_APB_DATA_WIDTH_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_APB_DATA_WIDTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_APB_DATA_WIDTH_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_APB_DATA_WIDTH_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3507</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Encoding of APB_DATA_WIDTH configuration parameter value.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x2</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>APB_16BITS</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>APB data width is 16 bits</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>APB_32BITS</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>APB data width is 32 bits</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>APB_8BITS</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>APB data width is 8 bits</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CPR_3to2</csr:identifier>
         <csr:widthMacro>UART_CPR_RSVD_CPR_3TO2_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_RSVD_CPR_3TO2_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_RSVD_CPR_3TO2_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_RSVD_CPR_3TO2_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_RSVD_CPR_3TO2_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_RSVD_CPR_3TO2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_RSVD_CPR_3TO2_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_RSVD_CPR_3TO2_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3514</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CPR 3to2 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>AFCE_MODE</csr:identifier>
         <csr:widthMacro>UART_CPR_AFCE_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_AFCE_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_AFCE_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_AFCE_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_AFCE_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_AFCE_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_AFCE_MODE_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_AFCE_MODE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3532</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Encoding of AFCE_MODE configuration parameter value.</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>AFCE mode disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>AFCE mode enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>THRE_MODE</csr:identifier>
         <csr:widthMacro>UART_CPR_THRE_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_THRE_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_THRE_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_THRE_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_THRE_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_THRE_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_THRE_MODE_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_THRE_MODE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3550</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Encoding of THRE_MODE configuration parameter value.</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>THRE mode disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>THRE mode enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SIR_MODE</csr:identifier>
         <csr:widthMacro>UART_CPR_SIR_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_SIR_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_SIR_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_SIR_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_SIR_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_SIR_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_SIR_MODE_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_SIR_MODE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3568</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Encoding of SIR_MODE configuration parameter value.</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>SIR mode disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>SIR mode enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SIR_LP_MODE</csr:identifier>
         <csr:widthMacro>UART_CPR_SIR_LP_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_SIR_LP_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_SIR_LP_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_SIR_LP_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_SIR_LP_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_SIR_LP_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_SIR_LP_MODE_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_SIR_LP_MODE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3586</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Encoding of SIR_LP_MODE configuration parameter value.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>SIR_LP mode disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>SIR_LP mode enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ADDITIONAL_FEAT</csr:identifier>
         <csr:widthMacro>UART_CPR_ADDITIONAL_FEAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_ADDITIONAL_FEAT_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_ADDITIONAL_FEAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_ADDITIONAL_FEAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_ADDITIONAL_FEAT_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_ADDITIONAL_FEAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_ADDITIONAL_FEAT_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_ADDITIONAL_FEAT_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3605</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Encoding of ADDITIONAL_FEATURES configuration parameter value.</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Additional features disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Additional features enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>FIFO_ACCESS</csr:identifier>
         <csr:widthMacro>UART_CPR_FIFO_ACCESS_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_FIFO_ACCESS_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_FIFO_ACCESS_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_FIFO_ACCESS_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_FIFO_ACCESS_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_FIFO_ACCESS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_FIFO_ACCESS_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_FIFO_ACCESS_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3623</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Encoding of FIFO_ACCESS configuration parameter value.</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>FIFO_ACCESS disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>FIFO ACCESS enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>FIFO_STAT</csr:identifier>
         <csr:widthMacro>UART_CPR_FIFO_STAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_FIFO_STAT_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_FIFO_STAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_FIFO_STAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_FIFO_STAT_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_FIFO_STAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_FIFO_STAT_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_FIFO_STAT_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3641</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Encoding of FIFO_STAT configuration parameter value.</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>FIFO_STAT disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>FIFO_STAT enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SHADOW</csr:identifier>
         <csr:widthMacro>UART_CPR_SHADOW_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_SHADOW_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_SHADOW_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_SHADOW_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_SHADOW_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_SHADOW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_SHADOW_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_SHADOW_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3659</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Encoding of SHADOW configuration parameter value.</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>SHADOW disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>SHADOW enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>UART_ADD_ENCODED_PARAMS</csr:identifier>
         <csr:widthMacro>UART_CPR_UART_ADD_ENCODED_PARAMS_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_UART_ADD_ENCODED_PARAMS_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_UART_ADD_ENCODED_PARAMS_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_UART_ADD_ENCODED_PARAMS_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_UART_ADD_ENCODED_PARAMS_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_UART_ADD_ENCODED_PARAMS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_UART_ADD_ENCODED_PARAMS_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_UART_ADD_ENCODED_PARAMS_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3678</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Encoding of UART_ADD_ENCODED_PARAMS configuration parameter value.</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>UART_ADD_ENCODED_PARAMS disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>UART_ADD_ENCODED_PARAMS enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DMA_EXTRA</csr:identifier>
         <csr:widthMacro>UART_CPR_DMA_EXTRA_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_DMA_EXTRA_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_DMA_EXTRA_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_DMA_EXTRA_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_DMA_EXTRA_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_DMA_EXTRA_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_DMA_EXTRA_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_DMA_EXTRA_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3696</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Encoding of DMA_EXTRA configuration parameter value.</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>DMA_EXTRA disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>DMA_EXTRA enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CPR_15to14</csr:identifier>
         <csr:widthMacro>UART_CPR_RSVD_CPR_15TO14_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_RSVD_CPR_15TO14_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_RSVD_CPR_15TO14_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_RSVD_CPR_15TO14_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_RSVD_CPR_15TO14_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_RSVD_CPR_15TO14_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_RSVD_CPR_15TO14_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_RSVD_CPR_15TO14_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3703</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CPR 15to14 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>FIFO_MODE</csr:identifier>
         <csr:widthMacro>UART_CPR_FIFO_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_FIFO_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_FIFO_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_FIFO_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_FIFO_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_FIFO_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_FIFO_MODE_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_FIFO_MODE_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3749</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Encoding of FIFO_MODE configuration parameter value.</csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x04</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FIFO_MODE_0</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>FIFO mode is 0</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_MODE_1024</csr:identifier>
           <csr:value>0x40</csr:value>
           <csr:title>FIFO mode is 1024</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_MODE_128</csr:identifier>
           <csr:value>0x8</csr:value>
           <csr:title>FIFO mode is 128</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_MODE_16</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>FIFO mode is 16</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_MODE_2048</csr:identifier>
           <csr:value>0x80</csr:value>
           <csr:title>FIFO mode is 2048</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_MODE_256</csr:identifier>
           <csr:value>0x10</csr:value>
           <csr:title>FIFO mode is 256</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_MODE_32</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>FIFO mode is 32</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_MODE_512</csr:identifier>
           <csr:value>0x20</csr:value>
           <csr:title>FIFO mode is 512</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>FIFO_MODE_64</csr:identifier>
           <csr:value>0x4</csr:value>
           <csr:title>FIFO mode is 64</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CPR_31to24</csr:identifier>
         <csr:widthMacro>UART_CPR_RSVD_CPR_31TO24_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CPR_RSVD_CPR_31TO24_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CPR_RSVD_CPR_31TO24_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CPR_RSVD_CPR_31TO24_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CPR_RSVD_CPR_31TO24_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CPR_RSVD_CPR_31TO24_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CPR_RSVD_CPR_31TO24_GET</csr:getMacro>
         <csr:setMacro>UART_CPR_RSVD_CPR_31TO24_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3756</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CPR 31to24 Reserved bits read as 0.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.UCV</csr:referenceName>
       <csr:identifier>UCV</csr:identifier>
       <csr:addressMacro>UART_UCV_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_UCV_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_UCV_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_UCV_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3776</csr:linenumber>
       <csr:title>UART Component Version</csr:title>
       <csr:offset>0xF8</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x3430322a</csr:registerResetValue>
       <csr:typeName>Uart_UCV</csr:typeName>
        <csr:description>
         <csr:p>UCV register is valid only when the DW_apb_uart is configured to have additional features implemented (ADDITIONAL_FEATURES = YES). If additional features are not implemented, this register does not exist and reading from this register address returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>UART_Component_Version</csr:identifier>
         <csr:widthMacro>UART_UCV_UART_COMPONENT_VERSION_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_UCV_UART_COMPONENT_VERSION_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_UCV_UART_COMPONENT_VERSION_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_UCV_UART_COMPONENT_VERSION_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_UCV_UART_COMPONENT_VERSION_RESET</csr:resetMacro>
         <csr:maskMacro>UART_UCV_UART_COMPONENT_VERSION_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_UCV_UART_COMPONENT_VERSION_GET</csr:getMacro>
         <csr:setMacro>UART_UCV_UART_COMPONENT_VERSION_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3775</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ASCII value for each number in the version, followed by *. </csr:p>
         <csr:p>For example 32_30_31_2A represents the version 2.01*</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x3430322a</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>uart.CTR</csr:referenceName>
       <csr:identifier>CTR</csr:identifier>
       <csr:addressMacro>UART_CTR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>UART_CTR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>UART_CTR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>UART_CTR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_uart.csr</csr:filename>
       <csr:linenumber>3795</csr:linenumber>
       <csr:title>Component Type Register</csr:title>
       <csr:offset>0xFC</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x44570110</csr:registerResetValue>
       <csr:typeName>Uart_CTR</csr:typeName>
        <csr:description>
         <csr:p>CTR is register is valid only when the DW_apb_uart is configured to have additional features implemented (ADDITIONAL_FEATURES = YES). If additional features are not implemented, this register does not exist and reading from this register address returns 0.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>Peripheral_ID</csr:identifier>
         <csr:widthMacro>UART_CTR_PERIPHERAL_ID_WIDTH</csr:widthMacro>
         <csr:msbMacro>UART_CTR_PERIPHERAL_ID_MSB</csr:msbMacro>
         <csr:lsbMacro>UART_CTR_PERIPHERAL_ID_LSB</csr:lsbMacro>
         <csr:rangeMacro>UART_CTR_PERIPHERAL_ID_RANGE</csr:rangeMacro>
         <csr:resetMacro>UART_CTR_PERIPHERAL_ID_RESET</csr:resetMacro>
         <csr:maskMacro>UART_CTR_PERIPHERAL_ID_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>UART_CTR_PERIPHERAL_ID_GET</csr:getMacro>
         <csr:setMacro>UART_CTR_PERIPHERAL_ID_SET</csr:setMacro>
         <csr:filename>DW_apb_uart.csr</csr:filename>
         <csr:linenumber>3794</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This register contains the peripherals identification code.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x44570110</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
     </csr:definitions>
    </csr:csrObject>
   </csr:csrData>
  </xml>
  <div id="docheader">
   <h2>Addressmap Information for 'DW_apb_uart'</h2>
   <table id="optiontable" border="1" cellpadding="1">
    <tr>
     <td>
      <div id="globalFileInfoCheckBoxDiv">
       <label for="globalFileInfoCheckBox">Input File Information</label>
       <input id="globalFileInfoCheckBox" type="checkbox" onclick="globalFileInfoCheckBox_click();"/>
      </div>
     </td>
     <td>
      <div id="globalHeaderFileInfoCheckBoxDiv">
       <label for="globalHeaderFileInfoCheckBox">Header File Information</label>
       <input id="globalHeaderFileInfoCheckBox" type="checkbox" onclick="globalHeaderFileInfoCheckBox_click();"/>
      </div>
     </td>
     <td>
      <div id="globalEnumInfoCheckBoxDiv">
       <label for="globalEnumInfoCheckBox">Enum Information</label>
       <input id="globalEnumInfoCheckBox" type="checkbox" onclick="globalEnumInfoCheckBox_click();"/>
      </div>
     </td>
    </tr>
   </table>
  </div>
  <div id="docinfo"></div>
  <div id="docroot"></div>
  <div id="docfooter"></div>
 </body>
</html>
