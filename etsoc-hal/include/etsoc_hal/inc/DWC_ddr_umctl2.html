<!--                                                                      -->
<!--                                                                      -->
<!-- Generated by Semifore, Inc. csrCompile                               -->
<!--    HTML output                                                       -->
<html>
 <head>
  <title>Addressmap Information for 'DWC_ddr_umctl2'</title>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
  <meta http-equiv="Expires" content="0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
   /*
    * Copyright (c) SEMIFORE, INC. 2006-2015. All rights reserved.
    *
    * This software and documentation constitute an unpublished work and
    * contain valuable trade secrets and proprietary information belonging
    * to Semifore, Inc.  None of the foregoing material may be copied,
    * duplicated or disclosed without the express written permission of
    * Semifore, Inc.
    * SEMIFORE, INC. EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING
    * THIS SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF
    * MERCHANTABILITY AND/OR FITNESS FOR ANY PARTICULAR PURPOSE,
    * AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY THAT
    * MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
    * TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT
    * TO THE USE OF THE SOFTWARE OR DOCUMENTATION.
    * Under no circumstances shall Semifore, Inc. be liable for incidental,
    * special, indirect, direct or consequential damages or loss of profits,
    * interruption of business, or related expenses which may arise from use
    * of this software or documentation, including but not limited to those
    * resulting from defects in software and/or documentation, or loss or
    * inaccuracy of data of any kind.
   */
   
   /*
    * csrStyles.css
    *
    * $Revision: 1.20 $
    * $Date: 2015/09/06 01:23:08 $
    *
    * @(#)$Id: csrStyles.css,v 1.20 2015/09/06 01:23:08 weber Exp $
    *
    * These are the CSS Styles attributes for the HTML pages
    *
   */
   
   body {
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   	margin: 0px;
           text-align: left;
           padding: 0px;
   	color: #4f6b72;
   	background-color: #e7e7e7;
   }
   
   a {
   	color: #c75f3e;
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   
   
   
   }
   
   div {
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   }
   
   table {
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   	background-color: #fff;
   
   
   	border-collapse: collapse;
   	margin-top: 2px;
   	margin-bottom: 2px;
   }
   
   
   th {
   	font: bold 7pt  Arial, Helvetica, sans-serif;
   	color: #4f6b72;
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   
   	letter-spacing: 1px;
   	text-align: left;
   	padding: 6px 6px 6px 12px;
   	background-color: #CAE8EA;
   }
   
   th.component {
           background-color: #FFCCFF;
   }
   
   th.addressmap {
           background-color: #CAE8EA;
   }
   
   th.register {
   	background-color: #CCFFCC;
   }
   
   th.group {
   	background-color: #FFFFCC;
   }
   
   th.union {
   	background-color: #CCCC00;
   }
   
   th.wideregister {
   	background-color: #FFCCCC;
   }
   
   th.memory {
   	background-color: #CCCCFF;
   }
   
   th.widememory {
   	background-color: #FF88FF;
   }
   
   th.submemory {
   	background-color: #CCCCFF;
   }
   
   th.field {
   	background-color: #CCFFFF;
   }
   
   
   td {
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   	background-color: #fff;
   	padding: 6px 6px 6px 12px;
   	color: #4f6b72;
   	text-align: left;
   }
   
   td.noborder {
   	border-right: 0px none #C1DAD7;
   	border-left: 0px none #C1DAD7;
   	border-bottom: 0px none #C1DAD7;
   	border-top: 0px none #C1DAD7;
   	background-color: #FFF;
   	text-align: left;
   }
   
   .addrMapClass
   {
   }
   
   
   .addrMapContent
   {
   }
   
   .frdiv {
   	float: right;
   }
   
   .fldiv {
   	float: left;
   	margin-right: 10px;
   }
   
   .window 
   {
     background-color: white; 
     border-color:  #7BA7E1;
     border-style: solid; 
     border-width: 1px;
     margin: 0px;
     padding: 0px;
     position: absolute;
     visibility: hidden;
   }
   
   .windowTitleBar 
   {
     background-color: #7BA7E1;
     border-style: none;
     color: white;
     font: bold 11pt auto  Arial, Helvetica, sans-serif;	
     margin-left: 6px;
     margin-right: 6px;
   }
   
   .windowList 
   {
     background-color: white;
     border-style: none; 
     border-width: 0px;
     margin: 0px;
     padding: 2px;
     position: absolute;
     left: 10px;
     top: 100px;
     width: 100px;
     height: 200px;
     visibility: hidden;
   }
   
   .windowListArea 
   {
     background-color: white;
     border-style: none; 
     border-width: 0px;
     text-align: center;
     margin: 0px 0px 0px 0px;
     overflow: auto;
     
   }
  </style>
  <script type="text/javascript">
   /*
    * Copyright (c) SEMIFORE, INC. 2006-2018. All rights reserved.
    *
    * This software and documentation constitute an unpublished work and
    * contain valuable trade secrets and proprietary information belonging
    * to Semifore, Inc.  None of the foregoing material may be copied,
    * duplicated or disclosed without the express written permission of
    * Semifore, Inc.
    * SEMIFORE, INC. EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING
    * THIS SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF
    * MERCHANTABILITY AND/OR FITNESS FOR ANY PARTICULAR PURPOSE,
    * AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY THAT
    * MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
    * TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT
    * TO THE USE OF THE SOFTWARE OR DOCUMENTATION.
    * Under no circumstances shall Semifore, Inc. be liable for incidental,
    * special, indirect, direct or consequential damages or loss of profits,
    * interruption of business, or related expenses which may arise from use
    * of this software or documentation, including but not limited to those
    * resulting from defects in software and/or documentation, or loss or
    * inaccuracy of data of any kind.
   */
   
   /*
    * csrJava.js
    *
    * $Revision: 1.75 $
    * $Date: 2018/02/22 02:35:02 $
    *
    * @(#)$Id: csrJava.js,v 1.75 2018/02/22 02:35:02 weber Exp $
    *
    * These are the Java Script functions for the HTML pages.
    *
   */
   
   var xmlDoc                   = 0;
   var debug                    = 0;
   var def_lookup_table         = new Array();
   var object_array             = new Array();
   var topDefinition_array      = new Array();
   var topObjectRefNames_array  = new Array();
   var definitions_array        = new Array();
   var csrNode_array            = new Array();
   var globalShowFileInfo       = false;
   var globalShowHeaderFileInfo = false;
   var globalShowEnumInfo       = false;
   var fileInfoDiv              = null;
   
   function csrNode() {
     this.referenceType = 0;
     this.referenceName = 0;
     this.definitionPtr = 0;
     this.objectIndex   = 0;
     this.divParent     = 0;
     this.divChild      = 0;
     this.visibility    = 0;
     this.addressMapWindow = 0;
     
     this.click = function() {
       if ( this.visibility == 0 )
       {
         //      alert('open ' + this.referenceName);
         printDefinition(this);
         this.visibility = 1;
         
         // window.location.hash = this.referenceName + 'Link';
         // if (mouseposy > 700 ) scrollBy(0,100);
       } else
       {
         //      alert('close' +  this.referenceName);
         this.divParent.removeChild(this.divChild);
         this.visibility = 0;
   
         //window.location.hash = this.referenceName + 'Link';
         
       }
     }
   
     this.expand = function() {
       if ( this.visibility == 0 )
       this.click();
     }
   
     this.collapse = function() {
       if (this.visibility == 1 )
       this.click();
     }
   
     this.showFileInfo = function () {
        return globalShowFileInfo;
     }
   
     this.showHeaderFileInfo = function () {
        return globalShowHeaderFileInfo;
     }
   
     this.showEnumInfo = function () {
        return globalShowEnumInfo;
     }
   }
   
   //debug alrets
   function alertd( msg ) 
   {
     if (debug) 
       alert(msg);
   }
   
   var mouseposx = 0;
   var mouseposy = 0;
   
   function getMousePos(e) {
     
   	if (!e) var e = window.event;
   	
   	if (e.pageX || e.pageY) 	{
   		mouseposx = e.pageX;
   		mouseposy = e.pageY;
   	}
   	else if (e.clientX || e.clientY) 	{
   		mouseposx = e.clientX + document.body.scrollLeft
   			+ document.documentElement.scrollLeft;
   		mouseposy = e.clientY + document.body.scrollTop
   			+ document.documentElement.scrollTop;
   	}
   }
   
   function redrawAll ()
   {
      var topObject;
   
      for (var i=0; i < topObjectRefNames_array.length; i++) {
         topObject = csrNodeLookup(i,topObjectRefNames_array[i]);
         if (topObject != null) {
            topObject.click();
            topObject.click();
         }
      }
   }
   
   function globalFileInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalFileInfoCheckBox');
   
      if (checkbox != null) {
         globalShowFileInfo = checkbox.checked;
   
         if (globalShowFileInfo) {
            printFileInfo();
         }
         else {
            var docinfo = document.getElementById('docinfo');
            if ((docinfo != null) && (fileInfoDiv != null)) {
               docinfo.removeChild(fileInfoDiv);
            }
         }
         redrawAll();
      }
   }
   
   function globalHeaderFileInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalHeaderFileInfoCheckBox');
   
      if (checkbox != null) {
         globalShowHeaderFileInfo = checkbox.checked;
         redrawAll();
      }
   }
   
   function globalEnumInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalEnumInfoCheckBox');
   
      if (checkbox != null) {
         globalShowEnumInfo = checkbox.checked;
         redrawAll();
      }
   }
   
   //import XML
   function importXML(xmlId)
   {
      xmlDoc = document.getElementById(xmlId);
      if (xmlDoc) {
         init();
      }
   }
   
   
   //parser helpers
   function getNodes_tag(node, tag)
   {
      return node.getElementsByTagName('csr:' + tag);
   }
   
   function getNodeValue_tag(node, tag)
   {
      var nodelist;
   
      nodelist = node.getElementsByTagName('csr:' + tag);
      if (nodelist.length > 0) {
         if (nodelist[0].firstChild) {
            return nodelist[0].firstChild.nodeValue;
         }
         else {
            return '';
         }
      }
      else {
         return '';
      }
   }
   
   function getNodeValue(node)
   {
     for (var i=0; node[0].childNodes.length; i++ )
       {
         
         if (node[0].childNodes[i].nodeType != 1) continue;
         return node[0].childNodes[i].firstChild.nodeValue
   
       }
   }
   
   function getNodeValue_description(node) 
   {
     var description = getNodes_tag(node,'description');
   
     if (description.length < 1)
       return '';
   
     var ptags = getNodes_tag(description[0],'p');
     var ret_string = '';
     
     for (var i=0; i < ptags.length; i++) {
        if (ptags[i].firstChild) {
           ret_string += '<p>' + ptags[i].firstChild.nodeValue + '</p>';
        }
        else {
           ret_string += '<p></p>';
        }
     }
     
     return ret_string;
   }
   
   function getNodeValue_attributes(node)
   {
      var attributesTag = getNodes_tag(node,'attributes');
   
      if (attributesTag.length < 1)
         return '';
      var attributeTags = getNodes_tag(attributesTag[0],'attribute');
      var result = '';
      var i;
   
      for (i=0; i < attributeTags.length; i++) {
         if (attributeTags[i].firstChild) {
            result += attributeTags[i].firstChild.nodeValue + '<br>';
         }
      }
   
      return result;
   }
   
   function getNodeValue_fieldAttributes(node)
   {
      var attributesTag = getNodes_tag(node,'fieldAttributes');
   
      if (attributesTag.length < 1)
         return '';
      var attributeTags = getNodes_tag(attributesTag[0],'attribute');
      var result = '';
      var i;
   
      for (i=0; i < attributeTags.length; i++) {
         if (attributeTags[i].firstChild) {
            result += attributeTags[i].firstChild.nodeValue + '<br>';
         }
      }
   
      return result;
   }
   
   function init() 
   {
     setGlobals();
   
     if (globalShowFileInfo) {
        printFileInfo();
     }
     
     printTopObjects();
     
   }
   
   function printHeader() 
   {
     header = document.getElementById('docheader');
     //header.innerHTML = "Header Text Goes Here";
   }
   
   
   function printFooter() 
   {
     footer = document.getElementById('docfooter');
     //footer.innerHTML = "Footer Text Goes Here";
   }
   
   
   function setGlobals() 
   {
     var checkbox;
   
     alertd(xmlDoc);
   
     checkbox = document.getElementById('globalFileInfoCheckBox');
     if (checkbox != null) {
        globalShowFileInfo = checkbox.checked;
     }
     checkbox = document.getElementById('globalHeaderFileInfoCheckBox');
     if (checkbox != null) {
        globalShowHeaderFileInfo = checkbox.checked;
     }
     checkbox = document.getElementById('globalEnumInfoCheckBox');
     if (checkbox != null) {
        globalShowEnumInfo = checkbox.checked;
     }
   
     // get the object elements
     object_array = getNodes_tag(xmlDoc,'csrObject');
     alertd('number of object_array elements=' + object_array.length);
   
     // create 2D lookup table array
     for (var i=0; i < object_array.length; i++)
       {
         def_lookup_table[i] = new Object();
         csrNode_array[i] = new Object();
       }
   
     // get the top definition elements
     for (var i=0; i < object_array.length; i++ )
       {
         topDefinition_array[i] = getNodes_tag(object_array[i],'topDefinition'); 
       }
     alertd('number of topDefinition_array elements=' + topDefinition_array.length);
   
     // get the referenece names of the top level modules
     for (var i=0; i < topDefinition_array.length; i++)
       {
         topObjectRefNames_array[i] = getNodeValue(topDefinition_array[i]);
         alertd('topObjectRefNames_array[' + i + ']=' + topObjectRefNames_array[i]);
       }
     
      
     // get definition elements
     for (var i=0; i < object_array.length; i++) 
       {
         definitions_array[i] = getNodes_tag(object_array[i],'definition');
       }
     alertd('number of definitions_array element=' + definitions_array.length);
     //alertd('definitions_array[0] =' + definitions_array[0].length + ' elements');
   
     // populate the definitions lookup table
     for ( var i=0; i < object_array.length; i++) 
       {
         for (var j=0; j < definitions_array[i].length; j++)
   	{
   	  referenceName = getNodeValue_tag(definitions_array[i][j], "referenceName");
   	  referenceType = getNodeValue_tag(definitions_array[i][j], "referenceType");
   	  def_lookup_table[i][referenceName] = definitions_array[i][j];
   	  
   	  var csrNode_obj = new csrNode();
   
   	  csrNode_obj.referenceName = referenceName;
   	  csrNode_obj.referenceType = referenceType;
   	  csrNode_obj.definitionPtr = definitions_array[i][j];
   	  csrNode_obj.objectIndex   = i;
   	  
   	  csrNode_array[i][referenceName] = csrNode_obj;
   	}
       
       }
   }
   
   
   function printFileInfo()
   {
      var docinfo = document.getElementById('docinfo');
   
      if (docinfo != null) {
         var inputFilesNodes = getNodes_tag(xmlDoc,'inputFiles');
         var includedFilesNodes = getNodes_tag(xmlDoc,'includedFiles');
         var configurationFilesNodes = getNodes_tag(xmlDoc,'configurationFiles');
         var fileNodes;
         var filename;
         var fileversionNodes;
         var table;
         var body;
         var row;
         var cell;
   
         fileInfoDiv = document.createElement('DIV');
   
         if (inputFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Input Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(inputFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         if (includedFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Included Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(includedFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         if (configurationFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Configuration Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(configurationFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         docinfo.appendChild(fileInfoDiv);
      }
   }
   
   function printTopObjects()
   {
     var csrNode;
     //print top level modules
     for ( var i=0; i < topObjectRefNames_array.length; i++)
       {
         csrNode = csrNodeLookup(i,topObjectRefNames_array[i]);
         if (csrNode.referenceType == 'component') {
            printTopComponentTable(csrNode);
         }
         else {
            printTopAddressmapTable(csrNode);
         }
         csrNode.expand();
       }
   }
   
   function csrNodeLookup(objectIndex, referenceName)
   {
      return csrNode_array[objectIndex][referenceName];
   }
   
   function printDefinition(csrNode)
   {
     
     referenceType = csrNode.referenceType;
   
     //case  
     switch (referenceType) 
       {
       case "component":
         printComponentDefinition(csrNode);
         break;
       case "addressmap":
         printAddressmapDefinition(csrNode);
         break;
       case "group":
         printGroupDefinition(csrNode);
         break;
       case "union":
         printUnionDefinition(csrNode);
         break;
       case "register":
         printRegisterDefinition(csrNode);
         break;
       case "wideregister":
         printWideRegisterDefinition(csrNode);
         break;
       case "memory":
         printMemoryDefinition(csrNode);
         break;
       case "widememory":
         printWideMemoryDefinition(csrNode);
         break;
       default:
         alertd('No default referenceType!');
       }
   }
   
   function printLeafDefinition(csrNode) 
   {
     referenceName_array = csrNode.referenceName.split(".");
   
     //print the def top down
     var parent_ref = '';
     for( var i = 0; i < referenceName_array.length; i++ )
       {
         var refName    = parent_ref + referenceName_array[i];
         var csrNode = csrNodeLookup(csrNode.objectIndex, refName);
         //if ( csrNodeObj.visibility == 0 )
         csrNode.expand();
         parent_ref = refName + '.';
       }
   
     //jump the window the the leaf link
     window.location.hash = '#' + csrNode.referenceName + 'Link';
   
     //move the address map so it remains onscreen
     var parent_ref = '';
     for( var i = 0; i < referenceName_array.length; i++ )
       {
         var refName    = parent_ref + referenceName_array[i];
         var csrNode = csrNodeLookup(csrNode.objectIndex, refName);
         //if ( csrNodeObj.visibility == 0 )
         if (csrNode.addressMapWindow) {
            csrNode.addressMapWindow.window.style.top =
               document.body.scrollTop + 25; 
         }
         parent_ref = refName + '.';
       }
   
   
     //highlight the div
     //highLightDiv(csrNode.referenceName);
     unhighLightDiv(csrNode.referenceName);
   
   }
   
   
   function printTopComponentTable(csrNode)
   {
   
     var xmlNode = csrNode.definitionPtr;
     //div to enclose module
     var moduleDiv     = document.createElement('DIV');
     var referenceName = csrNode.referenceName;
     var referenceType = csrNode.referenceType;
     var identifier    = getNodeValue_tag(xmlNode,"identifier");
   
     //set the div ID to the referenceName
     moduleDiv.id      = referenceName;
   
     csrNode.divParent = moduleDiv;
   
   
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
     var row = document.createElement('TR');
   
     var container     = document.createElement('TH');
     var theData       = document.createElement("div");
     theData.innerHTML = referenceType; 
     container.appendChild(theData);
     container.className = referenceType;
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'Link';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'ExpandAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'ExpandAllLink" onclick="expandAllNodes(' + csrNode.objectIndex + ');">' + 'expand all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   	
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'CollapseAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'CollapseAllLink" onclick="collapseAllNodes(' + csrNode.objectIndex + ');">' + 'collapse all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     tmp.appendChild(row);
   
     //add elements to DOM
     moduleDiv.appendChild(tableEl);
     document.getElementById('docroot').appendChild(moduleDiv);
   }
   
   
   function printTopAddressmapTable(csrNode)
   {
   
     var xmlNode = csrNode.definitionPtr;
     //div to enclose module
     var moduleDiv     = document.createElement('DIV');
     var referenceName = csrNode.referenceName;
     var referenceType = csrNode.referenceType;
     var identifier    = getNodeValue_tag(xmlNode,"identifier");
   
     //set the div ID to the referenceName
     moduleDiv.id      = referenceName;
   
     csrNode.divParent = moduleDiv;
   
   
     var tableEl = document.createElement('TABLE');
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
     var row = document.createElement('TR');
   
     var container     = document.createElement('TH');
     var theData       = document.createElement("div");
     theData.innerHTML = referenceType; 
     container.appendChild(theData);
     container.className = csrNode.referenceType;
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'Link';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'AddrMapLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'AddrMapLink" onclick="printAddressMap(' + csrNode.objectIndex + ',\'' + referenceName + '\');">' + 'address map' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
     
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'ExpandAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'ExpandAllLink" onclick="expandAllNodes(' + csrNode.objectIndex + ');">' + 'expand all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   	
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'CollapseAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'CollapseAllLink" onclick="collapseAllNodes(' + csrNode.objectIndex + ');">' + 'collapse all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     tmp.appendChild(row);
   
     //add elements to DOM
     moduleDiv.appendChild(tableEl);
     document.getElementById('docroot').appendChild(moduleDiv);
   }
   
   
   function printComponentDefinition(csrNode) 
   {
     var xmlNode = csrNode.definitionPtr;
     var componentDefContentDiv = document.createElement('DIV');
     componentDefContentDiv.style.marginLeft = "25px";
     componentDefContentDiv.id = csrNode.divParent.id+ 'DefContentDiv';
   
     csrNode.divChild = componentDefContentDiv;
   
     var identifier          = getNodeValue_tag(xmlNode,"identifier");
     var title               = getNodeValue_tag(xmlNode,"title");
     var description         = getNodeValue_description(xmlNode);
     var filename            = getNodeValue_tag(xmlNode,"filename");
     var linenumber          = getNodeValue_tag(xmlNode,"linenumber");
     var attributes          = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        if (filename != '') {
           tableData_array['Filename'] = filename;
        }
        if (linenumber != '') {
           tableData_array['Linenumber'] = linenumber;
        }
     }
     printRefInfoTable( tableData_array, componentDefContentDiv, csrNode);
     
     csrNode.divParent.appendChild( componentDefContentDiv );
   
     printComponentReference_links( csrNode );
   
   }
   
   function printAddressmapDefinition(csrNode) 
   {
     var xmlNode = csrNode.definitionPtr;
     var moduleDefContentDiv = document.createElement('DIV');
     moduleDefContentDiv.style.marginLeft = "25px";
     //moduleDefContentDiv.id = domParentNode.id + 'DefContentDiv';
     moduleDefContentDiv.id = csrNode.divParent.id+ 'DefContentDiv';
   
     csrNode.divChild = moduleDefContentDiv;
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var addressmapReference =
                           getNodeValue_tag(xmlNode,"addressmapReference");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (addressmapReference != '') {
        tableData_array['Reference']  = addressmapReference;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        if (filename != '') {
           tableData_array['Filename'] = filename;
        }
        if (linenumber != '') {
           tableData_array['Linenumber'] = linenumber;
        }
     }
     if (csrNode.showHeaderFileInfo()) {
        if (addressMacro != '') {
           tableData_array['Address Macro'] = addressMacro;
        }
        if (offsetMacro != '') {
           tableData_array['Offset Macro'] = offsetMacro;
        }
        if (typeName != '') {
           tableData_array['Type Name'] = typeName;
        }
     }
   
     printRefInfoTable( tableData_array, moduleDefContentDiv, csrNode);
     
     csrNode.divParent.appendChild( moduleDefContentDiv );
   
     printReference_links( csrNode );
   
   }
   
   
   function printReference_links(csrNode) {
   
    
     var objectIndex = csrNode.objectIndex;
     xmlNode         = csrNode.definitionPtr;
   
     var references = getNodes_tag(xmlNode,'reference');
   
     for (var i=0; i < references.length; i++ )
       {
         
         var referenceType = getNodeValue_tag(references[i],"referenceType");
         var referenceName = getNodeValue_tag(references[i],"referenceName");
   
         referencedCsrNode = csrNodeLookup(objectIndex, referenceName);
         var identifier    =
             getNodeValue_tag(referencedCsrNode.definitionPtr,"identifier");
   
         var referenceDiv  = document.createElement('DIV');
         referenceDiv.id = referenceName;
         var tableData_array = new Array();
   
         tableData_array[referenceType] = '<a id="' + referenceName + 'Link" name="'+ referenceName + 'Link" ' + 'href="javascript:void(0);" onclick="csrNodeLookup(' + objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
   
         //set parent of referenced node
         referencedCsrNode.divParent = referenceDiv;
   
         printRefInfoTable( tableData_array, referenceDiv, referencedCsrNode);
   
         csrNode.divChild.appendChild(referenceDiv);
     
         if ( referencedCsrNode.visibility == 1 )
   	printDefinition(referencedCsrNode);
       }
   }
   
   
   function printComponentReference_links(csrNode) {
   
    
     var objectIndex = csrNode.objectIndex;
     xmlNode         = csrNode.definitionPtr;
     var table;
     var body;
     var row;
     var cell;
     var theData;
     var theLink;
   
     var references = getNodes_tag(xmlNode,'reference');
   
     for (var i=0; i < references.length; i++ )
       {
         
         var referenceType = getNodeValue_tag(references[i],"referenceType");
         var referenceName = getNodeValue_tag(references[i],"referenceName");
   
         referencedCsrNode = csrNodeLookup(objectIndex, referenceName);
         var identifier    =
             getNodeValue_tag(referencedCsrNode.definitionPtr,"identifier");
   
         var referenceDiv  = document.createElement('DIV');
         referenceDiv.id = referenceName;
         var tableData_array = new Array();
   
         table = document.createElement('TABLE');
         body = document.createElement('TBODY');
         row = document.createElement('TR');
   
         cell              = document.createElement('TH');
         theData           = document.createElement("div");
         theData.innerHTML = referenceType; 
         cell.appendChild(theData);
         cell.className = referenceType;
         row.appendChild(cell);
   
         cell              = document.createElement('TD');
         theLink           = document.createElement("div");
         theLink.id        = referenceName + 'Link';
         theLink.innerHTML = '<a id="' + referenceName + 'Link" href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
         cell.appendChild(theLink) 
         row.appendChild(cell);
   
         cell              = document.createElement('TD');
         theLink           = document.createElement("div");
         theLink.id        = referenceName + 'AddrMapLink';
         theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'AddrMapLink" onclick="printAddressMap(' + csrNode.objectIndex + ',\'' + referenceName + '\');">' + 'address map' + '</a>';
         cell.appendChild(theLink) 
         row.appendChild(cell);
   
         body.appendChild(row);
         table.appendChild(body);
         referenceDiv.appendChild(table);
   
         //set parent of referenced node
         referencedCsrNode.divParent = referenceDiv;
   
         csrNode.divChild.appendChild(referenceDiv);
     
         if ( referencedCsrNode.visibility == 1 )
   	printDefinition(referencedCsrNode);
       }
   }
   
   function printGroupDefinition(csrNode)
   {
   
     var groupReferenceName        = csrNode.referenceName;
     var groupParentDiv            = document.getElementById(groupReferenceName);
     
     csrNode.divParent = groupParentDiv;
     var xmlNode = csrNode.definitionPtr;
   
     var groupDiv                  = document.createElement('DIV');
     groupDiv.id               = groupParentDiv.id + "child";
     groupDiv.style.marginLeft = "25px";
     
     csrNode.divChild = groupDiv;
   
     groupParentDiv.appendChild(groupDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayMax        = getNodeValue_tag(xmlNode,"arrayMax");
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']   = filename;
        tableData_array['Linenumber'] = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, groupDiv, csrNode);
   
   
     printReference_links(csrNode);
   
   }
   
   function printUnionDefinition(csrNode)
   {
   
     var unionReferenceName        = csrNode.referenceName;
     var unionParentDiv            = document.getElementById(unionReferenceName);
     
     csrNode.divParent = unionParentDiv;
     var xmlNode = csrNode.definitionPtr;
   
     var unionDiv                  = document.createElement('DIV');
     unionDiv.id               = unionParentDiv.id + "child";
     unionDiv.style.marginLeft = "25px";
     
     csrNode.divChild = unionDiv;
   
     unionParentDiv.appendChild(unionDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayMax        = getNodeValue_tag(xmlNode,"arrayMax");
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
       tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']   = filename;
        tableData_array['Linenumber'] = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, unionDiv, csrNode);
   
     printReference_links(csrNode);
   
   }
   
   function printRegisterDefinition(csrNode) 
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var aliasOf         = getNodeValue_tag(xmlNode,"aliasOf");
     var aliases         = getNodes_tag(xmlNode,'aliases');
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"registerResetValue");
     var resetMask       = getNodeValue_tag(xmlNode,"registerResetMask");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var isVolatile      = getNodeValue_tag(xmlNode,"volatile");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (aliasOf != '') {
        tableData_array['Alias Of'] = '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasOf + '\'));">' + aliasOf + '</a>';
     }
     if (aliases.length > 0) {
        var aliasList = getNodes_tag(aliases[0],'alias');
        var aliasesString = '';
        var aliasValue;
        if (aliasList[0].firstChild) {
              aliasValue = aliasList[0].firstChild.nodeValue;
              aliasesString += '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasValue + '\'));">' + aliasValue + '</a>';
        }
        for ( var i=1; i < aliasList.length; i++ ) {
           if (aliasList[i].firstChild) {
              aliasValue = aliasList[i].firstChild.nodeValue;
              aliasesString += '<br>';
              aliasesString += '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasValue + '\'));">' + aliasValue + '</a>';
           }
        }
        tableData_array['Aliases'] = aliasesString;
     }
     if (isVolatile != '') {
        tableData_array['Volatile'] = ((isVolatile == 'true') ? '1': '0');
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if ((resetValue != '') && (resetMask != '')) {
        tableData_array['Reset Mask'] = resetMask;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printCsrBitFields( csrNode );
   
   }
   
   function printCsrBitFields( csrNode )
   {
     var xmlNode = csrNode.definitionPtr;
    
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
     var fieldsHaveClockDomains =
        (getNodeValue_tag(xmlNode, "clockDomains") == 'true');
     var fieldsHaveSynchronizer =
        (getNodeValue_tag(xmlNode, "synchronizers") == 'true');
     var fieldsHaveAttributes =
        (getNodeValue_tag(xmlNode, "fieldsHaveAttributes") == 'true');
     var headers;
   
   //Header Row
     headers = ['Identifier', 'Title', 'Bit', 'Access', 'Reset'];
     if (fieldsHaveClockDomains) {
        headers.push('Clock Domain');
     }
     if (fieldsHaveSynchronizer) {
        headers.push('Synchronizer');
     }
     if (fieldsHaveAttributes) {
        headers.push('Attributes');
     }
     headers.push('Description');
   
     var row           = document.createElement('TR');
     for ( var i=0; i<headers.length; i++ ) 
       {
        
         var container     = document.createElement('TH');
         var theData       = document.createElement('DIV');
         theData.innerHTML = headers[i];
         container.className = csrNode.referenceType;
         container.appendChild(theData);
         row.appendChild(container);
       }
     tmp.appendChild(row);
   
     var bitfields = getNodes_tag(xmlNode,'bitfield');
   
     
   
     for ( var i=0; i < bitfields.length; i++ )
       {
         var identifier  = getNodeValue_tag(bitfields[i],"identifier");
         var title       = getNodeValue_tag(bitfields[i],"title");
         var msb         = getNodeValue_tag(bitfields[i],"msb");
         var lsb         = getNodeValue_tag(bitfields[i],"lsb");
   
         if (msb == lsb) 
   	var bit         = '[' + msb + ']';
         else 
   	var bit         = '[' + msb + ':' + lsb +']';
         
   
         var access      = getNodeValue_tag(bitfields[i],"access");
         var reset       = getNodeValue_tag(bitfields[i],"resetValue");
         var description = getNodeValue_description(bitfields[i]);
         var attributes  = getNodeValue_fieldAttributes(bitfields[i]);
   
         var clockDomain    = getNodeValue_tag(bitfields[i],"clockDomain");
         var synchronizer   = getNodeValue_tag(bitfields[i],"synchronizer");
   
         var widthMacro     = getNodeValue_tag(bitfields[i],"widthMacro");
         var msbMacro       = getNodeValue_tag(bitfields[i],"msbMacro");
         var lsbMacro       = getNodeValue_tag(bitfields[i],"lsbMacro");
         var rangeMacro     = getNodeValue_tag(bitfields[i],"rangeMacro");
         var resetMacro     = getNodeValue_tag(bitfields[i],"resetMacro");
         var getMacro       = getNodeValue_tag(bitfields[i],"getMacro");
         var setMacro       = getNodeValue_tag(bitfields[i],"setMacro");
   
         var filename       = getNodeValue_tag(bitfields[i],"filename");
         var linenumber     = getNodeValue_tag(bitfields[i],"linenumber");
         var enums          = getNodes_tag(bitfields[i], "enumeration");
   
         var row_data;
   
         row_data = [identifier, title, bit, access.toUpperCase(), reset];
         if (fieldsHaveClockDomains) {
            row_data.push(clockDomain);
         }
         if (fieldsHaveSynchronizer) {
            row_data.push(synchronizer);
         }
         if (fieldsHaveAttributes) {
            row_data.push(attributes);
         }
         row_data.push(description);
         row         = document.createElement('TR');
         
         for ( var j=0; j<row_data.length; j++ ) {
            var container     = document.createElement('TD');
            var theData       = document.createElement('DIV');
            theData.innerHTML = row_data[j];
            container.appendChild(theData);
            row.appendChild(container);
         }
         tmp.appendChild(row);
   
         //FIX ME SNPS title check not cool (there for reserved fields)
         if (
            (
               csrNode.showFileInfo() ||
               csrNode.showHeaderFileInfo() ||
               (csrNode.showEnumInfo() && enums && (enums.length > 0))
               ) &&
            (title != "-") &&
            (csrNode.referenceType != 'wideregister')
            ) {
            row         = document.createElement('TR');
            var container     = document.createElement('TD');
            container.colSpan = row_data.length;
            container.style.backgroundColor = "#e7e7e7";
           
            if (csrNode.showFileInfo()) {
              var tableData_array = new Array();
              var theData       = document.createElement('DIV');
              theData.className = "fldiv";
              tableData_array['Filename']   = filename;
              tableData_array['Linenumber'] = linenumber;
              printRefInfoTable(tableData_array, theData, csrNode);
              container.appendChild(theData);
            }
   
            if (csrNode.showHeaderFileInfo()) {
              var tableData_array = new Array();
              var theData       = document.createElement('DIV');
              theData.className = "fldiv";
              tableData_array['Width Macro']   = widthMacro;
              tableData_array['Range Macro']   = rangeMacro;
              tableData_array['Msb Macro']     = msbMacro;
              tableData_array['Lsb Macro']     = lsbMacro;
              tableData_array['Reset Macro']   = resetMacro;
              tableData_array['Set Macro']     = setMacro;
              tableData_array['Get Macro']     = getMacro;
              printRefInfoTable(tableData_array, theData, csrNode);
              container.appendChild(theData);
            }
   
            if (csrNode.showEnumInfo() && enums && (enums.length > 0)) {
              var enumDiv = printFieldEnumTable(csrNode, enums);
              container.appendChild(enumDiv);
            }
   
            row.appendChild(container);
   
            tmp.appendChild(row);
         }
         
   
         
       }
     
     csrNode.divChild.appendChild(tableEl);
     
   }
   
   function printFieldEnumTable( csrNode, enums )
   {
     var enumDiv       = document.createElement('DIV');
     enumDiv.className = "fldiv";
     var table = document.createElement('TABLE');
     var body = document.createElement('TBODY');
   
     var titles = (getNodeValue_tag(enums[0], "titles") == 'true');
     var descriptions = (getNodeValue_tag(enums[0], "descriptions") == 'true');
     var hasPartialAccess =
        (getNodeValue_tag(enums[0], "enumeratorsHavePartialAccess") == 'true');
   
     var headerCells = [];
     if (titles) {
        headerCells.push('Title');
     }
     headerCells.push('Identifier');
     headerCells.push('Value');
     if (hasPartialAccess) {
        headerCells.push('Access')
     }
     if (descriptions) {
        headerCells.push('Description')
     }
   
     var headerRow = document.createElement('TR');
     for ( var i=0; i < headerCells.length; i++ ) {
       var container     = document.createElement('TH');
       var theData       = document.createElement('DIV');
       theData.innerHTML = headerCells[i];
       container.appendChild(theData);
       container.className = csrNode.referenceType;
       container.className = 'field';
       headerRow.appendChild(container);
     }
     body.appendChild(headerRow);
   
     var enumerators = getNodes_tag(enums[0], "enumerator");
     for (var e=0; e < enumerators.length; e++) {
       var row = document.createElement('TR');
       var identifier = getNodeValue_tag(enumerators[e], "identifier");
       var value = getNodeValue_tag(enumerators[e], "value");
       var title;
       var description;
       var access;
       var cells = [];
       if (titles) {
         title = getNodeValue_tag(enumerators[e], "title");
         cells.push(title);
       }
       cells.push(identifier);
       cells.push(value);
       if (hasPartialAccess) {
         access = getNodeValue_tag(enumerators[e], "enumeratorAccess");
         cells.push(access);
       }
       if (descriptions) {
         description = getNodeValue_tag(enumerators[e], "description");
         cells.push(description);
       }
         
       for ( var i=0; i < cells.length; i++ ) {
         var container     = document.createElement('TD');
         var theData       = document.createElement('DIV');
         theData.innerHTML = cells[i];
         container.appendChild(theData);
         row.appendChild(container);
       }
       body.appendChild(row);
     }
   
     table.appendChild(body);
     enumDiv.appendChild(table);
     return enumDiv;
   }
   
   function printWideRegisterDefinition( csrNode )
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"resetValue");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var isVolatile      = getNodeValue_tag(xmlNode,"volatile");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier'] = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions']     = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (isVolatile != '') {
        tableData_array['Volatile'] = ((isVolatile == 'true') ? "1": "0");
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printCsrBitFields( csrNode );
   
     printReference_links( csrNode );
     
   
   }
   
   function printMemoryDefinition(csrNode) 
   {
     var memoryReferenceName = csrNode.referenceName;
     var memoryParentDiv     = document.getElementById(memoryReferenceName);
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = memoryParentDiv;
   
     var memoryDiv              = document.createElement('DIV');
   
     memoryDiv.id               = memoryParentDiv.id + "child";
     memoryDiv.style.marginLeft = "25px";
     csrNode.divChild = memoryDiv;
     memoryParentDiv.appendChild(memoryDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"resetValue");
     var resetMask       = getNodeValue_tag(xmlNode,"resetMask");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var memoryWidth     = getNodeValue_tag(xmlNode,"memoryWidth");
     var memoryWordCount = getNodeValue_tag(xmlNode,"memoryWordCount");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (memoryWidth != '') {
        tableData_array['Width'] = memoryWidth;
     }
     if (memoryWordCount != '') {
        tableData_array['Word Count'] = memoryWordCount;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if ((resetValue != '') && (resetMask != '')) {
        tableData_array['Reset Mask'] = resetMask;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, memoryDiv, csrNode);
   
     printReference_links(csrNode);
   }
   
   function printWideMemoryDefinition( csrNode )
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var memoryWidth     = getNodeValue_tag(xmlNode,"memoryWidth");
     var memoryWordCount = getNodeValue_tag(xmlNode,"memoryWordCount");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier'] = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions']     = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (memoryWidth != '') {
        tableData_array['Width'] = memoryWidth;
     }
     if (memoryWordCount != '') {
        tableData_array['Word Count'] = memoryWordCount;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printReference_links( csrNode );
   
   }
   
   
   function printRefInfoTable( refArray, domParentNode, csrNode ) 
   {
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
   
     for ( var type in refArray )
       {
         var row = document.createElement('TR');
         
         //headings
         var container = document.createElement('TH');
         //     var theData   = document.createTextNode(node);
         var theData = document.createElement('DIV');
         theData.innerHTML = type;
   
         container.className = csrNode.referenceType;
   
         container.appendChild(theData);
         row.appendChild(container);
         
         //values
         container     = document.createElement('TD');
         container.className = "noborder";
         //      theData       = document.createTextNode(refArray[type]);
         var theData = document.createElement('DIV');
         theData.innerHTML = refArray[type];
   
         container.appendChild(theData);
         row.appendChild(container);
         
         tmp.appendChild(row);
       }
     
     domParentNode.appendChild(tableEl);
   }
   
   function printAddressMap(objectIndex, referenceName)
   {
     var csrNode;
    
     csrNode = csrNodeLookup(objectIndex, referenceName);
   
     //if window is already open, close it
     if (csrNode.addressMapWindow) {
       if (csrNode.addressMapWindow.opened)
         return;
       else csrNode.addressMapWindow.open()
     }
   
     csrNode.addressMapWindow = new Window( document.body.clientWidth - 625, 25, 600, 400, 'AddrMap' + objectIndex );
   
     var addrMapDiv       = document.createElement('DIV');
     addrMapDiv.id        = 'AddrMap' + objectIndex;
     addrMapDiv.style.marginLeft = "10px";
     addrMapDiv.style.marginRight = "10px";
     addrMapDiv.style.marginTop = "10px";
     addrMapDiv.style.marginBottom = "10px";
   
     
     csrNode.addressMapWindow.changeTitle( 'Address Map for ' + referenceName );
   
     addressMapEntries = getNodes_tag(csrNode.definitionPtr,'addressMapEntry');
   
     alertd('addressMapEntries=' + addressMapEntries.length);
   
     var tableEl = document.createElement('TABLE');
     tableEl.width = "550px";
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
     var headers = ['Address', 'Instance Name'];
   
      var row           = document.createElement('TR');
     for ( var i=0; i<headers.length; i++ ) 
       {
         var container        = document.createElement('TH');
         var theData          = document.createElement('DIV');
         theData.innerHTML    = headers[i];
         container.appendChild(theData);
         row.appendChild(container);
       }
     tmp.appendChild(row);
   
   
     for ( var i=0; i < addressMapEntries.length; i++)
       {
         var print = false;
         var referenceName = getNodeValue_tag(addressMapEntries[i],"referenceName");
         var instanceName  = getNodeValue_tag(addressMapEntries[i],"instanceName");
         var referencedObj = csrNodeLookup(objectIndex, referenceName);
   
   
         var addressLow    = getNodeValue_tag(addressMapEntries[i],"addressLow");
         var addressHigh   = getNodeValue_tag(addressMapEntries[i],"addressHigh");
         
         if (addressLow == addressHigh) 
   	var addressRange = addressHigh;
         else
   	var addressRange = addressLow + ' - ' + addressHigh;
         
         if ( referencedObj ) 
   	{
   	  if (
                (referencedObj.referenceType == "register") ||
                (referencedObj.referenceType == "wideregister") ||
                (referencedObj.referenceType == "memory") ||
                (referencedObj.referenceType == "widememory")
             )
   	    {
   	      print = true;
   	      referenceName = '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + objectIndex + ',\'' + referenceName + '\'));">' + instanceName + '</a>';
   	    }
   	}
         else if ( referenceName == '' )
   	{
   	print = true;
   	referenceName = 'reserved';
   	}
   
         if ( print ) 
   	{
   	  var row_data = [ addressRange, referenceName];
   	  row          = document.createElement('TR');
   	  
   	  for ( var j=0; j<row_data.length; j++ ) 
   	    {
   	      var container     = document.createElement('TD');
   	      var theData       = document.createElement('DIV');
   	      theData.innerHTML = row_data[j];
   	      container.appendChild(theData);
   	      row.appendChild(container);
   	    }
   	  tmp.appendChild(row);
   	}
       }
   
     addrMapDiv.appendChild(tableEl);
   
     csrNode.addressMapWindow.appendDomEl(addrMapDiv);
     csrNode.addressMapWindow.open();
   }
   
   
   //expand nodes
   function expandAllNodes( objectIndex )
   {
     for ( var obj in csrNode_array[objectIndex] )
       {  
         var csrNodeObj = csrNodeLookup(objectIndex,obj);
         csrNodeObj.expand();
       }
   }
   
   function collapseAllNodes( objectIndex )
   {
      for ( var obj in csrNode_array[objectIndex] )
       {  
         var csrNodeObj = csrNodeLookup(objectIndex,obj);
         csrNodeObj.collapse();
       }
   }
   
   // Graphics Functions
   
   function highLightDiv( id )
   {
     fade(0xe7, 0xe7, 0xe7, 0xff, 0xff, 0x33, 100, id);  
   }
   
   function unhighLightDiv( id )
   {
     fade(0xff, 0xff, 0x33, 0xe7, 0xe7, 0xe7, 100, id);
   }
   
   function makearray(n)
   {
     this.length = n;
     for(var i = 1; i <= n; i++)
       this[i] = 0;
     return this;
   }
   
   hexa = new makearray(16);
   
   for(var i = 0; i < 10; i++) 
        hexa[i] = i;
   hexa[10]="a"; hexa[11]="b"; hexa[12]="c";
   hexa[13]="d"; hexa[14]="e"; hexa[15]="f";
   
   function hex(i)
   {
     if (i < 0) return "00";
     else if (i >255) return "ff";
     else return "" + hexa[Math.floor(i/16)] + hexa[i%16];
   }
   
   var fade_timer = 100;
   function setbgColor(r, g, b, id)
   {
     var hr = hex(r); var hg = hex(g); var hb = hex(b);
     document.getElementById(id).style.backgroundColor = "#"+hr+hg+hb;
     var timeOutString = 'document.getElementById("' + id + '").style.backgroundColor=' +  '"#'+hr+hg+hb +'"';
     fade_timer = fade_timer + 25;
     setTimeout(timeOutString, fade_timer);
   
   }
   
   function fade(sr, sg, sb, er, eg, eb, step, id)
   {
     fade_timer = 100;
     for(var i = 0; i <= step; i++){
       setbgColor(Math.floor(sr * ((step-i)/step) + er * (i/step)),Math.floor(sg * ((step-i)/step) + eg * (i/step)),Math.floor(sb * ((step-i)/step) + eb * (i/step)),id);
     }
   }
   
   // Browser Detect
   
   // Determine browser and version.
   
   function Browser() 
   {
   
     var ua, s, i;
   
     this.isIE    = false;
     this.isNS    = false;
     this.version = null;
   
     ua = navigator.userAgent;
   
     s = "MSIE";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isIE = true;
       this.version = parseFloat(ua.substr(i + s.length));
       return;
     }
   
     s = "Netscape6/";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isNS = true;
       this.version = parseFloat(ua.substr(i + s.length));
       return;
     }
   
     // Treat any other "Gecko" browser as NS 6.1.
   
     s = "Gecko";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isNS = true;
       this.version = 6.1;
       return;
     }
   }
   
   var browser = new Browser();
   
   //DHTML Windows Below
   
   var myWindow = new Object();
   var globalWindowZIndex = 500;
   
   // Window Class
   function Window(x,y,w,h,dom_id) 
   {
     
     // CLASS TAG ELEMENT VARAIBLES
     this.window             = 0;
     this.title              = 0;
     this.titleBar           = 0;
     this.titleBarText       = 0;
     this.titleBarButtons    = 0;
     this.clientArea         = 0;
     this.titleBarMap        = 0;
     this.left               = x;
     this.top                = y;
     this.width              = w;
     this.height             = h;
     this.opened             = false; 
     this.dom_id             = dom_id;
   
     if (browser.isNS) 
       {
         this.ca_width       = this.width - 2;
         this.ca_height      = this.height - 40;
       }
     if (browser.isIE) 
       {
         this.ca_width       = this.width - 2;
         this.ca_height      = this.height - 40;
     }
     this.inMoveDrag   = false;
   
     // CLASS METHOD FUNCTIONS
     this.create        = windowCreate;
     this.init          = windowInit;
     this.open          = windowOpen;
     this.makeActive    = windowMakeActive;
     this.insertHTML    = windowInsertHTML; 
     this.appendHTML    = windowAppendHTML;
     this.appendDomEl   = windowAppendDomEl;
     this.close         = windowClose;
     this.windowColor   = windowChangeColor;
   
     this.changeTitle = function(title) {
       this.title.innerHTML = title;
     }
   
     this.wallpaper = function(img) {
        this.windowArea.style.backgroundImage    = img;
        this.windowArea.style.backgroundPosition = "center";
        this.windowArea.style.backgroundRepeat   = "no-repeat";
     }
   
     this.create();
     this.init();
   }
   
   //
   // Create WINDOW DOM object Tree
   //
   // body
   //  |
   //  | -- div ( window )
   //        |
   //        | -- div ( titlebar )
   //              |
   //              | -- span ( title )
   //              |
   //        | -- div ( text window area )
   //
   
   function windowCreate() 
   {
     // Find the main Body Tag.  Only one should exist in page 
     var bodyEl = document.getElementsByTagName("body");
   
     //WINDOW DIV
     var windowEl          = document.createElement("div");
     windowEl.className    = "window";
     windowEl.style.left   = this.left + "px";
     windowEl.style.top    = this.top + "px";
     windowEl.style.width  = this.width + "px"; 
     windowEl.style.height = this.height + "px";
     windowEl.id           = "window" + this.dom_id;
     windowEl.parent       = this;
   
   
     //TOP TITLE DIV
   
     var titleBarEl         = document.createElement("div");
     //  titleBarEl.className   = "windowTitleBar";
     titleBarEl.id          = "titleBar"; 
     titleBarEl.onmousedown = windowMove;
     titleBarEl.parent      = this;
   
     // Put the title into a table
   
     var tableTitleEl       = document.createElement("table");
     tableTitleEl.width     = "100%";
     var tbodyTitleEl       = document.createElement("tbody");
     var trTitleEl          = document.createElement("tr");
     var tdTitlePinIconEl   = document.createElement("td");
     tdTitlePinIconEl.width = "10%";
     tdTitlePinIconEl.algin = "right";
     tdTitlePinIconEl.className = "windowTitleBar";
     var tdTitleTitleEl     = document.createElement("td");
     tdTitleTitleEl.width   = "90%";
     tdTitleTitleEl.algin   = "right";
     tdTitleTitleEl.className = "windowTitleBar";
     tdTitleTitleEl.innerHTML   = 'WINDOW TITLE';
     tdTitleTitleEl.parent      = this;
     tdTitleTitleEl.onmouseover = windowMoveCursorSet;
     tdTitleTitleEl.onmouseout  = windowDefaultCursorSet;
     
     this.title  = tdTitleTitleEl;
     
     // CLOSE DIV
     var closeLink       = document.createElement("a");
     closeLink.setAttribute('href', 'javascript:void(0);');
     closeLink.onclick    = this.close;
     closeLink.parent    = this;
     var linkText = document.createTextNode('close');
     closeLink.appendChild(linkText);
     closeLink.style.color = "white";
   
   
     // Window List Area
     var windowAreaEl = document.createElement("div");
     windowAreaEl.className    = "windowListArea";
     
     windowAreaEl.style.width  = this.ca_width + "px";
     windowAreaEl.style.height = this.ca_height + "px";
     
     // Build DOM
     tdTitlePinIconEl.appendChild(closeLink);
   
     trTitleEl.appendChild(tdTitleTitleEl);
     trTitleEl.appendChild(tdTitlePinIconEl);
     tbodyTitleEl.appendChild(trTitleEl);
     tableTitleEl.appendChild(tbodyTitleEl);
     titleBarEl.appendChild(tableTitleEl);
     
     windowEl.appendChild(titleBarEl);
     
     windowEl.appendChild(windowAreaEl);
     document.body.appendChild(windowEl);
     
     this.window           = windowEl;
     this.windowArea       = windowAreaEl; 
     this.title            = tdTitleTitleEl;
   
   }
   
   function windowInit() 
   {
   
   }
   
   function windowChangeColor(color) 
   {
     this.window.style.backgroundColor = color;
     this.windowArea.style.backgroundColor = color;
   }
   
   function windowInsertHTML(html) 
   {
     this.windowArea.innerHTML = html;
   }
   
   function windowAppendHTML(html) 
   {
     this.windowArea.innerHTML = this.windowArea.innerHTML + html;
   }
   
   function windowAppendDomEl(el)
   {
     this.windowArea.appendChild(el);
   }
   
   function windowOpen() 
   {
     if (this.isOpen)
       return;
   
     this.opened = true;
   
     // Restore the Window and make it visible.
     this.makeActive();
     this.isOpen = true;
     this.window.style.visibility = "visible";
   }
   
   
   function windowMakeActive() 
   {
     if (myWindow == this)
       return;
   
     this.window.style.zIndex = globalWindowZIndex;
     globalWindowZIndex++;
     myWindow = this;
   
   }
   
   //
   // Event handlers.
   //
   
   
   function windowClientAreaClick(event) 
   {
   
     // Make this Window the active one.
   
      myWindow.makeActive();
   }
   
   function windowMove(event) 
   {
     var target;
     var x, y;
   
     if (browser.isIE)
       target = window.event.srcElement.tagName;
     if (browser.isNS)
       target = event.target.tagName;
   
     if (target == "AREA")
       return;
   
     p = this.parent;
     p.makeActive();
     // Get cursor offset from Window window.
   
     if (browser.isIE) {
       x = window.event.x;
       y = window.event.y;
     }
     if (browser.isNS) {
       x = event.pageX;
       y = event.pageY;
     }
     myWindow.xOffset = myWindow.window.offsetLeft - x;
     myWindow.yOffset = myWindow.window.offsetTop  - y;
   
     // Set document to capture mousemove and mouseup events.
   
     if (browser.isIE) {
       document.onmousemove = windowMoveDragStart;
       document.onmouseup   = windowMoveDragStop;
     }
     if (browser.isNS) {
       document.addEventListener("mousemove", windowMoveDragStart,   true);
       document.addEventListener("mouseup",   windowMoveDragStop, true);
       event.preventDefault();
     }
     myWindow.inMoveDrag = true;
     
   }
   
   
   
   function windowClose() 
   {
     this.parent.opened = false;
     document.body.removeChild(this.parent.window);
   }
   
   
   function windowMoveDragStart(event) 
   {
   
     var x, y;
   
     if (!myWindow.inMoveDrag)
       return;
   
     // Get cursor position.
   
     if (browser.isIE) {
       x = window.event.x;
       y = window.event.y;
       window.event.cancelBubble = true;
       window.event.returnValue = false;
     }
     if (browser.isNS) {
       x = event.pageX;
       y = event.pageY;
       event.preventDefault();
     }
   
     // Move Window window based on offset from cursor.
    
     nx = ( x + myWindow.xOffset );
     ny = ( y + myWindow.yOffset );
   
     if ( (nx<0) || (ny<0) ) {
   
     } else {
       myWindow.window.style.left = (x + myWindow.xOffset) + "px";
       myWindow.window.style.top  = (y + myWindow.yOffset) + "px";
     }
   }
   
   
   function windowMoveDragStop(event) 
   {
     myWindow.inMoveDrag = false;
   
     // Remove mousemove and mouseup event captures on document.
   
     if (browser.isIE) {
       document.onmousemove = null;
       document.onmouseup   = null;
     }
     if (browser.isNS) {
       document.removeEventListener("mousemove", windowMoveDragStart,   true);
       document.removeEventListener("mouseup",   windowMoveDragStop, true);
     }
   }
   
   
   function windowMoveCursorSet(event) 
   {
      this.style.cursor = "move";
   }
   
   function windowDefaultCursorSet(event) 
   {
      this.style.cursor = "move";
   }
   
   // End of Java Script
  </script>
  <noscript>
   <div class="noscript">
    <h2>JavaScript required</h2>
    <p>csrCompiler HTML pages require JavaScript.</p>
    <p>Your web browser does not support JavaScript or it has been disabled.</p>
   <div>
  </noscript>
 </head>
 <body onload="importXML('xmlData')">
  <xml id="xmlData" style="display:none;">
   <?xml version="1.0" encoding="UTF-8" ?>
   <csr:csrData
    xmlns:csr="http://www.semifore.com/schema/csrXmlHtml"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.semifore.com/schema/csrXmlHtml http://www.semifore.com/schema/csrXmlHtml.xsd"
    >
    <csr:fileInfo>
     <csr:inputFiles>
      <csr:file>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
      </csr:file>
     </csr:inputFiles>
     <csr:configurationFiles>
       <csr:file>
       <csr:filename>/project/jenkins/workspace/Esperanto_DV/soc_hal/esperanto-soc/dv/common/scripts/semifore_css/etsoc_esr.css</csr:filename>
      </csr:file>
     </csr:configurationFiles>
    </csr:fileInfo>
    <csr:csrObject>
     <csr:topDefinition>
      <csr:referenceName>ddr</csr:referenceName>
     </csr:topDefinition>
     <csr:definitions>
      <csr:definition>
       <csr:referenceType>component</csr:referenceType>
       <csr:referenceName>ddr</csr:referenceName>
       <csr:identifier>ddr</csr:identifier>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6391</csr:linenumber>
       <csr:title></csr:title>
       <csr:addressedAccess>NA</csr:addressedAccess>
       <csr:typeName>Ddr</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>addressmap</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>addressmap</csr:referenceType>
         <csr:referenceName>ddr.AXI4_SLAVE_00</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>addressmap</csr:referenceType>
         <csr:referenceName>ddr.AXI4_SLAVE_01</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>addressmap</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE</csr:referenceName>
       <csr:identifier>APB_SLAVE</csr:identifier>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6388</csr:linenumber>
       <csr:title></csr:title>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Apb_slave</csr:typeName>
        <csr:description>
         <csr:p>DWC_ddr_umctl2 Memory Map</csr:p>
        </csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>group</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>group</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP</csr:referenceName>
        </csr:reference>
       </csr:references>
       <csr:addressMap>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0x1AFF</csr:addressHigh>
         <csr:instanceName>APB_SLAVE</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0x3F7</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0x0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.MSTR</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.MSTR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4</csr:addressLow>
         <csr:addressHigh>0x4</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.STAT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.STAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x8</csr:addressLow>
         <csr:addressHigh>0xF</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x10</csr:addressLow>
         <csr:addressHigh>0x10</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.MRCTRL0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.MRCTRL0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x14</csr:addressLow>
         <csr:addressHigh>0x14</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.MRCTRL1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.MRCTRL1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x18</csr:addressLow>
         <csr:addressHigh>0x18</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.MRSTAT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.MRSTAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1C</csr:addressLow>
         <csr:addressHigh>0x1F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x20</csr:addressLow>
         <csr:addressHigh>0x20</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DERATEEN</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DERATEEN</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x24</csr:addressLow>
         <csr:addressHigh>0x24</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DERATEINT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DERATEINT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x28</csr:addressLow>
         <csr:addressHigh>0x2B</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x2C</csr:addressLow>
         <csr:addressHigh>0x2C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DERATECTL</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DERATECTL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x30</csr:addressLow>
         <csr:addressHigh>0x30</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.PWRCTL</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PWRCTL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x34</csr:addressLow>
         <csr:addressHigh>0x34</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.PWRTMG</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PWRTMG</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x38</csr:addressLow>
         <csr:addressHigh>0x38</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.HWLPCTL</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.HWLPCTL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x3C</csr:addressLow>
         <csr:addressHigh>0x4F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x50</csr:addressLow>
         <csr:addressHigh>0x50</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.RFSHCTL0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.RFSHCTL0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x54</csr:addressLow>
         <csr:addressHigh>0x5F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x60</csr:addressLow>
         <csr:addressHigh>0x60</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.RFSHCTL3</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.RFSHCTL3</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x64</csr:addressLow>
         <csr:addressHigh>0x64</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.RFSHTMG</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.RFSHTMG</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x68</csr:addressLow>
         <csr:addressHigh>0x68</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.RFSHTMG1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.RFSHTMG1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x6C</csr:addressLow>
         <csr:addressHigh>0x6F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x70</csr:addressLow>
         <csr:addressHigh>0x70</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCCFG0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCFG0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x74</csr:addressLow>
         <csr:addressHigh>0x74</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCCFG1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCFG1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x78</csr:addressLow>
         <csr:addressHigh>0x78</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCSTAT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCSTAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x7C</csr:addressLow>
         <csr:addressHigh>0x7C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCCTL</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCTL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x80</csr:addressLow>
         <csr:addressHigh>0x80</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCERRCNT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCERRCNT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x84</csr:addressLow>
         <csr:addressHigh>0x84</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCCADDR0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCADDR0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x88</csr:addressLow>
         <csr:addressHigh>0x88</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCCADDR1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCADDR1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x8C</csr:addressLow>
         <csr:addressHigh>0x8C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCCSYN0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCSYN0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x90</csr:addressLow>
         <csr:addressHigh>0x90</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCCSYN1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCSYN1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x94</csr:addressLow>
         <csr:addressHigh>0x94</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCCSYN2</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCSYN2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x98</csr:addressLow>
         <csr:addressHigh>0x98</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCBITMASK0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCBITMASK0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x9C</csr:addressLow>
         <csr:addressHigh>0x9C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCBITMASK1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCBITMASK1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xA0</csr:addressLow>
         <csr:addressHigh>0xA0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCBITMASK2</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCBITMASK2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xA4</csr:addressLow>
         <csr:addressHigh>0xA4</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCUADDR0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUADDR0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xA8</csr:addressLow>
         <csr:addressHigh>0xA8</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCUADDR1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUADDR1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xAC</csr:addressLow>
         <csr:addressHigh>0xAC</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCUSYN0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUSYN0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xB0</csr:addressLow>
         <csr:addressHigh>0xB0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCUSYN1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUSYN1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xB4</csr:addressLow>
         <csr:addressHigh>0xB4</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCUSYN2</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUSYN2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xB8</csr:addressLow>
         <csr:addressHigh>0xB8</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCPOISONADDR0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCPOISONADDR0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xBC</csr:addressLow>
         <csr:addressHigh>0xBC</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCPOISONADDR1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCPOISONADDR1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC0</csr:addressLow>
         <csr:addressHigh>0xC0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.CRCPARCTL0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.CRCPARCTL0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC4</csr:addressLow>
         <csr:addressHigh>0xCB</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xCC</csr:addressLow>
         <csr:addressHigh>0xCC</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.CRCPARSTAT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.CRCPARSTAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD0</csr:addressLow>
         <csr:addressHigh>0xD0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.INIT0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD4</csr:addressLow>
         <csr:addressHigh>0xD4</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.INIT1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD8</csr:addressLow>
         <csr:addressHigh>0xD8</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.INIT2</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xDC</csr:addressLow>
         <csr:addressHigh>0xDC</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.INIT3</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT3</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xE0</csr:addressLow>
         <csr:addressHigh>0xE0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.INIT4</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT4</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xE4</csr:addressLow>
         <csr:addressHigh>0xE4</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.INIT5</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT5</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xE8</csr:addressLow>
         <csr:addressHigh>0xE8</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.INIT6</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT6</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xEC</csr:addressLow>
         <csr:addressHigh>0xEC</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.INIT7</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT7</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xF0</csr:addressLow>
         <csr:addressHigh>0xF0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DIMMCTL</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DIMMCTL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xF4</csr:addressLow>
         <csr:addressHigh>0xFF</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x100</csr:addressLow>
         <csr:addressHigh>0x100</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DRAMTMG0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x104</csr:addressLow>
         <csr:addressHigh>0x104</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DRAMTMG1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x108</csr:addressLow>
         <csr:addressHigh>0x108</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DRAMTMG2</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x10C</csr:addressLow>
         <csr:addressHigh>0x10C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DRAMTMG3</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG3</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x110</csr:addressLow>
         <csr:addressHigh>0x110</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DRAMTMG4</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG4</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x114</csr:addressLow>
         <csr:addressHigh>0x114</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DRAMTMG5</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG5</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x118</csr:addressLow>
         <csr:addressHigh>0x118</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DRAMTMG6</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG6</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x11C</csr:addressLow>
         <csr:addressHigh>0x11C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DRAMTMG7</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG7</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x120</csr:addressLow>
         <csr:addressHigh>0x120</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DRAMTMG8</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG8</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x124</csr:addressLow>
         <csr:addressHigh>0x12F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x130</csr:addressLow>
         <csr:addressHigh>0x130</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DRAMTMG12</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG12</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x134</csr:addressLow>
         <csr:addressHigh>0x134</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DRAMTMG13</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG13</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x138</csr:addressLow>
         <csr:addressHigh>0x138</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DRAMTMG14</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG14</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x13C</csr:addressLow>
         <csr:addressHigh>0x17F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x180</csr:addressLow>
         <csr:addressHigh>0x180</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ZQCTL0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ZQCTL0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x184</csr:addressLow>
         <csr:addressHigh>0x184</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ZQCTL1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ZQCTL1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x188</csr:addressLow>
         <csr:addressHigh>0x188</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ZQCTL2</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ZQCTL2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x18C</csr:addressLow>
         <csr:addressHigh>0x18C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ZQSTAT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ZQSTAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x190</csr:addressLow>
         <csr:addressHigh>0x190</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DFITMG0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFITMG0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x194</csr:addressLow>
         <csr:addressHigh>0x194</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DFITMG1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFITMG1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x198</csr:addressLow>
         <csr:addressHigh>0x198</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DFILPCFG0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFILPCFG0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x19C</csr:addressLow>
         <csr:addressHigh>0x19F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1A0</csr:addressLow>
         <csr:addressHigh>0x1A0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DFIUPD0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIUPD0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1A4</csr:addressLow>
         <csr:addressHigh>0x1A4</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DFIUPD1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIUPD1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1A8</csr:addressLow>
         <csr:addressHigh>0x1A8</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DFIUPD2</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIUPD2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1AC</csr:addressLow>
         <csr:addressHigh>0x1AF</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1B0</csr:addressLow>
         <csr:addressHigh>0x1B0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DFIMISC</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIMISC</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1B4</csr:addressLow>
         <csr:addressHigh>0x1B4</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DFITMG2</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFITMG2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1B8</csr:addressLow>
         <csr:addressHigh>0x1BB</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1BC</csr:addressLow>
         <csr:addressHigh>0x1BC</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DFISTAT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFISTAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1C0</csr:addressLow>
         <csr:addressHigh>0x1C0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DBICTL</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBICTL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1C4</csr:addressLow>
         <csr:addressHigh>0x1C4</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DFIPHYMSTR</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIPHYMSTR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1C8</csr:addressLow>
         <csr:addressHigh>0x203</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x204</csr:addressLow>
         <csr:addressHigh>0x204</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ADDRMAP1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x208</csr:addressLow>
         <csr:addressHigh>0x208</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ADDRMAP2</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x20C</csr:addressLow>
         <csr:addressHigh>0x20C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ADDRMAP3</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP3</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x210</csr:addressLow>
         <csr:addressHigh>0x210</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ADDRMAP4</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP4</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x214</csr:addressLow>
         <csr:addressHigh>0x214</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ADDRMAP5</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP5</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x218</csr:addressLow>
         <csr:addressHigh>0x218</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ADDRMAP6</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP6</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x21C</csr:addressLow>
         <csr:addressHigh>0x21C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ADDRMAP7</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP7</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x220</csr:addressLow>
         <csr:addressHigh>0x223</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x224</csr:addressLow>
         <csr:addressHigh>0x224</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ADDRMAP9</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP9</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x228</csr:addressLow>
         <csr:addressHigh>0x228</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ADDRMAP10</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP10</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x22C</csr:addressLow>
         <csr:addressHigh>0x22C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ADDRMAP11</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP11</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x230</csr:addressLow>
         <csr:addressHigh>0x23F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x240</csr:addressLow>
         <csr:addressHigh>0x240</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ODTCFG</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ODTCFG</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x244</csr:addressLow>
         <csr:addressHigh>0x244</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ODTMAP</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ODTMAP</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x248</csr:addressLow>
         <csr:addressHigh>0x24F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x250</csr:addressLow>
         <csr:addressHigh>0x250</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.SCHED</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.SCHED</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x254</csr:addressLow>
         <csr:addressHigh>0x254</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.SCHED1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.SCHED1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x258</csr:addressLow>
         <csr:addressHigh>0x25B</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x25C</csr:addressLow>
         <csr:addressHigh>0x25C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.PERFHPR1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PERFHPR1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x260</csr:addressLow>
         <csr:addressHigh>0x263</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x264</csr:addressLow>
         <csr:addressHigh>0x264</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.PERFLPR1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PERFLPR1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x268</csr:addressLow>
         <csr:addressHigh>0x26B</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x26C</csr:addressLow>
         <csr:addressHigh>0x26C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.PERFWR1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PERFWR1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x270</csr:addressLow>
         <csr:addressHigh>0x2FF</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x300</csr:addressLow>
         <csr:addressHigh>0x300</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DBG0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBG0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x304</csr:addressLow>
         <csr:addressHigh>0x304</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DBG1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBG1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x308</csr:addressLow>
         <csr:addressHigh>0x308</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DBGCAM</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBGCAM</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x30C</csr:addressLow>
         <csr:addressHigh>0x30C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DBGCMD</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBGCMD</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x310</csr:addressLow>
         <csr:addressHigh>0x310</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DBGSTAT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBGSTAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x314</csr:addressLow>
         <csr:addressHigh>0x317</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x318</csr:addressLow>
         <csr:addressHigh>0x318</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DBGCAM1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBGCAM1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x31C</csr:addressLow>
         <csr:addressHigh>0x31F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x320</csr:addressLow>
         <csr:addressHigh>0x320</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.SWCTL</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.SWCTL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x324</csr:addressLow>
         <csr:addressHigh>0x324</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.SWSTAT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.SWSTAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x328</csr:addressLow>
         <csr:addressHigh>0x36B</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x36C</csr:addressLow>
         <csr:addressHigh>0x36C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.POISONCFG</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.POISONCFG</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x370</csr:addressLow>
         <csr:addressHigh>0x370</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.POISONSTAT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.POISONSTAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x374</csr:addressLow>
         <csr:addressHigh>0x374</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ADVECCINDEX</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADVECCINDEX</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x378</csr:addressLow>
         <csr:addressHigh>0x37B</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x37C</csr:addressLow>
         <csr:addressHigh>0x37C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCPOISONPAT0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCPOISONPAT0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x380</csr:addressLow>
         <csr:addressHigh>0x383</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x384</csr:addressLow>
         <csr:addressHigh>0x384</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.ECCPOISONPAT2</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCPOISONPAT2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x388</csr:addressLow>
         <csr:addressHigh>0x3EF</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x3F0</csr:addressLow>
         <csr:addressHigh>0x3F0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_REGS.DERATESTAT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DERATESTAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x3F4</csr:addressLow>
         <csr:addressHigh>0x3F7</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x3F8</csr:addressLow>
         <csr:addressHigh>0x1AFF</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x3F8</csr:addressLow>
         <csr:addressHigh>0x3FB</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x3FC</csr:addressLow>
         <csr:addressHigh>0x3FC</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PSTAT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PSTAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x400</csr:addressLow>
         <csr:addressHigh>0x400</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCCFG</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCCFG</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x404</csr:addressLow>
         <csr:addressHigh>0x404</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCFGR_0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGR_0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x408</csr:addressLow>
         <csr:addressHigh>0x408</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCFGW_0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGW_0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x40C</csr:addressLow>
         <csr:addressHigh>0x48F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x490</csr:addressLow>
         <csr:addressHigh>0x490</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCTRL_0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCTRL_0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x494</csr:addressLow>
         <csr:addressHigh>0x494</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCFGQOS0_0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGQOS0_0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x498</csr:addressLow>
         <csr:addressHigh>0x498</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCFGQOS1_0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGQOS1_0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x49C</csr:addressLow>
         <csr:addressHigh>0x49C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCFGWQOS0_0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGWQOS0_0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4A0</csr:addressLow>
         <csr:addressHigh>0x4A0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCFGWQOS1_0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGWQOS1_0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4A4</csr:addressLow>
         <csr:addressHigh>0x4B3</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4B4</csr:addressLow>
         <csr:addressHigh>0x4B4</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCFGR_1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGR_1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4B8</csr:addressLow>
         <csr:addressHigh>0x4B8</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCFGW_1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGW_1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4BC</csr:addressLow>
         <csr:addressHigh>0x53F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x540</csr:addressLow>
         <csr:addressHigh>0x540</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCTRL_1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCTRL_1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x544</csr:addressLow>
         <csr:addressHigh>0x544</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCFGQOS0_1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGQOS0_1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x548</csr:addressLow>
         <csr:addressHigh>0x548</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCFGQOS1_1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGQOS1_1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x54C</csr:addressLow>
         <csr:addressHigh>0x54C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCFGWQOS0_1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGWQOS0_1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x550</csr:addressLow>
         <csr:addressHigh>0x550</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.PCFGWQOS1_1</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGWQOS1_1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x554</csr:addressLow>
         <csr:addressHigh>0xF23</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xF24</csr:addressLow>
         <csr:addressHigh>0xF24</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.SBRCTL</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.SBRCTL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xF28</csr:addressLow>
         <csr:addressHigh>0xF28</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.SBRSTAT</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.SBRSTAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xF2C</csr:addressLow>
         <csr:addressHigh>0xF2C</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.SBRWDATA0</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.SBRWDATA0</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xF30</csr:addressLow>
         <csr:addressHigh>0xFEF</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xFF0</csr:addressLow>
         <csr:addressHigh>0xFF0</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.UMCTL2_VER_NUMBER</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.UMCTL2_VER_NUMBER</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xFF4</csr:addressLow>
         <csr:addressHigh>0xFF4</csr:addressHigh>
         <csr:instanceName>APB_SLAVE.UMCTL2_MP.UMCTL2_VER_TYPE</csr:instanceName>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.UMCTL2_VER_TYPE</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xFF8</csr:addressLow>
         <csr:addressHigh>0x1AFF</csr:addressHigh>
        </csr:addressMapEntry>
       </csr:addressMap>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>group</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS</csr:referenceName>
       <csr:identifier>UMCTL2_REGS</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5427</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Apb_slave_UMCTL2_REGS</csr:typeName>
        <csr:description>
         <csr:p>uMCTL2 DDRC Registers</csr:p>
        </csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.MSTR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.STAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.MRCTRL0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.MRCTRL1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.MRSTAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DERATEEN</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DERATEINT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DERATECTL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PWRCTL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PWRTMG</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.HWLPCTL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.RFSHCTL0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.RFSHCTL3</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.RFSHTMG</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.RFSHTMG1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCFG0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCFG1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCSTAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCTL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCERRCNT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCADDR0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCADDR1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCSYN0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCSYN1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCSYN2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCBITMASK0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCBITMASK1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCBITMASK2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUADDR0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUADDR1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUSYN0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUSYN1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUSYN2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCPOISONADDR0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCPOISONADDR1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.CRCPARCTL0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.CRCPARSTAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT3</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT4</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT5</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT6</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT7</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DIMMCTL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG3</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG4</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG5</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG6</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG7</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG8</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG12</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG13</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG14</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ZQCTL0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ZQCTL1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ZQCTL2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ZQSTAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFITMG0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFITMG1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFILPCFG0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIUPD0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIUPD1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIUPD2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIMISC</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFITMG2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFISTAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBICTL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIPHYMSTR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP3</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP4</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP5</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP6</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP7</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP9</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP10</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP11</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ODTCFG</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ODTMAP</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.SCHED</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.SCHED1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PERFHPR1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PERFLPR1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PERFWR1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBG0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBG1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBGCAM</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBGCMD</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBGSTAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBGCAM1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.SWCTL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.SWSTAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.POISONCFG</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.POISONSTAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADVECCINDEX</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCPOISONPAT0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCPOISONPAT2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DERATESTAT</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.MSTR</csr:referenceName>
       <csr:identifier>MSTR</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_MSTR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_MSTR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_MSTR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_MSTR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>129</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00040000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_MSTR</csr:typeName>
        <csr:description>
         <csr:p>Master Register0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>1</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>lpddr2</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR2_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR2_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR2_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR2_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR2_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR2_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR2_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>40</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Select LPDDR2 SDRAM</csr:p>
         <csr:p> - 1 - LPDDR2 SDRAM device in use.</csr:p>
         <csr:p> - 0 - non-LPDDR2 device in use</csr:p>
         <csr:p>Present only in designs configured to support LPDDR2.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>lpddr3</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR3_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR3_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR3_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR3_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR3_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR3_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR3_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR3_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>51</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Select LPDDR3 SDRAM</csr:p>
         <csr:p> - 1 - LPDDR3 SDRAM device in use.</csr:p>
         <csr:p> - 0 - non-LPDDR3 device in use</csr:p>
         <csr:p>Present only in designs configured to support LPDDR3.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>lpddr4</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR4_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR4_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR4_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR4_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR4_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR4_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR4_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MSTR_LPDDR4_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>63</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p> Select LPDDR4 SDRAM</csr:p>
         <csr:p> - 1 - LPDDR4 SDRAM device in use.</csr:p>
         <csr:p> - 0 - non-LPDDR4 device in use</csr:p>
         <csr:p>Present only in designs configured to support LPDDR4.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>9</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>en_2t_timing_mode</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MSTR_EN_2T_TIMING_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MSTR_EN_2T_TIMING_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MSTR_EN_2T_TIMING_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MSTR_EN_2T_TIMING_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MSTR_EN_2T_TIMING_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MSTR_EN_2T_TIMING_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MSTR_EN_2T_TIMING_MODE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MSTR_EN_2T_TIMING_MODE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>82</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If 1, then uMCTL2 uses 2T timing. Otherwise, uses 1T timing. In 2T timing, all command signals (except chip select) are held for 2 clocks on the SDRAM bus. Chip select is asserted on the second cycle of the command</csr:p>
         <csr:p></csr:p>
         <csr:p>Note: </csr:p>
         <csr:p> - 2T timing is not supported in LPDDR2/LPDDR3/LPDDR4 mode</csr:p>
         <csr:p> - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set</csr:p>
         <csr:p> - 2T timing is not supported in DDR4 geardown mode.</csr:p>
         <csr:p> - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>11</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>data_bus_width</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MSTR_DATA_BUS_WIDTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MSTR_DATA_BUS_WIDTH_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MSTR_DATA_BUS_WIDTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MSTR_DATA_BUS_WIDTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MSTR_DATA_BUS_WIDTH_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MSTR_DATA_BUS_WIDTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MSTR_DATA_BUS_WIDTH_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MSTR_DATA_BUS_WIDTH_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>101</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects proportion of DQ bus width that is used by the SDRAM</csr:p>
         <csr:p> - 00 - Full DQ bus width to SDRAM</csr:p>
         <csr:p> - 01 - Half DQ bus width to SDRAM</csr:p>
         <csr:p> - 10 - Quarter DQ bus width to SDRAM</csr:p>
         <csr:p> - 11 - Reserved.</csr:p>
         <csr:p>Note that half bus width mode is only supported when the SDRAM bus width is a multiple of 16, and quarter bus width mode is only supported when the SDRAM bus width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is set. Bus width refers to DQ bus width (excluding any ECC width).</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>burst_rdwr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MSTR_BURST_RDWR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MSTR_BURST_RDWR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MSTR_BURST_RDWR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MSTR_BURST_RDWR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MSTR_BURST_RDWR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MSTR_BURST_RDWR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MSTR_BURST_RDWR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MSTR_BURST_RDWR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>128</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SDRAM burst length used:</csr:p>
         <csr:p> - 0001 - Burst length of 2 (only supported for mDDR)</csr:p>
         <csr:p> - 0010 - Burst length of 4</csr:p>
         <csr:p> - 0100 - Burst length of 8</csr:p>
         <csr:p> - 1000 - Burst length of 16 (only supported for mDDR, LPDDR2, and LPDDR4)</csr:p>
         <csr:p> All other values are reserved.</csr:p>
         <csr:p>This controls the burst size used to access the SDRAM. This must match the burst length mode register setting in the SDRAM. (For BC4/8 on-the-fly mode of DDR3 and DDR4, set this field to 0x0100) Burst length of 2 is not supported with AXI ports when MEMC_BURST_LENGTH is 8.</csr:p>
         <csr:p></csr:p>
         <csr:p> Burst length of 2 is only supported when the controller is operating in 1:1 frequency mode. </csr:p>
         <csr:p></csr:p>
         <csr:p> For DDR3, DDR4 and LPDDR3, this must be set to 0x0100 (BL8). </csr:p>
         <csr:p></csr:p>
         <csr:p> For LPDDR4, this must be set to 0x1000 (BL16).</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x4</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.STAT</csr:referenceName>
       <csr:identifier>STAT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_STAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_STAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_STAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_STAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>213</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x4</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_STAT</csr:typeName>
        <csr:description>
         <csr:p>Operating Mode Status Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>operating_mode</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_STAT_OPERATING_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_STAT_OPERATING_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_STAT_OPERATING_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_STAT_OPERATING_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_STAT_OPERATING_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_STAT_OPERATING_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_STAT_OPERATING_MODE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_STAT_OPERATING_MODE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>160</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Operating mode. This is 3-bits wide in configurations with mDDR/LPDDR2/LPDDR3/LPDDR4/DDR4 support and 2-bits in all other configurations.</csr:p>
         <csr:p>non-mDDR/LPDDR2/LPDDR3/LPDDR4 and non-DDR4 designs:</csr:p>
         <csr:p> - 00 - Init</csr:p>
         <csr:p> - 01 - Normal</csr:p>
         <csr:p> - 10 - Power-down</csr:p>
         <csr:p> - 11 - Self refresh</csr:p>
         <csr:p>mDDR/LPDDR2/LPDDR3 or DDR4 designs:</csr:p>
         <csr:p> - 000 - Init</csr:p>
         <csr:p> - 001 - Normal</csr:p>
         <csr:p> - 010 - Power-down</csr:p>
         <csr:p> - 011 - Self refresh</csr:p>
         <csr:p> - 1XX - Deep power-down / Maximum Power Saving Mode</csr:p>
         <csr:p>LPDDR4 designs:</csr:p>
         <csr:p> - 000 - Init</csr:p>
         <csr:p> - 001 - Normal</csr:p>
         <csr:p> - 010 - Power-down</csr:p>
         <csr:p> - 011 - Self refresh / Self refresh power-down</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>selfref_type</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_TYPE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_TYPE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_TYPE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_TYPE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_TYPE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_TYPE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_TYPE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_TYPE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>187</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Flags if Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4) is entered and if it was under Automatic Self Refresh control only or not.    </csr:p>
         <csr:p> - 00 - SDRAM is not in Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4). If retry is enabled by CRCPARCTRL1.crc_parity_retry_enable, this also indicates SRE command is still in parity error window or retry is in-progress.</csr:p>
         <csr:p> - 11 - SDRAM is in Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4), which was caused by Automatic Self Refresh only. If retry is enabled, this guarantees SRE command is executed correctly without parity error.</csr:p>
         <csr:p> - 10 - SDRAM is in Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4), which was not caused solely under Automatic Self Refresh control. It could have been caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw). If retry is enabled, this guarantees SRE command is executed correctly without parity error.</csr:p>
         <csr:p> - 01 - SDRAM is in Self Refresh, which was caused by PHY Master Request.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>selfref_state</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_STATE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_STATE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_STATE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_STATE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_STATE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_STATE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_STATE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_STATE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>202</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Self refresh state. This indicates self refresh or self refresh power down state for LPDDR4.</csr:p>
         <csr:p>This register is used for frequency change and MRR/MRW access during self refresh.</csr:p>
         <csr:p> - 00 - SDRAM is not in Self Refresh.</csr:p>
         <csr:p> - 01 - Self refresh 1</csr:p>
         <csr:p> - 10 - Self refresh power down</csr:p>
         <csr:p> - 11 - Self refresh 2</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>11</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>selfref_cam_not_empty</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_CAM_NOT_EMPTY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_CAM_NOT_EMPTY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_CAM_NOT_EMPTY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_CAM_NOT_EMPTY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_CAM_NOT_EMPTY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_CAM_NOT_EMPTY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_CAM_NOT_EMPTY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_STAT_SELFREF_CAM_NOT_EMPTY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>212</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Self refresh with CAMs not empty. Set to 1 when Self Refresh is entered but CAMs are not drained. Cleared after exiting Self Refresh.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.MRCTRL0</csr:referenceName>
       <csr:identifier>MRCTRL0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_MRCTRL0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_MRCTRL0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>319</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x10</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000010</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_MRCTRL0</csr:typeName>
        <csr:description>
         <csr:p>Mode Register Read/Write Control Register 0.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note: Do not enable more than one of the following fields simultaneously:</csr:p>
         <csr:p>- sw_init_int</csr:p>
         <csr:p>- pda_en</csr:p>
         <csr:p>- mpr_en</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>mr_type</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_TYPE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_TYPE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_TYPE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_TYPE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_TYPE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_TYPE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_TYPE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_TYPE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>233</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates whether the mode register operation is read or write. Only used for LPDDR2/LPDDR3/LPDDR4/DDR4.</csr:p>
         <csr:p> - 0 - Write</csr:p>
         <csr:p> - 1 - Read</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>2</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>sw_init_int</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_SW_INIT_INT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_SW_INIT_INT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_SW_INIT_INT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_SW_INIT_INT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_SW_INIT_INT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_SW_INIT_INT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_SW_INIT_INT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_SW_INIT_INT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>255</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates whether Software intervention is allowed via MRCTRL0/MRCTRL1 before automatic SDRAM initialization routine or not.</csr:p>
         <csr:p>For DDR4, this bit can be used to initialize the DDR4 RCD (MR7) before automatic SDRAM initialization.</csr:p>
         <csr:p>For LPDDR4, this bit can be used to program additional mode registers before automatic SDRAM initialization if necessary.</csr:p>
         <csr:p>In LPDDR4 dual channel mode, note that this must be programmed to both channels beforehand.</csr:p>
         <csr:p>Note that this must be cleared to 0 after completing Software operation. Otherwise, SDRAM initialization routine will not re-start.</csr:p>
         <csr:p> - 0 - Software intervention is not allowed</csr:p>
         <csr:p> - 1 - Software intervention is allowed</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>mr_rank</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_RANK_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_RANK_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_RANK_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_RANK_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_RANK_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_RANK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_RANK_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_RANK_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>273</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Controls which rank is accessed by MRCTRL0.mr_wr. Normally, it is desired to access all ranks, so all bits should be set to 1. However, for multi-rank UDIMMs/RDIMMs/LRDIMMs which implement address mirroring, it may be necessary to access ranks individually.</csr:p>
         <csr:p>Examples (assume uMCTL2 is configured for 4 ranks):</csr:p>
         <csr:p>    - 0x1 - select rank 0 only</csr:p>
         <csr:p>    - 0x2 - select rank 1 only</csr:p>
         <csr:p>    - 0x5 - select ranks 0 and 2</csr:p>
         <csr:p>    - 0xA - select ranks 1 and 3</csr:p>
         <csr:p>    - 0xF - select ranks 0, 1, 2 and 3</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>11</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>mr_addr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_ADDR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_ADDR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_ADDR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_ADDR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_ADDR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_ADDR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_ADDR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_ADDR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>302</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Address of the mode register that is to be written to.</csr:p>
         <csr:p> - 0000 - MR0</csr:p>
         <csr:p> - 0001 - MR1</csr:p>
         <csr:p> - 0010 - MR2</csr:p>
         <csr:p> - 0011 - MR3</csr:p>
         <csr:p> - 0100 - MR4</csr:p>
         <csr:p> - 0101 - MR5</csr:p>
         <csr:p> - 0110 - MR6</csr:p>
         <csr:p> - 0111 - MR7</csr:p>
         <csr:p>Don't Care for LPDDR2/LPDDR3/LPDDR4 (see MRCTRL1.mr_data for mode register addressing in LPDDR2/LPDDR3/LPDDR4).</csr:p>
         <csr:p></csr:p>
         <csr:p>This signal is also used for writing to control words of the register chip on RDIMMs/LRDIMMs. In that case, it corresponds to the bank address bits sent to the RDIMM/LRDIMM.</csr:p>
         <csr:p></csr:p>
         <csr:p>In case of DDR4, the bit[3:2] corresponds to the bank group bits. Therefore, the bit[3] as well as the bit[2:0] must be set to an appropriate value which is considered both the Address Mirroring of UDIMMs/RDIMMs/LRDIMMs and the Output Inversion of RDIMMs/LRDIMMs.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>30</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>mr_wr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_WR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_WR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_WR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_WR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_WR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_WR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_WR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL0_MR_WR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>318</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Setting this register bit to 1 triggers a mode register read or write operation. When the MR operation is complete, the uMCTL2 automatically clears this bit.</csr:p>
         <csr:p> The other register fields of this register must be written in a separate APB transaction, before setting this mr_wr bit. It is recommended NOT to set this signal if in Init, Deep power-down or MPSM operating modes.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1S</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.MRCTRL1</csr:referenceName>
       <csr:identifier>MRCTRL1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_MRCTRL1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_MRCTRL1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>337</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x14</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_MRCTRL1</csr:typeName>
        <csr:description>
         <csr:p>Mode Register Read/Write Control Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>mr_data</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL1_MR_DATA_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL1_MR_DATA_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL1_MR_DATA_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL1_MR_DATA_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL1_MR_DATA_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL1_MR_DATA_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL1_MR_DATA_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MRCTRL1_MR_DATA_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>336</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Mode register write data for all non-LPDDR2/non-LPDDR3/non-LPDDR4 modes.</csr:p>
         <csr:p>For LPDDR2/LPDDR3/LPDDR4, MRCTRL1[15:0] are interpreted as</csr:p>
         <csr:p>[15:8] MR Address</csr:p>
         <csr:p>[7:0] MR data for writes, don't care for reads. This is 18-bits wide in configurations with DDR4 support and 16-bits in all other configurations.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.MRSTAT</csr:referenceName>
       <csr:identifier>MRSTAT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_MRSTAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_MRSTAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_MRSTAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_MRSTAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>359</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x18</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_MRSTAT</csr:typeName>
        <csr:description>
         <csr:p>Mode Register Read/Write Status Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>mr_wr_busy</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_MRSTAT_MR_WR_BUSY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_MRSTAT_MR_WR_BUSY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_MRSTAT_MR_WR_BUSY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_MRSTAT_MR_WR_BUSY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_MRSTAT_MR_WR_BUSY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_MRSTAT_MR_WR_BUSY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_MRSTAT_MR_WR_BUSY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_MRSTAT_MR_WR_BUSY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>358</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The SoC core may initiate a MR write operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the MRW/MRR request. It goes low when the MRW/MRR command is issued to the SDRAM. It is recommended not to perform MRW/MRR commands when 'MRSTAT.mr_wr_busy' is high.</csr:p>
         <csr:p> - 0 - Indicates that the SoC core can initiate a mode register write operation</csr:p>
         <csr:p> - 1 - Indicates that mode register write operation is in progress</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DERATEEN</csr:referenceName>
       <csr:identifier>DERATEEN</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DERATEEN_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DERATEEN_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>447</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x20</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DERATEEN</csr:typeName>
        <csr:description>
         <csr:p>Temperature Derate Enable Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>derate_enable</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_ENABLE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_ENABLE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_ENABLE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_ENABLE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_ENABLE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_ENABLE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_ENABLE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_ENABLE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>378</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enables derating</csr:p>
         <csr:p> - 0 - Timing parameter derating is disabled</csr:p>
         <csr:p> - 1 - Timing parameter derating is enabled using MR4 read value.</csr:p>
         <csr:p>Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4</csr:p>
         <csr:p></csr:p>
         <csr:p>This field must be set to '0' for non-LPDDR2/LPDDR3/LPDDR4 mode.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>derate_value</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_VALUE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_VALUE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_VALUE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_VALUE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_VALUE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_VALUE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_VALUE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_VALUE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>397</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Derate value</csr:p>
         <csr:p> - 0 - Derating uses +1</csr:p>
         <csr:p> - 1 - Derating uses +2</csr:p>
         <csr:p>Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4</csr:p>
         <csr:p></csr:p>
         <csr:p>Set to 0 for all LPDDR2 speed grades as derating value of +1.875 ns is less than a core_ddrc_core_clk period.</csr:p>
         <csr:p>For LPDDR3/4, if the period of core_ddrc_core_clk is less than 1.875ns, this register field should be set to 1; otherwise it should be set to 0.</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>derate_byte</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_BYTE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_BYTE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_BYTE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_BYTE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_BYTE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_BYTE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_BYTE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_BYTE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>412</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Derate byte</csr:p>
         <csr:p>Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4</csr:p>
         <csr:p></csr:p>
         <csr:p>Indicates which byte of the MRR data is used for derating. The maximum valid value depends</csr:p>
         <csr:p>on MEMC_DRAM_TOTAL_DATA_WIDTH.</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rc_derate_value</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_RC_DERATE_VALUE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_RC_DERATE_VALUE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_RC_DERATE_VALUE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_RC_DERATE_VALUE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_RC_DERATE_VALUE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_RC_DERATE_VALUE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_RC_DERATE_VALUE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_RC_DERATE_VALUE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>430</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Derate value of tRC for LPDDR4</csr:p>
         <csr:p> - 0 - Derating uses +1</csr:p>
         <csr:p> - 1 - Derating uses +2</csr:p>
         <csr:p> - 2 - Derating uses +3</csr:p>
         <csr:p> - 3 - Derating uses +4</csr:p>
         <csr:p>Present only in designs configured to support LPDDR4.</csr:p>
         <csr:p>The required cycles for derating can be determined by dividing 3.75ns by the core_ddrc_core_clk period, and rounding it up to the next integer. Hence this register field should be set to the above value - 1.</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>11</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>derate_mr4_tuf_dis</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_MR4_TUF_DIS_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_MR4_TUF_DIS_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_MR4_TUF_DIS_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_MR4_TUF_DIS_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_MR4_TUF_DIS_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_MR4_TUF_DIS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_MR4_TUF_DIS_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DERATEEN_DERATE_MR4_TUF_DIS_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>446</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Disable use of MR4 TUF flag (MR4[7]) bit.</csr:p>
         <csr:p> - 0 - Use MR4 TUF flag (MR4[7])</csr:p>
         <csr:p> - 1 - Do not use MR4 TUF Flag (MR4[7])</csr:p>
         <csr:p>For LPDDR4, it is recommended to set this register to 1.</csr:p>
         <csr:p>For LPDDR2 and LPDDR3, please contact your memory vendor for recommended usage.</csr:p>
         <csr:p>This affects both the periodic derate logic (DERATEEN.derate_enable) and the derate_temp_limit_intr.</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DERATEINT</csr:referenceName>
       <csr:identifier>DERATEINT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DERATEINT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DERATEINT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DERATEINT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DERATEINT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>464</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x24</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00800000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DERATEINT</csr:typeName>
        <csr:description>
         <csr:p>Temperature Derate Interval Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>mr4_read_interval</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DERATEINT_MR4_READ_INTERVAL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DERATEINT_MR4_READ_INTERVAL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DERATEINT_MR4_READ_INTERVAL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DERATEINT_MR4_READ_INTERVAL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DERATEINT_MR4_READ_INTERVAL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DERATEINT_MR4_READ_INTERVAL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DERATEINT_MR4_READ_INTERVAL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DERATEINT_MR4_READ_INTERVAL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>463</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interval between two MR4 reads, used to derate the timing parameters.</csr:p>
         <csr:p>Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4. This register must not be set to zero.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00800000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DERATECTL</csr:referenceName>
       <csr:identifier>DERATECTL</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DERATECTL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DERATECTL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>506</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x2C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000001</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DERATECTL</csr:typeName>
        <csr:description>
         <csr:p>Temperature Derate Control Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>derate_temp_limit_intr_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>479</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt enable bit for derate_temp_limit_intr output pin.</csr:p>
         <csr:p>  -  1 Enabled</csr:p>
         <csr:p>  -   0 Disabled</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>derate_temp_limit_intr_clr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>491</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt clear bit for derate_temp_limit_intr.</csr:p>
         <csr:p>  At the end of the interrupt clear operation, the uMCTL2 automatically clears this bit.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>derate_temp_limit_intr_force</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>505</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt force bit for derate_temp_limit_intr. </csr:p>
         <csr:p>  Setting this register to 1 will cause the derate_temp_limit_intr output pin to be asserted.</csr:p>
         <csr:p>  At the end of the interrupt force operation, the uMCTL2 automatically clears this bit.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PWRCTL</csr:referenceName>
       <csr:identifier>PWRCTL</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_PWRCTL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_PWRCTL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>639</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x30</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_PWRCTL</csr:typeName>
        <csr:description>
         <csr:p>Low Power Control Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>selfref_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>521</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If true then the uMCTL2 puts the SDRAM into Self Refresh after a programmable number of cycles "maximum idle clocks before Self Refresh (PWRTMG.selfref_to_x32)". This register bit may be re-programmed during the course of normal operation.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>powerdown_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_POWERDOWN_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_POWERDOWN_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_POWERDOWN_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_POWERDOWN_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_POWERDOWN_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_POWERDOWN_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_POWERDOWN_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_POWERDOWN_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>533</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If true then the uMCTL2 goes into power-down after a programmable number of cycles "maximum idle clocks before power down" (PWRTMG.powerdown_to_x32).</csr:p>
         <csr:p>This register bit may be re-programmed during the course of normal operation.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>deeppowerdown_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DEEPPOWERDOWN_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DEEPPOWERDOWN_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DEEPPOWERDOWN_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DEEPPOWERDOWN_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DEEPPOWERDOWN_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DEEPPOWERDOWN_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DEEPPOWERDOWN_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DEEPPOWERDOWN_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>549</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When this is 1, uMCTL2 puts the SDRAM into deep power-down mode when the transaction store is empty.</csr:p>
         <csr:p>This register must be reset to '0' to bring uMCTL2 out of deep power-down mode. Controller performs automatic SDRAM initialization on deep power-down exit.</csr:p>
         <csr:p>Present only in designs configured to support mDDR or LPDDR2 or LPDDR3. For non-mDDR/non-LPDDR2/non-LPDDR3, this register should not be set to 1.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>en_dfi_dram_clk_disable</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>578</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enable the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM.</csr:p>
         <csr:p></csr:p>
         <csr:p>If set to 0, dfi_dram_clk_disable is never asserted.</csr:p>
         <csr:p></csr:p>
         <csr:p>Assertion of dfi_dram_clk_disable is as follows:</csr:p>
         <csr:p></csr:p>
         <csr:p>In DDR2/DDR3, can only be asserted in Self Refresh.</csr:p>
         <csr:p></csr:p>
         <csr:p>In DDR4, can be asserted in following:</csr:p>
         <csr:p>  - in Self Refresh.</csr:p>
         <csr:p>  - in Maximum Power Saving Mode</csr:p>
         <csr:p>In mDDR/LPDDR2/LPDDR3, can be asserted in following:</csr:p>
         <csr:p>  - in Self Refresh</csr:p>
         <csr:p>  - in Power Down</csr:p>
         <csr:p>  - in Deep Power Down</csr:p>
         <csr:p>  - during Normal operation (Clock Stop)</csr:p>
         <csr:p>In LPDDR4, can be asserted in following:</csr:p>
         <csr:p>  - in Self Refresh Power Down</csr:p>
         <csr:p>  - in Power Down</csr:p>
         <csr:p>  - during Normal operation (Clock Stop)</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>selfref_sw</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_SW_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_SW_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_SW_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_SW_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_SW_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_SW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_SW_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_SELFREF_SW_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>592</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>A value of 1 to this register causes system to move to Self Refresh state immediately, as long as it is not in INIT or DPD/MPSM operating_mode. This is referred to as Software Entry/Exit to Self Refresh.</csr:p>
         <csr:p>  - 1 - Software Entry to Self Refresh</csr:p>
         <csr:p>  - 0 - Software Exit from Self Refresh</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>stay_in_selfref</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_STAY_IN_SELFREF_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_STAY_IN_SELFREF_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_STAY_IN_SELFREF_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_STAY_IN_SELFREF_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_STAY_IN_SELFREF_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_STAY_IN_SELFREF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_STAY_IN_SELFREF_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_STAY_IN_SELFREF_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>607</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Self refresh state is an intermediate state to enter to Self refresh power down state or exit Self refresh power down state for LPDDR4.</csr:p>
         <csr:p>This register controls transition from the Self refresh state.</csr:p>
         <csr:p>  - 1 - Prohibit transition from Self refresh state</csr:p>
         <csr:p>  - 0 - Allow transition from Self refresh state</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dis_cam_drain_selfref</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DIS_CAM_DRAIN_SELFREF_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DIS_CAM_DRAIN_SELFREF_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DIS_CAM_DRAIN_SELFREF_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DIS_CAM_DRAIN_SELFREF_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DIS_CAM_DRAIN_SELFREF_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DIS_CAM_DRAIN_SELFREF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DIS_CAM_DRAIN_SELFREF_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_DIS_CAM_DRAIN_SELFREF_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>624</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates whether skipping CAM draining is allowed when entering Self-Refresh.</csr:p>
         <csr:p>This register field cannot be modified while PWRCTL.selfref_sw==1.</csr:p>
         <csr:p>  - 0 - CAMs must be empty before entering SR</csr:p>
         <csr:p>  - 1 - CAMs are not emptied before entering SR (unsupported)</csr:p>
         <csr:p>  Note, PWRCTL.dis_cam_drain_selfref=1 is unsupported in this release. PWRCTL.dis_cam_drain_selfref=0 is required.</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>lpddr4_sr_allowed</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_LPDDR4_SR_ALLOWED_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_LPDDR4_SR_ALLOWED_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_LPDDR4_SR_ALLOWED_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_LPDDR4_SR_ALLOWED_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_LPDDR4_SR_ALLOWED_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_LPDDR4_SR_ALLOWED_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_LPDDR4_SR_ALLOWED_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PWRCTL_LPDDR4_SR_ALLOWED_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>638</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates whether transition from SR-PD to SR and back to SR-PD is allowed. </csr:p>
         <csr:p>This register field cannot be modified while PWRCTL.selfref_sw==1.</csr:p>
         <csr:p>  - 0 - SR-PD -&gt; SR -&gt; SR-PD not allowed</csr:p>
         <csr:p>  - 1 - SR-PD -&gt; SR -&gt; SR-PD allowed</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PWRTMG</csr:referenceName>
       <csr:identifier>PWRTMG</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_PWRTMG_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_PWRTMG_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>698</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x34</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00402010</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_PWRTMG</csr:typeName>
        <csr:description>
         <csr:p>Low Power Timing Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>powerdown_to_x32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_POWERDOWN_TO_X32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_POWERDOWN_TO_X32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_POWERDOWN_TO_X32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_POWERDOWN_TO_X32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_POWERDOWN_TO_X32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_POWERDOWN_TO_X32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_POWERDOWN_TO_X32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_POWERDOWN_TO_X32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>659</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>After this many clocks of the DDRC command channel being idle the uMCTL2 automatically puts the SDRAM into power-down. The DDRC command channel is considered idle when there are no HIF commands outstanding. This must be enabled in the PWRCTL.powerdown_en.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Unit: Multiples of 32 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 4</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x10</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_dpd_x4096</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_T_DPD_X4096_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_T_DPD_X4096_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_T_DPD_X4096_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_T_DPD_X4096_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_T_DPD_X4096_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_T_DPD_X4096_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_T_DPD_X4096_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_T_DPD_X4096_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>679</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Minimum deep power-down time.</csr:p>
         <csr:p>For mDDR, value from the JEDEC specification is 0 as mDDR exits from deep power-down mode immediately after PWRCTL.deeppowerdown_en is de-asserted.</csr:p>
         <csr:p>For LPDDR2/LPDDR3, value from the JEDEC specification is 500us.</csr:p>
         <csr:p>Present only in designs configured to support mDDR, LPDDR2 or LPDDR3.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Unit: Multiples of 4096 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 4</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x20</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>selfref_to_x32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_SELFREF_TO_X32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_SELFREF_TO_X32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_SELFREF_TO_X32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_SELFREF_TO_X32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_SELFREF_TO_X32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_SELFREF_TO_X32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_SELFREF_TO_X32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PWRTMG_SELFREF_TO_X32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>697</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>After this many clocks of the DDRC command channel being idle the uMCTL2 automatically puts the SDRAM into Self Refresh.</csr:p>
         <csr:p>The DDRC command channel is considered idle when there are no HIF commands outstanding. This must be enabled in the PWRCTL.selfref_en.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Unit: Multiples of 32 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 4</csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x40</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.HWLPCTL</csr:referenceName>
       <csr:identifier>HWLPCTL</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_HWLPCTL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_HWLPCTL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>743</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x38</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000003</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_HWLPCTL</csr:typeName>
        <csr:description>
         <csr:p>Hardware Low Power Control Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>hw_lp_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>710</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enable for Hardware Low Power Interface.</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>hw_lp_exit_idle_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EXIT_IDLE_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EXIT_IDLE_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EXIT_IDLE_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EXIT_IDLE_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EXIT_IDLE_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EXIT_IDLE_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EXIT_IDLE_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_EXIT_IDLE_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>723</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When this bit is programmed to 1 the cactive_in_ddrc pin of the DDRC can be used to exit from the automatic clock stop, automatic power down or automatic self-refresh modes. Note, it will not cause exit of Self-Refresh that was caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>hw_lp_idle_x32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_IDLE_X32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_IDLE_X32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_IDLE_X32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_IDLE_X32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_IDLE_X32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_IDLE_X32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_IDLE_X32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_HWLPCTL_HW_LP_IDLE_X32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>742</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Hardware idle period. The cactive_ddrc output is driven low if the DDRC command channel is idle for hw_lp_idle * 32 cycles if not in INIT or DPD/MPSM operating_mode. The DDRC command channel is considered idle when there are no HIF commands outstanding. The hardware idle function is disabled when hw_lp_idle_x32=0. hw_lp_idle_x32=1 is an illegal value.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Unit: Multiples of 32 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>27</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.RFSHCTL0</csr:referenceName>
       <csr:identifier>RFSHCTL0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_RFSHCTL0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_RFSHCTL0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>847</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x50</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00210000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_RFSHCTL0</csr:typeName>
        <csr:description>
         <csr:p>Refresh Control Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>1</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>per_bank_refresh</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_PER_BANK_REFRESH_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_PER_BANK_REFRESH_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_PER_BANK_REFRESH_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_PER_BANK_REFRESH_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_PER_BANK_REFRESH_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_PER_BANK_REFRESH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_PER_BANK_REFRESH_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_PER_BANK_REFRESH_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>761</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p> - 1 - Per bank refresh</csr:p>
         <csr:p> - 0 - All bank refresh</csr:p>
         <csr:p>Per bank refresh allows traffic to flow to other banks. Per bank refresh is not supported by all LPDDR2 devices but should be supported by all LPDDR3/LPDDR4 devices. Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>refresh_burst</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_BURST_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_BURST_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_BURST_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_BURST_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_BURST_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_BURST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_BURST_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_BURST_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>799</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The programmed value + 1 is the number of refresh timeouts that is allowed to accumulate before traffic is blocked and the refreshes are forced to execute. Closing pages to perform a refresh is a one-time penalty that must be paid for each group of refreshes. Therefore, performing refreshes in a burst reduces the per-refresh penalty of these page closings. Higher numbers for RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases the worst-case latency associated with refreshes.</csr:p>
         <csr:p> - 0 - single refresh</csr:p>
         <csr:p> - 1 - burst-of-2 refresh</csr:p>
         <csr:p> - 7 - burst-of-8 refresh</csr:p>
         <csr:p>For information on burst refresh feature refer to section 3.9 of DDR2 JEDEC specification - JESD79-2F.pdf.</csr:p>
         <csr:p>For DDR2/3, the refresh is always per-rank and not per-bank. The rank refresh can be accumulated over 8*tREFI cycles using the burst refresh feature.</csr:p>
         <csr:p></csr:p>
         <csr:p>In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode. If using PHY-initiated updates, care must be taken in the setting of RFSHCTL0.refresh_burst, to ensure that tRFCmax is not violated due to a PHY-initiated update occurring shortly before a refresh burst was due. In this situation, the refresh burst will be delayed until the PHY-initiated update is complete.</csr:p>
         <csr:p>In per-bank refresh mode of LPDDR2/LPDDR3/LPDDR4 (RFSHCTL0.per_bank_refresh = 1), 64 refreshes can be postponed.</csr:p>
         <csr:p>Programming Mode: Dynamic - Refresh Related</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>11</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>refresh_to_x1_x32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_TO_X1_X32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_TO_X1_X32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_TO_X1_X32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_TO_X1_X32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_TO_X1_X32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_TO_X1_X32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_TO_X1_X32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_TO_X1_X32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>823</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If the refresh timer (tRFCnom, also known as tREFI) has expired at least once, then a speculative refresh may be performed. A speculative refresh is a refresh performed at a time when refresh would be useful. When the SDRAM bus is idle for a period of time determined by this RFSHCTL0.refresh_to_x1_x32 and the refresh timer has expired at least once since the last refresh, then a speculative refresh is performed. Speculative refreshes continues successively until there are no refreshes pending or until new reads or writes are issued to the uMCTL2.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY. </csr:p>
         <csr:p>Unit: DFI clock cycles or multiples of 32 DFI clock cycles, depending on RFSHTMG.t_rfc_nom_x1_sel.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Dynamic - Refresh Related</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x10</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>19</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>refresh_margin</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_MARGIN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_MARGIN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_MARGIN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_MARGIN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_MARGIN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_MARGIN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_MARGIN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL0_REFRESH_MARGIN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>846</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Threshold value in number of DFI clock cycles before the critical refresh or page timer expires. A critical refresh is to be issued before this threshold is reached. It is recommended that this not be changed from the default value, currently shown as 0x2. It must always be less than internally used t_rfc_nom/32.</csr:p>
         <csr:p> Note that internally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32 * 32 if RFSHTMG.t_rfc_nom_x1_sel=0. If RFSHTMG.t_rfc_nom_x1_sel=1 (for LPDDR2/LPDDR3/LPDDR4 per-bank refresh only), internally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32. Note that, in LPDDR2/LPDDR3/LPDDR4, internally used t_rfc_nom may be divided by four if derating is enabled (DERATEEN.derate_enable=1).</csr:p>
         <csr:p>Unit: Multiples of 32 DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Dynamic - Refresh Related</csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x2</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.RFSHCTL3</csr:referenceName>
       <csr:identifier>RFSHCTL3</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_RFSHCTL3_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_RFSHCTL3_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>884</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x60</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_RFSHCTL3</csr:typeName>
        <csr:description>
         <csr:p>Refresh Control Register 3</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dis_auto_refresh</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_DIS_AUTO_REFRESH_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_DIS_AUTO_REFRESH_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_DIS_AUTO_REFRESH_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_DIS_AUTO_REFRESH_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_DIS_AUTO_REFRESH_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_DIS_AUTO_REFRESH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_DIS_AUTO_REFRESH_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_DIS_AUTO_REFRESH_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>870</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When '1', disable auto-refresh generated by the uMCTL2. When auto-refresh is disabled, the SoC core must generate refreshes using the registers DBGCMD.rankn_refresh.</csr:p>
         <csr:p>When dis_auto_refresh transitions from 0 to 1, any pending refreshes are immediately scheduled by the uMCTL2.</csr:p>
         <csr:p>If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), disable auto-refresh is not supported, and this bit must be set to '0'.</csr:p>
         <csr:p>(DDR4 only) If FGR mode is enabled (RFSHCTL3.refresh_mode &gt; 0), disable auto-refresh is not supported, and this bit must be set to '0'.</csr:p>
         <csr:p>This register field is changeable on the fly.</csr:p>
         <csr:p>Programming Mode: Dynamic - Refresh Related</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>refresh_update_level</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_REFRESH_UPDATE_LEVEL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_REFRESH_UPDATE_LEVEL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_REFRESH_UPDATE_LEVEL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_REFRESH_UPDATE_LEVEL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_REFRESH_UPDATE_LEVEL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_REFRESH_UPDATE_LEVEL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_REFRESH_UPDATE_LEVEL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_RFSHCTL3_REFRESH_UPDATE_LEVEL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>883</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the refresh register(s) have been updated.</csr:p>
         <csr:p>refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0).</csr:p>
         <csr:p>The refresh register(s) are automatically updated when exiting reset.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.RFSHTMG</csr:referenceName>
       <csr:identifier>RFSHTMG</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_RFSHTMG_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_RFSHTMG_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>995</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x64</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0062008c</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_RFSHTMG</csr:typeName>
        <csr:description>
         <csr:p>Refresh Timing Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>t_rfc_min</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_MIN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_MIN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_MIN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_MIN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_MIN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_MIN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_MIN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_MIN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>915</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tRFC (min): Minimum time from refresh to refresh or activate.</csr:p>
         <csr:p></csr:p>
         <csr:p>When the controller is operating in 1:1 mode, t_rfc_min should be set to RoundUp(tRFCmin/tCK).</csr:p>
         <csr:p></csr:p>
         <csr:p>When the controller is operating in 1:2 mode, t_rfc_min should be set to RoundUp(RoundUp(tRFCmin/tCK)/2).</csr:p>
         <csr:p></csr:p>
         <csr:p>In LPDDR2/LPDDR3/LPDDR4 mode:</csr:p>
         <csr:p>  - if using all-bank refreshes, the tRFCmin value in the above equations is equal to tRFCab</csr:p>
         <csr:p>  - if using per-bank refreshes, the tRFCmin value in the above equations is equal to tRFCpb</csr:p>
         <csr:p>In DDR4 mode, the tRFCmin value in the above equations is different depending on the refresh mode (fixed 1X,2X,4X) and the device density. The user should program the appropriate value from the spec based on the 'refresh_mode' and the device density that is used.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Dynamic - Refresh Related</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x08c</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>14</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>lpddr3_trefbw_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_LPDDR3_TREFBW_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_LPDDR3_TREFBW_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_LPDDR3_TREFBW_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_LPDDR3_TREFBW_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_LPDDR3_TREFBW_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_LPDDR3_TREFBW_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_LPDDR3_TREFBW_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_LPDDR3_TREFBW_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>929</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Used only when LPDDR3 memory type is connected. Should only be changed when uMCTL2 is in reset. Specifies whether to use the tREFBW parameter (required by some LPDDR3 devices which comply with earlier versions of the LPDDR3 JEDEC specification) or not:</csr:p>
         <csr:p>   - 0 - tREFBW parameter not used</csr:p>
         <csr:p>   - 1 - tREFBW parameter used</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_rfc_nom_x1_x32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_X32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_X32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_X32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_X32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_X32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_X32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_X32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_X32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>979</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Average time interval between refreshes per rank (Specification: 7.8us for DDR2, DDR3 and DDR4. See JEDEC specification for mDDR, LPDDR2, LPDDR3 and LPDDR4).</csr:p>
         <csr:p></csr:p>
         <csr:p>  When the controller is operating in 1:1 mode, set this register to RoundDown(tREFI/tCK)</csr:p>
         <csr:p></csr:p>
         <csr:p>  When the controller is operating in 1:2 mode, set this register to RoundDown(RoundDown(tREFI/tCK)/2)</csr:p>
         <csr:p></csr:p>
         <csr:p>  In both the above cases, if RFSHTMG.t_rfc_nom_x1_sel = 0, divide the above result by 32 and round down.</csr:p>
         <csr:p></csr:p>
         <csr:p>  For LPDDR2/LPDDR3/LPDDR4:</csr:p>
         <csr:p>  - if using all-bank refreshes (RFSHCTL0.per_bank_refresh = 0), use tREFIab in the above calculations</csr:p>
         <csr:p>  - if using per-bank refreshes (RFSHCTL0.per_bank_refresh = 1), use tREFIpb in the above calculations</csr:p>
         <csr:p>For DDR4 mode, tREFI value is different depending on the refresh mode. The user should program the appropriate value from the spec based on the value programmed in the refresh mode register.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note that:</csr:p>
         <csr:p>  - RFSHTMG.t_rfc_nom_x1_x32 must be greater than 0x1.</csr:p>
         <csr:p>  - if RFSHTMG.t_rfc_nom_x1_sel == 1, RFSHTMG.t_rfc_nom_x1_x32 must be greater than RFSHTMG.t_rfc_min</csr:p>
         <csr:p>  - if RFSHTMG.t_rfc_nom_x1_sel == 0, RFSHTMG.t_rfc_nom_x1_x32 * 32 must be greater than RFSHTMG.t_rfc_min</csr:p>
         <csr:p>  - In non-DDR4 or DDR4 Fixed 1x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0xFFE.</csr:p>
         <csr:p>  - In DDR4 Fixed 2x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x7FF.</csr:p>
         <csr:p>  - In DDR4 Fixed 4x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x3FF.</csr:p>
         <csr:p>Unit: DFI clock cycles or multiples of 32 DFI clock cycles, depending on RFSHTMG.t_rfc_nom_x1_sel.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Dynamic - Refresh Related</csr:p>
        </csr:description>
         <csr:msb>27</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x062</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>30</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_rfc_nom_x1_sel</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_SEL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_SEL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_SEL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_SEL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_SEL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_SEL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_SEL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG_T_RFC_NOM_X1_SEL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>994</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies whether the RFSHTMG.t_rfc_nom_x1_x32 and RFSHCTL0.refresh_to_x1_x32 register values are x1 or x32.</csr:p>
         <csr:p>   - 0 - x32 register values are used</csr:p>
         <csr:p>   - 1 - x1 register values are used.</csr:p>
         <csr:p>This applies only when per-bank refresh is enabled (RFSHCTL0.per_bank_refresh=1); if per-bank refresh is not enabled, the x32 register values are used and this register field is ignored</csr:p>
         <csr:p>Programming Mode: Dynamic - Refresh Related</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.RFSHTMG1</csr:referenceName>
       <csr:identifier>RFSHTMG1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_RFSHTMG1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_RFSHTMG1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1025</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x68</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x008c0000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_RFSHTMG1</csr:typeName>
        <csr:description>
         <csr:p>Refresh Timing Register1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_pbr2pbr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG1_T_PBR2PBR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG1_T_PBR2PBR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG1_T_PBR2PBR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG1_T_PBR2PBR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG1_T_PBR2PBR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG1_T_PBR2PBR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG1_T_PBR2PBR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_RFSHTMG1_T_PBR2PBR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1024</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  LPDDR4: tpbR2pbR</csr:p>
         <csr:p></csr:p>
         <csr:p>  Per-bank Refresh to Per-bank refresh different bank Time.</csr:p>
         <csr:p></csr:p>
         <csr:p>  When the controller is operating in 1:1 frequency ratio mode, program this to RoundUp(tpbR2pbR/tCK).</csr:p>
         <csr:p></csr:p>
         <csr:p>  When the controller is operating in 1:2 frequency ratio mode, program this to RoundUp(RoundUp(tpbR2pbR/tCK)/2).</csr:p>
         <csr:p></csr:p>
         <csr:p>  The tpbR2pbR value in the above equations is different depending on the device density. The user should program the appropriate value from the spec.</csr:p>
         <csr:p></csr:p>
         <csr:p>  Register is valid only in LPDDR4 per-bank refresh mode (RFSHCTL0.per_bank_refresh_mode == 1).</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Dynamic - Refresh Related</csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x8c</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCFG0</csr:referenceName>
       <csr:identifier>ECCCFG0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCFG0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCFG0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1127</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x70</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x003f7f00</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCCFG0</csr:typeName>
        <csr:description>
         <csr:p>ECC Configuration Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_mode</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_MODE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_MODE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1040</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ECC mode indicator</csr:p>
         <csr:p> - 000 - ECC disabled</csr:p>
         <csr:p> - 100 - ECC enabled - SEC/DED over 1 beat</csr:p>
         <csr:p> - 101 - ECC enabled - Advanced ECC</csr:p>
         <csr:p> - all other settings are reserved for future use</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dis_scrub</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_DIS_SCRUB_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_DIS_SCRUB_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_DIS_SCRUB_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_DIS_SCRUB_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_DIS_SCRUB_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_DIS_SCRUB_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_DIS_SCRUB_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_DIS_SCRUB_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1053</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Disable ECC scrubs. Valid only when ECCCFG0.ecc_mode = 3'b100 or 3'b101 and MEMC_USE_RMW is defined.</csr:p>
         <csr:p></csr:p>
         <csr:p>  Note: Scrub is not supported in inline ECC mode and the register value is don't care.</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_region_map</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1088</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Selectable Protected Region setting.</csr:p>
         <csr:p>Memory space is divided to 8/16/32/64 regions which is determined by ECCCFG0.ecc_region_map_granu.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note: Highest 1/8 memory space is always ECC region.</csr:p>
         <csr:p></csr:p>
         <csr:p>Lowest 7 regions are Selectable Protected Regions. The Selectable Protected Regions can be protected/non-protected selectively by ECCCFG0.ecc_region_map[6:0]. Other upper regions are non-protected region if any. Each bit of ECCCFG0.ecc_region_map[6:0] correspond to each of lowest 7 regions respectively. </csr:p>
         <csr:p></csr:p>
         <csr:p>In order to protect a region with ECC, set the corresponding bit to 1, otherwise set to 0.  All "0"s is invalid - there must be at least one protected region if inline ECC is enabled via ECCCFG0.ecc_mode register.</csr:p>
         <csr:p></csr:p>
         <csr:p>All regions are protected with the following setting.</csr:p>
         <csr:p> - ecc_region_map=7'b1111111</csr:p>
         <csr:p> - ecc_region_map_granu=0</csr:p>
         <csr:p>Only first 1/64 region is protected with the following setting.</csr:p>
         <csr:p> - ecc_region_map=7'b0000001</csr:p>
         <csr:p> - ecc_region_map_granu=3</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>14</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x7f</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>blk_channel_idle_time_x32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_BLK_CHANNEL_IDLE_TIME_X32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_BLK_CHANNEL_IDLE_TIME_X32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_BLK_CHANNEL_IDLE_TIME_X32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_BLK_CHANNEL_IDLE_TIME_X32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_BLK_CHANNEL_IDLE_TIME_X32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_BLK_CHANNEL_IDLE_TIME_X32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_BLK_CHANNEL_IDLE_TIME_X32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_BLK_CHANNEL_IDLE_TIME_X32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1110</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates the number of cycles on HIF interface with no access to protected regions which will cause flush of all the block channels. In order to flush block channel, uMCTL2 injects write ECC command (when there is no incoming HIF command) if there is any write in the block and then stop tracking the block address.</csr:p>
         <csr:p>   - 0 indicates no timeout (feature is disabled, not supported with this version)</csr:p>
         <csr:p>   - 1 indicates 32 cycles</csr:p>
         <csr:p>   - 2 indicates 2*32 cycles, etc.</csr:p>
         <csr:p> Unit: Multiples of 32 DFI clock cycles.</csr:p>
         <csr:p></csr:p>
         <csr:p> Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>21</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x3f</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>29</csr:msb>
         <csr:lsb>22</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_region_map_granu</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_GRANU_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_GRANU_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_GRANU_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_GRANU_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_GRANU_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_GRANU_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_GRANU_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG0_ECC_REGION_MAP_GRANU_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1126</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Granularity of Selectable Protected Region.</csr:p>
         <csr:p></csr:p>
         <csr:p>Define one region size for ECCCFG0.ecc_region_map</csr:p>
         <csr:p> - 0 - 1/8 of memory spaces </csr:p>
         <csr:p> - 1 - 1/16 of memory spaces </csr:p>
         <csr:p> - 2 - 1/32 of memory spaces </csr:p>
         <csr:p> - 3 - 1/64 of memory spaces </csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>30</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCFG1</csr:referenceName>
       <csr:identifier>ECCCFG1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCFG1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCFG1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1214</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x74</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x000007b0</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCCFG1</csr:typeName>
        <csr:description>
         <csr:p>ECC Configuration Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>data_poison_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1142</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enable ECC data poisoning - introduces ECC errors on writes to address specified by the ECCPOISONADDR0/1 registers</csr:p>
         <csr:p>This field must be set to 0 if ECC is disabled (ECCCFG0.ecc_mode = 0).</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>data_poison_bit</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_BIT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_BIT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_BIT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_BIT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_BIT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_BIT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_BIT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_DATA_POISON_BIT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1153</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects whether to poison 1 or 2 bits - if 0 -&gt; 2-bit (uncorrectable) data poisoning, if 1 -&gt; 1-bit (correctable) data poisoning, if ECCCFG1.data_poison_en=1.</csr:p>
         <csr:p>Valid only when MEMC_ECC_SUPPORT==1 (SECDED ECC mode)</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_region_parity_lock</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_PARITY_LOCK_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_PARITY_LOCK_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_PARITY_LOCK_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_PARITY_LOCK_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_PARITY_LOCK_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_PARITY_LOCK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_PARITY_LOCK_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_PARITY_LOCK_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1167</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Locks the parity section of the ECC region (hole) which is the highest system address part of the memory that stores ECC parity for protected region.</csr:p>
         <csr:p>   - 1: Locked; if this region is accessed, error response is generated.</csr:p>
         <csr:p>   - 0: Unlocked; this region can be accessed normally, similar to non-ECC protected region.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_region_waste_lock</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_WASTE_LOCK_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_WASTE_LOCK_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_WASTE_LOCK_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_WASTE_LOCK_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_WASTE_LOCK_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_WASTE_LOCK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_WASTE_LOCK_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ECC_REGION_WASTE_LOCK_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1180</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Locks the remaining waste parts of the ECC region (hole) that are not locked by ecc_region_parity_lock.</csr:p>
         <csr:p>   - 1: Locked; if this region is accessed, error response is generated.</csr:p>
         <csr:p>   - 0: Unlocked; this region can be accessed normally, similar to non-ECC protected region.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>blk_channel_active_term</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_BLK_CHANNEL_ACTIVE_TERM_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_BLK_CHANNEL_ACTIVE_TERM_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_BLK_CHANNEL_ACTIVE_TERM_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_BLK_CHANNEL_ACTIVE_TERM_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_BLK_CHANNEL_ACTIVE_TERM_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_BLK_CHANNEL_ACTIVE_TERM_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_BLK_CHANNEL_ACTIVE_TERM_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_BLK_CHANNEL_ACTIVE_TERM_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1198</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Block Channel active terminate enable.</csr:p>
         <csr:p></csr:p>
         <csr:p>If enabled, block channel is terminated when full block write or full block read is performed (all address within block are written or read)</csr:p>
         <csr:p> - 0 - Disable (only for debug purpose)</csr:p>
         <csr:p> - 1 - Enable  (default)</csr:p>
         <csr:p>This is debug register, and this must be set to 1 for normal operation.</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>active_blk_channel</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ACTIVE_BLK_CHANNEL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ACTIVE_BLK_CHANNEL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ACTIVE_BLK_CHANNEL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ACTIVE_BLK_CHANNEL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ACTIVE_BLK_CHANNEL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ACTIVE_BLK_CHANNEL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ACTIVE_BLK_CHANNEL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCFG1_ACTIVE_BLK_CHANNEL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1213</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Number of active block channels. Total number of ECC block channels are defined by MEMC_NO_OF_BLK_CHANNEL hardware parameter. This register can limit the number of available channels. For example, if set to 0, only one channel is active and therefore block interleaving is disabled.</csr:p>
         <csr:p></csr:p>
         <csr:p>The valid range is from 0 to MEMC_NO_OF_BLK_CHANNEL-1.</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x7</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCSTAT</csr:referenceName>
       <csr:identifier>ECCSTAT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCSTAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCSTAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1263</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x78</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCSTAT</csr:typeName>
        <csr:description>
         <csr:p>SECDED ECC Status Register (Valid only in MEMC_ECC_SUPPORT==1 (SECDED ECC mode))</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_corrected_bit_num</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_BIT_NUM_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_BIT_NUM_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_BIT_NUM_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_BIT_NUM_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_BIT_NUM_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_BIT_NUM_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_BIT_NUM_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_BIT_NUM_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1232</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Bit number corrected by single-bit ECC error. See ECC section of architecture chapter for encoding of this field. If more than one data lane has an error, the lower data lane is selected. This register is 7 bits wide in order to handle 72 bits of the data present in a single lane.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_corrected_err</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_ERR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_ERR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_ERR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_ERR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_ERR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_ERR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_ERR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_CORRECTED_ERR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1247</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Single-bit error indicators.</csr:p>
         <csr:p></csr:p>
         <csr:p>  In sideband ECC mode, 1 bit per ECC lane. When the controller is operating in 1:1 frequency ratio mode, there are only two lanes, so only the lower two bits are used.</csr:p>
         <csr:p></csr:p>
         <csr:p>  In inline ECC mode, the register always is 1 bit to indicate correctable error on any lane.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_uncorrected_err</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_UNCORRECTED_ERR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_UNCORRECTED_ERR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_UNCORRECTED_ERR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_UNCORRECTED_ERR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_UNCORRECTED_ERR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_UNCORRECTED_ERR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_UNCORRECTED_ERR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCSTAT_ECC_UNCORRECTED_ERR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1262</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Double-bit error indicators.</csr:p>
         <csr:p></csr:p>
         <csr:p>  In sideband ECC mode, 1 bit per ECC lane. When the controller is operating in 1:1 frequency ratio mode, there are only two lanes, so only the lower two bits are used.</csr:p>
         <csr:p></csr:p>
         <csr:p>  In inline ECC mode, the register always is 1 bit to indicate uncorrectable error on any lane.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCTL</csr:referenceName>
       <csr:identifier>ECCCTL</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCTL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCTL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1387</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x7C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000300</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCCTL</csr:typeName>
        <csr:description>
         <csr:p>ECC Clear Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_corrected_err_clr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_CLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_CLR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_CLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_CLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_CLR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_CLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_CLR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_CLR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1290</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Setting this register bit to 1 clears the currently stored corrected ECC error. </csr:p>
         <csr:p> The following registers are cleared:</csr:p>
         <csr:p> - ECCSTAT.ecc_corrected_err</csr:p>
         <csr:p> - ADVECCSTAT.advecc_corrected_err</csr:p>
         <csr:p> - ADVECCSTAT.advecc_num_err_symbol</csr:p>
         <csr:p> - ADVECCSTAT.advecc_err_symbol_pos</csr:p>
         <csr:p> - ADVECCSTAT.advecc_err_symbol_bits</csr:p>
         <csr:p> - ECCCSYN0</csr:p>
         <csr:p> - ECCCSYN1</csr:p>
         <csr:p> - ECCCSYN2</csr:p>
         <csr:p> - ECCBITMASK0</csr:p>
         <csr:p> - ECCBITMASK1</csr:p>
         <csr:p> - ECCBITMASK2</csr:p>
         <csr:p>uMCTL2 automatically clears this bit.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_uncorrected_err_clr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_CLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_CLR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_CLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_CLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_CLR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_CLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_CLR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_CLR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1308</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Setting this register bit to 1 clears the currently stored uncorrected ECC error.</csr:p>
         <csr:p>The following registers are cleared:</csr:p>
         <csr:p> - ECCSTAT.ecc_uncorrected_err</csr:p>
         <csr:p> - ADVECCSTAT.advecc_uncorrected_err</csr:p>
         <csr:p> - ECCUSYN0</csr:p>
         <csr:p> - ECCUSYN1</csr:p>
         <csr:p> - ECCUSYN2</csr:p>
         <csr:p>uMCTL2 automatically clears this bit.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_corr_err_cnt_clr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORR_ERR_CNT_CLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORR_ERR_CNT_CLR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORR_ERR_CNT_CLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORR_ERR_CNT_CLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORR_ERR_CNT_CLR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORR_ERR_CNT_CLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORR_ERR_CNT_CLR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORR_ERR_CNT_CLR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1321</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Setting this register bit to 1 clears the currently stored corrected ECC error count. The ECCERRCNT.ecc_corr_err_cnt register is cleared by this operation. uMCTL2 automatically clears this bit.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_uncorr_err_cnt_clr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORR_ERR_CNT_CLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORR_ERR_CNT_CLR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORR_ERR_CNT_CLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORR_ERR_CNT_CLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORR_ERR_CNT_CLR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORR_ERR_CNT_CLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORR_ERR_CNT_CLR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORR_ERR_CNT_CLR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1334</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Setting this register bit to 1 clears the currently stored uncorrected ECC error count. The ECCERRCNT.ecc_uncorr_err_cnt register is cleared by this operation. uMCTL2 automatically clears this bit.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_corrected_err_intr_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1345</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt enable bit for ecc_corrected_err_intr.</csr:p>
         <csr:p>   - 1 Enabled</csr:p>
         <csr:p>   - 0 Disabled</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_uncorrected_err_intr_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1356</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt enable bit for ecc_uncorrected_err_intr.</csr:p>
         <csr:p>   - 1: Enabled</csr:p>
         <csr:p>   - 0: Disabled</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_corrected_err_intr_force</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_FORCE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_FORCE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_FORCE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_FORCE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_FORCE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_FORCE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_FORCE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_CORRECTED_ERR_INTR_FORCE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1371</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt force bit for ecc_corrected_err_intr. Setting this register will cause the output interrupt to be asserted. uMCTL2 automatically clears this bit. There is no interaction between functionally triggering an interrupt and forcing an interrupt (they are mutually exclusive).</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_uncorrected_err_intr_force</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_FORCE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_FORCE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_FORCE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_FORCE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_FORCE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_FORCE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_FORCE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCTL_ECC_UNCORRECTED_ERR_INTR_FORCE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1386</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt force bit for ecc_uncorrected_err_intr. Setting this register will cause the output interrupt to be asserted. uMCTL2 automatically clears this bit. There is no interaction between functionally triggering an interrupt and forcing an interrupt (they are mutually exclusive).</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCERRCNT</csr:referenceName>
       <csr:identifier>ECCERRCNT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCERRCNT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1416</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x80</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCERRCNT</csr:typeName>
        <csr:description>
         <csr:p>ECC Error Counter Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_corr_err_cnt</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_CORR_ERR_CNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_CORR_ERR_CNT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_CORR_ERR_CNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_CORR_ERR_CNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_CORR_ERR_CNT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_CORR_ERR_CNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_CORR_ERR_CNT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_CORR_ERR_CNT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1403</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Number of correctable ECC errors detected.</csr:p>
         <csr:p>Note that the saturation behavior of this register is different, depending on the type of ECC.  For advanced ECC or Inline ECC, it saturates at 0xFFFF, while for Side-band ECC with SECDED ECC, it saturates at 0xFFFC or above.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_uncorr_err_cnt</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_UNCORR_ERR_CNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_UNCORR_ERR_CNT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_UNCORR_ERR_CNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_UNCORR_ERR_CNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_UNCORR_ERR_CNT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_UNCORR_ERR_CNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_UNCORR_ERR_CNT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCERRCNT_ECC_UNCORR_ERR_CNT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1415</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Number of uncorrectable ECC errors detected.</csr:p>
         <csr:p>Note that the saturation behavior of this register is different, depending on the type of ECC.  For advanced ECC or Inline ECC, it saturates at 0xFFFF, while for Side-band ECC with SECDED ECC, it saturates at 0xFFFC or above.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCADDR0</csr:referenceName>
       <csr:identifier>ECCCADDR0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCADDR0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCADDR0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1431</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x84</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCCADDR0</csr:typeName>
        <csr:description>
         <csr:p>ECC Corrected Error Address Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_corr_row</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR0_ECC_CORR_ROW_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR0_ECC_CORR_ROW_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR0_ECC_CORR_ROW_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR0_ECC_CORR_ROW_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR0_ECC_CORR_ROW_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR0_ECC_CORR_ROW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR0_ECC_CORR_ROW_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR0_ECC_CORR_ROW_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1430</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Page/row number of a read resulting in a corrected ECC error. This is 18-bits wide in configurations with DDR4 support and 16-bits in all other configurations.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCADDR1</csr:referenceName>
       <csr:identifier>ECCCADDR1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCADDR1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1453</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x88</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCCADDR1</csr:typeName>
        <csr:description>
         <csr:p>ECC Corrected Error Address Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_corr_col</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_COL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_COL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_COL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_COL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_COL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_COL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_COL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_COL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1444</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Block number of a read resulting in a corrected ECC error (lowest bit not assigned here)</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_corr_bank</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_BANK_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_BANK_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_BANK_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_BANK_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_BANK_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_BANK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_BANK_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCADDR1_ECC_CORR_BANK_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1452</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Bank number of a read resulting in a corrected ECC error</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>18</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>19</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCSYN0</csr:referenceName>
       <csr:identifier>ECCCSYN0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCSYN0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCSYN0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1467</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x8C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCCSYN0</csr:typeName>
        <csr:description>
         <csr:p>ECC Corrected Syndrome Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_corr_syndromes_31_0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN0_ECC_CORR_SYNDROMES_31_0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN0_ECC_CORR_SYNDROMES_31_0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN0_ECC_CORR_SYNDROMES_31_0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN0_ECC_CORR_SYNDROMES_31_0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN0_ECC_CORR_SYNDROMES_31_0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN0_ECC_CORR_SYNDROMES_31_0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN0_ECC_CORR_SYNDROMES_31_0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN0_ECC_CORR_SYNDROMES_31_0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1466</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data pattern that resulted in a corrected error. For 16-bit ECC, only bits [15:0] are used</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCSYN1</csr:referenceName>
       <csr:identifier>ECCCSYN1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCSYN1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCSYN1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1481</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x90</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCCSYN1</csr:typeName>
        <csr:description>
         <csr:p>ECC Corrected Syndrome Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_corr_syndromes_63_32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN1_ECC_CORR_SYNDROMES_63_32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN1_ECC_CORR_SYNDROMES_63_32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN1_ECC_CORR_SYNDROMES_63_32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN1_ECC_CORR_SYNDROMES_63_32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN1_ECC_CORR_SYNDROMES_63_32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN1_ECC_CORR_SYNDROMES_63_32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN1_ECC_CORR_SYNDROMES_63_32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN1_ECC_CORR_SYNDROMES_63_32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1480</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data pattern that resulted in a corrected error. For 32-bit ECC and 16-bit ECC, this register is not used</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCCSYN2</csr:referenceName>
       <csr:identifier>ECCCSYN2</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCSYN2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCCSYN2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1498</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x94</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCCSYN2</csr:typeName>
        <csr:description>
         <csr:p>ECC Corrected Syndrome Register 2</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_corr_syndromes_71_64</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN2_ECC_CORR_SYNDROMES_71_64_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN2_ECC_CORR_SYNDROMES_71_64_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN2_ECC_CORR_SYNDROMES_71_64_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN2_ECC_CORR_SYNDROMES_71_64_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN2_ECC_CORR_SYNDROMES_71_64_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN2_ECC_CORR_SYNDROMES_71_64_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN2_ECC_CORR_SYNDROMES_71_64_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCCSYN2_ECC_CORR_SYNDROMES_71_64_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1497</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data pattern that resulted in a corrected error one for each ECC lane, all concatenated together</csr:p>
         <csr:p>This register refers to the ECC byte, which is bits [71:64] for 64-bit ECC, [39:32] for 32-bit ECC, or [23:16] for 16-bit ECC</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCBITMASK0</csr:referenceName>
       <csr:identifier>ECCBITMASK0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCBITMASK0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCBITMASK0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1520</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x98</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCBITMASK0</csr:typeName>
        <csr:description>
         <csr:p>ECC Corrected Data Bit Mask Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_corr_bit_mask_31_0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK0_ECC_CORR_BIT_MASK_31_0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK0_ECC_CORR_BIT_MASK_31_0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK0_ECC_CORR_BIT_MASK_31_0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK0_ECC_CORR_BIT_MASK_31_0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK0_ECC_CORR_BIT_MASK_31_0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK0_ECC_CORR_BIT_MASK_31_0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK0_ECC_CORR_BIT_MASK_31_0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK0_ECC_CORR_BIT_MASK_31_0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1519</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Mask for the corrected data portion</csr:p>
         <csr:p>    - 1 on any bit indicates that the bit has been corrected by the ECC logic</csr:p>
         <csr:p>    - 0 on any bit indicates that the bit has not been corrected by the ECC logic</csr:p>
         <csr:p>This register accumulates data over multiple ECC errors, to give an overall indication of which bits are being fixed. It is cleared by writing a 1 to ECCCTL.ecc_corrected_err_clr.</csr:p>
         <csr:p>For 16-bit ECC, only bits [15:0] are used</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCBITMASK1</csr:referenceName>
       <csr:identifier>ECCBITMASK1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCBITMASK1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCBITMASK1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1542</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x9C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCBITMASK1</csr:typeName>
        <csr:description>
         <csr:p>ECC Corrected Data Bit Mask Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_corr_bit_mask_63_32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK1_ECC_CORR_BIT_MASK_63_32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK1_ECC_CORR_BIT_MASK_63_32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK1_ECC_CORR_BIT_MASK_63_32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK1_ECC_CORR_BIT_MASK_63_32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK1_ECC_CORR_BIT_MASK_63_32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK1_ECC_CORR_BIT_MASK_63_32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK1_ECC_CORR_BIT_MASK_63_32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK1_ECC_CORR_BIT_MASK_63_32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1541</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Mask for the corrected data portion</csr:p>
         <csr:p>    - 1 on any bit indicates that the bit has been corrected by the ECC logic</csr:p>
         <csr:p>    - 0 on any bit indicates that the bit has not been corrected by the ECC logic</csr:p>
         <csr:p>This register accumulates data over multiple ECC errors, to give an overall indication of which bits are being fixed. It is cleared by writing a 1 to ECCCTL.ecc_corrected_err_clr.</csr:p>
         <csr:p>For 32-bit ECC and 16-bit ECC, this register is not used</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCBITMASK2</csr:referenceName>
       <csr:identifier>ECCBITMASK2</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCBITMASK2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCBITMASK2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1566</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xA0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCBITMASK2</csr:typeName>
        <csr:description>
         <csr:p>ECC Corrected Data Bit Mask Register 2</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_corr_bit_mask_71_64</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK2_ECC_CORR_BIT_MASK_71_64_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK2_ECC_CORR_BIT_MASK_71_64_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK2_ECC_CORR_BIT_MASK_71_64_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK2_ECC_CORR_BIT_MASK_71_64_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK2_ECC_CORR_BIT_MASK_71_64_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK2_ECC_CORR_BIT_MASK_71_64_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK2_ECC_CORR_BIT_MASK_71_64_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCBITMASK2_ECC_CORR_BIT_MASK_71_64_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1565</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Mask for the corrected data portion</csr:p>
         <csr:p>    - 1 on any bit indicates that the bit has been corrected by the ECC logic</csr:p>
         <csr:p>    - 0 on any bit indicates that the bit has not been corrected by the ECC logic</csr:p>
         <csr:p>This register accumulates data over multiple ECC errors, to give an overall indication of which bits are being fixed. It is cleared by writing a 1 to ECCCTL.ecc_corrected_err_clr.</csr:p>
         <csr:p>This register refers to the ECC byte, which is bits [71:64] for 64-bit ECC, [39:32] for 32-bit ECC, or [23:16] for 16-bit ECC</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUADDR0</csr:referenceName>
       <csr:identifier>ECCUADDR0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCUADDR0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCUADDR0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1581</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xA4</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCUADDR0</csr:typeName>
        <csr:description>
         <csr:p>ECC Uncorrected Error Address Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_uncorr_row</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR0_ECC_UNCORR_ROW_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR0_ECC_UNCORR_ROW_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR0_ECC_UNCORR_ROW_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR0_ECC_UNCORR_ROW_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR0_ECC_UNCORR_ROW_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR0_ECC_UNCORR_ROW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR0_ECC_UNCORR_ROW_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR0_ECC_UNCORR_ROW_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1580</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Page/row number of a read resulting in an uncorrected ECC error. This is 18-bits wide in configurations with DDR4 support and 16-bits in all other configurations.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUADDR1</csr:referenceName>
       <csr:identifier>ECCUADDR1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCUADDR1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1604</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xA8</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCUADDR1</csr:typeName>
        <csr:description>
         <csr:p>ECC Uncorrected Error Address Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_uncorr_col</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_COL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_COL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_COL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_COL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_COL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_COL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_COL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_COL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1594</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Block number of a read resulting in an uncorrected ECC error (lowest bit not assigned here)</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_uncorr_bank</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_BANK_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_BANK_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_BANK_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_BANK_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_BANK_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_BANK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_BANK_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCUADDR1_ECC_UNCORR_BANK_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1603</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Bank number of a read resulting in an uncorrected ECC error</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>18</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>19</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUSYN0</csr:referenceName>
       <csr:identifier>ECCUSYN0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCUSYN0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCUSYN0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1619</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xAC</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCUSYN0</csr:typeName>
        <csr:description>
         <csr:p>ECC Uncorrected Syndrome Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_uncorr_syndromes_31_0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN0_ECC_UNCORR_SYNDROMES_31_0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN0_ECC_UNCORR_SYNDROMES_31_0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN0_ECC_UNCORR_SYNDROMES_31_0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN0_ECC_UNCORR_SYNDROMES_31_0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN0_ECC_UNCORR_SYNDROMES_31_0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN0_ECC_UNCORR_SYNDROMES_31_0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN0_ECC_UNCORR_SYNDROMES_31_0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN0_ECC_UNCORR_SYNDROMES_31_0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1618</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data pattern that resulted in an uncorrected error, one for each ECC lane, all concatenated together. For 16-bit ECC, only bits [15:0] are used</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUSYN1</csr:referenceName>
       <csr:identifier>ECCUSYN1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCUSYN1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCUSYN1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1634</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xB0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCUSYN1</csr:typeName>
        <csr:description>
         <csr:p>ECC Uncorrected Syndrome Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_uncorr_syndromes_63_32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN1_ECC_UNCORR_SYNDROMES_63_32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN1_ECC_UNCORR_SYNDROMES_63_32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN1_ECC_UNCORR_SYNDROMES_63_32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN1_ECC_UNCORR_SYNDROMES_63_32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN1_ECC_UNCORR_SYNDROMES_63_32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN1_ECC_UNCORR_SYNDROMES_63_32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN1_ECC_UNCORR_SYNDROMES_63_32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN1_ECC_UNCORR_SYNDROMES_63_32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1633</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data pattern that resulted in an uncorrected error, one for each ECC lane, all concatenated together. For 32-bit ECC and 16-bit ECC, this register is not used</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCUSYN2</csr:referenceName>
       <csr:identifier>ECCUSYN2</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCUSYN2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCUSYN2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1651</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xB4</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCUSYN2</csr:typeName>
        <csr:description>
         <csr:p>ECC Uncorrected Syndrome Register 2</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_uncorr_syndromes_71_64</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN2_ECC_UNCORR_SYNDROMES_71_64_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN2_ECC_UNCORR_SYNDROMES_71_64_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN2_ECC_UNCORR_SYNDROMES_71_64_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN2_ECC_UNCORR_SYNDROMES_71_64_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN2_ECC_UNCORR_SYNDROMES_71_64_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN2_ECC_UNCORR_SYNDROMES_71_64_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN2_ECC_UNCORR_SYNDROMES_71_64_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCUSYN2_ECC_UNCORR_SYNDROMES_71_64_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1650</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Data pattern that resulted in an uncorrected error one for each ECC lane, all concatenated together.</csr:p>
         <csr:p>This register refers to the ECC byte, which is bits [71:64] for 64-bit ECC, [39:32] for 32-bit ECC, or [23:16] for 16-bit ECC</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCPOISONADDR0</csr:referenceName>
       <csr:identifier>ECCPOISONADDR0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1673</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xB8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCPOISONADDR0</csr:typeName>
        <csr:description>
         <csr:p>ECC Data Poisoning Address Register 0. If a HIF write data beat matches the address specified in this register, an ECC error will be introduced on that transaction (write/RMW), if ECCCFG1.data_poison_en=1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_poison_col</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR0_ECC_POISON_COL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR0_ECC_POISON_COL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR0_ECC_POISON_COL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR0_ECC_POISON_COL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR0_ECC_POISON_COL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR0_ECC_POISON_COL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR0_ECC_POISON_COL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR0_ECC_POISON_COL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1672</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Column address for ECC poisoning. Note that this column address must be burst aligned:</csr:p>
         <csr:p>- In full bus width mode, ecc_poison_col[2:0] must be set to 0</csr:p>
         <csr:p>- In half bus width mode, ecc_poison_col[3:0] must be set to 0</csr:p>
         <csr:p>- In quarter bus width mode, ecc_poison_col[4:0] must be set to 0</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCPOISONADDR1</csr:referenceName>
       <csr:identifier>ECCPOISONADDR1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1698</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xBC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCPOISONADDR1</csr:typeName>
        <csr:description>
         <csr:p>ECC Data Poisoning Address Register 1. If a HIF write data beat matches the address specified in this register, an ECC error will be introduced on that transaction (write/RMW), if ECCCFG1.data_poison_en=1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_poison_row</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_ROW_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_ROW_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_ROW_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_ROW_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_ROW_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_ROW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_ROW_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_ROW_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1689</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Row address for ECC poisoning. This is 18-bits wide in configurations with DDR4 support and 16-bits in all other configurations.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_poison_bank</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_BANK_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_BANK_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_BANK_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_BANK_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_BANK_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_BANK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_BANK_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONADDR1_ECC_POISON_BANK_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1697</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Bank address for ECC poisoning</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>26</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>27</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.CRCPARCTL0</csr:referenceName>
       <csr:identifier>CRCPARCTL0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1742</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xC0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_CRCPARCTL0</csr:typeName>
        <csr:description>
         <csr:p>CRC Parity Control Register0</csr:p>
         <csr:p> Note: Do not perform any APB access to CRCPARCTL0 within 32 pclk cycles of previous access to CRCPARCTL0, as this might lead to data loss.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dfi_alert_err_int_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1715</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt enable bit for DFI alert error. If this bit is set, any parity/CRC error detected on the dfi_alert_n input will result in an interrupt being set on CRCPARSTAT.dfi_alert_err_int.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_alert_err_int_clr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1728</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt clear bit for DFI alert error. If this bit is set, the alert error interrupt on CRCPARSTAT.dfi_alert_err_int will be cleared. uMCTL2 automatically clears this bit.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_alert_err_cnt_clr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1741</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DFI alert error count clear. Clear bit for DFI alert error counter. Asserting this bit will clear the DFI alert error counter, CRCPARSTAT.dfi_alert_err_cnt. uMCTL2 automatically clears this bit.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.CRCPARSTAT</csr:referenceName>
       <csr:identifier>CRCPARSTAT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1773</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xCC</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_CRCPARSTAT</csr:typeName>
        <csr:description>
         <csr:p>CRC Parity Status Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dfi_alert_err_cnt</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_CNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_CNT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_CNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_CNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_CNT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_CNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_CNT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_CNT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1759</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DFI alert error count.</csr:p>
         <csr:p>  If a parity/CRC error is detected on dfi_alert_n, this counter be incremented.  This is independent of the setting of CRCPARCTL0.dfi_alert_err_int_en.  It will saturate at 0xFFFF, and can be cleared by asserting CRCPARCTL0.dfi_alert_err_cnt_clr.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_alert_err_int</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_INT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_INT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_INT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_INT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_INT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_INT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_INT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_CRCPARSTAT_DFI_ALERT_ERR_INT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1772</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DFI alert error interrupt.</csr:p>
         <csr:p>  If a parity/CRC error is detected on dfi_alert_n, and the interrupt is enabled by CRCPARCTL0.dfi_alert_err_int_en, this interrupt bit will be set.  It will remain set until cleared by CRCPARCTL0.dfi_alert_err_int_clr</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT0</csr:referenceName>
       <csr:identifier>INIT0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_INIT0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_INIT0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1837</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xD0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0002004e</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_INIT0</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Initialization Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>pre_cke_x1024</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT0_PRE_CKE_X1024_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT0_PRE_CKE_X1024_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT0_PRE_CKE_X1024_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT0_PRE_CKE_X1024_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT0_PRE_CKE_X1024_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT0_PRE_CKE_X1024_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT0_PRE_CKE_X1024_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT0_PRE_CKE_X1024_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1798</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Cycles to wait after reset before driving CKE high to start the SDRAM initialization sequence.</csr:p>
         <csr:p>DDR2 specifications typically require this to be programmed for a delay of &gt;= 200 us.</csr:p>
         <csr:p>LPDDR2/LPDDR3: tINIT1 of 100 ns (min) </csr:p>
         <csr:p>LPDDR4: tINIT3 of 2 ms (min) </csr:p>
         <csr:p> When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value.</csr:p>
         <csr:p>For DDR3/DDR4 RDIMMs, this should include the time needed to satisfy tSTAB.</csr:p>
         <csr:p>Unit: Multiples of 1024 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x04e</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>post_cke_x1024</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT0_POST_CKE_X1024_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT0_POST_CKE_X1024_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT0_POST_CKE_X1024_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT0_POST_CKE_X1024_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT0_POST_CKE_X1024_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT0_POST_CKE_X1024_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT0_POST_CKE_X1024_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT0_POST_CKE_X1024_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1820</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Cycles to wait after driving CKE high to start the SDRAM initialization sequence.</csr:p>
         <csr:p>DDR2 typically requires a 400 ns delay, requiring this value to be programmed to 2 at all clock speeds.</csr:p>
         <csr:p>LPDDR2/LPDDR3 typically requires this to be programmed for a delay of 200 us.</csr:p>
         <csr:p>LPDDR4 typically requires this to be programmed for a delay of 2 us.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value.</csr:p>
         <csr:p>Unit: Multiples of 1024 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>25</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x002</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>29</csr:msb>
         <csr:lsb>26</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>skip_dram_init</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT0_SKIP_DRAM_INIT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT0_SKIP_DRAM_INIT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT0_SKIP_DRAM_INIT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT0_SKIP_DRAM_INIT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT0_SKIP_DRAM_INIT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT0_SKIP_DRAM_INIT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT0_SKIP_DRAM_INIT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT0_SKIP_DRAM_INIT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1836</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If lower bit is enabled the SDRAM initialization routine is skipped. The upper bit decides what state the controller starts up in when reset is removed  </csr:p>
         <csr:p> - 00 - SDRAM Initialization routine is run after power-up</csr:p>
         <csr:p> - 01 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Normal Mode</csr:p>
         <csr:p> - 11 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Self-refresh Mode</csr:p>
         <csr:p> - 10 - Reserved.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>30</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT1</csr:referenceName>
       <csr:identifier>INIT1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_INIT1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_INIT1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1875</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xD4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_INIT1</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Initialization Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>pre_ocd_x32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT1_PRE_OCD_X32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT1_PRE_OCD_X32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT1_PRE_OCD_X32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT1_PRE_OCD_X32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT1_PRE_OCD_X32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT1_PRE_OCD_X32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT1_PRE_OCD_X32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT1_PRE_OCD_X32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1855</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Wait period before driving the OCD complete command to SDRAM.</csr:p>
         <csr:p>There is no known specific requirement for this; it may be set to zero.</csr:p>
         <csr:p>Unit: Multiples of 32 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dram_rstn_x1024</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT1_DRAM_RSTN_X1024_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT1_DRAM_RSTN_X1024_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT1_DRAM_RSTN_X1024_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT1_DRAM_RSTN_X1024_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT1_DRAM_RSTN_X1024_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT1_DRAM_RSTN_X1024_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT1_DRAM_RSTN_X1024_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT1_DRAM_RSTN_X1024_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1874</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Number of cycles to assert SDRAM reset signal during init sequence.</csr:p>
         <csr:p>This is only present for designs supporting DDR3, DDR4 or LPDDR4 devices. For use with a Synopsys DDR PHY, this should be set to a minimum of 1.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value.</csr:p>
         <csr:p>Unit: Multiples of 1024 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>24</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>25</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT2</csr:referenceName>
       <csr:identifier>INIT2</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_INIT2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_INIT2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1909</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xD8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000d05</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_INIT2</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Initialization Register 2</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>min_stable_clock_x1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT2_MIN_STABLE_CLOCK_X1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT2_MIN_STABLE_CLOCK_X1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT2_MIN_STABLE_CLOCK_X1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT2_MIN_STABLE_CLOCK_X1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT2_MIN_STABLE_CLOCK_X1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT2_MIN_STABLE_CLOCK_X1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT2_MIN_STABLE_CLOCK_X1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT2_MIN_STABLE_CLOCK_X1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1892</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Time to wait after the first CKE high, tINIT2. Present only in designs configured to support LPDDR2/LPDDR3.</csr:p>
         <csr:p>LPDDR2/LPDDR3 typically requires 5 x tCK delay.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x5</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>idle_after_reset_x32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT2_IDLE_AFTER_RESET_X32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT2_IDLE_AFTER_RESET_X32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT2_IDLE_AFTER_RESET_X32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT2_IDLE_AFTER_RESET_X32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT2_IDLE_AFTER_RESET_X32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT2_IDLE_AFTER_RESET_X32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT2_IDLE_AFTER_RESET_X32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT2_IDLE_AFTER_RESET_X32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1908</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Idle time after the reset command, tINIT4. Present only in designs configured to support LPDDR2.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value.</csr:p>
         <csr:p>Unit: Multiples of 32 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0d</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT3</csr:referenceName>
       <csr:identifier>INIT3</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT3_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT3_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_INIT3_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_INIT3_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1939</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xDC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000510</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_INIT3</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Initialization Register 3</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>emr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT3_EMR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT3_EMR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT3_EMR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT3_EMR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT3_EMR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT3_EMR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT3_EMR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT3_EMR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1925</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DDR2: Value to write to EMR register. Bits 9:7 are for OCD and the setting in this register is ignored. The uMCTL2 sets those bits appropriately.</csr:p>
         <csr:p>DDR3/DDR4: Value to write to MR1 register  Set bit 7 to 0.</csr:p>
         <csr:p> mDDR: Value to write to EMR register.</csr:p>
         <csr:p>LPDDR2/LPDDR3/LPDDR4 - Value to write to MR2 register</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 4</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0510</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>mr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT3_MR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT3_MR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT3_MR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT3_MR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT3_MR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT3_MR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT3_MR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT3_MR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1938</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored. The uMCTL2 sets this bit appropriately.</csr:p>
         <csr:p>DDR3/DDR4: Value loaded into MR0 register.</csr:p>
         <csr:p>mDDR: Value to write to MR register.</csr:p>
         <csr:p>LPDDR2/LPDDR3/LPDDR4 - Value to write to MR1 register</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 4</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT4</csr:referenceName>
       <csr:identifier>INIT4</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT4_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT4_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_INIT4_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_INIT4_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>1965</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xE0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_INIT4</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Initialization Register 4</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>emr3</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR3_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR3_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR3_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR3_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR3_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR3_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR3_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR3_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1953</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DDR2: Value to write to EMR3 register.</csr:p>
         <csr:p>DDR3/DDR4: Value to write to MR3 register</csr:p>
         <csr:p>mDDR/LPDDR2/LPDDR3: Unused</csr:p>
         <csr:p>LPDDR4: Value to write to MR13 register</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>emr2</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR2_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR2_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR2_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR2_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR2_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR2_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT4_EMR2_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1964</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DDR2: Value to write to EMR2 register.</csr:p>
         <csr:p>DDR3/DDR4: Value to write to MR2 register</csr:p>
         <csr:p>LPDDR2/LPDDR3/LPDDR4: Value to write to MR3 register</csr:p>
         <csr:p>mDDR: Unused</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 4</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT5</csr:referenceName>
       <csr:identifier>INIT5</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT5_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT5_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_INIT5_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_INIT5_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2003</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xE4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00100004</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_INIT5</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Initialization Register 5</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>max_auto_init_x1024</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT5_MAX_AUTO_INIT_X1024_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT5_MAX_AUTO_INIT_X1024_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT5_MAX_AUTO_INIT_X1024_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT5_MAX_AUTO_INIT_X1024_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT5_MAX_AUTO_INIT_X1024_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT5_MAX_AUTO_INIT_X1024_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT5_MAX_AUTO_INIT_X1024_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT5_MAX_AUTO_INIT_X1024_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>1983</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Maximum duration of the auto initialization, tINIT5. Present only in designs configured to support LPDDR2/LPDDR3.</csr:p>
         <csr:p>LPDDR2/LPDDR3 typically requires 10 us.</csr:p>
         <csr:p>Unit: Multiples of 1024 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x004</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dev_zqinit_x32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT5_DEV_ZQINIT_X32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT5_DEV_ZQINIT_X32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT5_DEV_ZQINIT_X32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT5_DEV_ZQINIT_X32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT5_DEV_ZQINIT_X32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT5_DEV_ZQINIT_X32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT5_DEV_ZQINIT_X32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT5_DEV_ZQINIT_X32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2002</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ZQ initial calibration, tZQINIT. Present only in designs configured to support DDR3 or DDR4 or LPDDR2/LPDDR3.</csr:p>
         <csr:p>DDR3 typically requires 512 SDRAM clock cycles.</csr:p>
         <csr:p>DDR4 requires 1024 SDRAM clock cycles.</csr:p>
         <csr:p>LPDDR2/LPDDR3 requires 1 us.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value.</csr:p>
         <csr:p>Unit: Multiples of 32 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x10</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT6</csr:referenceName>
       <csr:identifier>INIT6</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT6_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT6_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_INIT6_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_INIT6_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2025</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xE8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_INIT6</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Initialization Register 6</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>mr5</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR5_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR5_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR5_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR5_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR5_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR5_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR5_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR5_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2015</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DDR4- Value to be loaded into SDRAM MR5 registers.</csr:p>
         <csr:p>LPDDR4- Value to be loaded into SDRAM MR12 registers.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 4</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>mr4</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR4_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR4_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR4_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR4_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR4_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR4_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR4_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT6_MR4_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2024</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DDR4- Value to be loaded into SDRAM MR4 registers.</csr:p>
         <csr:p>LPDDR4- Value to be loaded into SDRAM MR11 registers.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.INIT7</csr:referenceName>
       <csr:identifier>INIT7</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT7_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_INIT7_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_INIT7_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_INIT7_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2047</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xEC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_INIT7</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Initialization Register 7</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>mr6</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR6_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR6_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR6_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR6_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR6_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR6_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR6_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR6_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2037</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DDR4- Value to be loaded into SDRAM MR6 registers.</csr:p>
         <csr:p>LPDDR4- Value to be loaded into SDRAM MR14 registers.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 4</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>mr22</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR22_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR22_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR22_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR22_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR22_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR22_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR22_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_INIT7_MR22_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2046</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>LPDDR4- Value to be loaded into SDRAM MR22 registers.</csr:p>
         <csr:p>Used in LPDDR4 designs only.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 4</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DIMMCTL</csr:referenceName>
       <csr:identifier>DIMMCTL</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DIMMCTL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DIMMCTL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2105</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xF0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DIMMCTL</csr:typeName>
        <csr:description>
         <csr:p>DIMM Control Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dimm_stagger_cs_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_STAGGER_CS_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_STAGGER_CS_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_STAGGER_CS_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_STAGGER_CS_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_STAGGER_CS_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_STAGGER_CS_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_STAGGER_CS_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_STAGGER_CS_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2069</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Staggering enable for multi-rank accesses (for multi-rank UDIMM, RDIMM and LRDIMM implementations only).  This is not supported for mDDR, LPDDR2, LPDDR3 or LPDDR4 SDRAMs.</csr:p>
         <csr:p>Note: Even if this bit is set it does not take care of software driven MR commands (via MRCTRL0/MRCTRL1), where software is responsible to send them to seperate ranks as appropriate.</csr:p>
         <csr:p>    - 1 - (DDR4) Send MRS commands to each ranks seperately</csr:p>
         <csr:p>    - 1 - (non-DDR4) Send all commands to even and odd ranks seperately</csr:p>
         <csr:p>    - 0 - Do not stagger accesses</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dimm_addr_mirr_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_ADDR_MIRR_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_ADDR_MIRR_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_ADDR_MIRR_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_ADDR_MIRR_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_ADDR_MIRR_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_ADDR_MIRR_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_ADDR_MIRR_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DIMMCTL_DIMM_ADDR_MIRR_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2104</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Address Mirroring Enable (for multi-rank UDIMM implementations and multi-rank DDR4 RDIMM/LRDIMM implementations).</csr:p>
         <csr:p>Some UDIMMs and DDR4 RDIMMs/LRDIMMs implement address mirroring for odd ranks, which means that the following address, bank address and bank group bits are swapped: (A3, A4), (A5, A6), (A7, A8), (BA0, BA1) and also (A11, A13), (BG0, BG1) for the DDR4. Setting this bit ensures that, for mode register accesses during the automatic initialization routine, these bits are swapped within the uMCTL2 to compensate for this UDIMM/RDIMM/LRDIMM swapping. In addition to the automatic initialization routine, in case of DDR4 UDIMM/RDIMM/LRDIMM, they are swapped during the automatic MRS access to enable/disable of a particular DDR4 feature.</csr:p>
         <csr:p>Note: This has no effect on the address of any other memory accesses, or of software-driven mode register accesses.</csr:p>
         <csr:p>This is not supported for mDDR, LPDDR2, LPDDR3 or LPDDR4 SDRAMs.</csr:p>
         <csr:p>Note: In case of x16 DDR4 DIMMs, BG1 output of MRS for the odd ranks is same as BG0 because BG1 is invalid, hence dimm_dis_bg_mirroring register must be set to 1.</csr:p>
         <csr:p>    - 1 - For odd ranks, implement address mirroring for MRS commands to during initialization and for any automatic DDR4 MRS commands (to be used if UDIMM/RDIMM/LRDIMM implements address mirroring)</csr:p>
         <csr:p>    - 0 - Do not implement address mirroring</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG0</csr:referenceName>
       <csr:identifier>DRAMTMG0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2194</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x100</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0f101b0f</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DRAMTMG0</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Timing Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>t_ras_min</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MIN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MIN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MIN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MIN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MIN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MIN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MIN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MIN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2123</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tRAS(min):  Minimum time between activate and precharge to the same bank.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency mode, 1T mode, program this to tRAS(min)/2. No rounding up.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, 2T mode or LPDDR4 mode, program this to (tRAS(min)/2) and round it up to the next integer value.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0f</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_ras_max</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MAX_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MAX_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MAX_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MAX_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MAX_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MAX_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MAX_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_RAS_MAX_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2143</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tRAS(max):  Maximum time between activate and precharge to same bank. This is the maximum time that a page can be kept open</csr:p>
         <csr:p>Minimum value of this register is 1. Zero is invalid.</csr:p>
         <csr:p></csr:p>
         <csr:p>   When the controller is operating in 1:1 frequency ratio mode, t_ras_max should be set to RoundDown(tRAS(max)/tCK/1024).</csr:p>
         <csr:p></csr:p>
         <csr:p>   When the controller is operating in 1:2 frequency ratio mode, t_ras_max should be set to RoundDown((RoundDown(tRAS(max)/tCK/1024)-1)/2).</csr:p>
         <csr:p>Unit: Multiples of 1024 DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>14</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x1b</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_faw</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_FAW_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_FAW_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_FAW_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_FAW_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_FAW_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_FAW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_FAW_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_T_FAW_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2160</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tFAW Valid only when 8 or more banks(or banks x bank groups) are present.</csr:p>
         <csr:p>In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value.</csr:p>
         <csr:p>In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>21</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x10</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>22</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr2pre</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_WR2PRE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_WR2PRE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_WR2PRE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_WR2PRE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_WR2PRE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_WR2PRE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_WR2PRE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG0_WR2PRE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2193</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Minimum time between write and precharge to same bank.</csr:p>
         <csr:p>Specifications: WL + BL/2 + tWR = approximately 8 cycles + 15 ns = 14 clocks @400MHz and less for lower frequencies</csr:p>
         <csr:p>where:</csr:p>
         <csr:p> - WL = write latency</csr:p>
         <csr:p> - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM. BST (burst terminate) is not supported at present.</csr:p>
         <csr:p> - tWR = Write recovery time. This comes directly from the SDRAM specification. </csr:p>
         <csr:p>Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 for this parameter.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, 1T mode, divide the above value by 2. No rounding up.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, 2T mode or LPDDR4 mode, divide the above value by 2 and round it up to the next integer value.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>30</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0f</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG1</csr:referenceName>
       <csr:identifier>DRAMTMG1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2256</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x104</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00080414</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DRAMTMG1</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Timing Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>t_rc</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_RC_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_RC_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_RC_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_RC_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_RC_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_RC_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_RC_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_RC_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2209</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tRC:  Minimum time between activates to same bank.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to (tRC/2) and round up to next integer value.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x14</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd2pre</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_RD2PRE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_RD2PRE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_RD2PRE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_RD2PRE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_RD2PRE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_RD2PRE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_RD2PRE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_RD2PRE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2238</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tRTP:  Minimum time from read to precharge of same bank.</csr:p>
         <csr:p> - DDR2: tAL + BL/2 + max(tRTP, 2) - 2</csr:p>
         <csr:p> - DDR3: tAL + max (tRTP, 4)</csr:p>
         <csr:p> - DDR4: Max of following two equations:</csr:p>
         <csr:p>           tAL + max (tRTP, 4) or, </csr:p>
         <csr:p>           RL + BL/2 - tRP (*).</csr:p>
         <csr:p> - mDDR: BL/2</csr:p>
         <csr:p> - LPDDR2: Depends on if it's LPDDR2-S2 or LPDDR2-S4:</csr:p>
         <csr:p>           LPDDR2-S2: BL/2 + tRTP - 1.</csr:p>
         <csr:p>           LPDDR2-S4: BL/2 + max(tRTP,2) - 2.</csr:p>
         <csr:p> - LPDDR3: BL/2 +  max(tRTP,4) - 4</csr:p>
         <csr:p> - LPDDR4: BL/2 + max(tRTP,8) - 8</csr:p>
         <csr:p>(*) When both DDR4 SDRAM and ST-MRAM are used simultaneously, use SDRAM's tRP value for calculation.</csr:p>
         <csr:p></csr:p>
         <csr:p>When the controller is operating in 1:2 mode, 1T mode, divide the above value by 2. No rounding up. </csr:p>
         <csr:p>When the controller is operating in 1:2 mode, 2T mode or LPDDR4 mode, divide the above value by 2 and round it up to the next integer value.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x04</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_xp</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_XP_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_XP_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_XP_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_XP_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_XP_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_XP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_XP_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG1_T_XP_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2255</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tXP: Minimum time after power-down exit to any operation.  For DDR3, this should be programmed to tXPDLL if slow powerdown exit is selected in MR0[12].  </csr:p>
         <csr:p>If C/A parity for DDR4 is used, set to (tXP+PL) instead. </csr:p>
         <csr:p>If LPDDR4 is selected and its spec has tCKELPD parameter, set to the larger of tXP and tCKELPD instead.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to (tXP/2) and round it up to the next integer value.</csr:p>
         <csr:p>Units: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>20</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x08</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>21</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG2</csr:referenceName>
       <csr:identifier>DRAMTMG2</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2400</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x108</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0305060d</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DRAMTMG2</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Timing Register 2</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>wr2rd</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WR2RD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WR2RD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WR2RD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WR2RD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WR2RD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WR2RD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WR2RD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WR2RD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2300</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>DDR4: CWL + PL + BL/2 + tWTR_L</csr:p>
         <csr:p>LPDDR2/3/4: WL + BL/2 + tWTR + 1</csr:p>
         <csr:p>Others: CWL + BL/2 + tWTR</csr:p>
         <csr:p>In DDR4, minimum time from write command to read command for same bank group. In others, minimum time from write command to read command. Includes time for bus turnaround, recovery times, and all per-bank, per-rank, and global constraints.</csr:p>
         <csr:p></csr:p>
         <csr:p>Please see the relevant PHY databook for details of what should be included here.</csr:p>
         <csr:p>Where:</csr:p>
         <csr:p> - CWL = CAS write latency</csr:p>
         <csr:p> - WL = Write latency</csr:p>
         <csr:p> - PL = Parity latency</csr:p>
         <csr:p> - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM</csr:p>
         <csr:p> - tWTR_L = internal write to read command delay for same bank group. This comes directly from the SDRAM specification. </csr:p>
         <csr:p> - tWTR = internal write to read command delay. This comes directly from the SDRAM specification. </csr:p>
         <csr:p>After PHY has completed training the value programmed may need to be increased. Refer to relevant PHY documentation.</csr:p>
         <csr:p></csr:p>
         <csr:p>Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 operation. </csr:p>
         <csr:p>WTR_L should be increased by one if DDR4 2tCK write preamble is used.</csr:p>
         <csr:p>When the controller is operating in 1:2 mode, divide the value calculated using the above equation by 2, and round it up to next integer.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0d</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd2wr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_RD2WR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_RD2WR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_RD2WR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_RD2WR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_RD2WR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_RD2WR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_RD2WR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_RD2WR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2352</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>DDR2/3/mDDR: RL + BL/2 + 2 - WL</csr:p>
         <csr:p></csr:p>
         <csr:p>DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL</csr:p>
         <csr:p></csr:p>
         <csr:p>LPDDR2/LPDDR3: RL + BL/2 + RU(tDQSCKmax/tCK) + 1 - WL</csr:p>
         <csr:p></csr:p>
         <csr:p>LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL</csr:p>
         <csr:p></csr:p>
         <csr:p>LPDDR4(DQ ODT is Enabled) : RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE - ODTLon - RU(tODTon(min)/tCK) + 1</csr:p>
         <csr:p></csr:p>
         <csr:p>Minimum time from read command to write command. Include time for bus turnaround and all per-bank, per-rank, and global constraints.</csr:p>
         <csr:p></csr:p>
         <csr:p>Please see the relevant PHY databook for details of what should be included here.</csr:p>
         <csr:p>Where:</csr:p>
         <csr:p> - WL = write latency</csr:p>
         <csr:p> - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM</csr:p>
         <csr:p> - RL = read latency = CAS latency</csr:p>
         <csr:p> - WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble).  This is unique to DDR4 and LPDDR4.</csr:p>
         <csr:p> - RD_POSTAMBLE = 0.5 (0.5tCK read postamble), 1.5 (1.5tCK read postamble).  This is unique to LPDDR4.</csr:p>
         <csr:p>After PHY has completed training the value programmed may need to be increased. Refer to relevant PHY documentation.</csr:p>
         <csr:p></csr:p>
         <csr:p>For LPDDR2/LPDDR3/LPDDR4, if derating is enabled (DERATEEN.derate_enable=1), derated tDQSCKmax should be used.</csr:p>
         <csr:p></csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the above equation by 2, and round it up to next integer.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x06</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>read_latency</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_READ_LATENCY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_READ_LATENCY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_READ_LATENCY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_READ_LATENCY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_READ_LATENCY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_READ_LATENCY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_READ_LATENCY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_READ_LATENCY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2375</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Set to RL</csr:p>
         <csr:p>Time from read command to read data on SDRAM interface. This must be set to RL.</csr:p>
         <csr:p>Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to adjust the value of RL to compensate for the extra cycle of latency through the RDIMM/LRDIMM.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the above equation by 2, and round it up to next integer.</csr:p>
         <csr:p>This register field is not required for DDR2 and DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols</csr:p>
         <csr:p>For all protocols, in addition to programming this register field, it is necessary to program DFITMG0 and DFITMG1 to control the read and write latencies</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>21</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x05</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>22</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>write_latency</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WRITE_LATENCY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WRITE_LATENCY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WRITE_LATENCY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WRITE_LATENCY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WRITE_LATENCY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WRITE_LATENCY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WRITE_LATENCY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG2_WRITE_LATENCY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2399</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Set to WL</csr:p>
         <csr:p>Time from write command to write data on SDRAM interface. This must be set to WL.</csr:p>
         <csr:p>For mDDR, it should normally be set to 1.</csr:p>
         <csr:p>Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to adjust the value of WL to compensate for the extra cycle of latency through the RDIMM/LRDIMM.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the above equation by 2, and round it up to next integer.</csr:p>
         <csr:p>This register field is not required for DDR2 and DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols</csr:p>
         <csr:p>For all protocols, in addition to programming this register field, it is necessary to program DFITMG0 and DFITMG1 to control the read and write latencies</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>29</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x03</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>30</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG3</csr:referenceName>
       <csr:identifier>DRAMTMG3</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG3_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG3_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2448</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x10C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00504000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DRAMTMG3</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Timing Register 3</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>11</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_mrd</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2425</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tMRD: Cycles to wait after a mode register write or read. Depending on the connected SDRAM, tMRD represents:</csr:p>
         <csr:p>DDR2/mDDR: Time from MRS to any command</csr:p>
         <csr:p>DDR3/4: Time from MRS to MRS command</csr:p>
         <csr:p>LPDDR2: not used</csr:p>
         <csr:p>LPDDR3/4: Time from MRS to non-MRS command.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to (tMRD/2) and round it up to the next integer value.</csr:p>
         <csr:p>If C/A parity for DDR4 is used, set to tMRD_PAR(tMOD+PL) instead.</csr:p>
         <csr:p>If CAL mode is enabled (DFITMG1.dfi_t_cmd_lat &gt; 0), tCAL (=DFITMG1.dfi_cmd_lat) should be added to the above calculations.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x04</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>19</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_mrw</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRW_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRW_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRW_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRW_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRW_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRW_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG3_T_MRW_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2447</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Time to wait after a mode register write or read (MRW or MRR).</csr:p>
         <csr:p>Present only in designs configured to support LPDDR2, LPDDR3 or LPDDR4.</csr:p>
         <csr:p>LPDDR2 typically requires value of 5.</csr:p>
         <csr:p>LPDDR3 typically requires value of 10.</csr:p>
         <csr:p>LPDDR4: Set this to the larger of tMRW and tMRWCKEL.</csr:p>
         <csr:p>For LPDDR2, this register is used for the time from a MRW/MRR to all other commands.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to the above values divided by 2 and round it up to the next integer value.</csr:p>
         <csr:p>For LDPDR3, this register is used for the time from a MRW/MRR to a MRW/MRR.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>29</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x005</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>30</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG4</csr:referenceName>
       <csr:identifier>DRAMTMG4</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG4_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG4_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2520</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x110</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x05040405</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DRAMTMG4</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Timing Register 4</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>t_rp</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RP_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RP_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RP_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RP_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RP_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RP_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RP_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2473</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tRP:  Minimum time from single-bank precharge to activate of same bank.</csr:p>
         <csr:p></csr:p>
         <csr:p>    When the controller is operating in 1:1 frequency ratio mode, t_rp should be set to RoundUp(tRP/tCK).</csr:p>
         <csr:p></csr:p>
         <csr:p>    When the controller is operating in 1:2 frequency ratio mode, t_rp should be set to RoundDown(RoundUp(tRP/tCK)/2) + 1.</csr:p>
         <csr:p></csr:p>
         <csr:p>    When the controller is operating in 1:2 frequency ratio mode in LPDDR4, t_rp should be set to RoundUp(RoundUp(tRP/tCK)/2).</csr:p>
         <csr:p></csr:p>
         <csr:p>    Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x05</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_rrd</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RRD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RRD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RRD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RRD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RRD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RRD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RRD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RRD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2488</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DDR4: tRRD_L: Minimum time between activates from bank "a" to bank "b" for same bank group.</csr:p>
         <csr:p>Others: tRRD: Minimum time between activates from bank "a" to bank "b"</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to (tRRD_L/2 or tRRD/2) and round it up to the next integer value.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x4</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_ccd</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_CCD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_CCD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_CCD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_CCD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_CCD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_CCD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_CCD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_CCD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2503</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DDR4: tCCD_L: This is the minimum time between two reads or two writes for same bank group.</csr:p>
         <csr:p>Others: tCCD: This is the minimum time between two reads or two writes.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to (tCCD_L/2 or tCCD/2) and round it up to the next integer value.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x4</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_rcd</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RCD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RCD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RCD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RCD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RCD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RCD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RCD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG4_T_RCD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2519</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tRCD - tAL: Minimum time from activate to read or write command to same bank.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to ((tRCD - tAL)/2) and round it up to the next integer value. </csr:p>
         <csr:p>Minimum value allowed for this register is 1, which implies minimum (tRCD - tAL) value to be 2 when the controller is operating in 1:2 frequency ratio mode.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>28</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x05</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG5</csr:referenceName>
       <csr:identifier>DRAMTMG5</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG5_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG5_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2620</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x114</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x05050403</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DRAMTMG5</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Timing Register 5</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>t_cke</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2542</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Minimum number of cycles of CKE HIGH/LOW during power-down and self refresh.</csr:p>
         <csr:p> - LPDDR2/LPDDR3 mode: Set this to the larger of tCKE or tCKESR</csr:p>
         <csr:p> - LPDDR4 mode: Set this to the larger of tCKE or tSR.</csr:p>
         <csr:p> - Non-LPDDR2/non-LPDDR3/non-LPDDR4 designs: Set this to tCKE value.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to (value described above)/2 and round it up to the next integer value.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x03</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_ckesr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKESR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKESR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKESR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKESR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKESR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKESR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKESR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKESR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2568</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Minimum CKE low width for Self refresh or Self refresh power down entry to exit timing in memory clock cycles. </csr:p>
         <csr:p></csr:p>
         <csr:p>Recommended settings:</csr:p>
         <csr:p>    - mDDR: tRFC</csr:p>
         <csr:p>    - LPDDR2: tCKESR</csr:p>
         <csr:p>    - LPDDR3: tCKESR</csr:p>
         <csr:p>    - LPDDR4: max(tCKE, tSR)</csr:p>
         <csr:p>    - DDR2: tCKE </csr:p>
         <csr:p>    - DDR3: tCKE + 1  </csr:p>
         <csr:p>    - DDR4: tCKE + 1 (+ PL(parity latency)(*)) </csr:p>
         <csr:p>(*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register should be increased by PL.</csr:p>
         <csr:p></csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x04</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_cksre</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2595</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This is the time after Self Refresh Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after SRE. </csr:p>
         <csr:p></csr:p>
         <csr:p>   Recommended settings:</csr:p>
         <csr:p>    - mDDR: 0</csr:p>
         <csr:p>    - LPDDR2: 2</csr:p>
         <csr:p>    - LPDDR3: 2</csr:p>
         <csr:p>    - LPDDR4: tCKELCK</csr:p>
         <csr:p>    - DDR2: 1 </csr:p>
         <csr:p>    - DDR3: max (10 ns, 5 tCK)</csr:p>
         <csr:p>    - DDR4: max (10 ns, 5 tCK) (+ PL(parity latency)(*))</csr:p>
         <csr:p>(*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register should be increased by PL.</csr:p>
         <csr:p></csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x5</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_cksrx</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRX_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRX_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRX_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRX_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRX_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRX_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRX_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG5_T_CKSRX_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2619</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This is the time before Self Refresh Exit that CK is maintained as a valid clock before issuing SRX. Specifies the clock stable time before SRX. </csr:p>
         <csr:p></csr:p>
         <csr:p>    Recommended settings:</csr:p>
         <csr:p>    - mDDR: 1</csr:p>
         <csr:p>    - LPDDR2: 2</csr:p>
         <csr:p>    - LPDDR3: 2</csr:p>
         <csr:p>    - LPDDR4: tCKCKEH</csr:p>
         <csr:p>    - DDR2: 1  </csr:p>
         <csr:p>    - DDR3: tCKSRX </csr:p>
         <csr:p>    - DDR4: tCKSRX </csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>27</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x5</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG6</csr:referenceName>
       <csr:identifier>DRAMTMG6</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG6_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG6_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2695</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x118</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x02020005</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DRAMTMG6</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Timing Register 6</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>t_ckcsx</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKCSX_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKCSX_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKCSX_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKCSX_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKCSX_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKCSX_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKCSX_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKCSX_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2648</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This is the time before Clock Stop Exit that CK is maintained as a valid clock before issuing Clock Stop Exit. Specifies the clock stable time before next command after Clock Stop Exit. </csr:p>
         <csr:p></csr:p>
         <csr:p>    Recommended settings:</csr:p>
         <csr:p>    - mDDR: 1</csr:p>
         <csr:p>    - LPDDR2: tXP + 2</csr:p>
         <csr:p>    - LPDDR3: tXP + 2</csr:p>
         <csr:p>    - LPDDR4: tXP + 2</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. </csr:p>
         <csr:p></csr:p>
         <csr:p>This is only present for designs supporting mDDR or LPDDR2/LPDDR3/LPDDR4 devices.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x5</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_ckdpdx</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDX_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDX_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDX_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDX_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDX_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDX_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDX_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDX_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2671</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This is the time before Deep Power Down Exit that CK is maintained as a valid clock before issuing DPDX. Specifies the clock stable time before DPDX. </csr:p>
         <csr:p></csr:p>
         <csr:p>    Recommended settings:</csr:p>
         <csr:p>    - mDDR: 1</csr:p>
         <csr:p>    - LPDDR2: 2</csr:p>
         <csr:p>    - LPDDR3: 2</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. </csr:p>
         <csr:p></csr:p>
         <csr:p>This is only present for designs supporting mDDR or LPDDR2 devices.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x2</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_ckdpde</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG6_T_CKDPDE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2694</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This is the time after Deep Power Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after DPDE. </csr:p>
         <csr:p></csr:p>
         <csr:p>Recommended settings:</csr:p>
         <csr:p>    - mDDR: 0</csr:p>
         <csr:p>    - LPDDR2: 2</csr:p>
         <csr:p>    - LPDDR3: 2</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. </csr:p>
         <csr:p></csr:p>
         <csr:p>This is only present for designs supporting mDDR or LPDDR2/LPDDR3 devices.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>27</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x2</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG7</csr:referenceName>
       <csr:identifier>DRAMTMG7</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG7_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG7_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2751</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x11C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000202</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DRAMTMG7</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Timing Register 7</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>t_ckpdx</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDX_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDX_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDX_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDX_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDX_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDX_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDX_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDX_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2724</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This is the time before Power Down Exit that CK is maintained as a valid clock before issuing PDX. Specifies the clock stable time before PDX. </csr:p>
         <csr:p></csr:p>
         <csr:p>    Recommended settings:</csr:p>
         <csr:p>    - mDDR: 0</csr:p>
         <csr:p>    - LPDDR2: 2</csr:p>
         <csr:p>    - LPDDR3: 2</csr:p>
         <csr:p>    - LPDDR4: tCKCKEH</csr:p>
         <csr:p>When using DDR2/3/4 SDRAM, this register should be set to the same value as DRAMTMG5.t_cksrx.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. </csr:p>
         <csr:p></csr:p>
         <csr:p>This is only present for designs supporting mDDR or LPDDR2/LPDDR3/LPDDR4 devices.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x2</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_ckpde</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG7_T_CKPDE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2750</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This is the time after Power Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after PDE. </csr:p>
         <csr:p></csr:p>
         <csr:p>    Recommended settings:</csr:p>
         <csr:p>    - mDDR: 0</csr:p>
         <csr:p>    - LPDDR2: 2</csr:p>
         <csr:p>    - LPDDR3: 2</csr:p>
         <csr:p>    - LPDDR4: tCKELCK</csr:p>
         <csr:p>When using DDR2/3/4 SDRAM, this register should be set to the same value as DRAMTMG5.t_cksre.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. </csr:p>
         <csr:p></csr:p>
         <csr:p>This is only present for designs supporting mDDR or LPDDR2/LPDDR3/LPDDR4 devices.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x2</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG8</csr:referenceName>
       <csr:identifier>DRAMTMG8</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG8_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG8_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2789</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x120</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00004405</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DRAMTMG8</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Timing Register 8</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>t_xs_x32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_X32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_X32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_X32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_X32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_X32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_X32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_X32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_X32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2771</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tXS: Exit Self Refresh to commands not requiring a locked DLL.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value.</csr:p>
         <csr:p>Note: Used only for DDR2, DDR3 and DDR4 SDRAMs.</csr:p>
         <csr:p>Unit: Multiples of 32 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x05</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_xs_dll_x32</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_DLL_X32_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_DLL_X32_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_DLL_X32_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_DLL_X32_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_DLL_X32_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_DLL_X32_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_DLL_X32_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG8_T_XS_DLL_X32_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2788</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tXSDLL: Exit Self Refresh to commands requiring a locked DLL.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value.</csr:p>
         <csr:p>Note: Used only for DDR2, DDR3 and DDR4 SDRAMs.</csr:p>
         <csr:p>Unit: Multiples of 32 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>14</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x44</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG12</csr:referenceName>
       <csr:identifier>DRAMTMG12</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG12_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG12_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG12_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG12_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2806</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x130</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00020000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DRAMTMG12</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Timing Register 12</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_cmdcke</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG12_T_CMDCKE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG12_T_CMDCKE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG12_T_CMDCKE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG12_T_CMDCKE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG12_T_CMDCKE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG12_T_CMDCKE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG12_T_CMDCKE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG12_T_CMDCKE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2805</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tCMDCKE:  Delay from valid command to CKE input LOW.</csr:p>
         <csr:p>Set this to the larger of tESCKE or tCMDCKE</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to (max(tESCKE, tCMDCKE)/2) and round it up to the next integer value.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x2</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG13</csr:referenceName>
       <csr:identifier>DRAMTMG13</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG13_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG13_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2849</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x134</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x1c200004</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DRAMTMG13</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Timing Register 13</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>t_ppd</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_PPD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_PPD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_PPD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_PPD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_PPD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_PPD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_PPD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_PPD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2822</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>LPDDR4: tPPD: This is the minimum time from precharge to precharge command.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to (tPPD/2) and round it up to the next integer value.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x4</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_ccd_mw</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_CCD_MW_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_CCD_MW_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_CCD_MW_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_CCD_MW_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_CCD_MW_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_CCD_MW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_CCD_MW_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_T_CCD_MW_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2835</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>LPDDR4: tCCDMW: This is the minimum time from write or masked write to masked write command for same bank.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to (tCCDMW/2) and round it up to the next integer value.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>21</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x20</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>22</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>odtloff</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_ODTLOFF_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_ODTLOFF_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_ODTLOFF_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_ODTLOFF_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_ODTLOFF_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_ODTLOFF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_ODTLOFF_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG13_ODTLOFF_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2848</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>LPDDR4: ODTLoff: This is the latency from CAS-2 command to ODToff reference.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to (ODTLoff/2) and round it up to the next integer value.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>30</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x1c</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DRAMTMG14</csr:referenceName>
       <csr:identifier>DRAMTMG14</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG14_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DRAMTMG14_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG14_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG14_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2867</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x138</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x000000a0</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DRAMTMG14</csr:typeName>
        <csr:description>
         <csr:p>SDRAM Timing Register 14</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>t_xsr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG14_T_XSR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG14_T_XSR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG14_T_XSR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG14_T_XSR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG14_T_XSR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG14_T_XSR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG14_T_XSR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DRAMTMG14_T_XSR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2866</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tXSR: Exit Self Refresh to any command.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value.</csr:p>
         <csr:p>  The value 0xfff is illegal for this register field. </csr:p>
         <csr:p>Note: Used only for mDDR/LPDDR2/LPDDR3/LPDDR4 mode.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0a0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ZQCTL0</csr:referenceName>
       <csr:identifier>ZQCTL0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ZQCTL0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ZQCTL0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2959</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x180</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x02000040</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ZQCTL0</csr:typeName>
        <csr:description>
         <csr:p>ZQ Control Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>t_zq_short_nop</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_SHORT_NOP_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_SHORT_NOP_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_SHORT_NOP_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_SHORT_NOP_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_SHORT_NOP_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_SHORT_NOP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_SHORT_NOP_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_SHORT_NOP_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2887</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tZQCS for DDR3/DD4/LPDDR2/LPDDR3, tZQLAT for LPDDR4: Number of DFI clock cycles of NOP required after a ZQCS (ZQ calibration short)/MPC(ZQ Latch) command is issued to SDRAM.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to tZQCS/2 and round it up to the next integer value.</csr:p>
         <csr:p>This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x040</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_zq_long_nop</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_LONG_NOP_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_LONG_NOP_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_LONG_NOP_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_LONG_NOP_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_LONG_NOP_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_LONG_NOP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_LONG_NOP_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_T_ZQ_LONG_NOP_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2909</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tZQoper for DDR3/DDR4, tZQCL for LPDDR2/LPDDR3, tZQCAL for LPDDR4: Number of DFI clock cycles of NOP required after a ZQCL (ZQ calibration long)/MPC(ZQ Start) command is issued to SDRAM.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode:</csr:p>
         <csr:p>DDR3/DDR4: program this to tZQoper/2 and round it up to the next integer value.</csr:p>
         <csr:p>LPDDR2/LPDDR3: program this to tZQCL/2 and round it up to the next integer value.</csr:p>
         <csr:p>LPDDR4: program this to tZQCAL/2 and round it up to the next integer value.</csr:p>
         <csr:p>This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>26</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x200</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>28</csr:msb>
         <csr:lsb>27</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>zq_resistor_shared</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_ZQ_RESISTOR_SHARED_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_ZQ_RESISTOR_SHARED_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_ZQ_RESISTOR_SHARED_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_ZQ_RESISTOR_SHARED_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_ZQ_RESISTOR_SHARED_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_ZQ_RESISTOR_SHARED_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_ZQ_RESISTOR_SHARED_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_ZQ_RESISTOR_SHARED_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2926</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p> - 1 - Denotes that ZQ resistor is shared between ranks. Means ZQinit/ZQCL/ZQCS/MPC(ZQ calibration) commands are sent to one rank at a time with tZQinit/tZQCL/tZQCS/tZQCAL/tZQLAT timing met between commands so that commands to different ranks do not overlap. </csr:p>
         <csr:p> - 0 - ZQ resistor is not shared.</csr:p>
         <csr:p>This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>29</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dis_srx_zqcl</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_SRX_ZQCL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_SRX_ZQCL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_SRX_ZQCL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_SRX_ZQCL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_SRX_ZQCL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_SRX_ZQCL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_SRX_ZQCL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_SRX_ZQCL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2942</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p> - 1 - Disable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit. Only applicable when run in DDR3 or DDR4 or LPDDR2 or LPDDR3 or LPDDR4 mode.</csr:p>
         <csr:p> - 0 - Enable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit. Only applicable when run in DDR3 or DDR4 or LPDDR2 or LPDDR3 or LPDDR4 mode.</csr:p>
         <csr:p>This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>30</csr:msb>
         <csr:lsb>30</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dis_auto_zq</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_AUTO_ZQ_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_AUTO_ZQ_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_AUTO_ZQ_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_AUTO_ZQ_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_AUTO_ZQ_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_AUTO_ZQ_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_AUTO_ZQ_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL0_DIS_AUTO_ZQ_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2958</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p> - 1 - Disable uMCTL2 generation of ZQCS/MPC(ZQ calibration) command.  Register DBGCMD.zq_calib_short can be used instead to issue ZQ calibration request from APB module.</csr:p>
         <csr:p> - 0 - Internally generate ZQCS/MPC(ZQ calibration) commands based on ZQCTL1.t_zq_short_interval_x1024.</csr:p>
         <csr:p>This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ZQCTL1</csr:referenceName>
       <csr:identifier>ZQCTL1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ZQCTL1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ZQCTL1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>2996</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x184</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x02000100</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ZQCTL1</csr:typeName>
        <csr:description>
         <csr:p>ZQ Control Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>t_zq_short_interval_x1024</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2979</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Average interval to wait between automatically issuing ZQCS (ZQ calibration short)/MPC(ZQ calibration) commands to DDR3/DDR4/LPDDR2/LPDDR3/LPDDR4 devices.</csr:p>
         <csr:p>Meaningless, if ZQCTL0.dis_auto_zq=1.</csr:p>
         <csr:p>This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices.</csr:p>
         <csr:p>Unit: Multiples of 1024 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00100</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>t_zq_reset_nop</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_RESET_NOP_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_RESET_NOP_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_RESET_NOP_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_RESET_NOP_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_RESET_NOP_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_RESET_NOP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_RESET_NOP_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL1_T_ZQ_RESET_NOP_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>2995</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>tZQReset: Number of DFI clock cycles of NOP required after a ZQReset (ZQ calibration Reset) command is issued to SDRAM.</csr:p>
         <csr:p>When the controller is operating in 1:2 frequency ratio mode, program this to tZQReset/2 and round it up to the next integer value.</csr:p>
         <csr:p>This is only present for designs supporting LPDDR2/LPDDR3/LPDDR4 devices.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>29</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x020</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>30</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ZQCTL2</csr:referenceName>
       <csr:identifier>ZQCTL2</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ZQCTL2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ZQCTL2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3023</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x188</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ZQCTL2</csr:typeName>
        <csr:description>
         <csr:p>ZQ Control Register 2</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>zq_reset</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL2_ZQ_RESET_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL2_ZQ_RESET_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL2_ZQ_RESET_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL2_ZQ_RESET_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL2_ZQ_RESET_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL2_ZQ_RESET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL2_ZQ_RESET_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ZQCTL2_ZQ_RESET_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3022</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Setting this register bit to 1 triggers a ZQ Reset operation. When the ZQ Reset operation is complete, the uMCTL2 automatically clears this bit. It is recommended NOT to set this register bit if in Init, in Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) or Deep power-down operating modes.</csr:p>
         <csr:p>For Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) it will be scheduled after SR(except LPDDR4) or SPRD(LPDDR4) has been exited.</csr:p>
         <csr:p>For Deep power down, it will not be scheduled, although ZQSTAT.zq_reset_busy will be de-asserted.</csr:p>
         <csr:p>This is only present for designs supporting LPDDR2/LPDDR3/LPDDR4 devices.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1S</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ZQSTAT</csr:referenceName>
       <csr:identifier>ZQSTAT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ZQSTAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ZQSTAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ZQSTAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ZQSTAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3044</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x18C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ZQSTAT</csr:typeName>
        <csr:description>
         <csr:p>ZQ Status Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>zq_reset_busy</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ZQSTAT_ZQ_RESET_BUSY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ZQSTAT_ZQ_RESET_BUSY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ZQSTAT_ZQ_RESET_BUSY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ZQSTAT_ZQ_RESET_BUSY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ZQSTAT_ZQ_RESET_BUSY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ZQSTAT_ZQ_RESET_BUSY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ZQSTAT_ZQ_RESET_BUSY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ZQSTAT_ZQ_RESET_BUSY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3043</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SoC core may initiate a ZQ Reset operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the ZQ Reset request. It goes low when the ZQ Reset command is issued to the SDRAM and the associated NOP period is over. It is recommended not to perform ZQ Reset commands when this signal is high.</csr:p>
         <csr:p> - 0 - Indicates that the SoC core can initiate a ZQ Reset operation</csr:p>
         <csr:p> - 1 - Indicates that ZQ Reset operation is in progress</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFITMG0</csr:referenceName>
       <csr:identifier>DFITMG0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFITMG0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFITMG0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3162</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x190</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x07020002</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DFITMG0</csr:typeName>
        <csr:description>
         <csr:p>DFI Timing Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dfi_tphy_wrlat</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRLAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRLAT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRLAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRLAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRLAT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRLAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRLAT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRLAT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3066</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Write latency</csr:p>
         <csr:p>Number of clocks from the write command to write data enable (dfi_wrdata_en).  This corresponds to the DFI timing parameter tphy_wrlat.</csr:p>
         <csr:p>Refer to PHY specification for correct value.Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of tphy_wrlat. This is to compensate for the extra cycle(s) of latency through the RDIMM/LRDIMM.</csr:p>
         <csr:p>For LPDDR4, dfi_tphy_wrlat&gt;60 is not supported.</csr:p>
         <csr:p>Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x02</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_tphy_wrdata</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRDATA_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRDATA_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRDATA_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRDATA_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRDATA_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRDATA_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRDATA_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_TPHY_WRDATA_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3081</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the number of clock cycles between when dfi_wrdata_en is asserted to when the associated write data is driven on the dfi_wrdata signal.  This corresponds to the DFI timing parameter tphy_wrdata.  Refer to PHY specification for correct value. Note, max supported value is 8.</csr:p>
         <csr:p>Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 4</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>14</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_wrdata_use_dfi_phy_clk</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3105</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Defines whether dfi_wrdata_en/dfi_wrdata/dfi_wrdata_mask is generated using HDR (DFI clock) or SDR (DFI PHY clock) values</csr:p>
         <csr:p>Selects whether value in DFITMG0.dfi_tphy_wrlat  is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles</csr:p>
         <csr:p>Selects whether value in DFITMG0.dfi_tphy_wrdata is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles</csr:p>
         <csr:p> - 0 in terms of HDR (DFI clock) cycles</csr:p>
         <csr:p> - 1 in terms of SDR (DFI PHY clock) cycles</csr:p>
         <csr:p>Refer to PHY specification for correct value.</csr:p>
         <csr:p>If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:</csr:p>
         <csr:p> - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field should be set to 0</csr:p>
         <csr:p> - Else, it must be set to 1</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_t_rddata_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_RDDATA_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_RDDATA_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_RDDATA_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_RDDATA_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_RDDATA_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_RDDATA_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_RDDATA_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_RDDATA_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3122</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Time from the assertion of a read command on the DFI interface to the assertion of the dfi_rddata_en signal.</csr:p>
         <csr:p>Refer to PHY specification for correct value.</csr:p>
         <csr:p>This corresponds to the DFI parameter trddata_en. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of trddata_en. This is to compensate for the extra cycle(s) of latency through the RDIMM/LRDIMM.</csr:p>
         <csr:p>Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_rddata_use_dfi_phy_clk.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 4</csr:p>
        </csr:description>
         <csr:msb>22</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x02</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_rddata_use_dfi_phy_clk</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3144</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Defines whether dfi_rddata_en/dfi_rddata/dfi_rddata_valid is generated using HDR (DFI clock) or SDR (DFI PHY clock) values.  </csr:p>
         <csr:p>Selects whether value in DFITMG0.dfi_t_rddata_en is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles:</csr:p>
         <csr:p> - 0 in terms of HDR (DFI clock) cycles</csr:p>
         <csr:p> - 1 in terms of SDR (DFI PHY clock) cycles</csr:p>
         <csr:p>Refer to PHY specification for correct value.</csr:p>
         <csr:p>If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:</csr:p>
         <csr:p> - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field should be set to 0</csr:p>
         <csr:p> - Else, it must be set to 1</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>23</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_t_ctrl_delay</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_CTRL_DELAY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_CTRL_DELAY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_CTRL_DELAY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_CTRL_DELAY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_CTRL_DELAY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_CTRL_DELAY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_CTRL_DELAY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFITMG0_DFI_T_CTRL_DELAY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3161</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the number of DFI clock cycles after an assertion or de-assertion of the DFI control signals that the control signals at the PHY-DRAM interface reflect the assertion or de-assertion. If the DFI clock and the memory clock are not phase-aligned, this timing parameter should be rounded up to the next integer value. Note that if using RDIMM/LRDIMM, it is necessary to increment this parameter by RDIMM's/LRDIMM's extra cycle of latency in terms of DFI clock.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 4</csr:p>
        </csr:description>
         <csr:msb>28</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x07</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFITMG1</csr:referenceName>
       <csr:identifier>DFITMG1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFITMG1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFITMG1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3220</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x194</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000404</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DFITMG1</csr:typeName>
        <csr:description>
         <csr:p>DFI Timing Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dfi_t_dram_clk_enable</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_ENABLE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_ENABLE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_ENABLE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_ENABLE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_ENABLE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_ENABLE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_ENABLE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_ENABLE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3179</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the number of DFI clock cycles from the de-assertion of the dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 4</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x04</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_t_dram_clk_disable</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_DISABLE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_DISABLE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_DISABLE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_DISABLE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_DISABLE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_DISABLE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_DISABLE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_DRAM_CLK_DISABLE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3193</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the number of DFI clock cycles from the assertion of the dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory devices, at the PHY-DRAM boundary, maintains a low value. If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 4</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x04</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_t_wrdata_delay</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_WRDATA_DELAY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_WRDATA_DELAY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_WRDATA_DELAY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_WRDATA_DELAY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_WRDATA_DELAY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_WRDATA_DELAY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_WRDATA_DELAY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFITMG1_DFI_T_WRDATA_DELAY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3219</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the number of DFI clock cycles between when the dfi_wrdata_en</csr:p>
         <csr:p>signal is asserted and when the corresponding write data transfer is completed on the DRAM bus. </csr:p>
         <csr:p>This corresponds to the DFI timing parameter twrdata_delay.  Refer to PHY specification for correct value. </csr:p>
         <csr:p>For DFI 3.0 PHY, set to twrdata_delay, a new timing parameter introduced in DFI 3.0.</csr:p>
         <csr:p>For DFI 2.1 PHY, set to tphy_wrdata + (delay of DFI write data to the DRAM). </csr:p>
         <csr:p>Value to be programmed is in terms of DFI clocks, not PHY clocks.</csr:p>
         <csr:p>In FREQ_RATIO=2, divide PHY's value by 2 and round up to next integer.</csr:p>
         <csr:p>If using DFITMG0.dfi_wrdata_use_dfi_phy_clk=1, add 1 to the value.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 4</csr:p>
        </csr:description>
         <csr:msb>20</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>21</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFILPCFG0</csr:referenceName>
       <csr:identifier>DFILPCFG0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFILPCFG0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFILPCFG0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3355</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x198</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x07000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DFILPCFG0</csr:typeName>
        <csr:description>
         <csr:p>DFI Low Power Configuration Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dfi_lp_en_pd</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_PD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_PD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_PD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_PD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_PD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_PD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_PD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_PD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3234</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enables DFI Low Power interface handshaking during Power Down Entry/Exit.</csr:p>
         <csr:p>  - 0 - Disabled </csr:p>
         <csr:p>  - 1 - Enabled</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_lp_wakeup_pd</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_PD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_PD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_PD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_PD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_PD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_PD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_PD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_PD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3261</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Value in DFI clock cycles to drive on dfi_lp_wakeup signal when Power Down mode is entered. </csr:p>
         <csr:p>Determines the DFI's tlp_wakeup time:</csr:p>
         <csr:p>  - 0x0 - 16 cycles</csr:p>
         <csr:p>  - 0x1 - 32 cycles</csr:p>
         <csr:p>  - 0x2 - 64 cycles</csr:p>
         <csr:p>  - 0x3 - 128 cycles</csr:p>
         <csr:p>  - 0x4 - 256 cycles</csr:p>
         <csr:p>  - 0x5 - 512 cycles</csr:p>
         <csr:p>  - 0x6 - 1024 cycles</csr:p>
         <csr:p>  - 0x7 - 2048 cycles</csr:p>
         <csr:p>  - 0x8 - 4096 cycles</csr:p>
         <csr:p>  - 0x9 - 8192 cycles</csr:p>
         <csr:p>  - 0xA - 16384 cycles</csr:p>
         <csr:p>  - 0xB - 32768 cycles</csr:p>
         <csr:p>  - 0xC - 65536 cycles</csr:p>
         <csr:p>  - 0xD - 131072 cycles</csr:p>
         <csr:p>  - 0xE - 262144 cycles</csr:p>
         <csr:p>  - 0xF - Unlimited</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_lp_en_sr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_SR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_SR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_SR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_SR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_SR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_SR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_SR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_SR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3272</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enables DFI Low Power interface handshaking during Self Refresh Entry/Exit.</csr:p>
         <csr:p>  - 0 - Disabled </csr:p>
         <csr:p>  - 1 - Enabled</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>11</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_lp_wakeup_sr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_SR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_SR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_SR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_SR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_SR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_SR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_SR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_SR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3299</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Value in DFI clock cycles to drive on dfi_lp_wakeup signal when Self Refresh mode is entered. </csr:p>
         <csr:p>Determines the DFI's tlp_wakeup time:</csr:p>
         <csr:p>  - 0x0 - 16 cycles</csr:p>
         <csr:p>  - 0x1 - 32 cycles</csr:p>
         <csr:p>  - 0x2 - 64 cycles</csr:p>
         <csr:p>  - 0x3 - 128 cycles</csr:p>
         <csr:p>  - 0x4 - 256 cycles</csr:p>
         <csr:p>  - 0x5 - 512 cycles</csr:p>
         <csr:p>  - 0x6 - 1024 cycles</csr:p>
         <csr:p>  - 0x7 - 2048 cycles</csr:p>
         <csr:p>  - 0x8 - 4096 cycles</csr:p>
         <csr:p>  - 0x9 - 8192 cycles</csr:p>
         <csr:p>  - 0xA - 16384 cycles</csr:p>
         <csr:p>  - 0xB - 32768 cycles</csr:p>
         <csr:p>  - 0xC - 65536 cycles</csr:p>
         <csr:p>  - 0xD - 131072 cycles</csr:p>
         <csr:p>  - 0xE - 262144 cycles</csr:p>
         <csr:p>  - 0xF - Unlimited</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_lp_en_dpd</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_DPD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_DPD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_DPD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_DPD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_DPD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_DPD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_DPD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_EN_DPD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3312</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enables DFI Low Power interface handshaking during Deep Power Down Entry/Exit.</csr:p>
         <csr:p>  - 0 - Disabled </csr:p>
         <csr:p>  - 1 - Enabled </csr:p>
         <csr:p>This is only present for designs supporting mDDR or LPDDR2/LPDDR3 devices.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>19</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_lp_wakeup_dpd</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_DPD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_DPD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_DPD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_DPD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_DPD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_DPD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_DPD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_LP_WAKEUP_DPD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3342</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Value in DFI clock cycles to drive on dfi_lp_wakeup signal when Deep Power Down mode is entered. </csr:p>
         <csr:p>Determines the DFI's tlp_wakeup time:</csr:p>
         <csr:p>  - 0x0 - 16 cycles</csr:p>
         <csr:p>  - 0x1 - 32 cycles</csr:p>
         <csr:p>  - 0x2 - 64 cycles</csr:p>
         <csr:p>  - 0x3 - 128 cycles</csr:p>
         <csr:p>  - 0x4 - 256 cycles</csr:p>
         <csr:p>  - 0x5 - 512 cycles</csr:p>
         <csr:p>  - 0x6 - 1024 cycles</csr:p>
         <csr:p>  - 0x7 - 2048 cycles</csr:p>
         <csr:p>  - 0x8 - 4096 cycles</csr:p>
         <csr:p>  - 0x9 - 8192 cycles</csr:p>
         <csr:p>  - 0xA - 16384 cycles</csr:p>
         <csr:p>  - 0xB - 32768 cycles</csr:p>
         <csr:p>  - 0xC - 65536 cycles</csr:p>
         <csr:p>  - 0xD - 131072 cycles</csr:p>
         <csr:p>  - 0xE - 262144 cycles</csr:p>
         <csr:p>  - 0xF - Unlimited</csr:p>
         <csr:p>This is only present for designs supporting mDDR or LPDDR2/LPDDR3 devices.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_tlp_resp</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_TLP_RESP_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_TLP_RESP_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_TLP_RESP_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_TLP_RESP_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_TLP_RESP_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_TLP_RESP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_TLP_RESP_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFILPCFG0_DFI_TLP_RESP_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3354</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Setting in DFI clock cycles for DFI's tlp_resp time. </csr:p>
         <csr:p>Same value is used for both Power Down, Self Refresh, Deep Power Down and Maximum Power Saving modes. </csr:p>
         <csr:p>Refer to PHY databook for recommended values</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>28</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x07</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIUPD0</csr:referenceName>
       <csr:identifier>DFIUPD0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFIUPD0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFIUPD0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3421</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x1A0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00400003</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DFIUPD0</csr:typeName>
        <csr:description>
         <csr:p>DFI Update Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dfi_t_ctrlup_min</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MIN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MIN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MIN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MIN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MIN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MIN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MIN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MIN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3372</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the minimum number of DFI clock cycles that the dfi_ctrlupd_req signal must be asserted. The uMCTL2 expects the PHY to respond within this time.  If the PHY does not respond, the uMCTL2 will de-assert dfi_ctrlupd_req after dfi_t_ctrlup_min + 2 cycles.  Lowest value to assign to this variable is 0x3.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x003</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_t_ctrlup_max</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MAX_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MAX_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MAX_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MAX_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MAX_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MAX_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MAX_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DFI_T_CTRLUP_MAX_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3383</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the maximum number of DFI clock cycles that the dfi_ctrlupd_req signal can assert. Lowest value to assign to this variable is 0x40.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>25</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x040</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>28</csr:msb>
         <csr:lsb>26</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ctrlupd_pre_srx</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_CTRLUPD_PRE_SRX_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_CTRLUPD_PRE_SRX_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_CTRLUPD_PRE_SRX_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_CTRLUPD_PRE_SRX_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_CTRLUPD_PRE_SRX_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_CTRLUPD_PRE_SRX_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_CTRLUPD_PRE_SRX_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_CTRLUPD_PRE_SRX_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3397</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects dfi_ctrlupd_req requirements at SRX:</csr:p>
         <csr:p>  - 0 : send ctrlupd after SRX</csr:p>
         <csr:p>  - 1 : send ctrlupd before SRX</csr:p>
         <csr:p>  If DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no dfi_ctrlupd_req will be issued when SRX.</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>29</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dis_auto_ctrlupd_srx</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3409</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2 at self-refresh exit.</csr:p>
         <csr:p>When '0', uMCTL2 issues a dfi_ctrlupd_req before or after exiting self-refresh,  depending on DFIUPD0.ctrlupd_pre_srx.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>30</csr:msb>
         <csr:lsb>30</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dis_auto_ctrlupd</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD0_DIS_AUTO_CTRLUPD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3420</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2. The core must issue the dfi_ctrlupd_req signal using register DBGCMD.ctrlupd.</csr:p>
         <csr:p>When '0', uMCTL2 issues dfi_ctrlupd_req periodically.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIUPD1</csr:referenceName>
       <csr:identifier>DFIUPD1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFIUPD1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFIUPD1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3466</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x1A4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00010001</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DFIUPD1</csr:typeName>
        <csr:description>
         <csr:p>DFI Update Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dfi_t_ctrlupd_interval_max_x1024</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3448</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This is the maximum amount of time between uMCTL2 initiated DFI update requests. This timer resets with each update request; when the timer expires dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is received. PHY can use this idle time to recalibrate the delay lines to the DLLs. The DFI controller update is also used to reset PHY FIFO pointers in case of data capture errors. Updates are required to maintain calibration over PVT, but frequent updates may impact performance. Minimum allowed value for this field is 1.</csr:p>
         <csr:p>Note: Value programmed for DFIUPD1.dfi_t_ctrlupd_interval_max_x1024 must be greater than DFIUPD1.dfi_t_ctrlupd_interval_min_x1024.</csr:p>
         <csr:p>Unit: Multiples of 1024 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x01</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_t_ctrlupd_interval_min_x1024</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3465</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This is the minimum amount of time between uMCTL2 initiated DFI update requests (which is executed whenever the uMCTL2 is idle). Set this number higher to reduce the frequency of update requests, which can have a small impact on the latency of the first read request when the uMCTL2 is idle. Minimum allowed value for this field is 1.</csr:p>
         <csr:p>Unit: Multiples of 1024 DFI clock cycles.</csr:p>
         <csr:p>Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x01</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIUPD2</csr:referenceName>
       <csr:identifier>DFIUPD2</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFIUPD2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFIUPD2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3481</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x1A8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x80000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DFIUPD2</csr:typeName>
        <csr:description>
         <csr:p>DFI Update Register 2</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>30</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_phyupd_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD2_DFI_PHYUPD_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD2_DFI_PHYUPD_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD2_DFI_PHYUPD_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD2_DFI_PHYUPD_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD2_DFI_PHYUPD_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD2_DFI_PHYUPD_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD2_DFI_PHYUPD_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIUPD2_DFI_PHYUPD_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3480</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enables the support for acknowledging PHY-initiated updates:</csr:p>
         <csr:p>    - 0 - Disabled</csr:p>
         <csr:p>    - 1 - Enabled</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIMISC</csr:referenceName>
       <csr:identifier>DFIMISC</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFIMISC_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFIMISC_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3560</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x1B0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000001</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DFIMISC</csr:typeName>
        <csr:description>
         <csr:p>DFI Miscellaneous Control Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dfi_init_complete_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_COMPLETE_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_COMPLETE_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_COMPLETE_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_COMPLETE_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_COMPLETE_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_COMPLETE_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_COMPLETE_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_COMPLETE_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3494</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>PHY initialization complete enable signal.</csr:p>
         <csr:p>When asserted the dfi_init_complete signal can be used to trigger SDRAM initialisation</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>phy_dbi_mode</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_PHY_DBI_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_PHY_DBI_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_PHY_DBI_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_PHY_DBI_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_PHY_DBI_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_PHY_DBI_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_PHY_DBI_MODE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_PHY_DBI_MODE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3506</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DBI implemented in DDRC or PHY.</csr:p>
         <csr:p>  - 0 - DDRC implements DBI functionality.</csr:p>
         <csr:p>  - 1 - PHY implements DBI functionality.</csr:p>
         <csr:p>  Present only in designs configured to support DDR4 and LPDDR4.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_data_cs_polarity</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_DATA_CS_POLARITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_DATA_CS_POLARITY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_DATA_CS_POLARITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_DATA_CS_POLARITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_DATA_CS_POLARITY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_DATA_CS_POLARITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_DATA_CS_POLARITY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_DATA_CS_POLARITY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3518</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Defines polarity of dfi_wrdata_cs and dfi_rddata_cs signals.</csr:p>
         <csr:p>   - 0: Signals are active low</csr:p>
         <csr:p>   - 1: Signals are active high</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ctl_idle_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_CTL_IDLE_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_CTL_IDLE_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_CTL_IDLE_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_CTL_IDLE_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_CTL_IDLE_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_CTL_IDLE_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_CTL_IDLE_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_CTL_IDLE_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3530</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enables support of ctl_idle signal, which is non-DFI related pin specific to certain Synopsys PHYs. See signal description of ctl_idle signal for further details of ctl_idle functionality. </csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_init_start</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_START_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_START_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_START_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_START_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_START_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_START_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_START_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_INIT_START_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3539</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>PHY init start request signal.When asserted it triggers the PHY init start request</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>lp_optimized_write</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_LP_OPTIMIZED_WRITE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_LP_OPTIMIZED_WRITE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_LP_OPTIMIZED_WRITE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_LP_OPTIMIZED_WRITE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_LP_OPTIMIZED_WRITE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_LP_OPTIMIZED_WRITE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_LP_OPTIMIZED_WRITE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_LP_OPTIMIZED_WRITE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3549</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If this bit is 1, LPDDR4 write DQ is set to 8'hF8 if masked write with enabling DBI; otherwise, that value is set to 8'hFF</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_frequency</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_FREQUENCY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_FREQUENCY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_FREQUENCY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_FREQUENCY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_FREQUENCY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_FREQUENCY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_FREQUENCY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIMISC_DFI_FREQUENCY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3559</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates the operating frequency of the system. The number of supported frequencies and the mapping of signal values to clock frequencies are defined by the PHY.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFITMG2</csr:referenceName>
       <csr:identifier>DFITMG2</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFITMG2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFITMG2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3591</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x1B4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000202</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DFITMG2</csr:typeName>
        <csr:description>
         <csr:p>DFI Timing Register 2</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dfi_tphy_wrcslat</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_WRCSLAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_WRCSLAT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_WRCSLAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_WRCSLAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_WRCSLAT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_WRCSLAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_WRCSLAT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_WRCSLAT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3576</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Number of DFI PHY clock cycles between when a write command is sent on the DFI control interface and when the associated dfi_wrdata_cs signal is asserted. This corresponds to the DFI timing parameter tphy_wrcslat.</csr:p>
         <csr:p> Refer to PHY specification for correct value.</csr:p>
         <csr:p>Unit: DFI PHY clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x02</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_tphy_rdcslat</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_RDCSLAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_RDCSLAT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_RDCSLAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_RDCSLAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_RDCSLAT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_RDCSLAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_RDCSLAT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFITMG2_DFI_TPHY_RDCSLAT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3590</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Number of DFI PHY clock cycles between when a read command is sent on the DFI control interface </csr:p>
         <csr:p>and when the associated dfi_rddata_cs signal is asserted. This corresponds to the DFI timing parameter tphy_rdcslat.</csr:p>
         <csr:p>Refer to PHY specification for correct value.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI PHY clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 2, Group 4</csr:p>
        </csr:description>
         <csr:msb>14</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x02</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFISTAT</csr:referenceName>
       <csr:identifier>DFISTAT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFISTAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFISTAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3616</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x1BC</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DFISTAT</csr:typeName>
        <csr:description>
         <csr:p>DFI Status Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dfi_init_complete</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_INIT_COMPLETE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_INIT_COMPLETE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_INIT_COMPLETE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_INIT_COMPLETE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_INIT_COMPLETE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_INIT_COMPLETE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_INIT_COMPLETE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_INIT_COMPLETE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3606</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The status flag register which announces when the DFI initialization has been completed. The DFI INIT triggered by dfi_init_start signal and then the dfi_init_complete flag is polled to know when the initialization is done.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dfi_lp_ack</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_LP_ACK_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_LP_ACK_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_LP_ACK_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_LP_ACK_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_LP_ACK_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_LP_ACK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_LP_ACK_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFISTAT_DFI_LP_ACK_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3615</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Stores the value of the dfi_lp_ack input to the controller.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBICTL</csr:referenceName>
       <csr:identifier>DBICTL</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBICTL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBICTL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3666</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x1C0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000001</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DBICTL</csr:typeName>
        <csr:description>
         <csr:p>DM/DBI Control Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dm_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_DM_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_DM_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_DM_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_DM_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_DM_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_DM_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_DM_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_DM_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3635</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DM enable signal in DDRC.</csr:p>
         <csr:p>  - 0 - DM is disabled.</csr:p>
         <csr:p>  - 1 - DM is enabled.</csr:p>
         <csr:p>This signal must be set the same logical value as DRAM's mode register.</csr:p>
         <csr:p>  - DDR4:   Set this to same value as MR5 bit A10. When x4 devices are used, this signal must be set to 0.</csr:p>
         <csr:p>  - LPDDR4: Set this to inverted value of MR13[5] which is opposite polarity from this signal</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_dbi_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_WR_DBI_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_WR_DBI_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_WR_DBI_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_WR_DBI_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_WR_DBI_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_WR_DBI_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_WR_DBI_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_WR_DBI_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3650</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Write DBI enable signal in DDRC.</csr:p>
         <csr:p>  - 0 - Write DBI is disabled.</csr:p>
         <csr:p>  - 1 - Write DBI is enabled.</csr:p>
         <csr:p>This signal must be set the same value as DRAM's mode register.</csr:p>
         <csr:p>  - DDR4:   MR5 bit A11. When x4 devices are used, this signal must be set to 0.</csr:p>
         <csr:p>  - LPDDR4: MR3[7]</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_dbi_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_RD_DBI_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_RD_DBI_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_RD_DBI_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_RD_DBI_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_RD_DBI_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_RD_DBI_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_RD_DBI_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBICTL_RD_DBI_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3665</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read DBI enable signal in DDRC.</csr:p>
         <csr:p>  - 0 - Read DBI is disabled.</csr:p>
         <csr:p>  - 1 - Read DBI is enabled.</csr:p>
         <csr:p>This signal must be set the same value as DRAM's mode register.</csr:p>
         <csr:p>  - DDR4:   MR5 bit A12. When x4 devices are used, this signal must be set to 0.</csr:p>
         <csr:p>  - LPDDR4: MR3[6]</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DFIPHYMSTR</csr:referenceName>
       <csr:identifier>DFIPHYMSTR</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFIPHYMSTR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DFIPHYMSTR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DFIPHYMSTR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DFIPHYMSTR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3680</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x1C4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000001</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DFIPHYMSTR</csr:typeName>
        <csr:description>
         <csr:p>DFI PHY Master</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dfi_phymstr_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DFIPHYMSTR_DFI_PHYMSTR_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DFIPHYMSTR_DFI_PHYMSTR_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DFIPHYMSTR_DFI_PHYMSTR_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DFIPHYMSTR_DFI_PHYMSTR_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DFIPHYMSTR_DFI_PHYMSTR_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DFIPHYMSTR_DFI_PHYMSTR_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DFIPHYMSTR_DFI_PHYMSTR_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DFIPHYMSTR_DFI_PHYMSTR_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3679</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enables the PHY Master Interface:</csr:p>
         <csr:p>    - 0 - Disabled</csr:p>
         <csr:p>    - 1 - Enabled</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP1</csr:referenceName>
       <csr:identifier>ADDRMAP1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3731</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x204</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ADDRMAP1</csr:typeName>
        <csr:description>
         <csr:p>Address Map Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>addrmap_bank_b0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3699</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as bank address bit 0.</csr:p>
         <csr:p>Valid Range: 0 to 32, and 63</csr:p>
         <csr:p>Internal Base: 2</csr:p>
         <csr:p>The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 63 and then bank address bit 0 is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_bank_b1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3715</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as bank address bit 1.</csr:p>
         <csr:p>Valid Range: 0 to 32, and 63</csr:p>
         <csr:p>Internal Base: 3</csr:p>
         <csr:p>The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 63 and then bank address bit 1 is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_bank_b2</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B2_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B2_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B2_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B2_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B2_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B2_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP1_ADDRMAP_BANK_B2_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3730</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bit used as bank address bit 2.</csr:p>
         <csr:p>Valid Range: 0 to 31, and 63</csr:p>
         <csr:p>Internal Base: 4</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 63 and then bank address bit 2 is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>21</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>22</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP2</csr:referenceName>
       <csr:identifier>ADDRMAP2</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>3857</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x208</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ADDRMAP2</csr:typeName>
        <csr:description>
         <csr:p>Address Map Register 2</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>addrmap_col_b2</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B2_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B2_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B2_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B2_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B2_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B2_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B2_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3779</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  - Full bus width mode: Selects the HIF address bit used as column address bit 2.</csr:p>
         <csr:p>  - Half bus width mode: Selects the HIF address bit used as column address bit 3.</csr:p>
         <csr:p>  - Quarter bus width mode: Selects the HIF address bit used as column address bit 4.</csr:p>
         <csr:p>Valid Range: 0 to 7</csr:p>
         <csr:p>Internal Base: 2</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field. </csr:p>
         <csr:p></csr:p>
         <csr:p>Note, if UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=8, it is required to program this to 0 unless:</csr:p>
         <csr:p>  - in Half or Quarter bus width (MSTR.data_bus_width!=00) and</csr:p>
         <csr:p>  - PCCFG.bl_exp_mode==1 and either</csr:p>
         <csr:p>  - In DDR4   and ADDRMAP8.addrmap_bg_b0==0 or</csr:p>
         <csr:p>  - In LPDDR4 and ADDRMAP1.addrmap_bank_b0==0</csr:p>
         <csr:p>If UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=16, it is required to program this to 0 unless:</csr:p>
         <csr:p>  - in Half or Quarter bus width (MSTR.data_bus_width!=00) and </csr:p>
         <csr:p>  - PCCFG.bl_exp_mode==1 and</csr:p>
         <csr:p>  - In DDR4 and ADDRMAP8.addrmap_bg_b0==0</csr:p>
         <csr:p>Otherwise, if MEMC_BURST_LENGTH=8 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2.</csr:p>
         <csr:p></csr:p>
         <csr:p>If MEMC_BURST_LENGTH=16 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2.</csr:p>
         <csr:p></csr:p>
         <csr:p>If MEMC_BURST_LENGTH=16 and Half Bus Width (MSTR.data_bus_width==01), it is recommended to program this to 0 so that HIF[2] maps to column address bit 3.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_col_b3</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B3_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B3_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B3_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B3_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B3_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B3_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B3_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B3_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3814</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  - Full bus width mode: Selects the HIF address bit used as column address bit 3. </csr:p>
         <csr:p>  - Half bus width mode: Selects the HIF address bit used as column address bit 4.</csr:p>
         <csr:p>  - Quarter bus width mode: Selects the HIF address bit used as column address bit 5.</csr:p>
         <csr:p>Valid Range: 0 to 7, x. x indicate a valid value in inline ECC configuration. </csr:p>
         <csr:p>Internal Base: 3</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Note, if UMCTL2_INCL_ARB=1, MEMC_BURST_LENGTH=16, Full bus width (MSTR.data_bus_width=00) and BL16 (MSTR.burst_rdwr=1000), it is recommended to program this to 0.</csr:p>
         <csr:p></csr:p>
         <csr:p>  In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode&gt;0), if MEMC_BURST_LENGTH is 16, number of column address is 10 and work on half bus width mode, column bit 8, column bit 7 and column bit 3 must map to the highest 3 valid HIF address bits. This register need be set to x. (x = the highest valid HIF address bit - internal base - 2)</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_col_b4</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B4_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B4_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B4_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B4_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B4_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B4_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B4_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B4_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3835</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  - Full bus width mode: Selects the HIF address bit used as column address bit 4.</csr:p>
         <csr:p>  - Half bus width mode: Selects the HIF address bit used as column address bit 5.</csr:p>
         <csr:p>  - Quarter bus width mode: Selects the HIF address bit used as column address bit 6.</csr:p>
         <csr:p>Valid Range: 0 to 7, and 15</csr:p>
         <csr:p>Internal Base: 4</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p> </csr:p>
         <csr:p>  If unused, set to 15 and then this column address bit is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_col_b5</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B5_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B5_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B5_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B5_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B5_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B5_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B5_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP2_ADDRMAP_COL_B5_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3856</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  - Full bus width mode: Selects the HIF address bit used as column address bit 5.</csr:p>
         <csr:p>  - Half bus width mode: Selects the HIF address bit used as column address bit 6.</csr:p>
         <csr:p>  - Quarter bus width mode: Selects the HIF address bit used as column address bit 7 .</csr:p>
         <csr:p>Valid Range: 0 to 7, and 15</csr:p>
         <csr:p>Internal Base: 5</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 15 and then this column address bit is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>27</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP3</csr:referenceName>
       <csr:identifier>ADDRMAP3</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP3_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4014</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x20C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ADDRMAP3</csr:typeName>
        <csr:description>
         <csr:p>Address Map Register 3</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>addrmap_col_b6</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B6_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B6_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B6_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B6_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B6_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B6_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B6_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B6_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3892</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  - Full bus width mode: Selects the HIF address bit used as column address bit 6.</csr:p>
         <csr:p>  - Half bus width mode: Selects the HIF address bit used as column address bit 7.</csr:p>
         <csr:p>  - Quarter bus width mode: Selects the HIF address bit used as column address bit 8.</csr:p>
         <csr:p>Valid Range: 0 to 7, x and 31. x indicate a valid value in inline ECC configuration.</csr:p>
         <csr:p>Internal Base: 6</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 31 and then this column address bit is set to 0.</csr:p>
         <csr:p></csr:p>
         <csr:p>  In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode&gt;0), if MEMC_BURST_LENGTH is 8, number of column address is 10 and work on half bus width mode, column bit 8, column bit 7 and column bit 6 must map to the highest 3 valid HIF address bits. This register need be set to x. (x = the highest valid HIF address bit - internal base - 2)</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_col_b7</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B7_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B7_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B7_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B7_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B7_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B7_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B7_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B7_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3923</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  - Full bus width mode: Selects the HIF address bit used as column address bit 7.</csr:p>
         <csr:p>  - Half bus width mode: Selects the HIF address bit used as column address bit 8.</csr:p>
         <csr:p>  - Quarter bus width mode: Selects the HIF address bit used as column address bit 9.</csr:p>
         <csr:p>Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration.</csr:p>
         <csr:p>Internal Base: 7 </csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field. </csr:p>
         <csr:p></csr:p>
         <csr:p>  In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode&gt;0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If column bit 7 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 31 and then this column address bit is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_col_b8</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B8_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B8_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B8_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B8_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B8_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B8_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B8_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>3966</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  - Full bus width mode: Selects the HIF address bit used as column address bit 8.</csr:p>
         <csr:p>  - Half bus width mode: Selects the HIF address bit used as column address bit 9.</csr:p>
         <csr:p>  - Quarter bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode).</csr:p>
         <csr:p>Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration.</csr:p>
         <csr:p>Internal Base: 8</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p>Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10.</csr:p>
         <csr:p>In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.</csr:p>
         <csr:p></csr:p>
         <csr:p>  In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode&gt;0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If column bit 8 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)</csr:p>
         <csr:p></csr:p>
         <csr:p>  If column bit 8 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 31 and then this column address bit is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>20</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>21</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_col_b9</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B9_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B9_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B9_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B9_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B9_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B9_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B9_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP3_ADDRMAP_COL_B9_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4013</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  - Full bus width mode: Selects the HIF address bit used as column address bit 9.</csr:p>
         <csr:p>  - Half bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode).</csr:p>
         <csr:p>  - Quarter bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode).</csr:p>
         <csr:p>Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration.</csr:p>
         <csr:p>Internal Base: 9</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p>Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10.</csr:p>
         <csr:p>In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.</csr:p>
         <csr:p></csr:p>
         <csr:p>  In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode&gt;0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If column bit 9 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base)</csr:p>
         <csr:p></csr:p>
         <csr:p>  If column bit 9 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)</csr:p>
         <csr:p></csr:p>
         <csr:p>  If column bit 9 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 31 and then this column address bit is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>28</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP4</csr:referenceName>
       <csr:identifier>ADDRMAP4</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP4_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4133</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x210</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ADDRMAP4</csr:typeName>
        <csr:description>
         <csr:p>Address Map Register 4</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>addrmap_col_b10</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B10_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B10_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B10_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B10_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B10_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B10_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B10_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B10_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4065</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  - Full bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode).</csr:p>
         <csr:p>  - Half bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode).</csr:p>
         <csr:p>  - Quarter bus width mode: UNUSED. See later in this description for value you need to set to make it unused.</csr:p>
         <csr:p>Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration.</csr:p>
         <csr:p>Internal Base: 10</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p>Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10.</csr:p>
         <csr:p>In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.</csr:p>
         <csr:p></csr:p>
         <csr:p>  In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode&gt;0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If column bit 10 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base)</csr:p>
         <csr:p></csr:p>
         <csr:p>  If column bit 10 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)</csr:p>
         <csr:p></csr:p>
         <csr:p>  If column bit 10 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 31 and then this column address bit is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_col_b11</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B11_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B11_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B11_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B11_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B11_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B11_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B11_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_ADDRMAP_COL_B11_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4113</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  - Full bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode).</csr:p>
         <csr:p>  - Half bus width mode: UNUSED. See later in this description for value you need to set to make it unused.</csr:p>
         <csr:p>  - Quarter bus width mode: UNUSED. See later in this description for value you need to set to make it unused.</csr:p>
         <csr:p>Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration.</csr:p>
         <csr:p>Internal Base: 11</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p>Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10.</csr:p>
         <csr:p>In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.</csr:p>
         <csr:p></csr:p>
         <csr:p>  In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode&gt;0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If column bit 11 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base)</csr:p>
         <csr:p></csr:p>
         <csr:p>  If column bit 11 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)</csr:p>
         <csr:p></csr:p>
         <csr:p>  If column bit 11 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 31 and then this column address bit is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>30</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>col_addr_shift</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_COL_ADDR_SHIFT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_COL_ADDR_SHIFT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_COL_ADDR_SHIFT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_COL_ADDR_SHIFT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_COL_ADDR_SHIFT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_COL_ADDR_SHIFT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_COL_ADDR_SHIFT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP4_COL_ADDR_SHIFT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4132</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  The register provide a capability to map column address to lower HIF address in specific cases required by inline ECC configuration.</csr:p>
         <csr:p>  - if it is 1, internal base of all the column address will -2 to make mapping range of column address shift left 2 bit.</csr:p>
         <csr:p>  - if it is 0, internal base of all the column address has no change.</csr:p>
         <csr:p>  Set to 0 if inline ECC is not enabled (ECCCFG0.ecc_mode==0).</csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP5</csr:referenceName>
       <csr:identifier>ADDRMAP5</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP5_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4196</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x214</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ADDRMAP5</csr:typeName>
        <csr:description>
         <csr:p>Address Map Register 5</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4149</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as row address bit 0.</csr:p>
         <csr:p>Valid Range: 0 to 11</csr:p>
         <csr:p>Internal Base: 6</csr:p>
         <csr:p>The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4162</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as row address bit 1.</csr:p>
         <csr:p>Valid Range: 0 to 11</csr:p>
         <csr:p>Internal Base: 7</csr:p>
         <csr:p>The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b2_10</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B2_10_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B2_10_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B2_10_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B2_10_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B2_10_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B2_10_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B2_10_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B2_10_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4180</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as row address bits 2 to 10.</csr:p>
         <csr:p>Valid Range: 0 to 11, and 15</csr:p>
         <csr:p>Internal Base: 8 (for row address bit 2), 9 (for row address bit 3), 10 (for row address bit 4) etc increasing to 16 (for row address bit 10)</csr:p>
         <csr:p>The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p>When set to 15, the values of row address bits 2 to 10 are defined by registers ADDRMAP9, ADDRMAP10, ADDRMAP11.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b11</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B11_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B11_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B11_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B11_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B11_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B11_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B11_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP5_ADDRMAP_ROW_B11_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4195</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bit used as row address bit 11.</csr:p>
         <csr:p>Valid Range: 0 to 11, and 15</csr:p>
         <csr:p>Internal Base: 17</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 15 and then row address bit 11 is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>27</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP6</csr:referenceName>
       <csr:identifier>ADDRMAP6</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP6_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4297</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x218</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ADDRMAP6</csr:typeName>
        <csr:description>
         <csr:p>Address Map Register 6</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b12</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B12_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B12_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B12_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B12_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B12_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B12_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B12_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B12_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4214</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bit used as row address bit 12.</csr:p>
         <csr:p>Valid Range: 0 to 11, and 15</csr:p>
         <csr:p>Internal Base: 18</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 15 and then row address bit 12 is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b13</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B13_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B13_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B13_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B13_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B13_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B13_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B13_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B13_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4229</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bit used as row address bit 13.</csr:p>
         <csr:p>Valid Range: 0 to 11, and 15</csr:p>
         <csr:p>Internal Base: 19</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 15 and then row address bit 13 is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b14</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B14_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B14_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B14_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B14_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B14_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B14_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B14_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B14_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4244</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bit used as row address bit 14.</csr:p>
         <csr:p>Valid Range: 0 to 11, and 15</csr:p>
         <csr:p>Internal Base: 20</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 15 and then row address bit 14 is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b15</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B15_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B15_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B15_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B15_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B15_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B15_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B15_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_ADDRMAP_ROW_B15_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4259</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bit used as row address bit 15.</csr:p>
         <csr:p>Valid Range: 0 to 11, and 15</csr:p>
         <csr:p>Internal Base: 21</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 15 and then row address bit 15 is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>27</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>28</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>lpddr4_3gb_6gb_12gb</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR4_3GB_6GB_12GB_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR4_3GB_6GB_12GB_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR4_3GB_6GB_12GB_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR4_3GB_6GB_12GB_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR4_3GB_6GB_12GB_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR4_3GB_6GB_12GB_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR4_3GB_6GB_12GB_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR4_3GB_6GB_12GB_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4281</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p> Indicates what type of LPDDR4 SDRAM device is in use. Here, the density size is per channel.</csr:p>
         <csr:p> - 2'b00: No LPDDR4 SDRAM 3Gb/6Gb/12Gb device in use. All addresses are valid</csr:p>
         <csr:p> - 2'b01: LPDDR4 SDRAM 3Gb device with x16 mode in use. Every address having row[14:13]==2'b11 is considered as invalid</csr:p>
         <csr:p> - 2'b10: LPDDR4 SDRAM 6Gb device with x16 mode or 3Gb device with byte mode in use. Every address having row[15:14]==2'b11 is considered as invalid</csr:p>
         <csr:p> - 2'b11: LPDDR4 SDRAM 12Gb device with x16 mode or 6Gb device with byte mode in use. Every address having row[16:15]==2'b11 is considered as invalid</csr:p>
         <csr:p>Present only in designs configured to support LPDDR4.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>30</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>lpddr3_6gb_12gb</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR3_6GB_12GB_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR3_6GB_12GB_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR3_6GB_12GB_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR3_6GB_12GB_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR3_6GB_12GB_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR3_6GB_12GB_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR3_6GB_12GB_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP6_LPDDR3_6GB_12GB_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4296</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p> Set this to 1 if there is an LPDDR3 SDRAM 6Gb or 12Gb device in use.</csr:p>
         <csr:p> - 1 - LPDDR3 SDRAM 6Gb/12Gb device in use. Every address having row[14:13]==2'b11 is considered as invalid</csr:p>
         <csr:p> - 0 - non-LPDDR3 6Gb/12Gb device in use. All addresses are valid</csr:p>
         <csr:p>Present only in designs configured to support LPDDR3.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP7</csr:referenceName>
       <csr:identifier>ADDRMAP7</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP7_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP7_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP7_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP7_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4316</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x21C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ADDRMAP7</csr:typeName>
        <csr:description>
         <csr:p>Address Map Register 7</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b16</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP7_ADDRMAP_ROW_B16_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP7_ADDRMAP_ROW_B16_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP7_ADDRMAP_ROW_B16_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP7_ADDRMAP_ROW_B16_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP7_ADDRMAP_ROW_B16_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP7_ADDRMAP_ROW_B16_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP7_ADDRMAP_ROW_B16_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP7_ADDRMAP_ROW_B16_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4315</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bit used as row address bit 16.</csr:p>
         <csr:p>Valid Range: 0 to 11, and 15</csr:p>
         <csr:p>Internal Base: 22</csr:p>
         <csr:p>The selected HIF address bit is determined by adding the internal base to the value of this field.</csr:p>
         <csr:p></csr:p>
         <csr:p>  If unused, set to 15 and then row address bit 16 is set to 0.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP9</csr:referenceName>
       <csr:identifier>ADDRMAP9</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP9_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4376</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x224</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ADDRMAP9</csr:typeName>
        <csr:description>
         <csr:p>Address Map Register 9</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b2</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B2_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B2_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B2_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B2_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B2_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B2_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B2_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4333</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as row address bit 2.</csr:p>
         <csr:p>Valid Range: 0 to 11</csr:p>
         <csr:p>Internal Base: 8</csr:p>
         <csr:p>The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b3</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B3_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B3_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B3_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B3_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B3_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B3_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B3_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B3_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4347</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as row address bit 3.</csr:p>
         <csr:p>Valid Range: 0 to 11</csr:p>
         <csr:p>Internal Base: 9</csr:p>
         <csr:p>The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b4</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B4_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B4_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B4_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B4_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B4_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B4_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B4_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B4_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4361</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as row address bit 4.</csr:p>
         <csr:p>Valid Range: 0 to 11</csr:p>
         <csr:p>Internal Base: 10</csr:p>
         <csr:p>The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b5</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B5_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B5_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B5_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B5_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B5_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B5_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B5_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP9_ADDRMAP_ROW_B5_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4375</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as row address bit 5.</csr:p>
         <csr:p>Valid Range: 0 to 11</csr:p>
         <csr:p>Internal Base: 11</csr:p>
         <csr:p>The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>27</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP10</csr:referenceName>
       <csr:identifier>ADDRMAP10</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP10_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4436</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x228</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ADDRMAP10</csr:typeName>
        <csr:description>
         <csr:p>Address Map Register 10</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b6</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B6_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B6_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B6_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B6_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B6_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B6_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B6_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B6_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4393</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as row address bit 6.</csr:p>
         <csr:p>Valid Range: 0 to 11</csr:p>
         <csr:p>Internal Base: 12</csr:p>
         <csr:p>The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b7</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B7_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B7_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B7_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B7_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B7_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B7_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B7_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B7_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4407</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as row address bit 7.</csr:p>
         <csr:p>Valid Range: 0 to 11</csr:p>
         <csr:p>Internal Base: 13</csr:p>
         <csr:p>The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b8</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B8_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B8_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B8_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B8_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B8_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B8_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B8_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4421</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as row address bit 8.</csr:p>
         <csr:p>Valid Range: 0 to 11</csr:p>
         <csr:p>Internal Base: 14</csr:p>
         <csr:p>The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b9</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B9_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B9_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B9_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B9_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B9_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B9_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B9_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP10_ADDRMAP_ROW_B9_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4435</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as row address bit 9.</csr:p>
         <csr:p>Valid Range: 0 to 11</csr:p>
         <csr:p>Internal Base: 15</csr:p>
         <csr:p>The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>27</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADDRMAP11</csr:referenceName>
       <csr:identifier>ADDRMAP11</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP11_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADDRMAP11_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP11_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP11_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4454</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x22C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ADDRMAP11</csr:typeName>
        <csr:description>
         <csr:p>Address Map Register 11</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>addrmap_row_b10</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP11_ADDRMAP_ROW_B10_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP11_ADDRMAP_ROW_B10_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP11_ADDRMAP_ROW_B10_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP11_ADDRMAP_ROW_B10_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP11_ADDRMAP_ROW_B10_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP11_ADDRMAP_ROW_B10_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP11_ADDRMAP_ROW_B10_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADDRMAP11_ADDRMAP_ROW_B10_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4453</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selects the HIF address bits used as row address bit 10.</csr:p>
         <csr:p>Valid Range: 0 to 11</csr:p>
         <csr:p>Internal Base: 16</csr:p>
         <csr:p>The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ODTCFG</csr:referenceName>
       <csr:identifier>ODTCFG</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ODTCFG_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ODTCFG_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4574</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x240</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x04000400</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ODTCFG</csr:typeName>
        <csr:description>
         <csr:p>ODT Configuration Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>1</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_odt_delay</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_DELAY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_DELAY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_DELAY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_DELAY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_DELAY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_DELAY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_DELAY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_DELAY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4492</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>The delay, in DFI PHY clock cycles, from issuing a read command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2.</csr:p>
         <csr:p></csr:p>
         <csr:p>Recommended values:</csr:p>
         <csr:p></csr:p>
         <csr:p> DDR2:</csr:p>
         <csr:p> - CL + AL - 4 (not DDR2-1066),  CL + AL - 5 (DDR2-1066)</csr:p>
         <csr:p>   If (CL + AL - 4 &lt; 0),  uMCTL2 does not support ODT for read operation.</csr:p>
         <csr:p> DDR3:</csr:p>
         <csr:p> - CL - CWL</csr:p>
         <csr:p> DDR4:</csr:p>
         <csr:p> - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)</csr:p>
         <csr:p>   WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)</csr:p>
         <csr:p></csr:p>
         <csr:p>   RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)</csr:p>
         <csr:p></csr:p>
         <csr:p>   If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) &lt; 0,  uMCTL2 does not support ODT for read operation.</csr:p>
         <csr:p> LPDDR3:</csr:p>
         <csr:p> - RL + RD(tDQSCK(min)/tCK) - 1 - RU(tODTon(max)/tCK)</csr:p>
         <csr:p>Unit: DFI PHY clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 4</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_odt_hold</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_HOLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_HOLD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_HOLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_HOLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_HOLD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_HOLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_HOLD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_RD_ODT_HOLD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4518</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2.</csr:p>
         <csr:p></csr:p>
         <csr:p>Recommended values:</csr:p>
         <csr:p></csr:p>
         <csr:p> DDR2:</csr:p>
         <csr:p> - BL8: 0x6 (not DDR2-1066),  0x7 (DDR2-1066)</csr:p>
         <csr:p> - BL4: 0x4 (not DDR2-1066),  0x5 (DDR2-1066)</csr:p>
         <csr:p> DDR3:</csr:p>
         <csr:p> - BL8 - 0x6</csr:p>
         <csr:p> DDR4:</csr:p>
         <csr:p> - BL8: 5 + RD_PREAMBLE</csr:p>
         <csr:p>   RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)</csr:p>
         <csr:p> LPDDR3:</csr:p>
         <csr:p> - BL8:  5 + RU(tDQSCK(max)/tCK) - RD(tDQSCK(min)/tCK) + RU(tODTon(max)/tCK)</csr:p>
         <csr:p>Unit: DFI PHY clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 4</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x4</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_odt_delay</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_DELAY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_DELAY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_DELAY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_DELAY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_DELAY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_DELAY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_DELAY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_DELAY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4545</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>The delay, in DFI PHY clock cycles, from issuing a write command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2.</csr:p>
         <csr:p></csr:p>
         <csr:p>Recommended values:</csr:p>
         <csr:p></csr:p>
         <csr:p> DDR2:</csr:p>
         <csr:p> - CWL + AL - 3 (DDR2-400/533/667),  CWL + AL - 4 (DDR2-800),  CWL + AL - 5 (DDR2-1066)</csr:p>
         <csr:p>   If (CWL + AL - 3  &lt; 0),  uMCTL2 does not support ODT for write operation.</csr:p>
         <csr:p> DDR3:</csr:p>
         <csr:p> - 0x0</csr:p>
         <csr:p> DDR4:</csr:p>
         <csr:p> - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode) </csr:p>
         <csr:p> LPDDR3:</csr:p>
         <csr:p> - WL - 1 - RU(tODTon(max)/tCK))</csr:p>
         <csr:p>Unit: DFI PHY clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 4</csr:p>
        </csr:description>
         <csr:msb>20</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>21</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_odt_hold</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_HOLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_HOLD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_HOLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_HOLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_HOLD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_HOLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_HOLD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ODTCFG_WR_ODT_HOLD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4573</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2.</csr:p>
         <csr:p></csr:p>
         <csr:p>Recommended values:</csr:p>
         <csr:p></csr:p>
         <csr:p> DDR2:</csr:p>
         <csr:p> - BL8:  0x5 (DDR2-400/533/667),  0x6 (DDR2-800),  0x7 (DDR2-1066)</csr:p>
         <csr:p> - BL4:  0x3 (DDR2-400/533/667),  0x4 (DDR2-800),  0x5 (DDR2-1066)</csr:p>
         <csr:p> DDR3:</csr:p>
         <csr:p> - BL8: 0x6</csr:p>
         <csr:p> DDR4: </csr:p>
         <csr:p> - BL8: 5 + WR_PREAMBLE + CRC_MODE</csr:p>
         <csr:p>   WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)</csr:p>
         <csr:p>   CRC_MODE = 0 (not CRC mode),  1 (CRC mode)</csr:p>
         <csr:p> LPDDR3:</csr:p>
         <csr:p> - BL8: 7 + RU(tODTon(max)/tCK)</csr:p>
         <csr:p>Unit: DFI PHY clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1, Group 4</csr:p>
        </csr:description>
         <csr:msb>27</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x4</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ODTMAP</csr:referenceName>
       <csr:identifier>ODTMAP</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ODTMAP_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ODTMAP_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4606</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x244</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000011</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ODTMAP</csr:typeName>
        <csr:description>
         <csr:p>ODT/Rank Map Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>rank0_wr_odt</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_WR_ODT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_WR_ODT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_WR_ODT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_WR_ODT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_WR_ODT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_WR_ODT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_WR_ODT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_WR_ODT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4591</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates which remote ODTs must be turned on during a write to rank 0.</csr:p>
         <csr:p>Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here.</csr:p>
         <csr:p>Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.</csr:p>
         <csr:p>For each rank, set its bit to 1 to enable its ODT.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rank0_rd_odt</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_RD_ODT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_RD_ODT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_RD_ODT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_RD_ODT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_RD_ODT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_RD_ODT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_RD_ODT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ODTMAP_RANK0_RD_ODT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4605</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates which remote ODTs must be turned on during a read from rank 0.</csr:p>
         <csr:p>Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here.</csr:p>
         <csr:p>Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.</csr:p>
         <csr:p>For each rank, set its bit to 1 to enable its ODT.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.SCHED</csr:referenceName>
       <csr:identifier>SCHED</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_SCHED_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_SCHED_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_SCHED_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_SCHED_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4729</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x250</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00001005</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_SCHED</csr:typeName>
        <csr:description>
         <csr:p>Scheduler Control Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>force_low_pri_n</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_SCHED_FORCE_LOW_PRI_N_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_FORCE_LOW_PRI_N_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_FORCE_LOW_PRI_N_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_SCHED_FORCE_LOW_PRI_N_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_SCHED_FORCE_LOW_PRI_N_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_SCHED_FORCE_LOW_PRI_N_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_SCHED_FORCE_LOW_PRI_N_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_SCHED_FORCE_LOW_PRI_N_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4626</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Active low signal. When asserted ('0'), all incoming transactions are forced to low priority. This implies that all High Priority Read (HPR) and Variable Priority Read commands (VPR) will be treated as Low Priority Read (LPR) commands. On the write side, all Variable Priority Write (VPW) commands will be treated as Normal Priority Write (NPW) commands. Forcing the incoming transactions to low priority implicitly turns off Bypass path for read commands.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>prefer_write</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PREFER_WRITE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PREFER_WRITE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PREFER_WRITE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PREFER_WRITE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PREFER_WRITE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PREFER_WRITE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PREFER_WRITE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PREFER_WRITE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4635</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set then the bank selector prefers writes over reads.</csr:p>
         <csr:p>FOR DEBUG ONLY.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>pageclose</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PAGECLOSE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PAGECLOSE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PAGECLOSE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PAGECLOSE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PAGECLOSE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PAGECLOSE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PAGECLOSE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_SCHED_PAGECLOSE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4663</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If true, bank is kept open only while there are page hit transactions available in the CAM to that bank. The last read or write command in the CAM with a bank and page hit will be executed with auto-precharge if SCHED1.pageclose_timer=0. Even if this register set to 1 and SCHED1.pageclose_timer is set to 0, explicit precharge (and not auto-precharge) may be issued in some cases where there is a mode switch between Write and Read or between LPR and HPR. The Read and Write commands that are executed as part of the ECC scrub requests are also executed without auto-precharge.</csr:p>
         <csr:p></csr:p>
         <csr:p>If false, the bank remains open until there is a need to close it (to open a different page, or for page timeout or refresh timeout) - also known as open page policy. The open page policy can be overridden by setting the per-command-autopre bit on the HIF interface (hif_cmd_autopre).</csr:p>
         <csr:p>The pageclose feature provids a midway between Open and Close page policies.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>6</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>autopre_rmw</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_SCHED_AUTOPRE_RMW_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_AUTOPRE_RMW_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_AUTOPRE_RMW_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_SCHED_AUTOPRE_RMW_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_SCHED_AUTOPRE_RMW_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_SCHED_AUTOPRE_RMW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_SCHED_AUTOPRE_RMW_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_SCHED_AUTOPRE_RMW_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4679</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Select behavior of hif_cmd_autopre if a RMW is received on HIF with hif_cmd_autopre=1</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>   1: Apply Autopre only for write part of RMW</csr:p>
         <csr:p></csr:p>
         <csr:p>   0: Apply Autopre for both read and write parts of RMW</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>lpr_num_entries</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_SCHED_LPR_NUM_ENTRIES_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_LPR_NUM_ENTRIES_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_LPR_NUM_ENTRIES_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_SCHED_LPR_NUM_ENTRIES_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_SCHED_LPR_NUM_ENTRIES_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_SCHED_LPR_NUM_ENTRIES_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_SCHED_LPR_NUM_ENTRIES_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_SCHED_LPR_NUM_ENTRIES_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4701</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Number of entries in the low priority transaction store is this value + 1.</csr:p>
         <csr:p>(MEMC_NO_OF_ENTRY - (SCHED.lpr_num_entries + 1)) is the number of entries available for the high priority transaction store.</csr:p>
         <csr:p>Setting this to maximum value allocates all entries to low priority transaction store.</csr:p>
         <csr:p>Setting this to 0 allocates 1 entry to low priority transaction store and the rest to high priority transaction store.</csr:p>
         <csr:p>Note: In ECC configurations, the numbers of write and low priority read credits issued is one less than in the non-ECC case.  One entry each is reserved in the write and low-priority read CAMs for storing the RMW requests arising out of single bit error correction RMW operation.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x10</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>go2critical_hysteresis</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_SCHED_GO2CRITICAL_HYSTERESIS_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_GO2CRITICAL_HYSTERESIS_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_GO2CRITICAL_HYSTERESIS_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_SCHED_GO2CRITICAL_HYSTERESIS_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_SCHED_GO2CRITICAL_HYSTERESIS_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_SCHED_GO2CRITICAL_HYSTERESIS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_SCHED_GO2CRITICAL_HYSTERESIS_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_SCHED_GO2CRITICAL_HYSTERESIS_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4709</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>UNUSED</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rdwr_idle_gap</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_SCHED_RDWR_IDLE_GAP_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_RDWR_IDLE_GAP_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_SCHED_RDWR_IDLE_GAP_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_SCHED_RDWR_IDLE_GAP_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_SCHED_RDWR_IDLE_GAP_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_SCHED_RDWR_IDLE_GAP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_SCHED_RDWR_IDLE_GAP_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_SCHED_RDWR_IDLE_GAP_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4728</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When the preferred transaction store is empty for these many clock cycles, switch to the alternate transaction store if it is non-empty.</csr:p>
         <csr:p>The read transaction store (both high and low priority) is the default preferred transaction store and the write transaction store is the alternative store.</csr:p>
         <csr:p>When prefer write over read is set this is reversed.</csr:p>
         <csr:p>0x0 is a legal value for this register. When set to 0x0, the transaction store switching will happen immediately when the switching conditions become true.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>30</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.SCHED1</csr:referenceName>
       <csr:identifier>SCHED1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_SCHED1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_SCHED1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_SCHED1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_SCHED1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4764</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x254</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_SCHED1</csr:typeName>
        <csr:description>
         <csr:p>Scheduler Control Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>pageclose_timer</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_SCHED1_PAGECLOSE_TIMER_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_SCHED1_PAGECLOSE_TIMER_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_SCHED1_PAGECLOSE_TIMER_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_SCHED1_PAGECLOSE_TIMER_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_SCHED1_PAGECLOSE_TIMER_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_SCHED1_PAGECLOSE_TIMER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_SCHED1_PAGECLOSE_TIMER_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_SCHED1_PAGECLOSE_TIMER_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4763</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field works in conjunction with SCHED.pageclose.</csr:p>
         <csr:p>It only has meaning if SCHED.pageclose==1.</csr:p>
         <csr:p></csr:p>
         <csr:p>If SCHED.pageclose==1 and pageclose_timer==0, then an auto-precharge may be scheduled for last read </csr:p>
         <csr:p>or write command in the CAM with a bank and page hit. </csr:p>
         <csr:p>Note, sometimes an explicit precharge is scheduled instead of the auto-precharge. See SCHED.pageclose for details of when this may happen.</csr:p>
         <csr:p></csr:p>
         <csr:p>If SCHED.pageclose==1 and pageclose_timer&gt;0, then an auto-precharge is not scheduled for last read</csr:p>
         <csr:p>or write command in the CAM with a bank and page hit.</csr:p>
         <csr:p>Instead, a timer is started, with pageclose_timer as the initial value.</csr:p>
         <csr:p>There is a timer on a per bank basis.</csr:p>
         <csr:p>The timer decrements unless the next read or write in the CAM to a bank is a page hit.</csr:p>
         <csr:p>It gets reset to pageclose_timer value if the next read or write in the CAM to a bank is a page hit.</csr:p>
         <csr:p>Once the timer has reached zero, an explcit precharge will be attempted to be scheduled.</csr:p>
         <csr:p></csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PERFHPR1</csr:referenceName>
       <csr:identifier>PERFHPR1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_PERFHPR1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_PERFHPR1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4797</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x25C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0f000001</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_PERFHPR1</csr:typeName>
        <csr:description>
         <csr:p>High Priority Read CAM Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>hpr_max_starve</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_MAX_STARVE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_MAX_STARVE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_MAX_STARVE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_MAX_STARVE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_MAX_STARVE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_MAX_STARVE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_MAX_STARVE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_MAX_STARVE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4782</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Number of DFI clocks that the HPR queue can be starved before it goes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0001</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>hpr_xact_run_length</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_XACT_RUN_LENGTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_XACT_RUN_LENGTH_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_XACT_RUN_LENGTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_XACT_RUN_LENGTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_XACT_RUN_LENGTH_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_XACT_RUN_LENGTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_XACT_RUN_LENGTH_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PERFHPR1_HPR_XACT_RUN_LENGTH_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4796</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Number of transactions that are serviced once the HPR queue goes critical is the smaller of:</csr:p>
         <csr:p> - (a) This number</csr:p>
         <csr:p> - (b) Number of transactions available.  </csr:p>
         <csr:p> Unit: Transaction.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0f</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PERFLPR1</csr:referenceName>
       <csr:identifier>PERFLPR1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_PERFLPR1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_PERFLPR1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4830</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x264</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0f00007f</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_PERFLPR1</csr:typeName>
        <csr:description>
         <csr:p>Low Priority Read CAM Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>lpr_max_starve</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_MAX_STARVE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_MAX_STARVE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_MAX_STARVE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_MAX_STARVE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_MAX_STARVE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_MAX_STARVE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_MAX_STARVE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_MAX_STARVE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4815</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Number of DFI clocks that the LPR queue can be starved before it goes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x007f</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>lpr_xact_run_length</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_XACT_RUN_LENGTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_XACT_RUN_LENGTH_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_XACT_RUN_LENGTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_XACT_RUN_LENGTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_XACT_RUN_LENGTH_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_XACT_RUN_LENGTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_XACT_RUN_LENGTH_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PERFLPR1_LPR_XACT_RUN_LENGTH_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4829</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Number of transactions that are serviced once the LPR queue goes critical is the smaller of:</csr:p>
         <csr:p> - (a) This number</csr:p>
         <csr:p> - (b) Number of transactions available.</csr:p>
         <csr:p>Unit: Transaction.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0f</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.PERFWR1</csr:referenceName>
       <csr:identifier>PERFWR1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_PERFWR1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_PERFWR1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4863</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x26C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0f00007f</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_PERFWR1</csr:typeName>
        <csr:description>
         <csr:p>Write CAM Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>w_max_starve</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_MAX_STARVE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_MAX_STARVE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_MAX_STARVE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_MAX_STARVE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_MAX_STARVE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_MAX_STARVE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_MAX_STARVE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_MAX_STARVE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4848</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Number of DFI clocks that the WR queue can be starved before it goes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Unit: DFI clock cycles.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x007f</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>w_xact_run_length</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_XACT_RUN_LENGTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_XACT_RUN_LENGTH_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_XACT_RUN_LENGTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_XACT_RUN_LENGTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_XACT_RUN_LENGTH_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_XACT_RUN_LENGTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_XACT_RUN_LENGTH_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_PERFWR1_W_XACT_RUN_LENGTH_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4862</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Number of transactions that are serviced once the WR queue goes critical is the smaller of:</csr:p>
         <csr:p> - (a) This number </csr:p>
         <csr:p> - (b) Number of transactions available.</csr:p>
         <csr:p>Unit: Transaction.</csr:p>
         <csr:p>FOR PERFORMANCE ONLY.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0f</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBG0</csr:referenceName>
       <csr:identifier>DBG0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBG0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBG0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DBG0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DBG0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4891</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x300</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DBG0</csr:typeName>
        <csr:description>
         <csr:p>Debug Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dis_wc</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_WC_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_WC_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_WC_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_WC_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_WC_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_WC_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_WC_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_WC_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4875</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When 1, disable write combine.</csr:p>
         <csr:p>FOR DEBUG ONLY</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dis_collision_page_opt</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_COLLISION_PAGE_OPT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_COLLISION_PAGE_OPT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_COLLISION_PAGE_OPT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_COLLISION_PAGE_OPT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_COLLISION_PAGE_OPT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_COLLISION_PAGE_OPT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_COLLISION_PAGE_OPT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBG0_DIS_COLLISION_PAGE_OPT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4890</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When this is set to '0', auto-precharge is disabled for the flushed command in a collision case. Collision cases are write followed by read to same address, read followed by write to same address, or write followed by write to same address with DBG0.dis_wc bit = 1 (where same address comparisons exclude the two address bits representing critical word).</csr:p>
         <csr:p>FOR DEBUG ONLY.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBG1</csr:referenceName>
       <csr:identifier>DBG1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBG1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBG1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DBG1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DBG1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>4927</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x304</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DBG1</csr:typeName>
        <csr:description>
         <csr:p>Debug Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dis_dq</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_DQ_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_DQ_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_DQ_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_DQ_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_DQ_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_DQ_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_DQ_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_DQ_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4915</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When 1, uMCTL2 will not de-queue any transactions from the CAM. Bypass is also disabled. All transactions are queued in the CAM. No reads or writes are issued to SDRAM as long as this is asserted.</csr:p>
         <csr:p>This bit may be used to prevent reads or writes being issued by the uMCTL2, which makes it safe to modify certain register fields associated with reads and writes (see Programming Chapter for details).  After setting this bit, it is strongly recommended to poll DBGCAM.wr_data_pipeline_empty and DBGCAM.rd_data_pipeline_empty, before making changes to any registers which affect reads and writes.  This will ensure that the relevant logic in the DDRC is idle.</csr:p>
         <csr:p>This bit is intended to be switched on-the-fly.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dis_hif</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_HIF_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_HIF_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_HIF_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_HIF_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_HIF_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_HIF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_HIF_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBG1_DIS_HIF_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4926</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When 1, uMCTL2 asserts the HIF command signal hif_cmd_stall. uMCTL2 will ignore the hif_cmd_valid and all other associated request signals.</csr:p>
         <csr:p>This bit is intended to be switched on-the-fly.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBGCAM</csr:referenceName>
       <csr:identifier>DBGCAM</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBGCAM_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBGCAM_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5028</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x308</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DBGCAM</csr:typeName>
        <csr:description>
         <csr:p>CAM Debug Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dbg_hpr_q_depth</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_HPR_Q_DEPTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_HPR_Q_DEPTH_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_HPR_Q_DEPTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_HPR_Q_DEPTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_HPR_Q_DEPTH_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_HPR_Q_DEPTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_HPR_Q_DEPTH_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_HPR_Q_DEPTH_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4940</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>High priority read queue depth</csr:p>
         <csr:p>FOR DEBUG ONLY</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dbg_lpr_q_depth</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_LPR_Q_DEPTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_LPR_Q_DEPTH_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_LPR_Q_DEPTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_LPR_Q_DEPTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_LPR_Q_DEPTH_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_LPR_Q_DEPTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_LPR_Q_DEPTH_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_LPR_Q_DEPTH_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4952</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Low priority read queue depth</csr:p>
         <csr:p>The last entry of Lpr queue is reserved for ECC SCRUB operation. This entry is not included in the calculation of the queue depth.</csr:p>
         <csr:p>FOR DEBUG ONLY</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dbg_w_q_depth</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_W_Q_DEPTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_W_Q_DEPTH_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_W_Q_DEPTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_W_Q_DEPTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_W_Q_DEPTH_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_W_Q_DEPTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_W_Q_DEPTH_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_W_Q_DEPTH_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4964</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Write queue depth</csr:p>
         <csr:p>The last entry of WR queue is reserved for ECC SCRUB operation. This entry is not included in the calculation of the queue depth.</csr:p>
         <csr:p>FOR DEBUG ONLY</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>21</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>22</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dbg_stall</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_STALL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_STALL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_STALL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_STALL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_STALL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_STALL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_STALL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_STALL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4973</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Stall</csr:p>
         <csr:p>FOR DEBUG ONLY</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>24</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dbg_rd_q_empty</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_RD_Q_EMPTY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_RD_Q_EMPTY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_RD_Q_EMPTY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_RD_Q_EMPTY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_RD_Q_EMPTY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_RD_Q_EMPTY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_RD_Q_EMPTY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_RD_Q_EMPTY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>4989</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When 1, all the Read command queues and Read data buffers inside DDRC are empty. This register is to be used for debug purpose. </csr:p>
         <csr:p>An example use-case scenario: When Controller enters Self-Refresh using the Low-Power entry sequence, Controller is expected to have executed all the commands in its queues and the write and read data drained. Hence this register should be 1 at that time.</csr:p>
         <csr:p>FOR DEBUG ONLY</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>25</csr:msb>
         <csr:lsb>25</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>dbg_wr_q_empty</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_WR_Q_EMPTY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_WR_Q_EMPTY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_WR_Q_EMPTY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_WR_Q_EMPTY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_WR_Q_EMPTY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_WR_Q_EMPTY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_WR_Q_EMPTY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_DBG_WR_Q_EMPTY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5005</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When 1, all the Write command queues and Write data buffers inside DDRC are empty. This register is to be used for debug purpose. </csr:p>
         <csr:p>An example use-case scenario: When Controller enters Self-Refresh using the Low-Power entry sequence, Controller is expected to have executed all the commands in its queues and the write and read data drained. Hence this register should be 1 at that time.</csr:p>
         <csr:p>FOR DEBUG ONLY</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>26</csr:msb>
         <csr:lsb>26</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>27</csr:msb>
         <csr:lsb>27</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_data_pipeline_empty</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_RD_DATA_PIPELINE_EMPTY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_RD_DATA_PIPELINE_EMPTY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_RD_DATA_PIPELINE_EMPTY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_RD_DATA_PIPELINE_EMPTY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_RD_DATA_PIPELINE_EMPTY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_RD_DATA_PIPELINE_EMPTY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_RD_DATA_PIPELINE_EMPTY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_RD_DATA_PIPELINE_EMPTY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5016</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit indicates that the read data pipeline on the DFI interface is empty.  This register is intended to be polled at least twice after setting DBG1.dis_dq, to ensure that all remaining commands/data have completed.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>28</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_data_pipeline_empty</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_WR_DATA_PIPELINE_EMPTY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_WR_DATA_PIPELINE_EMPTY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_WR_DATA_PIPELINE_EMPTY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_WR_DATA_PIPELINE_EMPTY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_WR_DATA_PIPELINE_EMPTY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_WR_DATA_PIPELINE_EMPTY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_WR_DATA_PIPELINE_EMPTY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM_WR_DATA_PIPELINE_EMPTY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5027</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit indicates that the write data pipeline on the DFI interface is empty.  This register is intended to be polled at least twice after setting DBG1.dis_dq, to ensure that all remaining commands/data have completed.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>29</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>30</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBGCMD</csr:referenceName>
       <csr:identifier>DBGCMD</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBGCMD_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBGCMD_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5092</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x30C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DBGCMD</csr:typeName>
        <csr:description>
         <csr:p>Command Debug Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>rank0_refresh</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_RANK0_REFRESH_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_RANK0_REFRESH_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_RANK0_REFRESH_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_RANK0_REFRESH_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_RANK0_REFRESH_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_RANK0_REFRESH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_RANK0_REFRESH_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_RANK0_REFRESH_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5051</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Setting this register bit to 1 indicates to the uMCTL2 to issue a refresh to rank 0. Writing to this bit causes DBGSTAT.rank0_refresh_busy to be set. When DBGSTAT.rank0_refresh_busy is cleared, the command has been stored in uMCTL2. </csr:p>
         <csr:p> For 3DS configuration, refresh is sent to rank index 0. </csr:p>
         <csr:p> This operation can be performed only when RFSHCTL3.dis_auto_refresh=1. It is recommended NOT to set this register bit if in Init or Deep power-down operating modes or Maximum Power Saving Mode.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1S</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>zq_calib_short</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_ZQ_CALIB_SHORT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_ZQ_CALIB_SHORT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_ZQ_CALIB_SHORT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_ZQ_CALIB_SHORT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_ZQ_CALIB_SHORT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_ZQ_CALIB_SHORT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_ZQ_CALIB_SHORT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_ZQ_CALIB_SHORT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5076</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Setting this register bit to 1 indicates to the uMCTL2 to issue a ZQCS (ZQ calibration short)/MPC(ZQ calibration) command to the SDRAM.  When this request is stored in the uMCTL2, the bit is automatically cleared. This operation can be performed only when ZQCTL0.dis_auto_zq=1. It is recommended NOT to set this register bit if in Init, in Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) or Deep power-down operating modes or Maximum Power Saving Mode. </csr:p>
         <csr:p>For Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) it will be scheduled after SR(except LPDDR4) or SPRD(LPDDR4) has been exited.</csr:p>
         <csr:p>For Deep power down and Maximum Power Saving Mode, it will not be scheduled, although DBGSTAT.zq_calib_short_busy will be de-asserted.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1S</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ctrlupd</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_CTRLUPD_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_CTRLUPD_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_CTRLUPD_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_CTRLUPD_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_CTRLUPD_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_CTRLUPD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_CTRLUPD_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGCMD_CTRLUPD_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5091</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Setting this register bit to 1 indicates to the uMCTL2 to issue a dfi_ctrlupd_req to the PHY.  When this request is stored in the uMCTL2, the bit is automatically cleared. This operation must only be performed when DFIUPD0.dis_auto_ctrlupd=1.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1S</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBGSTAT</csr:referenceName>
       <csr:identifier>DBGSTAT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBGSTAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBGSTAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5150</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x310</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DBGSTAT</csr:typeName>
        <csr:description>
         <csr:p>Status Debug Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>rank0_refresh_busy</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_RANK0_REFRESH_BUSY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_RANK0_REFRESH_BUSY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_RANK0_REFRESH_BUSY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_RANK0_REFRESH_BUSY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_RANK0_REFRESH_BUSY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_RANK0_REFRESH_BUSY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_RANK0_REFRESH_BUSY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_RANK0_REFRESH_BUSY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5114</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SoC core may initiate a rank0_refresh operation (refresh operation to rank 0) only if this signal is low.</csr:p>
         <csr:p> This signal goes high in the clock after DBGCMD.rank0_refresh is set to one. It goes low when the rank0_refresh operation is stored in the uMCTL2.</csr:p>
         <csr:p> It is recommended not to perform rank0_refresh operations when this signal is high.</csr:p>
         <csr:p> - 0 - Indicates that the SoC core can initiate a rank0_refresh operation</csr:p>
         <csr:p> - 1 - Indicates that rank0_refresh operation has not been stored yet in the uMCTL2</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>zq_calib_short_busy</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_ZQ_CALIB_SHORT_BUSY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_ZQ_CALIB_SHORT_BUSY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_ZQ_CALIB_SHORT_BUSY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_ZQ_CALIB_SHORT_BUSY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_ZQ_CALIB_SHORT_BUSY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_ZQ_CALIB_SHORT_BUSY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_ZQ_CALIB_SHORT_BUSY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_ZQ_CALIB_SHORT_BUSY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5131</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SoC core may initiate a ZQCS (ZQ calibration short) operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the ZQCS request. It goes low when the ZQCS operation is initiated in the uMCTL2. It is recommended not to perform ZQCS operations when this signal is high.</csr:p>
         <csr:p> - 0 - Indicates that the SoC core can initiate a ZQCS operation</csr:p>
         <csr:p> - 1 - Indicates that ZQCS operation has not been initiated yet in the uMCTL2</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ctrlupd_busy</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_CTRLUPD_BUSY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_CTRLUPD_BUSY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_CTRLUPD_BUSY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_CTRLUPD_BUSY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_CTRLUPD_BUSY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_CTRLUPD_BUSY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_CTRLUPD_BUSY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGSTAT_CTRLUPD_BUSY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5149</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SoC core may initiate a ctrlupd operation only if this signal is low.</csr:p>
         <csr:p> This signal goes high in the clock after the uMCTL2 accepts the ctrlupd request. It goes low when the ctrlupd operation is initiated in the uMCTL2.</csr:p>
         <csr:p> It is recommended not to perform ctrlupd operations when this signal is high.</csr:p>
         <csr:p> - 0 - Indicates that the SoC core can initiate a ctrlupd operation</csr:p>
         <csr:p> - 1 - Indicates that ctrlupd operation has not been initiated yet in the uMCTL2</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DBGCAM1</csr:referenceName>
       <csr:identifier>DBGCAM1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBGCAM1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DBGCAM1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5164</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x318</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DBGCAM1</csr:typeName>
        <csr:description>
         <csr:p>CAM Debug Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>dbg_wrecc_q_depth</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM1_DBG_WRECC_Q_DEPTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM1_DBG_WRECC_Q_DEPTH_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM1_DBG_WRECC_Q_DEPTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM1_DBG_WRECC_Q_DEPTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM1_DBG_WRECC_Q_DEPTH_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM1_DBG_WRECC_Q_DEPTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM1_DBG_WRECC_Q_DEPTH_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DBGCAM1_DBG_WRECC_Q_DEPTH_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5163</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Write ECC queue depth</csr:p>
         <csr:p>FOR DEBUG ONLY</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.SWCTL</csr:referenceName>
       <csr:identifier>SWCTL</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_SWCTL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_SWCTL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_SWCTL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_SWCTL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5178</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x320</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000001</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_SWCTL</csr:typeName>
        <csr:description>
         <csr:p>Software Register Programming Control Enable</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sw_done</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_SWCTL_SW_DONE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_SWCTL_SW_DONE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_SWCTL_SW_DONE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_SWCTL_SW_DONE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_SWCTL_SW_DONE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_SWCTL_SW_DONE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_SWCTL_SW_DONE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_SWCTL_SW_DONE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5177</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enable quasi-dynamic register programming outside reset. Program register to 0 to enable quasi-dynamic programming. Set back register to 1 once programming is done.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.SWSTAT</csr:referenceName>
       <csr:identifier>SWSTAT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_SWSTAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_SWSTAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_SWSTAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_SWSTAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5196</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x324</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000001</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_SWSTAT</csr:typeName>
        <csr:description>
         <csr:p>Software Register Programming Control Status</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>sw_done_ack</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_SWSTAT_SW_DONE_ACK_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_SWSTAT_SW_DONE_ACK_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_SWSTAT_SW_DONE_ACK_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_SWSTAT_SW_DONE_ACK_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_SWSTAT_SW_DONE_ACK_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_SWSTAT_SW_DONE_ACK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_SWSTAT_SW_DONE_ACK_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_SWSTAT_SW_DONE_ACK_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5195</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Register programming done. This register is the echo of SWCTL.sw_done. Wait for sw_done value 1 to propagate to sw_done_ack at the end of the programming sequence to ensure that the correct registers values are propagated to the destination clock domains.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.POISONCFG</csr:referenceName>
       <csr:identifier>POISONCFG</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_POISONCFG_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_POISONCFG_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5262</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x36C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00110011</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_POISONCFG</csr:typeName>
        <csr:description>
         <csr:p>AXI Poison Configuration Register. Common for all AXI ports</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>wr_poison_slverr_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_SLVERR_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_SLVERR_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_SLVERR_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_SLVERR_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_SLVERR_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_SLVERR_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_SLVERR_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_SLVERR_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5208</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables SLVERR response for write transaction poisoning</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_poison_intr_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5217</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables interrupts for write transaction poisoning</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_poison_intr_clr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_CLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_CLR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_CLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_CLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_CLR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_CLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_CLR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_WR_POISON_INTR_CLR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5230</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt clear for write transaction poisoning. Allow 2/3 clock cycles for correct value to propagate to core logic and clear the interrupts. uMCTL2 automatically clears this bit.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_poison_slverr_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_SLVERR_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_SLVERR_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_SLVERR_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_SLVERR_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_SLVERR_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_SLVERR_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_SLVERR_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_SLVERR_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5239</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables SLVERR response for read transaction poisoning</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>19</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_poison_intr_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5248</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables interrupts for read transaction poisoning</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>20</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>21</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_poison_intr_clr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_CLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_CLR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_CLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_CLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_CLR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_CLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_CLR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_POISONCFG_RD_POISON_INTR_CLR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5261</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Interrupt clear for read transaction poisoning.  Allow 2/3 clock cycles for correct value to propagate to core logic and clear the interrupts. uMCTL2 automatically clears this bit.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>24</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>25</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.POISONSTAT</csr:referenceName>
       <csr:identifier>POISONSTAT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_POISONSTAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_POISONSTAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5323</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x370</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_POISONSTAT</csr:typeName>
        <csr:description>
         <csr:p>AXI Poison Status Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>wr_poison_intr_0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5280</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Write transaction poisoning error interrupt for port 0. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_poison_intr_1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_WR_POISON_INTR_1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5294</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Write transaction poisoning error interrupt for port 1. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_poison_intr_0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5308</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read transaction poisoning error interrupt for port 0. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_poison_intr_1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_POISONSTAT_RD_POISON_INTR_1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5322</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read transaction poisoning error interrupt for port 1. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ADVECCINDEX</csr:referenceName>
       <csr:identifier>ADVECCINDEX</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5374</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x374</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ADVECCINDEX</csr:typeName>
        <csr:description>
         <csr:p>Advanced ECC Index Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_syndrome_sel</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_SYNDROME_SEL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_SYNDROME_SEL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_SYNDROME_SEL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_SYNDROME_SEL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_SYNDROME_SEL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_SYNDROME_SEL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_SYNDROME_SEL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_SYNDROME_SEL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5339</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selector of which DRAM beat data output to ECCCSYN0/1/2 as well as ECCUCSYN.</csr:p>
         <csr:p></csr:p>
         <csr:p>  In Advanced ECC, the syndrome consist of number of DRAM beats. This register select which beats of data will be output to ECCCSYN0/1/2 and ECCUCSYN0/1/2 registers.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_err_symbol_sel</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_ERR_SYMBOL_SEL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_ERR_SYMBOL_SEL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_ERR_SYMBOL_SEL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_ERR_SYMBOL_SEL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_ERR_SYMBOL_SEL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_ERR_SYMBOL_SEL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_ERR_SYMBOL_SEL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_ERR_SYMBOL_SEL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5352</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selector of which error symbol's status output to ADVECCSTAT.advecc_err_symbol_pos and advecc_err_symbol_bits. The default is first error symbol.</csr:p>
         <csr:p></csr:p>
         <csr:p>  The value should be less than ADVECCSTAT.advecc_num_err_symbol.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ecc_poison_beats_sel</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_POISON_BEATS_SEL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_POISON_BEATS_SEL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_POISON_BEATS_SEL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_POISON_BEATS_SEL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_POISON_BEATS_SEL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_POISON_BEATS_SEL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_POISON_BEATS_SEL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ADVECCINDEX_ECC_POISON_BEATS_SEL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5373</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Selector of which DRAM beat's poison pattern will be set by ECCPOISONPAT0/1/2 registers. </csr:p>
         <csr:p> </csr:p>
         <csr:p>  For frequency ratio 1:1 mode, 2 DRAM beats can be poisoned. Set ecc_poison_beats_sel to 0 and given ECCPOISONPAT0/1/2 to set 1st beat's poison pattern; set ecc_poison_beats_sel to 1 and given ECCPOISONPAT0/1/2 to set 2nd beat's poison pattern.</csr:p>
         <csr:p></csr:p>
         <csr:p>  For frequency ratio 1:2 mode, 4 DRAM beats can be poisoned. Set ecc_poison_beats_sel from 0~3 to set 1st to 4th beat's poison pattern.</csr:p>
         <csr:p></csr:p>
         <csr:p>  The other value is reserved.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 1</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCPOISONPAT0</csr:referenceName>
       <csr:identifier>ECCPOISONPAT0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5391</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x37C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCPOISONPAT0</csr:typeName>
        <csr:description>
         <csr:p>ECC Poison Pattern 0 Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_poison_data_31_0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT0_ECC_POISON_DATA_31_0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT0_ECC_POISON_DATA_31_0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT0_ECC_POISON_DATA_31_0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT0_ECC_POISON_DATA_31_0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT0_ECC_POISON_DATA_31_0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT0_ECC_POISON_DATA_31_0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT0_ECC_POISON_DATA_31_0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT0_ECC_POISON_DATA_31_0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5390</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Poison pattern for DRAM data[31:0].</csr:p>
         <csr:p>  Only bit is set to 1 indicate poison (invert) corresponding DRAM bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>  It is indirect register. Selector is ADVECCINDEX.ecc_poison_beats_sel.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.ECCPOISONPAT2</csr:referenceName>
       <csr:identifier>ECCPOISONPAT2</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5408</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x384</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_ECCPOISONPAT2</csr:typeName>
        <csr:description>
         <csr:p>ECC Poison Pattern 2 Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ecc_poison_data_71_64</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT2_ECC_POISON_DATA_71_64_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT2_ECC_POISON_DATA_71_64_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT2_ECC_POISON_DATA_71_64_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT2_ECC_POISON_DATA_71_64_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT2_ECC_POISON_DATA_71_64_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT2_ECC_POISON_DATA_71_64_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT2_ECC_POISON_DATA_71_64_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_ECCPOISONPAT2_ECC_POISON_DATA_71_64_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5407</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Poison pattern for DRAM data[71:64]. </csr:p>
         <csr:p>  Only bit is set to 1 indicate poison (invert) corresponding DRAM bit.</csr:p>
         <csr:p></csr:p>
         <csr:p>  It is indirect register. Selector is ADVECCINDEX.ecc_poison_beats_sel.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_REGS.DERATESTAT</csr:referenceName>
       <csr:identifier>DERATESTAT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DERATESTAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_REGS_DERATESTAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_REGS_DERATESTAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_REGS_DERATESTAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5426</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x3F0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_REGS_DERATESTAT</csr:typeName>
        <csr:description>
         <csr:p>Temperature Derate Status Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>derate_temp_limit_intr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_REGS_DERATESTAT_DERATE_TEMP_LIMIT_INTR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_REGS_DERATESTAT_DERATE_TEMP_LIMIT_INTR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_REGS_DERATESTAT_DERATE_TEMP_LIMIT_INTR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_REGS_DERATESTAT_DERATE_TEMP_LIMIT_INTR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_REGS_DERATESTAT_DERATE_TEMP_LIMIT_INTR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_REGS_DERATESTAT_DERATE_TEMP_LIMIT_INTR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_REGS_DERATESTAT_DERATE_TEMP_LIMIT_INTR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_REGS_DERATESTAT_DERATE_TEMP_LIMIT_INTR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5425</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Derate temperature interrupt indicating LPDDR2/3/4 SDRAM temperature operating limit is exceeded. </csr:p>
         <csr:p>  This register field is set to 1 when the value read from MR4[2:0] is 3'b000 or 3'b111. Cleared by register DERATECTL.derate_temp_limit_intr_clr.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>group</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP</csr:referenceName>
       <csr:identifier>UMCTL2_MP</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6357</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x3F8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Apb_slave_UMCTL2_MP</csr:typeName>
        <csr:description>
         <csr:p>uMCTL2 Multi-Port Registers</csr:p>
        </csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PSTAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCCFG</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGR_0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGW_0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCTRL_0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGQOS0_0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGQOS1_0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGWQOS0_0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGWQOS1_0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGR_1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGW_1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCTRL_1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGQOS0_1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGQOS1_1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGWQOS0_1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGWQOS1_1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.SBRCTL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.SBRSTAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.SBRWDATA0</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.UMCTL2_VER_NUMBER</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.UMCTL2_VER_TYPE</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PSTAT</csr:referenceName>
       <csr:identifier>PSTAT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PSTAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PSTAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PSTAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PSTAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5468</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x4</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PSTAT</csr:typeName>
        <csr:description>
         <csr:p>Port Status Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>rd_port_busy_0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5443</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates if there are outstanding reads for AXI port 0.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_port_busy_1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PSTAT_RD_PORT_BUSY_1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5451</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates if there are outstanding reads for AXI port 1.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_port_busy_0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5459</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates if there are outstanding writes for AXI port 0.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_port_busy_1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PSTAT_WR_PORT_BUSY_1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5467</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates if there are outstanding writes for AXI port 1.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCCFG</csr:referenceName>
       <csr:identifier>PCCFG</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCCFG_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCCFG_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCCFG_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCCFG_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5534</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCCFG</csr:typeName>
        <csr:description>
         <csr:p>Port Common Configuration Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>go2critical_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCCFG_GO2CRITICAL_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCCFG_GO2CRITICAL_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCCFG_GO2CRITICAL_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCCFG_GO2CRITICAL_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCCFG_GO2CRITICAL_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCCFG_GO2CRITICAL_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCCFG_GO2CRITICAL_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCCFG_GO2CRITICAL_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5487</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1 (enabled), sets co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals going to DDRC based on urgent input (awurgent, arurgent) coming from AXI master. If set to 0 (disabled), co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals at DDRC are driven to 1b'0.</csr:p>
         <csr:p></csr:p>
         <csr:p>For uPCTL2, this register field must be set to 0</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>pagematch_limit</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCCFG_PAGEMATCH_LIMIT_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCCFG_PAGEMATCH_LIMIT_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCCFG_PAGEMATCH_LIMIT_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCCFG_PAGEMATCH_LIMIT_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCCFG_PAGEMATCH_LIMIT_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCCFG_PAGEMATCH_LIMIT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCCFG_PAGEMATCH_LIMIT_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCCFG_PAGEMATCH_LIMIT_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5500</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Page match four limit. If set to 1, limits the number of consecutive same page DDRC transactions that can be granted by the Port Arbiter to four when Page Match feature is enabled.       If set to 0, there is no limit imposed on number of consecutive same page DDRC transactions.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>bl_exp_mode</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCCFG_BL_EXP_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCCFG_BL_EXP_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCCFG_BL_EXP_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCCFG_BL_EXP_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCCFG_BL_EXP_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCCFG_BL_EXP_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCCFG_BL_EXP_MODE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCCFG_BL_EXP_MODE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5533</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Burst length expansion mode. By default (i.e. bl_exp_mode==0) XPI expands every AXI burst into multiple HIF commands, using the memory burst length as a unit. If set to 1, then XPI will use half of the memory burst length as a unit. </csr:p>
         <csr:p>    This applies to both reads and writes. When MSTR.data_bus_width==00, setting bl_exp_mode to 1 has no effect.</csr:p>
         <csr:p>    </csr:p>
         <csr:p>This can be used in cases where Partial Writes is enabled (UMCTL2_PARTIAL_WR=1), in order to avoid or minimize t_ccd_l penalty in DDR4 and t_ccd_mw penalty in LPDDR4. Hence, bl_exp_mode=1 is only recommended if DDR4 or LPDDR4.</csr:p>
         <csr:p>    </csr:p>
         <csr:p>Note that if DBICTL.dm_en=0, functionality is not supported in the following cases:</csr:p>
         <csr:p>    - UMCTL2_PARTIAL_WR=0</csr:p>
         <csr:p>    - UMCTL2_PARTIAL_WR=1, MSTR.data_bus_width=01, MEMC_BURST_LENGTH=8 and MSTR.burst_rdwr=1000 (LPDDR4 only)</csr:p>
         <csr:p>    - UMCTL2_PARTIAL_WR=1, MSTR.data_bus_width=01, MEMC_BURST_LENGTH=4 and MSTR.burst_rdwr=0100 (DDR4 only), with either MSTR.burstchop=0 or CRCPARCTL1.crc_enable=1</csr:p>
         <csr:p>    </csr:p>
         <csr:p>Functionality is also not supported if Data Channel Interleave is enabled</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGR_0</csr:referenceName>
       <csr:identifier>PCFGR_0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGR_0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGR_0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5606</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00004000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCFGR_0</csr:typeName>
        <csr:description>
         <csr:p>Port n Configuration Read Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>rd_port_priority</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PRIORITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PRIORITY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PRIORITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PRIORITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PRIORITY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PRIORITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PRIORITY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PRIORITY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5568</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Determines the initial load value of read aging counters.        These counters will be parallel loaded after reset, or after each grant to the corresponding port.      The aging counters down-count every clock cycle where the port is requesting but not </csr:p>
         <csr:p>         granted. The higher significant 5-bits of the read aging counter sets the priority of the </csr:p>
         <csr:p>         read channel of a given port.   Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.      When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0).  For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority         inputs (arqos) are enabled (timeout is still applicable).     For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.    In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority </csr:p>
         <csr:p>         (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis.      </csr:p>
         <csr:p>Note: The two LSBs of this register field are tied internally to 2'b00.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>11</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_port_aging_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_AGING_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_AGING_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_AGING_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_AGING_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_AGING_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_AGING_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_AGING_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_AGING_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5577</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables aging function for the read channel of the port.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_port_urgent_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_URGENT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_URGENT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_URGENT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_URGENT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_URGENT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_URGENT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_URGENT_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_URGENT_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5593</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent    is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to    DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be       asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command).</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_port_pagematch_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PAGEMATCH_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PAGEMATCH_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PAGEMATCH_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PAGEMATCH_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PAGEMATCH_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PAGEMATCH_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PAGEMATCH_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGR_0_RD_PORT_PAGEMATCH_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5605</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,       the port is continued to be granted if the following immediate commands are to the same         memory page (same bank and same row). See also related PCCFG.pagematch_limit register.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>14</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGW_0</csr:referenceName>
       <csr:identifier>PCFGW_0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGW_0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGW_0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5675</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x10</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00004000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCFGW_0</csr:typeName>
        <csr:description>
         <csr:p>Port n Configuration Write Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>wr_port_priority</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PRIORITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PRIORITY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PRIORITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PRIORITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PRIORITY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PRIORITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PRIORITY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PRIORITY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5637</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Determines the initial load value of write aging counters.       These counters will be parallel loaded after reset, or after each grant to the corresponding port.      The aging counters down-count every clock cycle where the port is requesting but not       granted. The higher significant 5-bits of the write aging counter sets the initial priority of the </csr:p>
         <csr:p>         write channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level.  </csr:p>
         <csr:p>For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority         inputs (awqos) are enabled (timeout is still applicable).     </csr:p>
         <csr:p>For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.     </csr:p>
         <csr:p>Note: The two LSBs of this register field are tied internally to 2'b00.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>11</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_port_aging_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_AGING_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_AGING_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_AGING_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_AGING_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_AGING_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_AGING_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_AGING_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_AGING_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5646</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables aging function for the write channel of the port.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_port_urgent_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_URGENT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_URGENT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_URGENT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_URGENT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_URGENT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_URGENT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_URGENT_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_URGENT_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5662</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent    is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register.</csr:p>
         <csr:p> Note that awurgent signal can be        asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command).</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_port_pagematch_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PAGEMATCH_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PAGEMATCH_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PAGEMATCH_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PAGEMATCH_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PAGEMATCH_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PAGEMATCH_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PAGEMATCH_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGW_0_WR_PORT_PAGEMATCH_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5674</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,       the port is continued to be granted if the following immediate commands are to the same         memory page (same bank and same row). See also related PCCFG.pagematch_limit register.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>14</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCTRL_0</csr:referenceName>
       <csr:identifier>PCTRL_0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCTRL_0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCTRL_0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCTRL_0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCTRL_0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5687</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x98</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCTRL_0</csr:typeName>
        <csr:description>
         <csr:p>Port n Control Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>port_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCTRL_0_PORT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCTRL_0_PORT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCTRL_0_PORT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCTRL_0_PORT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCTRL_0_PORT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCTRL_0_PORT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCTRL_0_PORT_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCTRL_0_PORT_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5686</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enables AXI port n.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGQOS0_0</csr:referenceName>
       <csr:identifier>PCFGQOS0_0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5746</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x9C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCFGQOS0_0</csr:typeName>
        <csr:description>
         <csr:p>Port n Read QoS Configuration Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>rqos_map_level1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_LEVEL1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_LEVEL1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_LEVEL1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_LEVEL1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_LEVEL1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_LEVEL1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_LEVEL1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_LEVEL1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5706</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos.          </csr:p>
         <csr:p>Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.</csr:p>
         <csr:p> All of the map_level* registers must be set to distinct values.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rqos_map_region0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5725</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bitfield indicates the traffic class of region 0.</csr:p>
         <csr:p> Valid values are:</csr:p>
         <csr:p> - 0: LPR</csr:p>
         <csr:p> - 1: VPR</csr:p>
         <csr:p> - 2: HPR</csr:p>
         <csr:p>For dual address queue configurations, region 0 maps to the blue address queue.</csr:p>
         <csr:p> In this case, valid values are: </csr:p>
         <csr:p>0: LPR and 1: VPR only.</csr:p>
         <csr:p> When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR), VPR traffic is aliased to LPR traffic.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>19</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rqos_map_region1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_0_RQOS_MAP_REGION1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5745</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bitfield indicates the traffic class of region 1.</csr:p>
         <csr:p> Valid values are:</csr:p>
         <csr:p> - 0 : LPR</csr:p>
         <csr:p> - 1: VPR</csr:p>
         <csr:p> - 2: HPR</csr:p>
         <csr:p> For dual address queue configurations, region1 maps to the blue address queue.</csr:p>
         <csr:p> In this case, valid values are </csr:p>
         <csr:p> - 0: LPR</csr:p>
         <csr:p> - 1: VPR only</csr:p>
         <csr:p> When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR), VPR traffic is aliased to LPR traffic.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>21</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>22</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGQOS1_0</csr:referenceName>
       <csr:identifier>PCFGQOS1_0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5768</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xA0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCFGQOS1_0</csr:typeName>
        <csr:description>
         <csr:p>Port n Read QoS Configuration Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>rqos_map_timeoutb</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5758</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the timeout value for transactions mapped to the blue address queue.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rqos_map_timeoutr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5767</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the timeout value for transactions mapped to the red address queue.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>26</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>27</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGWQOS0_0</csr:referenceName>
       <csr:identifier>PCFGWQOS0_0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5845</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xA4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000e00</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCFGWQOS0_0</csr:typeName>
        <csr:description>
         <csr:p>Port n Write QoS Configuration Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>wqos_map_level1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5786</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.</csr:p>
         <csr:p> Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.</csr:p>
         <csr:p> All of the map_level* registers must be set to distinct values.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wqos_map_level2</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL2_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL2_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL2_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL2_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL2_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL2_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_LEVEL2_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5802</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to awqos.</csr:p>
         <csr:p> Region2 starts from (level2 + 1) up to 15.</csr:p>
         <csr:p> Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.</csr:p>
         <csr:p> All of the map_level* registers must be set to distinct values.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0xe</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wqos_map_region0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5818</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bitfield indicates the traffic class of region 0.</csr:p>
         <csr:p></csr:p>
         <csr:p>          Valid values are: </csr:p>
         <csr:p></csr:p>
         <csr:p>          0: NPW, 1: VPW. </csr:p>
         <csr:p></csr:p>
         <csr:p>     When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>19</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wqos_map_region1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5831</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bitfield indicates the traffic class of region 1.</csr:p>
         <csr:p> Valid values are:</csr:p>
         <csr:p> 0: NPW, 1: VPW.</csr:p>
         <csr:p> When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>21</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>22</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wqos_map_region2</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION2_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION2_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION2_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION2_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION2_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION2_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_0_WQOS_MAP_REGION2_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5844</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bitfield indicates the traffic class of region 2.</csr:p>
         <csr:p> Valid values are:</csr:p>
         <csr:p> 0: NPW, 1: VPW.</csr:p>
         <csr:p> When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>25</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>26</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGWQOS1_0</csr:referenceName>
       <csr:identifier>PCFGWQOS1_0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5867</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xA8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCFGWQOS1_0</csr:typeName>
        <csr:description>
         <csr:p>Port n Write QoS Configuration Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>wqos_map_timeout1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5857</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the timeout value for write transactions in region 0 and 1.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wqos_map_timeout2</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5866</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the timeout value for write transactions in region 2.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>26</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>27</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGR_1</csr:referenceName>
       <csr:identifier>PCFGR_1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGR_1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGR_1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>5939</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xBC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00004000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCFGR_1</csr:typeName>
        <csr:description>
         <csr:p>Port n Configuration Read Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>rd_port_priority</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PRIORITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PRIORITY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PRIORITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PRIORITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PRIORITY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PRIORITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PRIORITY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PRIORITY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5901</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Determines the initial load value of read aging counters.        These counters will be parallel loaded after reset, or after each grant to the corresponding port.      The aging counters down-count every clock cycle where the port is requesting but not </csr:p>
         <csr:p>         granted. The higher significant 5-bits of the read aging counter sets the priority of the </csr:p>
         <csr:p>         read channel of a given port.   Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.      When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0).  For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority         inputs (arqos) are enabled (timeout is still applicable).     For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.    In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority </csr:p>
         <csr:p>         (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis.      </csr:p>
         <csr:p>Note: The two LSBs of this register field are tied internally to 2'b00.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>11</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_port_aging_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_AGING_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_AGING_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_AGING_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_AGING_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_AGING_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_AGING_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_AGING_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_AGING_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5910</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables aging function for the read channel of the port.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_port_urgent_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_URGENT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_URGENT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_URGENT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_URGENT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_URGENT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_URGENT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_URGENT_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_URGENT_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5926</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent    is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to    DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be       asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command).</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rd_port_pagematch_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PAGEMATCH_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PAGEMATCH_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PAGEMATCH_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PAGEMATCH_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PAGEMATCH_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PAGEMATCH_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PAGEMATCH_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGR_1_RD_PORT_PAGEMATCH_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5938</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,       the port is continued to be granted if the following immediate commands are to the same         memory page (same bank and same row). See also related PCCFG.pagematch_limit register.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>14</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGW_1</csr:referenceName>
       <csr:identifier>PCFGW_1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGW_1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGW_1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6008</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xC0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00004000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCFGW_1</csr:typeName>
        <csr:description>
         <csr:p>Port n Configuration Write Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>wr_port_priority</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PRIORITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PRIORITY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PRIORITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PRIORITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PRIORITY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PRIORITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PRIORITY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PRIORITY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5970</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Determines the initial load value of write aging counters.       These counters will be parallel loaded after reset, or after each grant to the corresponding port.      The aging counters down-count every clock cycle where the port is requesting but not       granted. The higher significant 5-bits of the write aging counter sets the initial priority of the </csr:p>
         <csr:p>         write channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level.  </csr:p>
         <csr:p>For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority         inputs (awqos) are enabled (timeout is still applicable).     </csr:p>
         <csr:p>For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.     </csr:p>
         <csr:p>Note: The two LSBs of this register field are tied internally to 2'b00.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>11</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_port_aging_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_AGING_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_AGING_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_AGING_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_AGING_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_AGING_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_AGING_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_AGING_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_AGING_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5979</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables aging function for the write channel of the port.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_port_urgent_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_URGENT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_URGENT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_URGENT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_URGENT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_URGENT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_URGENT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_URGENT_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_URGENT_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>5995</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent    is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register.</csr:p>
         <csr:p> Note that awurgent signal can be        asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command).</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wr_port_pagematch_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PAGEMATCH_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PAGEMATCH_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PAGEMATCH_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PAGEMATCH_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PAGEMATCH_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PAGEMATCH_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PAGEMATCH_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGW_1_WR_PORT_PAGEMATCH_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6007</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,       the port is continued to be granted if the following immediate commands are to the same         memory page (same bank and same row). See also related PCCFG.pagematch_limit register.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>14</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCTRL_1</csr:referenceName>
       <csr:identifier>PCTRL_1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCTRL_1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCTRL_1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCTRL_1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCTRL_1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6020</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x148</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCTRL_1</csr:typeName>
        <csr:description>
         <csr:p>Port n Control Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>port_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCTRL_1_PORT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCTRL_1_PORT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCTRL_1_PORT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCTRL_1_PORT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCTRL_1_PORT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCTRL_1_PORT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCTRL_1_PORT_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCTRL_1_PORT_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6019</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enables AXI port n.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGQOS0_1</csr:referenceName>
       <csr:identifier>PCFGQOS0_1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6079</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x14C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCFGQOS0_1</csr:typeName>
        <csr:description>
         <csr:p>Port n Read QoS Configuration Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>rqos_map_level1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_LEVEL1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_LEVEL1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_LEVEL1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_LEVEL1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_LEVEL1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_LEVEL1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_LEVEL1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_LEVEL1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6039</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos.          </csr:p>
         <csr:p>Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.</csr:p>
         <csr:p> All of the map_level* registers must be set to distinct values.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rqos_map_region0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6058</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bitfield indicates the traffic class of region 0.</csr:p>
         <csr:p> Valid values are:</csr:p>
         <csr:p> - 0: LPR</csr:p>
         <csr:p> - 1: VPR</csr:p>
         <csr:p> - 2: HPR</csr:p>
         <csr:p>For dual address queue configurations, region 0 maps to the blue address queue.</csr:p>
         <csr:p> In this case, valid values are: </csr:p>
         <csr:p>0: LPR and 1: VPR only.</csr:p>
         <csr:p> When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR), VPR traffic is aliased to LPR traffic.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>19</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rqos_map_region1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS0_1_RQOS_MAP_REGION1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6078</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bitfield indicates the traffic class of region 1.</csr:p>
         <csr:p> Valid values are:</csr:p>
         <csr:p> - 0 : LPR</csr:p>
         <csr:p> - 1: VPR</csr:p>
         <csr:p> - 2: HPR</csr:p>
         <csr:p> For dual address queue configurations, region1 maps to the blue address queue.</csr:p>
         <csr:p> In this case, valid values are </csr:p>
         <csr:p> - 0: LPR</csr:p>
         <csr:p> - 1: VPR only</csr:p>
         <csr:p> When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR), VPR traffic is aliased to LPR traffic.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>21</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>22</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGQOS1_1</csr:referenceName>
       <csr:identifier>PCFGQOS1_1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6101</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x150</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCFGQOS1_1</csr:typeName>
        <csr:description>
         <csr:p>Port n Read QoS Configuration Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>rqos_map_timeoutb</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6091</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the timeout value for transactions mapped to the blue address queue.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>rqos_map_timeoutr</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6100</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the timeout value for transactions mapped to the red address queue.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>26</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>27</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGWQOS0_1</csr:referenceName>
       <csr:identifier>PCFGWQOS0_1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6178</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x154</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000e00</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCFGWQOS0_1</csr:typeName>
        <csr:description>
         <csr:p>Port n Write QoS Configuration Register 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>wqos_map_level1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6119</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.</csr:p>
         <csr:p> Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.</csr:p>
         <csr:p> All of the map_level* registers must be set to distinct values.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wqos_map_level2</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL2_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL2_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL2_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL2_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL2_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL2_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_LEVEL2_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6135</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to awqos.</csr:p>
         <csr:p> Region2 starts from (level2 + 1) up to 15.</csr:p>
         <csr:p> Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.</csr:p>
         <csr:p> All of the map_level* registers must be set to distinct values.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0xe</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wqos_map_region0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6151</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bitfield indicates the traffic class of region 0.</csr:p>
         <csr:p></csr:p>
         <csr:p>          Valid values are: </csr:p>
         <csr:p></csr:p>
         <csr:p>          0: NPW, 1: VPW. </csr:p>
         <csr:p></csr:p>
         <csr:p>     When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>19</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wqos_map_region1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6164</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bitfield indicates the traffic class of region 1.</csr:p>
         <csr:p> Valid values are:</csr:p>
         <csr:p> 0: NPW, 1: VPW.</csr:p>
         <csr:p> When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>21</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>22</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wqos_map_region2</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION2_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION2_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION2_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION2_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION2_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION2_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS0_1_WQOS_MAP_REGION2_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6177</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bitfield indicates the traffic class of region 2.</csr:p>
         <csr:p> Valid values are:</csr:p>
         <csr:p> 0: NPW, 1: VPW.</csr:p>
         <csr:p> When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>25</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>26</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.PCFGWQOS1_1</csr:referenceName>
       <csr:identifier>PCFGWQOS1_1</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6200</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x158</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_PCFGWQOS1_1</csr:typeName>
        <csr:description>
         <csr:p>Port n Write QoS Configuration Register 1</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>wqos_map_timeout1</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6190</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the timeout value for write transactions in region 0 and 1.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>wqos_map_timeout2</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6199</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specifies the timeout value for write transactions in region 2.</csr:p>
         <csr:p>Programming Mode: Quasi-dynamic Group 3</csr:p>
        </csr:description>
         <csr:msb>26</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>27</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.SBRCTL</csr:referenceName>
       <csr:identifier>SBRCTL</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_SBRCTL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_SBRCTL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6289</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xB2C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0000ff10</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_SBRCTL</csr:typeName>
        <csr:description>
         <csr:p>Scrubber Control Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>scrub_en</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_EN_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_EN_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_EN_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6218</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Enable ECC scrubber. </csr:p>
         <csr:p>If set to 1, enables the scrubber to generate background read commands after the memories are initialized.</csr:p>
         <csr:p> If set to 0, disables the scrubber, resets the address generator to 0 </csr:p>
         <csr:p>     and clears the scrubber status.</csr:p>
         <csr:p> This bitfield must be accessed separately from the other bitfields in this register.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>scrub_during_lowpower</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_DURING_LOWPOWER_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_DURING_LOWPOWER_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_DURING_LOWPOWER_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_DURING_LOWPOWER_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_DURING_LOWPOWER_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_DURING_LOWPOWER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_DURING_LOWPOWER_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_DURING_LOWPOWER_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6235</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Continue scrubbing during low power.</csr:p>
         <csr:p> If set to 1, burst of scrubs will be issued in HW controlled low power modes. There are two such modes: automatically initiated by idleness or initiated by Hardware low power interface.</csr:p>
         <csr:p> If set to 0, the scrubber will not attempt to send commands while the DDRC is in HW controlled low power modes. In this case, the scrubber will remember the last address issued and will automatically continue from there when the DDRC exits the LP mode.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>scrub_mode</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_MODE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_MODE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6244</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>scrub_mode:0 ECC scrubber will perform reads </csr:p>
         <csr:p> scrub_mode:1 ECC scrubber will perform writes</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>scrub_burst</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_BURST_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_BURST_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_BURST_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_BURST_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_BURST_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_BURST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_BURST_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_BURST_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6267</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Scrub burst count. Determines the number of back-to-back scrub read commands that can be issued together</csr:p>
         <csr:p>     when the controller is in one of the HW controlled low power modes with Sideband ECC, both normal operation mode and low-power mode with Inline ECC. During these modes, the period of the scrub burst</csr:p>
         <csr:p>     becomes "scrub_burst*scrub_interval" cycles. During normal operation mode of the controller with Sideband ECC (not in power-down</csr:p>
         <csr:p>     or self refresh), scrub_burst is ignored and only one scrub command is generated.</csr:p>
         <csr:p> Valid values are (Sideband ECC): 1: 1 read, 2: 4 reads, 3: 16 reads, 4: 64 reads, 5: 256 reads, 6: 1024 reads. (Inline ECC): 1: 8 reads, 2: 16 reads, 3: 32 reads.</csr:p>
         <csr:p>     New programmed value will take effect only after scrubber is disabled by programming scrub_en to 0.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>scrub_interval</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_INTERVAL_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_INTERVAL_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_INTERVAL_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_INTERVAL_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_INTERVAL_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_INTERVAL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_INTERVAL_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_SBRCTL_SCRUB_INTERVAL_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6288</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Scrub interval. (512 x scrub_interval) number of clock cycles between two scrub read commands. If set to 0, scrub commands are issued back-to-back. This mode of operation (scrub_interval=0) can typically be used for scrubbing the full range of memory at once before or after SW controlled low power operations. After completing the full range of scrub while scrub_interval=0, scrub_done register is set and sbr_done_intr interrupt signal is asserted. </csr:p>
         <csr:p>     This mode can't be used with Inline ECC: If MEMC_INLINE_ECC is 1 and scrub_interval is programme to 0, then RMW logic inside scrubber is disabled.</csr:p>
         <csr:p>     New programmed value will take effect only after scrubber is disabled by programming scrub_en to 0.</csr:p>
         <csr:p>Unit: Multiples of 512 sbr_clk cycles.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>20</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00ff</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>21</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.SBRSTAT</csr:referenceName>
       <csr:identifier>SBRSTAT</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_SBRSTAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_SBRSTAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6318</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xB30</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_SBRSTAT</csr:typeName>
        <csr:description>
         <csr:p>Scrubber Status Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>scrub_busy</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_BUSY_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_BUSY_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_BUSY_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_BUSY_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_BUSY_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_BUSY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_BUSY_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_BUSY_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6304</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Scrubber busy. Controller sets this bit to 1 when the scrubber logic has outstanding read commands being executed. Cleared when there are no active outstanding scrub reads in the system.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>scrub_done</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_DONE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_DONE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_DONE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_DONE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_DONE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_DONE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_DONE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_SBRSTAT_SCRUB_DONE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6317</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Scrubber done. Controller sets this bit to 1, after full range of addresses are scrubbed once while scrub_interval is set to 0. Cleared if scrub_en is set to 0 (scrubber disabled) or scrub_interval is set to a non-zero value for normal scrub operation. The interrupt signal, sbr_done_intr, is equivalent to this status bitfield.</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.SBRWDATA0</csr:referenceName>
       <csr:identifier>SBRWDATA0</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_SBRWDATA0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_SBRWDATA0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_SBRWDATA0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_SBRWDATA0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6330</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xB34</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_SBRWDATA0</csr:typeName>
        <csr:description>
         <csr:p>Scrubber Write Data Pattern0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>scrub_pattern0</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_SBRWDATA0_SCRUB_PATTERN0_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_SBRWDATA0_SCRUB_PATTERN0_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_SBRWDATA0_SCRUB_PATTERN0_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_SBRWDATA0_SCRUB_PATTERN0_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_SBRWDATA0_SCRUB_PATTERN0_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_SBRWDATA0_SCRUB_PATTERN0_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_SBRWDATA0_SCRUB_PATTERN0_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_SBRWDATA0_SCRUB_PATTERN0_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6329</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ECC Scrubber write data pattern for data bus[31:0]</csr:p>
         <csr:p>Programming Mode: Dynamic</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.UMCTL2_VER_NUMBER</csr:referenceName>
       <csr:identifier>UMCTL2_VER_NUMBER</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_UMCTL2_VER_NUMBER_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_UMCTL2_VER_NUMBER_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_NUMBER_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_NUMBER_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6343</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xBF8</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x3335302a</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_UMCTL2_VER_NUMBER</csr:typeName>
        <csr:description>
         <csr:p>UMCTL2 Version Number Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ver_number</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_NUMBER_VER_NUMBER_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_NUMBER_VER_NUMBER_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_NUMBER_VER_NUMBER_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_NUMBER_VER_NUMBER_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_NUMBER_VER_NUMBER_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_NUMBER_VER_NUMBER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_NUMBER_VER_NUMBER_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_NUMBER_VER_NUMBER_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6342</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates the Device Version Number value.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x3335302a</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>ddr.APB_SLAVE.UMCTL2_MP.UMCTL2_VER_TYPE</csr:referenceName>
       <csr:identifier>UMCTL2_VER_TYPE</csr:identifier>
       <csr:addressMacro>DDR_APB_SLAVE_UMCTL2_MP_UMCTL2_VER_TYPE_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_APB_SLAVE_UMCTL2_MP_UMCTL2_VER_TYPE_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_TYPE_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_TYPE_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6356</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0xBFC</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x67612a2a</csr:registerResetValue>
       <csr:typeName>Apb_slave_UMCTL2_MP_UMCTL2_VER_TYPE</csr:typeName>
        <csr:description>
         <csr:p>UMCTL2 Version Type Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ver_type</csr:identifier>
         <csr:widthMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_TYPE_VER_TYPE_WIDTH</csr:widthMacro>
         <csr:msbMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_TYPE_VER_TYPE_MSB</csr:msbMacro>
         <csr:lsbMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_TYPE_VER_TYPE_LSB</csr:lsbMacro>
         <csr:rangeMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_TYPE_VER_TYPE_RANGE</csr:rangeMacro>
         <csr:resetMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_TYPE_VER_TYPE_RESET</csr:resetMacro>
         <csr:maskMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_TYPE_VER_TYPE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_TYPE_VER_TYPE_GET</csr:getMacro>
         <csr:setMacro>APB_SLAVE_UMCTL2_MP_UMCTL2_VER_TYPE_VER_TYPE_SET</csr:setMacro>
         <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
         <csr:linenumber>6355</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates the Device Version Type value.</csr:p>
         <csr:p>Programming Mode: Static</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x67612a2a</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>addressmap</csr:referenceType>
       <csr:referenceName>ddr.AXI4_SLAVE_00</csr:referenceName>
       <csr:identifier>AXI4_SLAVE_00</csr:identifier>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6389</csr:linenumber>
       <csr:title></csr:title>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Axi4_slave_00</csr:typeName>
        <csr:description>
         <csr:p>AXI address map for port 0</csr:p>
        </csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>memory</csr:referenceType>
         <csr:referenceName>ddr.AXI4_SLAVE_00.AXI_block</csr:referenceName>
        </csr:reference>
       </csr:references>
       <csr:addressMap>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0xFFF</csr:addressHigh>
         <csr:instanceName>AXI4_SLAVE_00</csr:instanceName>
         <csr:referenceName>ddr.AXI4_SLAVE_00</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0xFFF</csr:addressHigh>
         <csr:instanceName>AXI4_SLAVE_00.AXI_block</csr:instanceName>
         <csr:referenceName>ddr.AXI4_SLAVE_00.AXI_block</csr:referenceName>
        </csr:addressMapEntry>
       </csr:addressMap>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>memory</csr:referenceType>
       <csr:referenceName>ddr.AXI4_SLAVE_00.AXI_block</csr:referenceName>
       <csr:identifier>AXI_block</csr:identifier>
       <csr:addressMacro>DDR_AXI4_SLAVE_00_AXI_BLOCK_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_AXI4_SLAVE_00_AXI_BLOCK_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>AXI4_SLAVE_00_AXI_BLOCK_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>AXI4_SLAVE_00_AXI_BLOCK_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6369</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:memoryWordCount>0x400</csr:memoryWordCount>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Axi4_slave_00_AXI_block</csr:typeName>
        <csr:description>
         <csr:p>UMCTL2 AXI Port Block</csr:p>
        </csr:description>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>addressmap</csr:referenceType>
       <csr:referenceName>ddr.AXI4_SLAVE_01</csr:referenceName>
       <csr:identifier>AXI4_SLAVE_01</csr:identifier>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6390</csr:linenumber>
       <csr:title></csr:title>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Axi4_slave_01</csr:typeName>
        <csr:description>
         <csr:p>AXI address map for port 1</csr:p>
        </csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>memory</csr:referenceType>
         <csr:referenceName>ddr.AXI4_SLAVE_01.AXI_block_0</csr:referenceName>
        </csr:reference>
       </csr:references>
       <csr:addressMap>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0xFFF</csr:addressHigh>
         <csr:instanceName>AXI4_SLAVE_01</csr:instanceName>
         <csr:referenceName>ddr.AXI4_SLAVE_01</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0xFFF</csr:addressHigh>
         <csr:instanceName>AXI4_SLAVE_01.AXI_block_0</csr:instanceName>
         <csr:referenceName>ddr.AXI4_SLAVE_01.AXI_block_0</csr:referenceName>
        </csr:addressMapEntry>
       </csr:addressMap>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>memory</csr:referenceType>
       <csr:referenceName>ddr.AXI4_SLAVE_01.AXI_block_0</csr:referenceName>
       <csr:identifier>AXI_block_0</csr:identifier>
       <csr:addressMacro>DDR_AXI4_SLAVE_01_AXI_BLOCK_0_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>DDR_AXI4_SLAVE_01_AXI_BLOCK_0_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>AXI4_SLAVE_01_AXI_BLOCK_0_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>AXI4_SLAVE_01_AXI_BLOCK_0_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DWC_ddr_umctl2.csr</csr:filename>
       <csr:linenumber>6381</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:memoryWordCount>0x400</csr:memoryWordCount>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>Axi4_slave_01_AXI_block_0</csr:typeName>
        <csr:description>
         <csr:p>UMCTL2 AXI Port Block</csr:p>
        </csr:description>
      </csr:definition>
     </csr:definitions>
    </csr:csrObject>
   </csr:csrData>
  </xml>
  <div id="docheader">
   <h2>Addressmap Information for 'DWC_ddr_umctl2'</h2>
   <table id="optiontable" border="1" cellpadding="1">
    <tr>
     <td>
      <div id="globalFileInfoCheckBoxDiv">
       <label for="globalFileInfoCheckBox">Input File Information</label>
       <input id="globalFileInfoCheckBox" type="checkbox" onclick="globalFileInfoCheckBox_click();"/>
      </div>
     </td>
     <td>
      <div id="globalHeaderFileInfoCheckBoxDiv">
       <label for="globalHeaderFileInfoCheckBox">Header File Information</label>
       <input id="globalHeaderFileInfoCheckBox" type="checkbox" onclick="globalHeaderFileInfoCheckBox_click();"/>
      </div>
     </td>
     <td>
      <div id="globalEnumInfoCheckBoxDiv">
       <label for="globalEnumInfoCheckBox">Enum Information</label>
       <input id="globalEnumInfoCheckBox" type="checkbox" onclick="globalEnumInfoCheckBox_click();"/>
      </div>
     </td>
    </tr>
   </table>
  </div>
  <div id="docinfo"></div>
  <div id="docroot"></div>
  <div id="docfooter"></div>
 </body>
</html>
