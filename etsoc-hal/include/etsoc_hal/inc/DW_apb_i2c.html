<!--                                                                      -->
<!--                                                                      -->
<!-- Generated by Semifore, Inc. csrCompile                               -->
<!--    HTML output                                                       -->
<html>
 <head>
  <title>Addressmap Information for 'DW_apb_i2c'</title>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
  <meta http-equiv="Expires" content="0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
   /*
    * Copyright (c) SEMIFORE, INC. 2006-2015. All rights reserved.
    *
    * This software and documentation constitute an unpublished work and
    * contain valuable trade secrets and proprietary information belonging
    * to Semifore, Inc.  None of the foregoing material may be copied,
    * duplicated or disclosed without the express written permission of
    * Semifore, Inc.
    * SEMIFORE, INC. EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING
    * THIS SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF
    * MERCHANTABILITY AND/OR FITNESS FOR ANY PARTICULAR PURPOSE,
    * AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY THAT
    * MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
    * TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT
    * TO THE USE OF THE SOFTWARE OR DOCUMENTATION.
    * Under no circumstances shall Semifore, Inc. be liable for incidental,
    * special, indirect, direct or consequential damages or loss of profits,
    * interruption of business, or related expenses which may arise from use
    * of this software or documentation, including but not limited to those
    * resulting from defects in software and/or documentation, or loss or
    * inaccuracy of data of any kind.
   */
   
   /*
    * csrStyles.css
    *
    * $Revision: 1.20 $
    * $Date: 2015/09/06 01:23:08 $
    *
    * @(#)$Id: csrStyles.css,v 1.20 2015/09/06 01:23:08 weber Exp $
    *
    * These are the CSS Styles attributes for the HTML pages
    *
   */
   
   body {
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   	margin: 0px;
           text-align: left;
           padding: 0px;
   	color: #4f6b72;
   	background-color: #e7e7e7;
   }
   
   a {
   	color: #c75f3e;
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   
   
   
   }
   
   div {
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   }
   
   table {
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   	background-color: #fff;
   
   
   	border-collapse: collapse;
   	margin-top: 2px;
   	margin-bottom: 2px;
   }
   
   
   th {
   	font: bold 7pt  Arial, Helvetica, sans-serif;
   	color: #4f6b72;
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   
   	letter-spacing: 1px;
   	text-align: left;
   	padding: 6px 6px 6px 12px;
   	background-color: #CAE8EA;
   }
   
   th.component {
           background-color: #FFCCFF;
   }
   
   th.addressmap {
           background-color: #CAE8EA;
   }
   
   th.register {
   	background-color: #CCFFCC;
   }
   
   th.group {
   	background-color: #FFFFCC;
   }
   
   th.union {
   	background-color: #CCCC00;
   }
   
   th.wideregister {
   	background-color: #FFCCCC;
   }
   
   th.memory {
   	background-color: #CCCCFF;
   }
   
   th.widememory {
   	background-color: #FF88FF;
   }
   
   th.submemory {
   	background-color: #CCCCFF;
   }
   
   th.field {
   	background-color: #CCFFFF;
   }
   
   
   td {
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   	background-color: #fff;
   	padding: 6px 6px 6px 12px;
   	color: #4f6b72;
   	text-align: left;
   }
   
   td.noborder {
   	border-right: 0px none #C1DAD7;
   	border-left: 0px none #C1DAD7;
   	border-bottom: 0px none #C1DAD7;
   	border-top: 0px none #C1DAD7;
   	background-color: #FFF;
   	text-align: left;
   }
   
   .addrMapClass
   {
   }
   
   
   .addrMapContent
   {
   }
   
   .frdiv {
   	float: right;
   }
   
   .fldiv {
   	float: left;
   	margin-right: 10px;
   }
   
   .window 
   {
     background-color: white; 
     border-color:  #7BA7E1;
     border-style: solid; 
     border-width: 1px;
     margin: 0px;
     padding: 0px;
     position: absolute;
     visibility: hidden;
   }
   
   .windowTitleBar 
   {
     background-color: #7BA7E1;
     border-style: none;
     color: white;
     font: bold 11pt auto  Arial, Helvetica, sans-serif;	
     margin-left: 6px;
     margin-right: 6px;
   }
   
   .windowList 
   {
     background-color: white;
     border-style: none; 
     border-width: 0px;
     margin: 0px;
     padding: 2px;
     position: absolute;
     left: 10px;
     top: 100px;
     width: 100px;
     height: 200px;
     visibility: hidden;
   }
   
   .windowListArea 
   {
     background-color: white;
     border-style: none; 
     border-width: 0px;
     text-align: center;
     margin: 0px 0px 0px 0px;
     overflow: auto;
     
   }
  </style>
  <script type="text/javascript">
   /*
    * Copyright (c) SEMIFORE, INC. 2006-2018. All rights reserved.
    *
    * This software and documentation constitute an unpublished work and
    * contain valuable trade secrets and proprietary information belonging
    * to Semifore, Inc.  None of the foregoing material may be copied,
    * duplicated or disclosed without the express written permission of
    * Semifore, Inc.
    * SEMIFORE, INC. EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING
    * THIS SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF
    * MERCHANTABILITY AND/OR FITNESS FOR ANY PARTICULAR PURPOSE,
    * AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY THAT
    * MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
    * TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT
    * TO THE USE OF THE SOFTWARE OR DOCUMENTATION.
    * Under no circumstances shall Semifore, Inc. be liable for incidental,
    * special, indirect, direct or consequential damages or loss of profits,
    * interruption of business, or related expenses which may arise from use
    * of this software or documentation, including but not limited to those
    * resulting from defects in software and/or documentation, or loss or
    * inaccuracy of data of any kind.
   */
   
   /*
    * csrJava.js
    *
    * $Revision: 1.75 $
    * $Date: 2018/02/22 02:35:02 $
    *
    * @(#)$Id: csrJava.js,v 1.75 2018/02/22 02:35:02 weber Exp $
    *
    * These are the Java Script functions for the HTML pages.
    *
   */
   
   var xmlDoc                   = 0;
   var debug                    = 0;
   var def_lookup_table         = new Array();
   var object_array             = new Array();
   var topDefinition_array      = new Array();
   var topObjectRefNames_array  = new Array();
   var definitions_array        = new Array();
   var csrNode_array            = new Array();
   var globalShowFileInfo       = false;
   var globalShowHeaderFileInfo = false;
   var globalShowEnumInfo       = false;
   var fileInfoDiv              = null;
   
   function csrNode() {
     this.referenceType = 0;
     this.referenceName = 0;
     this.definitionPtr = 0;
     this.objectIndex   = 0;
     this.divParent     = 0;
     this.divChild      = 0;
     this.visibility    = 0;
     this.addressMapWindow = 0;
     
     this.click = function() {
       if ( this.visibility == 0 )
       {
         //      alert('open ' + this.referenceName);
         printDefinition(this);
         this.visibility = 1;
         
         // window.location.hash = this.referenceName + 'Link';
         // if (mouseposy > 700 ) scrollBy(0,100);
       } else
       {
         //      alert('close' +  this.referenceName);
         this.divParent.removeChild(this.divChild);
         this.visibility = 0;
   
         //window.location.hash = this.referenceName + 'Link';
         
       }
     }
   
     this.expand = function() {
       if ( this.visibility == 0 )
       this.click();
     }
   
     this.collapse = function() {
       if (this.visibility == 1 )
       this.click();
     }
   
     this.showFileInfo = function () {
        return globalShowFileInfo;
     }
   
     this.showHeaderFileInfo = function () {
        return globalShowHeaderFileInfo;
     }
   
     this.showEnumInfo = function () {
        return globalShowEnumInfo;
     }
   }
   
   //debug alrets
   function alertd( msg ) 
   {
     if (debug) 
       alert(msg);
   }
   
   var mouseposx = 0;
   var mouseposy = 0;
   
   function getMousePos(e) {
     
   	if (!e) var e = window.event;
   	
   	if (e.pageX || e.pageY) 	{
   		mouseposx = e.pageX;
   		mouseposy = e.pageY;
   	}
   	else if (e.clientX || e.clientY) 	{
   		mouseposx = e.clientX + document.body.scrollLeft
   			+ document.documentElement.scrollLeft;
   		mouseposy = e.clientY + document.body.scrollTop
   			+ document.documentElement.scrollTop;
   	}
   }
   
   function redrawAll ()
   {
      var topObject;
   
      for (var i=0; i < topObjectRefNames_array.length; i++) {
         topObject = csrNodeLookup(i,topObjectRefNames_array[i]);
         if (topObject != null) {
            topObject.click();
            topObject.click();
         }
      }
   }
   
   function globalFileInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalFileInfoCheckBox');
   
      if (checkbox != null) {
         globalShowFileInfo = checkbox.checked;
   
         if (globalShowFileInfo) {
            printFileInfo();
         }
         else {
            var docinfo = document.getElementById('docinfo');
            if ((docinfo != null) && (fileInfoDiv != null)) {
               docinfo.removeChild(fileInfoDiv);
            }
         }
         redrawAll();
      }
   }
   
   function globalHeaderFileInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalHeaderFileInfoCheckBox');
   
      if (checkbox != null) {
         globalShowHeaderFileInfo = checkbox.checked;
         redrawAll();
      }
   }
   
   function globalEnumInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalEnumInfoCheckBox');
   
      if (checkbox != null) {
         globalShowEnumInfo = checkbox.checked;
         redrawAll();
      }
   }
   
   //import XML
   function importXML(xmlId)
   {
      xmlDoc = document.getElementById(xmlId);
      if (xmlDoc) {
         init();
      }
   }
   
   
   //parser helpers
   function getNodes_tag(node, tag)
   {
      return node.getElementsByTagName('csr:' + tag);
   }
   
   function getNodeValue_tag(node, tag)
   {
      var nodelist;
   
      nodelist = node.getElementsByTagName('csr:' + tag);
      if (nodelist.length > 0) {
         if (nodelist[0].firstChild) {
            return nodelist[0].firstChild.nodeValue;
         }
         else {
            return '';
         }
      }
      else {
         return '';
      }
   }
   
   function getNodeValue(node)
   {
     for (var i=0; node[0].childNodes.length; i++ )
       {
         
         if (node[0].childNodes[i].nodeType != 1) continue;
         return node[0].childNodes[i].firstChild.nodeValue
   
       }
   }
   
   function getNodeValue_description(node) 
   {
     var description = getNodes_tag(node,'description');
   
     if (description.length < 1)
       return '';
   
     var ptags = getNodes_tag(description[0],'p');
     var ret_string = '';
     
     for (var i=0; i < ptags.length; i++) {
        if (ptags[i].firstChild) {
           ret_string += '<p>' + ptags[i].firstChild.nodeValue + '</p>';
        }
        else {
           ret_string += '<p></p>';
        }
     }
     
     return ret_string;
   }
   
   function getNodeValue_attributes(node)
   {
      var attributesTag = getNodes_tag(node,'attributes');
   
      if (attributesTag.length < 1)
         return '';
      var attributeTags = getNodes_tag(attributesTag[0],'attribute');
      var result = '';
      var i;
   
      for (i=0; i < attributeTags.length; i++) {
         if (attributeTags[i].firstChild) {
            result += attributeTags[i].firstChild.nodeValue + '<br>';
         }
      }
   
      return result;
   }
   
   function getNodeValue_fieldAttributes(node)
   {
      var attributesTag = getNodes_tag(node,'fieldAttributes');
   
      if (attributesTag.length < 1)
         return '';
      var attributeTags = getNodes_tag(attributesTag[0],'attribute');
      var result = '';
      var i;
   
      for (i=0; i < attributeTags.length; i++) {
         if (attributeTags[i].firstChild) {
            result += attributeTags[i].firstChild.nodeValue + '<br>';
         }
      }
   
      return result;
   }
   
   function init() 
   {
     setGlobals();
   
     if (globalShowFileInfo) {
        printFileInfo();
     }
     
     printTopObjects();
     
   }
   
   function printHeader() 
   {
     header = document.getElementById('docheader');
     //header.innerHTML = "Header Text Goes Here";
   }
   
   
   function printFooter() 
   {
     footer = document.getElementById('docfooter');
     //footer.innerHTML = "Footer Text Goes Here";
   }
   
   
   function setGlobals() 
   {
     var checkbox;
   
     alertd(xmlDoc);
   
     checkbox = document.getElementById('globalFileInfoCheckBox');
     if (checkbox != null) {
        globalShowFileInfo = checkbox.checked;
     }
     checkbox = document.getElementById('globalHeaderFileInfoCheckBox');
     if (checkbox != null) {
        globalShowHeaderFileInfo = checkbox.checked;
     }
     checkbox = document.getElementById('globalEnumInfoCheckBox');
     if (checkbox != null) {
        globalShowEnumInfo = checkbox.checked;
     }
   
     // get the object elements
     object_array = getNodes_tag(xmlDoc,'csrObject');
     alertd('number of object_array elements=' + object_array.length);
   
     // create 2D lookup table array
     for (var i=0; i < object_array.length; i++)
       {
         def_lookup_table[i] = new Object();
         csrNode_array[i] = new Object();
       }
   
     // get the top definition elements
     for (var i=0; i < object_array.length; i++ )
       {
         topDefinition_array[i] = getNodes_tag(object_array[i],'topDefinition'); 
       }
     alertd('number of topDefinition_array elements=' + topDefinition_array.length);
   
     // get the referenece names of the top level modules
     for (var i=0; i < topDefinition_array.length; i++)
       {
         topObjectRefNames_array[i] = getNodeValue(topDefinition_array[i]);
         alertd('topObjectRefNames_array[' + i + ']=' + topObjectRefNames_array[i]);
       }
     
      
     // get definition elements
     for (var i=0; i < object_array.length; i++) 
       {
         definitions_array[i] = getNodes_tag(object_array[i],'definition');
       }
     alertd('number of definitions_array element=' + definitions_array.length);
     //alertd('definitions_array[0] =' + definitions_array[0].length + ' elements');
   
     // populate the definitions lookup table
     for ( var i=0; i < object_array.length; i++) 
       {
         for (var j=0; j < definitions_array[i].length; j++)
   	{
   	  referenceName = getNodeValue_tag(definitions_array[i][j], "referenceName");
   	  referenceType = getNodeValue_tag(definitions_array[i][j], "referenceType");
   	  def_lookup_table[i][referenceName] = definitions_array[i][j];
   	  
   	  var csrNode_obj = new csrNode();
   
   	  csrNode_obj.referenceName = referenceName;
   	  csrNode_obj.referenceType = referenceType;
   	  csrNode_obj.definitionPtr = definitions_array[i][j];
   	  csrNode_obj.objectIndex   = i;
   	  
   	  csrNode_array[i][referenceName] = csrNode_obj;
   	}
       
       }
   }
   
   
   function printFileInfo()
   {
      var docinfo = document.getElementById('docinfo');
   
      if (docinfo != null) {
         var inputFilesNodes = getNodes_tag(xmlDoc,'inputFiles');
         var includedFilesNodes = getNodes_tag(xmlDoc,'includedFiles');
         var configurationFilesNodes = getNodes_tag(xmlDoc,'configurationFiles');
         var fileNodes;
         var filename;
         var fileversionNodes;
         var table;
         var body;
         var row;
         var cell;
   
         fileInfoDiv = document.createElement('DIV');
   
         if (inputFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Input Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(inputFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         if (includedFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Included Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(includedFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         if (configurationFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Configuration Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(configurationFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         docinfo.appendChild(fileInfoDiv);
      }
   }
   
   function printTopObjects()
   {
     var csrNode;
     //print top level modules
     for ( var i=0; i < topObjectRefNames_array.length; i++)
       {
         csrNode = csrNodeLookup(i,topObjectRefNames_array[i]);
         if (csrNode.referenceType == 'component') {
            printTopComponentTable(csrNode);
         }
         else {
            printTopAddressmapTable(csrNode);
         }
         csrNode.expand();
       }
   }
   
   function csrNodeLookup(objectIndex, referenceName)
   {
      return csrNode_array[objectIndex][referenceName];
   }
   
   function printDefinition(csrNode)
   {
     
     referenceType = csrNode.referenceType;
   
     //case  
     switch (referenceType) 
       {
       case "component":
         printComponentDefinition(csrNode);
         break;
       case "addressmap":
         printAddressmapDefinition(csrNode);
         break;
       case "group":
         printGroupDefinition(csrNode);
         break;
       case "union":
         printUnionDefinition(csrNode);
         break;
       case "register":
         printRegisterDefinition(csrNode);
         break;
       case "wideregister":
         printWideRegisterDefinition(csrNode);
         break;
       case "memory":
         printMemoryDefinition(csrNode);
         break;
       case "widememory":
         printWideMemoryDefinition(csrNode);
         break;
       default:
         alertd('No default referenceType!');
       }
   }
   
   function printLeafDefinition(csrNode) 
   {
     referenceName_array = csrNode.referenceName.split(".");
   
     //print the def top down
     var parent_ref = '';
     for( var i = 0; i < referenceName_array.length; i++ )
       {
         var refName    = parent_ref + referenceName_array[i];
         var csrNode = csrNodeLookup(csrNode.objectIndex, refName);
         //if ( csrNodeObj.visibility == 0 )
         csrNode.expand();
         parent_ref = refName + '.';
       }
   
     //jump the window the the leaf link
     window.location.hash = '#' + csrNode.referenceName + 'Link';
   
     //move the address map so it remains onscreen
     var parent_ref = '';
     for( var i = 0; i < referenceName_array.length; i++ )
       {
         var refName    = parent_ref + referenceName_array[i];
         var csrNode = csrNodeLookup(csrNode.objectIndex, refName);
         //if ( csrNodeObj.visibility == 0 )
         if (csrNode.addressMapWindow) {
            csrNode.addressMapWindow.window.style.top =
               document.body.scrollTop + 25; 
         }
         parent_ref = refName + '.';
       }
   
   
     //highlight the div
     //highLightDiv(csrNode.referenceName);
     unhighLightDiv(csrNode.referenceName);
   
   }
   
   
   function printTopComponentTable(csrNode)
   {
   
     var xmlNode = csrNode.definitionPtr;
     //div to enclose module
     var moduleDiv     = document.createElement('DIV');
     var referenceName = csrNode.referenceName;
     var referenceType = csrNode.referenceType;
     var identifier    = getNodeValue_tag(xmlNode,"identifier");
   
     //set the div ID to the referenceName
     moduleDiv.id      = referenceName;
   
     csrNode.divParent = moduleDiv;
   
   
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
     var row = document.createElement('TR');
   
     var container     = document.createElement('TH');
     var theData       = document.createElement("div");
     theData.innerHTML = referenceType; 
     container.appendChild(theData);
     container.className = referenceType;
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'Link';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'ExpandAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'ExpandAllLink" onclick="expandAllNodes(' + csrNode.objectIndex + ');">' + 'expand all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   	
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'CollapseAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'CollapseAllLink" onclick="collapseAllNodes(' + csrNode.objectIndex + ');">' + 'collapse all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     tmp.appendChild(row);
   
     //add elements to DOM
     moduleDiv.appendChild(tableEl);
     document.getElementById('docroot').appendChild(moduleDiv);
   }
   
   
   function printTopAddressmapTable(csrNode)
   {
   
     var xmlNode = csrNode.definitionPtr;
     //div to enclose module
     var moduleDiv     = document.createElement('DIV');
     var referenceName = csrNode.referenceName;
     var referenceType = csrNode.referenceType;
     var identifier    = getNodeValue_tag(xmlNode,"identifier");
   
     //set the div ID to the referenceName
     moduleDiv.id      = referenceName;
   
     csrNode.divParent = moduleDiv;
   
   
     var tableEl = document.createElement('TABLE');
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
     var row = document.createElement('TR');
   
     var container     = document.createElement('TH');
     var theData       = document.createElement("div");
     theData.innerHTML = referenceType; 
     container.appendChild(theData);
     container.className = csrNode.referenceType;
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'Link';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'AddrMapLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'AddrMapLink" onclick="printAddressMap(' + csrNode.objectIndex + ',\'' + referenceName + '\');">' + 'address map' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
     
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'ExpandAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'ExpandAllLink" onclick="expandAllNodes(' + csrNode.objectIndex + ');">' + 'expand all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   	
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'CollapseAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'CollapseAllLink" onclick="collapseAllNodes(' + csrNode.objectIndex + ');">' + 'collapse all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     tmp.appendChild(row);
   
     //add elements to DOM
     moduleDiv.appendChild(tableEl);
     document.getElementById('docroot').appendChild(moduleDiv);
   }
   
   
   function printComponentDefinition(csrNode) 
   {
     var xmlNode = csrNode.definitionPtr;
     var componentDefContentDiv = document.createElement('DIV');
     componentDefContentDiv.style.marginLeft = "25px";
     componentDefContentDiv.id = csrNode.divParent.id+ 'DefContentDiv';
   
     csrNode.divChild = componentDefContentDiv;
   
     var identifier          = getNodeValue_tag(xmlNode,"identifier");
     var title               = getNodeValue_tag(xmlNode,"title");
     var description         = getNodeValue_description(xmlNode);
     var filename            = getNodeValue_tag(xmlNode,"filename");
     var linenumber          = getNodeValue_tag(xmlNode,"linenumber");
     var attributes          = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        if (filename != '') {
           tableData_array['Filename'] = filename;
        }
        if (linenumber != '') {
           tableData_array['Linenumber'] = linenumber;
        }
     }
     printRefInfoTable( tableData_array, componentDefContentDiv, csrNode);
     
     csrNode.divParent.appendChild( componentDefContentDiv );
   
     printComponentReference_links( csrNode );
   
   }
   
   function printAddressmapDefinition(csrNode) 
   {
     var xmlNode = csrNode.definitionPtr;
     var moduleDefContentDiv = document.createElement('DIV');
     moduleDefContentDiv.style.marginLeft = "25px";
     //moduleDefContentDiv.id = domParentNode.id + 'DefContentDiv';
     moduleDefContentDiv.id = csrNode.divParent.id+ 'DefContentDiv';
   
     csrNode.divChild = moduleDefContentDiv;
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var addressmapReference =
                           getNodeValue_tag(xmlNode,"addressmapReference");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (addressmapReference != '') {
        tableData_array['Reference']  = addressmapReference;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        if (filename != '') {
           tableData_array['Filename'] = filename;
        }
        if (linenumber != '') {
           tableData_array['Linenumber'] = linenumber;
        }
     }
     if (csrNode.showHeaderFileInfo()) {
        if (addressMacro != '') {
           tableData_array['Address Macro'] = addressMacro;
        }
        if (offsetMacro != '') {
           tableData_array['Offset Macro'] = offsetMacro;
        }
        if (typeName != '') {
           tableData_array['Type Name'] = typeName;
        }
     }
   
     printRefInfoTable( tableData_array, moduleDefContentDiv, csrNode);
     
     csrNode.divParent.appendChild( moduleDefContentDiv );
   
     printReference_links( csrNode );
   
   }
   
   
   function printReference_links(csrNode) {
   
    
     var objectIndex = csrNode.objectIndex;
     xmlNode         = csrNode.definitionPtr;
   
     var references = getNodes_tag(xmlNode,'reference');
   
     for (var i=0; i < references.length; i++ )
       {
         
         var referenceType = getNodeValue_tag(references[i],"referenceType");
         var referenceName = getNodeValue_tag(references[i],"referenceName");
   
         referencedCsrNode = csrNodeLookup(objectIndex, referenceName);
         var identifier    =
             getNodeValue_tag(referencedCsrNode.definitionPtr,"identifier");
   
         var referenceDiv  = document.createElement('DIV');
         referenceDiv.id = referenceName;
         var tableData_array = new Array();
   
         tableData_array[referenceType] = '<a id="' + referenceName + 'Link" name="'+ referenceName + 'Link" ' + 'href="javascript:void(0);" onclick="csrNodeLookup(' + objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
   
         //set parent of referenced node
         referencedCsrNode.divParent = referenceDiv;
   
         printRefInfoTable( tableData_array, referenceDiv, referencedCsrNode);
   
         csrNode.divChild.appendChild(referenceDiv);
     
         if ( referencedCsrNode.visibility == 1 )
   	printDefinition(referencedCsrNode);
       }
   }
   
   
   function printComponentReference_links(csrNode) {
   
    
     var objectIndex = csrNode.objectIndex;
     xmlNode         = csrNode.definitionPtr;
     var table;
     var body;
     var row;
     var cell;
     var theData;
     var theLink;
   
     var references = getNodes_tag(xmlNode,'reference');
   
     for (var i=0; i < references.length; i++ )
       {
         
         var referenceType = getNodeValue_tag(references[i],"referenceType");
         var referenceName = getNodeValue_tag(references[i],"referenceName");
   
         referencedCsrNode = csrNodeLookup(objectIndex, referenceName);
         var identifier    =
             getNodeValue_tag(referencedCsrNode.definitionPtr,"identifier");
   
         var referenceDiv  = document.createElement('DIV');
         referenceDiv.id = referenceName;
         var tableData_array = new Array();
   
         table = document.createElement('TABLE');
         body = document.createElement('TBODY');
         row = document.createElement('TR');
   
         cell              = document.createElement('TH');
         theData           = document.createElement("div");
         theData.innerHTML = referenceType; 
         cell.appendChild(theData);
         cell.className = referenceType;
         row.appendChild(cell);
   
         cell              = document.createElement('TD');
         theLink           = document.createElement("div");
         theLink.id        = referenceName + 'Link';
         theLink.innerHTML = '<a id="' + referenceName + 'Link" href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
         cell.appendChild(theLink) 
         row.appendChild(cell);
   
         cell              = document.createElement('TD');
         theLink           = document.createElement("div");
         theLink.id        = referenceName + 'AddrMapLink';
         theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'AddrMapLink" onclick="printAddressMap(' + csrNode.objectIndex + ',\'' + referenceName + '\');">' + 'address map' + '</a>';
         cell.appendChild(theLink) 
         row.appendChild(cell);
   
         body.appendChild(row);
         table.appendChild(body);
         referenceDiv.appendChild(table);
   
         //set parent of referenced node
         referencedCsrNode.divParent = referenceDiv;
   
         csrNode.divChild.appendChild(referenceDiv);
     
         if ( referencedCsrNode.visibility == 1 )
   	printDefinition(referencedCsrNode);
       }
   }
   
   function printGroupDefinition(csrNode)
   {
   
     var groupReferenceName        = csrNode.referenceName;
     var groupParentDiv            = document.getElementById(groupReferenceName);
     
     csrNode.divParent = groupParentDiv;
     var xmlNode = csrNode.definitionPtr;
   
     var groupDiv                  = document.createElement('DIV');
     groupDiv.id               = groupParentDiv.id + "child";
     groupDiv.style.marginLeft = "25px";
     
     csrNode.divChild = groupDiv;
   
     groupParentDiv.appendChild(groupDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayMax        = getNodeValue_tag(xmlNode,"arrayMax");
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']   = filename;
        tableData_array['Linenumber'] = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, groupDiv, csrNode);
   
   
     printReference_links(csrNode);
   
   }
   
   function printUnionDefinition(csrNode)
   {
   
     var unionReferenceName        = csrNode.referenceName;
     var unionParentDiv            = document.getElementById(unionReferenceName);
     
     csrNode.divParent = unionParentDiv;
     var xmlNode = csrNode.definitionPtr;
   
     var unionDiv                  = document.createElement('DIV');
     unionDiv.id               = unionParentDiv.id + "child";
     unionDiv.style.marginLeft = "25px";
     
     csrNode.divChild = unionDiv;
   
     unionParentDiv.appendChild(unionDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayMax        = getNodeValue_tag(xmlNode,"arrayMax");
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
       tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']   = filename;
        tableData_array['Linenumber'] = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, unionDiv, csrNode);
   
     printReference_links(csrNode);
   
   }
   
   function printRegisterDefinition(csrNode) 
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var aliasOf         = getNodeValue_tag(xmlNode,"aliasOf");
     var aliases         = getNodes_tag(xmlNode,'aliases');
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"registerResetValue");
     var resetMask       = getNodeValue_tag(xmlNode,"registerResetMask");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var isVolatile      = getNodeValue_tag(xmlNode,"volatile");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (aliasOf != '') {
        tableData_array['Alias Of'] = '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasOf + '\'));">' + aliasOf + '</a>';
     }
     if (aliases.length > 0) {
        var aliasList = getNodes_tag(aliases[0],'alias');
        var aliasesString = '';
        var aliasValue;
        if (aliasList[0].firstChild) {
              aliasValue = aliasList[0].firstChild.nodeValue;
              aliasesString += '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasValue + '\'));">' + aliasValue + '</a>';
        }
        for ( var i=1; i < aliasList.length; i++ ) {
           if (aliasList[i].firstChild) {
              aliasValue = aliasList[i].firstChild.nodeValue;
              aliasesString += '<br>';
              aliasesString += '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasValue + '\'));">' + aliasValue + '</a>';
           }
        }
        tableData_array['Aliases'] = aliasesString;
     }
     if (isVolatile != '') {
        tableData_array['Volatile'] = ((isVolatile == 'true') ? '1': '0');
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if ((resetValue != '') && (resetMask != '')) {
        tableData_array['Reset Mask'] = resetMask;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printCsrBitFields( csrNode );
   
   }
   
   function printCsrBitFields( csrNode )
   {
     var xmlNode = csrNode.definitionPtr;
    
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
     var fieldsHaveClockDomains =
        (getNodeValue_tag(xmlNode, "clockDomains") == 'true');
     var fieldsHaveSynchronizer =
        (getNodeValue_tag(xmlNode, "synchronizers") == 'true');
     var fieldsHaveAttributes =
        (getNodeValue_tag(xmlNode, "fieldsHaveAttributes") == 'true');
     var headers;
   
   //Header Row
     headers = ['Identifier', 'Title', 'Bit', 'Access', 'Reset'];
     if (fieldsHaveClockDomains) {
        headers.push('Clock Domain');
     }
     if (fieldsHaveSynchronizer) {
        headers.push('Synchronizer');
     }
     if (fieldsHaveAttributes) {
        headers.push('Attributes');
     }
     headers.push('Description');
   
     var row           = document.createElement('TR');
     for ( var i=0; i<headers.length; i++ ) 
       {
        
         var container     = document.createElement('TH');
         var theData       = document.createElement('DIV');
         theData.innerHTML = headers[i];
         container.className = csrNode.referenceType;
         container.appendChild(theData);
         row.appendChild(container);
       }
     tmp.appendChild(row);
   
     var bitfields = getNodes_tag(xmlNode,'bitfield');
   
     
   
     for ( var i=0; i < bitfields.length; i++ )
       {
         var identifier  = getNodeValue_tag(bitfields[i],"identifier");
         var title       = getNodeValue_tag(bitfields[i],"title");
         var msb         = getNodeValue_tag(bitfields[i],"msb");
         var lsb         = getNodeValue_tag(bitfields[i],"lsb");
   
         if (msb == lsb) 
   	var bit         = '[' + msb + ']';
         else 
   	var bit         = '[' + msb + ':' + lsb +']';
         
   
         var access      = getNodeValue_tag(bitfields[i],"access");
         var reset       = getNodeValue_tag(bitfields[i],"resetValue");
         var description = getNodeValue_description(bitfields[i]);
         var attributes  = getNodeValue_fieldAttributes(bitfields[i]);
   
         var clockDomain    = getNodeValue_tag(bitfields[i],"clockDomain");
         var synchronizer   = getNodeValue_tag(bitfields[i],"synchronizer");
   
         var widthMacro     = getNodeValue_tag(bitfields[i],"widthMacro");
         var msbMacro       = getNodeValue_tag(bitfields[i],"msbMacro");
         var lsbMacro       = getNodeValue_tag(bitfields[i],"lsbMacro");
         var rangeMacro     = getNodeValue_tag(bitfields[i],"rangeMacro");
         var resetMacro     = getNodeValue_tag(bitfields[i],"resetMacro");
         var getMacro       = getNodeValue_tag(bitfields[i],"getMacro");
         var setMacro       = getNodeValue_tag(bitfields[i],"setMacro");
   
         var filename       = getNodeValue_tag(bitfields[i],"filename");
         var linenumber     = getNodeValue_tag(bitfields[i],"linenumber");
         var enums          = getNodes_tag(bitfields[i], "enumeration");
   
         var row_data;
   
         row_data = [identifier, title, bit, access.toUpperCase(), reset];
         if (fieldsHaveClockDomains) {
            row_data.push(clockDomain);
         }
         if (fieldsHaveSynchronizer) {
            row_data.push(synchronizer);
         }
         if (fieldsHaveAttributes) {
            row_data.push(attributes);
         }
         row_data.push(description);
         row         = document.createElement('TR');
         
         for ( var j=0; j<row_data.length; j++ ) {
            var container     = document.createElement('TD');
            var theData       = document.createElement('DIV');
            theData.innerHTML = row_data[j];
            container.appendChild(theData);
            row.appendChild(container);
         }
         tmp.appendChild(row);
   
         //FIX ME SNPS title check not cool (there for reserved fields)
         if (
            (
               csrNode.showFileInfo() ||
               csrNode.showHeaderFileInfo() ||
               (csrNode.showEnumInfo() && enums && (enums.length > 0))
               ) &&
            (title != "-") &&
            (csrNode.referenceType != 'wideregister')
            ) {
            row         = document.createElement('TR');
            var container     = document.createElement('TD');
            container.colSpan = row_data.length;
            container.style.backgroundColor = "#e7e7e7";
           
            if (csrNode.showFileInfo()) {
              var tableData_array = new Array();
              var theData       = document.createElement('DIV');
              theData.className = "fldiv";
              tableData_array['Filename']   = filename;
              tableData_array['Linenumber'] = linenumber;
              printRefInfoTable(tableData_array, theData, csrNode);
              container.appendChild(theData);
            }
   
            if (csrNode.showHeaderFileInfo()) {
              var tableData_array = new Array();
              var theData       = document.createElement('DIV');
              theData.className = "fldiv";
              tableData_array['Width Macro']   = widthMacro;
              tableData_array['Range Macro']   = rangeMacro;
              tableData_array['Msb Macro']     = msbMacro;
              tableData_array['Lsb Macro']     = lsbMacro;
              tableData_array['Reset Macro']   = resetMacro;
              tableData_array['Set Macro']     = setMacro;
              tableData_array['Get Macro']     = getMacro;
              printRefInfoTable(tableData_array, theData, csrNode);
              container.appendChild(theData);
            }
   
            if (csrNode.showEnumInfo() && enums && (enums.length > 0)) {
              var enumDiv = printFieldEnumTable(csrNode, enums);
              container.appendChild(enumDiv);
            }
   
            row.appendChild(container);
   
            tmp.appendChild(row);
         }
         
   
         
       }
     
     csrNode.divChild.appendChild(tableEl);
     
   }
   
   function printFieldEnumTable( csrNode, enums )
   {
     var enumDiv       = document.createElement('DIV');
     enumDiv.className = "fldiv";
     var table = document.createElement('TABLE');
     var body = document.createElement('TBODY');
   
     var titles = (getNodeValue_tag(enums[0], "titles") == 'true');
     var descriptions = (getNodeValue_tag(enums[0], "descriptions") == 'true');
     var hasPartialAccess =
        (getNodeValue_tag(enums[0], "enumeratorsHavePartialAccess") == 'true');
   
     var headerCells = [];
     if (titles) {
        headerCells.push('Title');
     }
     headerCells.push('Identifier');
     headerCells.push('Value');
     if (hasPartialAccess) {
        headerCells.push('Access')
     }
     if (descriptions) {
        headerCells.push('Description')
     }
   
     var headerRow = document.createElement('TR');
     for ( var i=0; i < headerCells.length; i++ ) {
       var container     = document.createElement('TH');
       var theData       = document.createElement('DIV');
       theData.innerHTML = headerCells[i];
       container.appendChild(theData);
       container.className = csrNode.referenceType;
       container.className = 'field';
       headerRow.appendChild(container);
     }
     body.appendChild(headerRow);
   
     var enumerators = getNodes_tag(enums[0], "enumerator");
     for (var e=0; e < enumerators.length; e++) {
       var row = document.createElement('TR');
       var identifier = getNodeValue_tag(enumerators[e], "identifier");
       var value = getNodeValue_tag(enumerators[e], "value");
       var title;
       var description;
       var access;
       var cells = [];
       if (titles) {
         title = getNodeValue_tag(enumerators[e], "title");
         cells.push(title);
       }
       cells.push(identifier);
       cells.push(value);
       if (hasPartialAccess) {
         access = getNodeValue_tag(enumerators[e], "enumeratorAccess");
         cells.push(access);
       }
       if (descriptions) {
         description = getNodeValue_tag(enumerators[e], "description");
         cells.push(description);
       }
         
       for ( var i=0; i < cells.length; i++ ) {
         var container     = document.createElement('TD');
         var theData       = document.createElement('DIV');
         theData.innerHTML = cells[i];
         container.appendChild(theData);
         row.appendChild(container);
       }
       body.appendChild(row);
     }
   
     table.appendChild(body);
     enumDiv.appendChild(table);
     return enumDiv;
   }
   
   function printWideRegisterDefinition( csrNode )
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"resetValue");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var isVolatile      = getNodeValue_tag(xmlNode,"volatile");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier'] = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions']     = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (isVolatile != '') {
        tableData_array['Volatile'] = ((isVolatile == 'true') ? "1": "0");
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printCsrBitFields( csrNode );
   
     printReference_links( csrNode );
     
   
   }
   
   function printMemoryDefinition(csrNode) 
   {
     var memoryReferenceName = csrNode.referenceName;
     var memoryParentDiv     = document.getElementById(memoryReferenceName);
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = memoryParentDiv;
   
     var memoryDiv              = document.createElement('DIV');
   
     memoryDiv.id               = memoryParentDiv.id + "child";
     memoryDiv.style.marginLeft = "25px";
     csrNode.divChild = memoryDiv;
     memoryParentDiv.appendChild(memoryDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"resetValue");
     var resetMask       = getNodeValue_tag(xmlNode,"resetMask");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var memoryWidth     = getNodeValue_tag(xmlNode,"memoryWidth");
     var memoryWordCount = getNodeValue_tag(xmlNode,"memoryWordCount");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (memoryWidth != '') {
        tableData_array['Width'] = memoryWidth;
     }
     if (memoryWordCount != '') {
        tableData_array['Word Count'] = memoryWordCount;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if ((resetValue != '') && (resetMask != '')) {
        tableData_array['Reset Mask'] = resetMask;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, memoryDiv, csrNode);
   
     printReference_links(csrNode);
   }
   
   function printWideMemoryDefinition( csrNode )
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var memoryWidth     = getNodeValue_tag(xmlNode,"memoryWidth");
     var memoryWordCount = getNodeValue_tag(xmlNode,"memoryWordCount");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier'] = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions']     = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (memoryWidth != '') {
        tableData_array['Width'] = memoryWidth;
     }
     if (memoryWordCount != '') {
        tableData_array['Word Count'] = memoryWordCount;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printReference_links( csrNode );
   
   }
   
   
   function printRefInfoTable( refArray, domParentNode, csrNode ) 
   {
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
   
     for ( var type in refArray )
       {
         var row = document.createElement('TR');
         
         //headings
         var container = document.createElement('TH');
         //     var theData   = document.createTextNode(node);
         var theData = document.createElement('DIV');
         theData.innerHTML = type;
   
         container.className = csrNode.referenceType;
   
         container.appendChild(theData);
         row.appendChild(container);
         
         //values
         container     = document.createElement('TD');
         container.className = "noborder";
         //      theData       = document.createTextNode(refArray[type]);
         var theData = document.createElement('DIV');
         theData.innerHTML = refArray[type];
   
         container.appendChild(theData);
         row.appendChild(container);
         
         tmp.appendChild(row);
       }
     
     domParentNode.appendChild(tableEl);
   }
   
   function printAddressMap(objectIndex, referenceName)
   {
     var csrNode;
    
     csrNode = csrNodeLookup(objectIndex, referenceName);
   
     //if window is already open, close it
     if (csrNode.addressMapWindow) {
       if (csrNode.addressMapWindow.opened)
         return;
       else csrNode.addressMapWindow.open()
     }
   
     csrNode.addressMapWindow = new Window( document.body.clientWidth - 625, 25, 600, 400, 'AddrMap' + objectIndex );
   
     var addrMapDiv       = document.createElement('DIV');
     addrMapDiv.id        = 'AddrMap' + objectIndex;
     addrMapDiv.style.marginLeft = "10px";
     addrMapDiv.style.marginRight = "10px";
     addrMapDiv.style.marginTop = "10px";
     addrMapDiv.style.marginBottom = "10px";
   
     
     csrNode.addressMapWindow.changeTitle( 'Address Map for ' + referenceName );
   
     addressMapEntries = getNodes_tag(csrNode.definitionPtr,'addressMapEntry');
   
     alertd('addressMapEntries=' + addressMapEntries.length);
   
     var tableEl = document.createElement('TABLE');
     tableEl.width = "550px";
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
     var headers = ['Address', 'Instance Name'];
   
      var row           = document.createElement('TR');
     for ( var i=0; i<headers.length; i++ ) 
       {
         var container        = document.createElement('TH');
         var theData          = document.createElement('DIV');
         theData.innerHTML    = headers[i];
         container.appendChild(theData);
         row.appendChild(container);
       }
     tmp.appendChild(row);
   
   
     for ( var i=0; i < addressMapEntries.length; i++)
       {
         var print = false;
         var referenceName = getNodeValue_tag(addressMapEntries[i],"referenceName");
         var instanceName  = getNodeValue_tag(addressMapEntries[i],"instanceName");
         var referencedObj = csrNodeLookup(objectIndex, referenceName);
   
   
         var addressLow    = getNodeValue_tag(addressMapEntries[i],"addressLow");
         var addressHigh   = getNodeValue_tag(addressMapEntries[i],"addressHigh");
         
         if (addressLow == addressHigh) 
   	var addressRange = addressHigh;
         else
   	var addressRange = addressLow + ' - ' + addressHigh;
         
         if ( referencedObj ) 
   	{
   	  if (
                (referencedObj.referenceType == "register") ||
                (referencedObj.referenceType == "wideregister") ||
                (referencedObj.referenceType == "memory") ||
                (referencedObj.referenceType == "widememory")
             )
   	    {
   	      print = true;
   	      referenceName = '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + objectIndex + ',\'' + referenceName + '\'));">' + instanceName + '</a>';
   	    }
   	}
         else if ( referenceName == '' )
   	{
   	print = true;
   	referenceName = 'reserved';
   	}
   
         if ( print ) 
   	{
   	  var row_data = [ addressRange, referenceName];
   	  row          = document.createElement('TR');
   	  
   	  for ( var j=0; j<row_data.length; j++ ) 
   	    {
   	      var container     = document.createElement('TD');
   	      var theData       = document.createElement('DIV');
   	      theData.innerHTML = row_data[j];
   	      container.appendChild(theData);
   	      row.appendChild(container);
   	    }
   	  tmp.appendChild(row);
   	}
       }
   
     addrMapDiv.appendChild(tableEl);
   
     csrNode.addressMapWindow.appendDomEl(addrMapDiv);
     csrNode.addressMapWindow.open();
   }
   
   
   //expand nodes
   function expandAllNodes( objectIndex )
   {
     for ( var obj in csrNode_array[objectIndex] )
       {  
         var csrNodeObj = csrNodeLookup(objectIndex,obj);
         csrNodeObj.expand();
       }
   }
   
   function collapseAllNodes( objectIndex )
   {
      for ( var obj in csrNode_array[objectIndex] )
       {  
         var csrNodeObj = csrNodeLookup(objectIndex,obj);
         csrNodeObj.collapse();
       }
   }
   
   // Graphics Functions
   
   function highLightDiv( id )
   {
     fade(0xe7, 0xe7, 0xe7, 0xff, 0xff, 0x33, 100, id);  
   }
   
   function unhighLightDiv( id )
   {
     fade(0xff, 0xff, 0x33, 0xe7, 0xe7, 0xe7, 100, id);
   }
   
   function makearray(n)
   {
     this.length = n;
     for(var i = 1; i <= n; i++)
       this[i] = 0;
     return this;
   }
   
   hexa = new makearray(16);
   
   for(var i = 0; i < 10; i++) 
        hexa[i] = i;
   hexa[10]="a"; hexa[11]="b"; hexa[12]="c";
   hexa[13]="d"; hexa[14]="e"; hexa[15]="f";
   
   function hex(i)
   {
     if (i < 0) return "00";
     else if (i >255) return "ff";
     else return "" + hexa[Math.floor(i/16)] + hexa[i%16];
   }
   
   var fade_timer = 100;
   function setbgColor(r, g, b, id)
   {
     var hr = hex(r); var hg = hex(g); var hb = hex(b);
     document.getElementById(id).style.backgroundColor = "#"+hr+hg+hb;
     var timeOutString = 'document.getElementById("' + id + '").style.backgroundColor=' +  '"#'+hr+hg+hb +'"';
     fade_timer = fade_timer + 25;
     setTimeout(timeOutString, fade_timer);
   
   }
   
   function fade(sr, sg, sb, er, eg, eb, step, id)
   {
     fade_timer = 100;
     for(var i = 0; i <= step; i++){
       setbgColor(Math.floor(sr * ((step-i)/step) + er * (i/step)),Math.floor(sg * ((step-i)/step) + eg * (i/step)),Math.floor(sb * ((step-i)/step) + eb * (i/step)),id);
     }
   }
   
   // Browser Detect
   
   // Determine browser and version.
   
   function Browser() 
   {
   
     var ua, s, i;
   
     this.isIE    = false;
     this.isNS    = false;
     this.version = null;
   
     ua = navigator.userAgent;
   
     s = "MSIE";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isIE = true;
       this.version = parseFloat(ua.substr(i + s.length));
       return;
     }
   
     s = "Netscape6/";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isNS = true;
       this.version = parseFloat(ua.substr(i + s.length));
       return;
     }
   
     // Treat any other "Gecko" browser as NS 6.1.
   
     s = "Gecko";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isNS = true;
       this.version = 6.1;
       return;
     }
   }
   
   var browser = new Browser();
   
   //DHTML Windows Below
   
   var myWindow = new Object();
   var globalWindowZIndex = 500;
   
   // Window Class
   function Window(x,y,w,h,dom_id) 
   {
     
     // CLASS TAG ELEMENT VARAIBLES
     this.window             = 0;
     this.title              = 0;
     this.titleBar           = 0;
     this.titleBarText       = 0;
     this.titleBarButtons    = 0;
     this.clientArea         = 0;
     this.titleBarMap        = 0;
     this.left               = x;
     this.top                = y;
     this.width              = w;
     this.height             = h;
     this.opened             = false; 
     this.dom_id             = dom_id;
   
     if (browser.isNS) 
       {
         this.ca_width       = this.width - 2;
         this.ca_height      = this.height - 40;
       }
     if (browser.isIE) 
       {
         this.ca_width       = this.width - 2;
         this.ca_height      = this.height - 40;
     }
     this.inMoveDrag   = false;
   
     // CLASS METHOD FUNCTIONS
     this.create        = windowCreate;
     this.init          = windowInit;
     this.open          = windowOpen;
     this.makeActive    = windowMakeActive;
     this.insertHTML    = windowInsertHTML; 
     this.appendHTML    = windowAppendHTML;
     this.appendDomEl   = windowAppendDomEl;
     this.close         = windowClose;
     this.windowColor   = windowChangeColor;
   
     this.changeTitle = function(title) {
       this.title.innerHTML = title;
     }
   
     this.wallpaper = function(img) {
        this.windowArea.style.backgroundImage    = img;
        this.windowArea.style.backgroundPosition = "center";
        this.windowArea.style.backgroundRepeat   = "no-repeat";
     }
   
     this.create();
     this.init();
   }
   
   //
   // Create WINDOW DOM object Tree
   //
   // body
   //  |
   //  | -- div ( window )
   //        |
   //        | -- div ( titlebar )
   //              |
   //              | -- span ( title )
   //              |
   //        | -- div ( text window area )
   //
   
   function windowCreate() 
   {
     // Find the main Body Tag.  Only one should exist in page 
     var bodyEl = document.getElementsByTagName("body");
   
     //WINDOW DIV
     var windowEl          = document.createElement("div");
     windowEl.className    = "window";
     windowEl.style.left   = this.left + "px";
     windowEl.style.top    = this.top + "px";
     windowEl.style.width  = this.width + "px"; 
     windowEl.style.height = this.height + "px";
     windowEl.id           = "window" + this.dom_id;
     windowEl.parent       = this;
   
   
     //TOP TITLE DIV
   
     var titleBarEl         = document.createElement("div");
     //  titleBarEl.className   = "windowTitleBar";
     titleBarEl.id          = "titleBar"; 
     titleBarEl.onmousedown = windowMove;
     titleBarEl.parent      = this;
   
     // Put the title into a table
   
     var tableTitleEl       = document.createElement("table");
     tableTitleEl.width     = "100%";
     var tbodyTitleEl       = document.createElement("tbody");
     var trTitleEl          = document.createElement("tr");
     var tdTitlePinIconEl   = document.createElement("td");
     tdTitlePinIconEl.width = "10%";
     tdTitlePinIconEl.algin = "right";
     tdTitlePinIconEl.className = "windowTitleBar";
     var tdTitleTitleEl     = document.createElement("td");
     tdTitleTitleEl.width   = "90%";
     tdTitleTitleEl.algin   = "right";
     tdTitleTitleEl.className = "windowTitleBar";
     tdTitleTitleEl.innerHTML   = 'WINDOW TITLE';
     tdTitleTitleEl.parent      = this;
     tdTitleTitleEl.onmouseover = windowMoveCursorSet;
     tdTitleTitleEl.onmouseout  = windowDefaultCursorSet;
     
     this.title  = tdTitleTitleEl;
     
     // CLOSE DIV
     var closeLink       = document.createElement("a");
     closeLink.setAttribute('href', 'javascript:void(0);');
     closeLink.onclick    = this.close;
     closeLink.parent    = this;
     var linkText = document.createTextNode('close');
     closeLink.appendChild(linkText);
     closeLink.style.color = "white";
   
   
     // Window List Area
     var windowAreaEl = document.createElement("div");
     windowAreaEl.className    = "windowListArea";
     
     windowAreaEl.style.width  = this.ca_width + "px";
     windowAreaEl.style.height = this.ca_height + "px";
     
     // Build DOM
     tdTitlePinIconEl.appendChild(closeLink);
   
     trTitleEl.appendChild(tdTitleTitleEl);
     trTitleEl.appendChild(tdTitlePinIconEl);
     tbodyTitleEl.appendChild(trTitleEl);
     tableTitleEl.appendChild(tbodyTitleEl);
     titleBarEl.appendChild(tableTitleEl);
     
     windowEl.appendChild(titleBarEl);
     
     windowEl.appendChild(windowAreaEl);
     document.body.appendChild(windowEl);
     
     this.window           = windowEl;
     this.windowArea       = windowAreaEl; 
     this.title            = tdTitleTitleEl;
   
   }
   
   function windowInit() 
   {
   
   }
   
   function windowChangeColor(color) 
   {
     this.window.style.backgroundColor = color;
     this.windowArea.style.backgroundColor = color;
   }
   
   function windowInsertHTML(html) 
   {
     this.windowArea.innerHTML = html;
   }
   
   function windowAppendHTML(html) 
   {
     this.windowArea.innerHTML = this.windowArea.innerHTML + html;
   }
   
   function windowAppendDomEl(el)
   {
     this.windowArea.appendChild(el);
   }
   
   function windowOpen() 
   {
     if (this.isOpen)
       return;
   
     this.opened = true;
   
     // Restore the Window and make it visible.
     this.makeActive();
     this.isOpen = true;
     this.window.style.visibility = "visible";
   }
   
   
   function windowMakeActive() 
   {
     if (myWindow == this)
       return;
   
     this.window.style.zIndex = globalWindowZIndex;
     globalWindowZIndex++;
     myWindow = this;
   
   }
   
   //
   // Event handlers.
   //
   
   
   function windowClientAreaClick(event) 
   {
   
     // Make this Window the active one.
   
      myWindow.makeActive();
   }
   
   function windowMove(event) 
   {
     var target;
     var x, y;
   
     if (browser.isIE)
       target = window.event.srcElement.tagName;
     if (browser.isNS)
       target = event.target.tagName;
   
     if (target == "AREA")
       return;
   
     p = this.parent;
     p.makeActive();
     // Get cursor offset from Window window.
   
     if (browser.isIE) {
       x = window.event.x;
       y = window.event.y;
     }
     if (browser.isNS) {
       x = event.pageX;
       y = event.pageY;
     }
     myWindow.xOffset = myWindow.window.offsetLeft - x;
     myWindow.yOffset = myWindow.window.offsetTop  - y;
   
     // Set document to capture mousemove and mouseup events.
   
     if (browser.isIE) {
       document.onmousemove = windowMoveDragStart;
       document.onmouseup   = windowMoveDragStop;
     }
     if (browser.isNS) {
       document.addEventListener("mousemove", windowMoveDragStart,   true);
       document.addEventListener("mouseup",   windowMoveDragStop, true);
       event.preventDefault();
     }
     myWindow.inMoveDrag = true;
     
   }
   
   
   
   function windowClose() 
   {
     this.parent.opened = false;
     document.body.removeChild(this.parent.window);
   }
   
   
   function windowMoveDragStart(event) 
   {
   
     var x, y;
   
     if (!myWindow.inMoveDrag)
       return;
   
     // Get cursor position.
   
     if (browser.isIE) {
       x = window.event.x;
       y = window.event.y;
       window.event.cancelBubble = true;
       window.event.returnValue = false;
     }
     if (browser.isNS) {
       x = event.pageX;
       y = event.pageY;
       event.preventDefault();
     }
   
     // Move Window window based on offset from cursor.
    
     nx = ( x + myWindow.xOffset );
     ny = ( y + myWindow.yOffset );
   
     if ( (nx<0) || (ny<0) ) {
   
     } else {
       myWindow.window.style.left = (x + myWindow.xOffset) + "px";
       myWindow.window.style.top  = (y + myWindow.yOffset) + "px";
     }
   }
   
   
   function windowMoveDragStop(event) 
   {
     myWindow.inMoveDrag = false;
   
     // Remove mousemove and mouseup event captures on document.
   
     if (browser.isIE) {
       document.onmousemove = null;
       document.onmouseup   = null;
     }
     if (browser.isNS) {
       document.removeEventListener("mousemove", windowMoveDragStart,   true);
       document.removeEventListener("mouseup",   windowMoveDragStop, true);
     }
   }
   
   
   function windowMoveCursorSet(event) 
   {
      this.style.cursor = "move";
   }
   
   function windowDefaultCursorSet(event) 
   {
      this.style.cursor = "move";
   }
   
   // End of Java Script
  </script>
  <noscript>
   <div class="noscript">
    <h2>JavaScript required</h2>
    <p>csrCompiler HTML pages require JavaScript.</p>
    <p>Your web browser does not support JavaScript or it has been disabled.</p>
   <div>
  </noscript>
 </head>
 <body onload="importXML('xmlData')">
  <xml id="xmlData" style="display:none;">
   <?xml version="1.0" encoding="UTF-8" ?>
   <csr:csrData
    xmlns:csr="http://www.semifore.com/schema/csrXmlHtml"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.semifore.com/schema/csrXmlHtml http://www.semifore.com/schema/csrXmlHtml.xsd"
    >
    <csr:fileInfo>
     <csr:inputFiles>
      <csr:file>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
      </csr:file>
     </csr:inputFiles>
     <csr:configurationFiles>
       <csr:file>
       <csr:filename>/project/jenkins/workspace/Esperanto_DV/soc_hal/esperanto-soc/dv/common/scripts/semifore_css/etsoc_esr.css</csr:filename>
      </csr:file>
     </csr:configurationFiles>
    </csr:fileInfo>
    <csr:csrObject>
     <csr:topDefinition>
      <csr:referenceName>i2c</csr:referenceName>
     </csr:topDefinition>
     <csr:definitions>
      <csr:definition>
       <csr:referenceType>addressmap</csr:referenceType>
       <csr:referenceName>i2c</csr:referenceName>
       <csr:identifier>i2c</csr:identifier>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>4845</csr:linenumber>
       <csr:title></csr:title>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>I2c</csr:typeName>
        <csr:description>
         <csr:p>DW_apb_i2c memory map</csr:p>
        </csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CON</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_TAR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SAR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_DATA_CMD</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SS_SCL_HCNT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SS_SCL_LCNT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_FS_SCL_HCNT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_FS_SCL_LCNT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_INTR_STAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_INTR_MASK</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_RAW_INTR_STAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_RX_TL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_TX_TL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_INTR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_RX_UNDER</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_RX_OVER</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_TX_OVER</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_RD_REQ</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_TX_ABRT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_RX_DONE</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_ACTIVITY</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_STOP_DET</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_START_DET</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_GEN_CALL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_ENABLE</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_STATUS</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_TXFLR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_RXFLR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SDA_HOLD</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_TX_ABRT_SOURCE</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SDA_SETUP</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_ACK_GENERAL_CALL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_ENABLE_STATUS</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_FS_SPKLEN</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SCL_STUCK_AT_LOW_TIMEOUT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SDA_STUCK_AT_LOW_TIMEOUT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_SCL_STUCK_DET</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SMBUS_CLK_LOW_SEXT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SMBUS_CLK_LOW_MEXT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SMBUS_THIGH_MAX_IDLE_COUNT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SMBUS_INTR_STAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SMBUS_INTR_MASK</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_SMBUS_RAW_INTR_STAT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_CLR_SMBUS_INTR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.REG_TIMEOUT_RST</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_COMP_PARAM_1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_COMP_VERSION</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i2c.IC_COMP_TYPE</csr:referenceName>
        </csr:reference>
       </csr:references>
       <csr:addressMap>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0xFF</csr:addressHigh>
         <csr:instanceName>i2c</csr:instanceName>
         <csr:referenceName>i2c</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0x0</csr:addressHigh>
         <csr:instanceName>i2c.IC_CON</csr:instanceName>
         <csr:referenceName>i2c.IC_CON</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4</csr:addressLow>
         <csr:addressHigh>0x4</csr:addressHigh>
         <csr:instanceName>i2c.IC_TAR</csr:instanceName>
         <csr:referenceName>i2c.IC_TAR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x8</csr:addressLow>
         <csr:addressHigh>0x8</csr:addressHigh>
         <csr:instanceName>i2c.IC_SAR</csr:instanceName>
         <csr:referenceName>i2c.IC_SAR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC</csr:addressLow>
         <csr:addressHigh>0xF</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x10</csr:addressLow>
         <csr:addressHigh>0x10</csr:addressHigh>
         <csr:instanceName>i2c.IC_DATA_CMD</csr:instanceName>
         <csr:referenceName>i2c.IC_DATA_CMD</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x14</csr:addressLow>
         <csr:addressHigh>0x14</csr:addressHigh>
         <csr:instanceName>i2c.IC_SS_SCL_HCNT</csr:instanceName>
         <csr:referenceName>i2c.IC_SS_SCL_HCNT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x18</csr:addressLow>
         <csr:addressHigh>0x18</csr:addressHigh>
         <csr:instanceName>i2c.IC_SS_SCL_LCNT</csr:instanceName>
         <csr:referenceName>i2c.IC_SS_SCL_LCNT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1C</csr:addressLow>
         <csr:addressHigh>0x1C</csr:addressHigh>
         <csr:instanceName>i2c.IC_FS_SCL_HCNT</csr:instanceName>
         <csr:referenceName>i2c.IC_FS_SCL_HCNT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x20</csr:addressLow>
         <csr:addressHigh>0x20</csr:addressHigh>
         <csr:instanceName>i2c.IC_FS_SCL_LCNT</csr:instanceName>
         <csr:referenceName>i2c.IC_FS_SCL_LCNT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x24</csr:addressLow>
         <csr:addressHigh>0x2B</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x2C</csr:addressLow>
         <csr:addressHigh>0x2C</csr:addressHigh>
         <csr:instanceName>i2c.IC_INTR_STAT</csr:instanceName>
         <csr:referenceName>i2c.IC_INTR_STAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x30</csr:addressLow>
         <csr:addressHigh>0x30</csr:addressHigh>
         <csr:instanceName>i2c.IC_INTR_MASK</csr:instanceName>
         <csr:referenceName>i2c.IC_INTR_MASK</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x34</csr:addressLow>
         <csr:addressHigh>0x34</csr:addressHigh>
         <csr:instanceName>i2c.IC_RAW_INTR_STAT</csr:instanceName>
         <csr:referenceName>i2c.IC_RAW_INTR_STAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x38</csr:addressLow>
         <csr:addressHigh>0x38</csr:addressHigh>
         <csr:instanceName>i2c.IC_RX_TL</csr:instanceName>
         <csr:referenceName>i2c.IC_RX_TL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x3C</csr:addressLow>
         <csr:addressHigh>0x3C</csr:addressHigh>
         <csr:instanceName>i2c.IC_TX_TL</csr:instanceName>
         <csr:referenceName>i2c.IC_TX_TL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x40</csr:addressLow>
         <csr:addressHigh>0x40</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_INTR</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_INTR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x44</csr:addressLow>
         <csr:addressHigh>0x44</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_RX_UNDER</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_RX_UNDER</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x48</csr:addressLow>
         <csr:addressHigh>0x48</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_RX_OVER</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_RX_OVER</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4C</csr:addressLow>
         <csr:addressHigh>0x4C</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_TX_OVER</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_TX_OVER</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x50</csr:addressLow>
         <csr:addressHigh>0x50</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_RD_REQ</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_RD_REQ</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x54</csr:addressLow>
         <csr:addressHigh>0x54</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_TX_ABRT</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_TX_ABRT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x58</csr:addressLow>
         <csr:addressHigh>0x58</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_RX_DONE</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_RX_DONE</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x5C</csr:addressLow>
         <csr:addressHigh>0x5C</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_ACTIVITY</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_ACTIVITY</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x60</csr:addressLow>
         <csr:addressHigh>0x60</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_STOP_DET</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_STOP_DET</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x64</csr:addressLow>
         <csr:addressHigh>0x64</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_START_DET</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_START_DET</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x68</csr:addressLow>
         <csr:addressHigh>0x68</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_GEN_CALL</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_GEN_CALL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x6C</csr:addressLow>
         <csr:addressHigh>0x6C</csr:addressHigh>
         <csr:instanceName>i2c.IC_ENABLE</csr:instanceName>
         <csr:referenceName>i2c.IC_ENABLE</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x70</csr:addressLow>
         <csr:addressHigh>0x70</csr:addressHigh>
         <csr:instanceName>i2c.IC_STATUS</csr:instanceName>
         <csr:referenceName>i2c.IC_STATUS</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x74</csr:addressLow>
         <csr:addressHigh>0x74</csr:addressHigh>
         <csr:instanceName>i2c.IC_TXFLR</csr:instanceName>
         <csr:referenceName>i2c.IC_TXFLR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x78</csr:addressLow>
         <csr:addressHigh>0x78</csr:addressHigh>
         <csr:instanceName>i2c.IC_RXFLR</csr:instanceName>
         <csr:referenceName>i2c.IC_RXFLR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x7C</csr:addressLow>
         <csr:addressHigh>0x7C</csr:addressHigh>
         <csr:instanceName>i2c.IC_SDA_HOLD</csr:instanceName>
         <csr:referenceName>i2c.IC_SDA_HOLD</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x80</csr:addressLow>
         <csr:addressHigh>0x80</csr:addressHigh>
         <csr:instanceName>i2c.IC_TX_ABRT_SOURCE</csr:instanceName>
         <csr:referenceName>i2c.IC_TX_ABRT_SOURCE</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x84</csr:addressLow>
         <csr:addressHigh>0x93</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x94</csr:addressLow>
         <csr:addressHigh>0x94</csr:addressHigh>
         <csr:instanceName>i2c.IC_SDA_SETUP</csr:instanceName>
         <csr:referenceName>i2c.IC_SDA_SETUP</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x98</csr:addressLow>
         <csr:addressHigh>0x98</csr:addressHigh>
         <csr:instanceName>i2c.IC_ACK_GENERAL_CALL</csr:instanceName>
         <csr:referenceName>i2c.IC_ACK_GENERAL_CALL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x9C</csr:addressLow>
         <csr:addressHigh>0x9C</csr:addressHigh>
         <csr:instanceName>i2c.IC_ENABLE_STATUS</csr:instanceName>
         <csr:referenceName>i2c.IC_ENABLE_STATUS</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xA0</csr:addressLow>
         <csr:addressHigh>0xA0</csr:addressHigh>
         <csr:instanceName>i2c.IC_FS_SPKLEN</csr:instanceName>
         <csr:referenceName>i2c.IC_FS_SPKLEN</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xA4</csr:addressLow>
         <csr:addressHigh>0xAB</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xAC</csr:addressLow>
         <csr:addressHigh>0xAC</csr:addressHigh>
         <csr:instanceName>i2c.IC_SCL_STUCK_AT_LOW_TIMEOUT</csr:instanceName>
         <csr:referenceName>i2c.IC_SCL_STUCK_AT_LOW_TIMEOUT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xB0</csr:addressLow>
         <csr:addressHigh>0xB0</csr:addressHigh>
         <csr:instanceName>i2c.IC_SDA_STUCK_AT_LOW_TIMEOUT</csr:instanceName>
         <csr:referenceName>i2c.IC_SDA_STUCK_AT_LOW_TIMEOUT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xB4</csr:addressLow>
         <csr:addressHigh>0xB4</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_SCL_STUCK_DET</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_SCL_STUCK_DET</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xB8</csr:addressLow>
         <csr:addressHigh>0xBB</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xBC</csr:addressLow>
         <csr:addressHigh>0xBC</csr:addressHigh>
         <csr:instanceName>i2c.IC_SMBUS_CLK_LOW_SEXT</csr:instanceName>
         <csr:referenceName>i2c.IC_SMBUS_CLK_LOW_SEXT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC0</csr:addressLow>
         <csr:addressHigh>0xC0</csr:addressHigh>
         <csr:instanceName>i2c.IC_SMBUS_CLK_LOW_MEXT</csr:instanceName>
         <csr:referenceName>i2c.IC_SMBUS_CLK_LOW_MEXT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC4</csr:addressLow>
         <csr:addressHigh>0xC4</csr:addressHigh>
         <csr:instanceName>i2c.IC_SMBUS_THIGH_MAX_IDLE_COUNT</csr:instanceName>
         <csr:referenceName>i2c.IC_SMBUS_THIGH_MAX_IDLE_COUNT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC8</csr:addressLow>
         <csr:addressHigh>0xC8</csr:addressHigh>
         <csr:instanceName>i2c.IC_SMBUS_INTR_STAT</csr:instanceName>
         <csr:referenceName>i2c.IC_SMBUS_INTR_STAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xCC</csr:addressLow>
         <csr:addressHigh>0xCC</csr:addressHigh>
         <csr:instanceName>i2c.IC_SMBUS_INTR_MASK</csr:instanceName>
         <csr:referenceName>i2c.IC_SMBUS_INTR_MASK</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD0</csr:addressLow>
         <csr:addressHigh>0xD0</csr:addressHigh>
         <csr:instanceName>i2c.IC_SMBUS_RAW_INTR_STAT</csr:instanceName>
         <csr:referenceName>i2c.IC_SMBUS_RAW_INTR_STAT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD4</csr:addressLow>
         <csr:addressHigh>0xD4</csr:addressHigh>
         <csr:instanceName>i2c.IC_CLR_SMBUS_INTR</csr:instanceName>
         <csr:referenceName>i2c.IC_CLR_SMBUS_INTR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD8</csr:addressLow>
         <csr:addressHigh>0xEF</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xF0</csr:addressLow>
         <csr:addressHigh>0xF0</csr:addressHigh>
         <csr:instanceName>i2c.REG_TIMEOUT_RST</csr:instanceName>
         <csr:referenceName>i2c.REG_TIMEOUT_RST</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xF4</csr:addressLow>
         <csr:addressHigh>0xF4</csr:addressHigh>
         <csr:instanceName>i2c.IC_COMP_PARAM_1</csr:instanceName>
         <csr:referenceName>i2c.IC_COMP_PARAM_1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xF8</csr:addressLow>
         <csr:addressHigh>0xF8</csr:addressHigh>
         <csr:instanceName>i2c.IC_COMP_VERSION</csr:instanceName>
         <csr:referenceName>i2c.IC_COMP_VERSION</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xFC</csr:addressLow>
         <csr:addressHigh>0xFC</csr:addressHigh>
         <csr:instanceName>i2c.IC_COMP_TYPE</csr:instanceName>
         <csr:referenceName>i2c.IC_COMP_TYPE</csr:referenceName>
        </csr:addressMapEntry>
       </csr:addressMap>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CON</csr:referenceName>
       <csr:identifier>IC_CON</csr:identifier>
       <csr:addressMacro>I2C_IC_CON_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CON_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CON_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CON_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>440</csr:linenumber>
       <csr:title>I2C Control Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000065</csr:registerResetValue>
       <csr:typeName>I2c_IC_CON</csr:typeName>
        <csr:description>
         <csr:p>I2C Control Register.</csr:p>
         <csr:p>This register can be written only when the DW_apb_i2c</csr:p>
         <csr:p>is disabled, which corresponds to the IC_ENABLE[0] register</csr:p>
         <csr:p>being set to 0. Writes at other times have no effect.</csr:p>
         <csr:p></csr:p>
         <csr:p>Read/Write Access: </csr:p>
         <csr:p>  - If configuration parameter I2C_DYNAMIC_TAR_UPDATE=1, bit 4 is read only.</csr:p>
         <csr:p>  - If configuration parameter IC_RX_FULL_HLD_BUS_EN =0, bit 9 is read only.</csr:p>
         <csr:p>  - If configuration parameter IC_STOP_DET_IF_MASTER_ACTIVE =0, bit 10 is read only.</csr:p>
         <csr:p>  - If configuration parameter IC_BUS_CLEAR_FEATURE=0, bit 11 is read only</csr:p>
         <csr:p>  - If configuration parameter IC_OPTIONAL_SAR=0, bit 16 is read only</csr:p>
         <csr:p>  - If configuration parameter IC_SMBUS=0, bit 17 is read only</csr:p>
         <csr:p>  - If configuration parameter IC_SMBUS_ARP=0, bits 18 and 19 are read only.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>MASTER_MODE</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_MASTER_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_MASTER_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_MASTER_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_MASTER_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_MASTER_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_MASTER_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_MASTER_MODE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_MASTER_MODE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>71</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit controls whether the DW_apb_i2c master is enabled.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>NOTE: Software should ensure that if this bit is written with '1'</csr:p>
         <csr:p>then bit 6 should also be written with a '1'.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master mode is disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master mode is enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SPEED</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_SPEED_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_SPEED_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_SPEED_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_SPEED_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_SPEED_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_SPEED_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_SPEED_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_SPEED_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>119</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>These bits control at which speed the DW_apb_i2c operates; its</csr:p>
         <csr:p>setting is relevant only if one is operating the DW_apb_i2c in</csr:p>
         <csr:p>master mode. Hardware protects against illegal values being</csr:p>
         <csr:p>programmed by software. These bits must be programmed</csr:p>
         <csr:p>appropriately for slave mode also, as it is used to capture</csr:p>
         <csr:p>correct value of spike filter as per the speed mode. </csr:p>
         <csr:p></csr:p>
         <csr:p>This register should be programmed only with a value in the range </csr:p>
         <csr:p>of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of</csr:p>
         <csr:p>IC_MAX_SPEED_MODE.</csr:p>
         <csr:p></csr:p>
         <csr:p>1: standard mode (100 kbit/s)</csr:p>
         <csr:p></csr:p>
         <csr:p>2: fast mode (&lt;=400 kbit/s) or fast mode plus (&lt;=1000Kbit/s)</csr:p>
         <csr:p></csr:p>
         <csr:p>3: high speed mode (3.4 Mbit/s)</csr:p>
         <csr:p></csr:p>
         <csr:p>Note: This field is not applicable  when IC_ULTRA_FAST_MODE=1</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x2</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FAST</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>Fast or Fast Plus mode of operation</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>HIGH</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>High Speed mode of operation</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>STANDARD</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Standard Speed mode of operation</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IC_10BITADDR_SLAVE</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_IC_10BITADDR_SLAVE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_IC_10BITADDR_SLAVE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_IC_10BITADDR_SLAVE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_IC_10BITADDR_SLAVE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_IC_10BITADDR_SLAVE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_IC_10BITADDR_SLAVE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_IC_10BITADDR_SLAVE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_IC_10BITADDR_SLAVE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>146</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses.</csr:p>
         <csr:p> - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared.</csr:p>
         <csr:p> - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ADDR_10BITS</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Slave 10Bit addressing</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ADDR_7BITS</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Slave  7Bit addressing</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IC_10BITADDR_MASTER</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_IC_10BITADDR_MASTER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_IC_10BITADDR_MASTER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_IC_10BITADDR_MASTER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_IC_10BITADDR_MASTER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_IC_10BITADDR_MASTER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_IC_10BITADDR_MASTER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_IC_10BITADDR_MASTER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_IC_10BITADDR_MASTER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>176</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If the I2C_DYNAMIC_TAR_UPDATE configuration parameter is</csr:p>
         <csr:p>set to 'No' (0), this bit is named IC_10BITADDR_MASTER and</csr:p>
         <csr:p>controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit</csr:p>
         <csr:p>addressing mode when acting as a master.</csr:p>
         <csr:p>If I2C_DYNAMIC_TAR_UPDATE is set to 'Yes' (1), the</csr:p>
         <csr:p>function of this bit is handled by bit 12 of IC_TAR register, and</csr:p>
         <csr:p>becomes a read-only copy called</csr:p>
         <csr:p>IC_10BITADDR_MASTER_rd_only.</csr:p>
         <csr:p> - 0: 7-bit addressing</csr:p>
         <csr:p> - 1: 10-bit addressing</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ADDR_10BITS</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master 10Bit addressing mode</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ADDR_7BITS</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master  7Bit addressing mode</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IC_RESTART_EN</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_IC_RESTART_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_IC_RESTART_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_IC_RESTART_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_IC_RESTART_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_IC_RESTART_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_IC_RESTART_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_IC_RESTART_EN_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_IC_RESTART_EN_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>215</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Determines whether RESTART conditions may be sent when</csr:p>
         <csr:p>acting as a master. Some older slaves do not support handling</csr:p>
         <csr:p>RESTART conditions; however, RESTART conditions are used in</csr:p>
         <csr:p>several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from</csr:p>
         <csr:p>performing the following functions:</csr:p>
         <csr:p> - Sending a START BYTE</csr:p>
         <csr:p> - Performing any high-speed mode operation</csr:p>
         <csr:p> - High-speed mode operation</csr:p>
         <csr:p> - Performing direction changes in combined format mode</csr:p>
         <csr:p> - Performing a read operation with a 10-bit address</csr:p>
         <csr:p>By replacing RESTART condition followed by a STOP and a</csr:p>
         <csr:p>subsequent START condition, split operations are broken down</csr:p>
         <csr:p>into multiple DW_apb_i2c transfers. If the above operations are</csr:p>
         <csr:p>performed, it will result in setting bit 6 (TX_ABRT) of the</csr:p>
         <csr:p>IC_RAW_INTR_STAT register.</csr:p>
         <csr:p>.</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master restart disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master restart enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IC_SLAVE_DISABLE</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_IC_SLAVE_DISABLE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_IC_SLAVE_DISABLE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_IC_SLAVE_DISABLE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_IC_SLAVE_DISABLE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_IC_SLAVE_DISABLE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_IC_SLAVE_DISABLE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_IC_SLAVE_DISABLE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_IC_SLAVE_DISABLE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>254</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit controls whether I2C has its slave disabled,</csr:p>
         <csr:p>which means once the presetn signal is applied, then</csr:p>
         <csr:p>this bit takes on the value of the configuration parameter</csr:p>
         <csr:p>IC_SLAVE_DISABLE. You have the choice of having the slave enabled</csr:p>
         <csr:p>or disabled after reset is applied, which means software does not</csr:p>
         <csr:p>have to configure the slave. By default, the slave is always enabled</csr:p>
         <csr:p>(in reset state as well). If you need to disable it after reset, set</csr:p>
         <csr:p>this bit to 1.</csr:p>
         <csr:p></csr:p>
         <csr:p>If this bit is set (slave is disabled), DW_apb_i2c functions only as</csr:p>
         <csr:p>a master and does not perform any action that requires a slave.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>NOTE: Software should ensure that if this bit is written with 0,</csr:p>
         <csr:p>then bit 0 should also be written with a 0.</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>SLAVE_DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Slave mode is disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SLAVE_ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Slave mode is enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>STOP_DET_IFADDRESSED</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_STOP_DET_IFADDRESSED_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_STOP_DET_IFADDRESSED_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_STOP_DET_IFADDRESSED_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_STOP_DET_IFADDRESSED_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_STOP_DET_IFADDRESSED_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_STOP_DET_IFADDRESSED_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_STOP_DET_IFADDRESSED_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_STOP_DET_IFADDRESSED_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>287</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>In slave mode:</csr:p>
         <csr:p> - 1'b1:  issues the STOP_DET interrrupt only when it is addressed.</csr:p>
         <csr:p> - 0'b0:  issues the STOP_DET irrespective of whether it's addressed or not.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>NOTE: During a general call address, this slave does not issue the </csr:p>
         <csr:p>STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if</csr:p>
         <csr:p>the slave responds to the general call address by generating ACK.</csr:p>
         <csr:p>The STOP_DET interrupt is generated only when the transmitted</csr:p>
         <csr:p>address matches the slave address (SAR).</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>slave issues STOP_DET intr always</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>slave issues STOP_DET intr only if addressed</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TX_EMPTY_CTRL</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_TX_EMPTY_CTRL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_TX_EMPTY_CTRL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_TX_EMPTY_CTRL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_TX_EMPTY_CTRL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_TX_EMPTY_CTRL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_TX_EMPTY_CTRL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_TX_EMPTY_CTRL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_TX_EMPTY_CTRL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>308</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit controls the generation </csr:p>
         <csr:p>of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Default behaviour of TX_EMPTY interrupt</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Controlled generation of TX_EMPTY interrupt</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_FIFO_FULL_HLD_CTRL</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_RX_FIFO_FULL_HLD_CTRL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_RX_FIFO_FULL_HLD_CTRL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_RX_FIFO_FULL_HLD_CTRL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_RX_FIFO_FULL_HLD_CTRL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_RX_FIFO_FULL_HLD_CTRL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_RX_FIFO_FULL_HLD_CTRL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_RX_FIFO_FULL_HLD_CTRL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_RX_FIFO_FULL_HLD_CTRL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>331</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit controls whether </csr:p>
         <csr:p>DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH,</csr:p>
         <csr:p>as described in the IC_RX_FULL_HLD_BUS_EN parameter. </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Overflow when RX_FIFO is full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Hold bus when RX_FIFO is full</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>STOP_DET_IF_MASTER_ACTIVE</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_STOP_DET_IF_MASTER_ACTIVE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_STOP_DET_IF_MASTER_ACTIVE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_STOP_DET_IF_MASTER_ACTIVE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_STOP_DET_IF_MASTER_ACTIVE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_STOP_DET_IF_MASTER_ACTIVE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_STOP_DET_IF_MASTER_ACTIVE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_STOP_DET_IF_MASTER_ACTIVE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_STOP_DET_IF_MASTER_ACTIVE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>357</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>In Master mode:</csr:p>
         <csr:p> - 1'b1: issues the STOP_DET interrupt only when master is active.</csr:p>
         <csr:p> - 1'b0: issues the STOP_DET irrespective of whether master is active or not.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master issues the STOP_DET interrupt irrespective of whether master is active or not</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master issues the STOP_DET interrupt only when master is active</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>BUS_CLEAR_FEATURE_CTRL</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_BUS_CLEAR_FEATURE_CTRL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_BUS_CLEAR_FEATURE_CTRL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_BUS_CLEAR_FEATURE_CTRL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_BUS_CLEAR_FEATURE_CTRL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_BUS_CLEAR_FEATURE_CTRL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_BUS_CLEAR_FEATURE_CTRL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_BUS_CLEAR_FEATURE_CTRL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_BUS_CLEAR_FEATURE_CTRL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>379</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>In Master mode:</csr:p>
         <csr:p> - 1'b1: Bus Clear Feature is enabled.</csr:p>
         <csr:p> - 1'b0: Bus Clear Feature is Disabled.</csr:p>
         <csr:p>In Slave mode, this register bit is not applicable.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Bus Clear Feature is disabled.</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Bus Clear Feature ois enabled.</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CON_1</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_RSVD_IC_CON_1_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_RSVD_IC_CON_1_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_RSVD_IC_CON_1_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_RSVD_IC_CON_1_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_RSVD_IC_CON_1_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_RSVD_IC_CON_1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_RSVD_IC_CON_1_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_RSVD_IC_CON_1_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>386</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CON_1 Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_OPTIONAL_SAR_CTRL</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_RSVD_OPTIONAL_SAR_CTRL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_RSVD_OPTIONAL_SAR_CTRL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_RSVD_OPTIONAL_SAR_CTRL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_RSVD_OPTIONAL_SAR_CTRL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_RSVD_OPTIONAL_SAR_CTRL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_RSVD_OPTIONAL_SAR_CTRL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_RSVD_OPTIONAL_SAR_CTRL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_RSVD_OPTIONAL_SAR_CTRL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>393</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>OPTIONAL_SAR_CTRL Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SMBUS_SLAVE_QUICK_EN</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_SMBUS_SLAVE_QUICK_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_SMBUS_SLAVE_QUICK_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_SMBUS_SLAVE_QUICK_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_SMBUS_SLAVE_QUICK_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_SMBUS_SLAVE_QUICK_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_SMBUS_SLAVE_QUICK_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_SMBUS_SLAVE_QUICK_EN_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_SMBUS_SLAVE_QUICK_EN_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>418</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>If this bit is set to 1, DW_apb_i2c slave only receives Quick commands in SMBus Mode.</csr:p>
         <csr:p></csr:p>
         <csr:p>If this bit is set to 0, DW_apb_i2c slave receives all bus protocols but not Quick commands.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is applicable only in slave mode.</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>SMBus SLave is disabled to receive Quick command.</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>SMBus SLave is enabled to receive Quick command.</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SMBUS_ARP_EN</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_RSVD_SMBUS_ARP_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_RSVD_SMBUS_ARP_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_RSVD_SMBUS_ARP_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_RSVD_SMBUS_ARP_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_RSVD_SMBUS_ARP_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_RSVD_SMBUS_ARP_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_RSVD_SMBUS_ARP_EN_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_RSVD_SMBUS_ARP_EN_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>425</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SMBUS_ARP_EN Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>18</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SMBUS_PERSISTENT_SLV_ADDR_EN</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_RSVD_SMBUS_PERSISTENT_SLV_ADDR_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_RSVD_SMBUS_PERSISTENT_SLV_ADDR_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_RSVD_SMBUS_PERSISTENT_SLV_ADDR_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_RSVD_SMBUS_PERSISTENT_SLV_ADDR_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_RSVD_SMBUS_PERSISTENT_SLV_ADDR_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_RSVD_SMBUS_PERSISTENT_SLV_ADDR_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_RSVD_SMBUS_PERSISTENT_SLV_ADDR_EN_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_RSVD_SMBUS_PERSISTENT_SLV_ADDR_EN_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>432</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SMBUS_PERSISTENT_SLV_ADDR_EN Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>19</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CON_2</csr:identifier>
         <csr:widthMacro>I2C_IC_CON_RSVD_IC_CON_2_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CON_RSVD_IC_CON_2_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CON_RSVD_IC_CON_2_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CON_RSVD_IC_CON_2_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CON_RSVD_IC_CON_2_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CON_RSVD_IC_CON_2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CON_RSVD_IC_CON_2_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CON_RSVD_IC_CON_2_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>439</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CON_2 Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_TAR</csr:referenceName>
       <csr:identifier>IC_TAR</csr:identifier>
       <csr:addressMacro>I2C_IC_TAR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_TAR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_TAR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_TAR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>609</csr:linenumber>
       <csr:title>I2C Target Address Register</csr:title>
       <csr:offset>0x4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000055</csr:registerResetValue>
       <csr:typeName>I2c_IC_TAR</csr:typeName>
        <csr:description>
         <csr:p>I2C Target Address Register</csr:p>
         <csr:p></csr:p>
         <csr:p>If the configuration parameter I2C_DYNAMIC_TAR_UPDATE is set to 'No' (0),</csr:p>
         <csr:p>this register is 12 bits wide, and bits 31:12 are reserved. This register</csr:p>
         <csr:p>can be written to only when IC_ENABLE[0] is set to 0.</csr:p>
         <csr:p></csr:p>
         <csr:p>However, if I2C_DYNAMIC_TAR_UPDATE = 1, then the register becomes 13 bits wide.</csr:p>
         <csr:p>In this case, writes to IC_TAR succeed when one of the following conditions are true:</csr:p>
         <csr:p> - DW_apb_i2c is NOT enabled (IC_ENABLE[0] is set to 0); or</csr:p>
         <csr:p> - DW_apb_i2c is enabled (IC_ENABLE[0]=1); AND DW_apb_i2c is NOT engaged in any Master (tx, rx) operation (IC_STATUS[5]=0); AND DW_apb_i2c is enabled to operate in Master mode (IC_CON[0]=1); AND there are NO entries in the TX FIFO (IC_STATUS[2]=1)</csr:p>
         <csr:p>You can change the TAR address dynamically without losing the bus, only if the following conditions are met.</csr:p>
         <csr:p> - DW_apb_i2c is enabled (IC_ENABLE[0]=1); AND IC_EMPTYFIFO_HOLD_MASTER_EN configuration parameter is set to 1; AND DW_apb_i2c is enabled to operate in Master mode (IC_CON[0]=1); AND there are NO entries in the Tx FIFO and the master is in HOLD state (IC_INTR_STAT[13]=1).</csr:p>
         <csr:p> Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the</csr:p>
         <csr:p>    Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0).</csr:p>
         <csr:p>  - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_TAR</csr:identifier>
         <csr:widthMacro>I2C_IC_TAR_IC_TAR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TAR_IC_TAR_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TAR_IC_TAR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TAR_IC_TAR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TAR_IC_TAR_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TAR_IC_TAR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TAR_IC_TAR_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TAR_IC_TAR_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>501</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This is the target address for any master transaction. When</csr:p>
         <csr:p>transmitting a General Call, these bits are ignored. To generate a</csr:p>
         <csr:p>START BYTE, the CPU needs to write only once into these bits.</csr:p>
         <csr:p></csr:p>
         <csr:p>If the IC_TAR and IC_SAR are the same, loopback exists but the</csr:p>
         <csr:p>FIFOs are shared between master and slave, so full loopback is</csr:p>
         <csr:p>not feasible. Only one direction loopback mode is supported</csr:p>
         <csr:p>(simplex), not duplex. A master cannot transmit to itself; it can</csr:p>
         <csr:p>transmit to only a slave.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x055</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>GC_OR_START</csr:identifier>
         <csr:widthMacro>I2C_IC_TAR_GC_OR_START_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TAR_GC_OR_START_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TAR_GC_OR_START_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TAR_GC_OR_START_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TAR_GC_OR_START_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TAR_GC_OR_START_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TAR_GC_OR_START_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TAR_GC_OR_START_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>531</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a</csr:p>
         <csr:p>General Call or START byte command is to be performed by the</csr:p>
         <csr:p>DW_apb_i2c.</csr:p>
         <csr:p> - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared.</csr:p>
         <csr:p> - 1: START BYTE</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>GENERAL_CALL</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>GENERAL_CALL byte transmission</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>START_BYTE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>START byte transmission</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SPECIAL</csr:identifier>
         <csr:widthMacro>I2C_IC_TAR_SPECIAL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TAR_SPECIAL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TAR_SPECIAL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TAR_SPECIAL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TAR_SPECIAL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TAR_SPECIAL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TAR_SPECIAL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TAR_SPECIAL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>557</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit indicates whether software performs a Device-ID or General Call or</csr:p>
         <csr:p>START BYTE command.</csr:p>
         <csr:p> - 0: ignore bit 10 GC_OR_START and use IC_TAR normally</csr:p>
         <csr:p> - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Disables programming of GENERAL_CALL or START_BYTE transmission</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Enables  programming of GENERAL_CALL or START_BYTE transmission</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_10BITADDR_MASTER</csr:identifier>
         <csr:widthMacro>I2C_IC_TAR_RSVD_IC_10BITADDR_MASTER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TAR_RSVD_IC_10BITADDR_MASTER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TAR_RSVD_IC_10BITADDR_MASTER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TAR_RSVD_IC_10BITADDR_MASTER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TAR_RSVD_IC_10BITADDR_MASTER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TAR_RSVD_IC_10BITADDR_MASTER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TAR_RSVD_IC_10BITADDR_MASTER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TAR_RSVD_IC_10BITADDR_MASTER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>564</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_10BITADDR_MASTER Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_DEVICE_ID</csr:identifier>
         <csr:widthMacro>I2C_IC_TAR_RSVD_DEVICE_ID_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TAR_RSVD_DEVICE_ID_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TAR_RSVD_DEVICE_ID_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TAR_RSVD_DEVICE_ID_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TAR_RSVD_DEVICE_ID_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TAR_RSVD_DEVICE_ID_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TAR_RSVD_DEVICE_ID_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TAR_RSVD_DEVICE_ID_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>571</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DEVICE_ID Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_TAR_1</csr:identifier>
         <csr:widthMacro>I2C_IC_TAR_RSVD_IC_TAR_1_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TAR_RSVD_IC_TAR_1_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TAR_RSVD_IC_TAR_1_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TAR_RSVD_IC_TAR_1_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TAR_RSVD_IC_TAR_1_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TAR_RSVD_IC_TAR_1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TAR_RSVD_IC_TAR_1_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TAR_RSVD_IC_TAR_1_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>578</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_TAR_1 Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SMBUS_QUICK_CMD</csr:identifier>
         <csr:widthMacro>I2C_IC_TAR_SMBUS_QUICK_CMD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TAR_SMBUS_QUICK_CMD_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TAR_SMBUS_QUICK_CMD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TAR_SMBUS_QUICK_CMD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TAR_SMBUS_QUICK_CMD_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TAR_SMBUS_QUICK_CMD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TAR_SMBUS_QUICK_CMD_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TAR_SMBUS_QUICK_CMD_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>601</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a Quick command is to be performed by the DW_apb_i2c.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Disables programming of QUICK-CMD transmission</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Enables  programming of QUICK-CMD transmission</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_TAR_2</csr:identifier>
         <csr:widthMacro>I2C_IC_TAR_RSVD_IC_TAR_2_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TAR_RSVD_IC_TAR_2_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TAR_RSVD_IC_TAR_2_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TAR_RSVD_IC_TAR_2_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TAR_RSVD_IC_TAR_2_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TAR_RSVD_IC_TAR_2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TAR_RSVD_IC_TAR_2_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TAR_RSVD_IC_TAR_2_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>608</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_TAR_2 Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SAR</csr:referenceName>
       <csr:identifier>IC_SAR</csr:identifier>
       <csr:addressMacro>I2C_IC_SAR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SAR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SAR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SAR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>650</csr:linenumber>
       <csr:title>I2C Slave Address Register</csr:title>
       <csr:offset>0x8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000055</csr:registerResetValue>
       <csr:typeName>I2c_IC_SAR</csr:typeName>
        <csr:description>
         <csr:p>I2C Slave Address Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_SAR</csr:identifier>
         <csr:widthMacro>I2C_IC_SAR_IC_SAR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SAR_IC_SAR_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SAR_IC_SAR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SAR_IC_SAR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SAR_IC_SAR_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SAR_IC_SAR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SAR_IC_SAR_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SAR_IC_SAR_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>642</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit</csr:p>
         <csr:p>addressing, only IC_SAR[6:0] is used.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register can be written only when the I2C interface is disabled, which</csr:p>
         <csr:p>corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have</csr:p>
         <csr:p>no effect.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note: </csr:p>
         <csr:p>The default values cannot be any of the reserved address locations:</csr:p>
         <csr:p>that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the</csr:p>
         <csr:p>device is not guaranteed if you program the IC_SAR or IC_TAR to</csr:p>
         <csr:p>a reserved value. Refer to Table "I2C/SMBus Definition of Bits in First Byte" for a complete list of these reserved values.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x055</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_SAR</csr:identifier>
         <csr:widthMacro>I2C_IC_SAR_RSVD_IC_SAR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SAR_RSVD_IC_SAR_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SAR_RSVD_IC_SAR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SAR_RSVD_IC_SAR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SAR_RSVD_IC_SAR_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SAR_RSVD_IC_SAR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SAR_RSVD_IC_SAR_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SAR_RSVD_IC_SAR_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>649</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_SAR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_DATA_CMD</csr:referenceName>
       <csr:identifier>IC_DATA_CMD</csr:identifier>
       <csr:addressMacro>I2C_IC_DATA_CMD_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_DATA_CMD_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_DATA_CMD_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_DATA_CMD_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>818</csr:linenumber>
       <csr:title>I2C Rx/Tx Data Buffer and Command Register</csr:title>
       <csr:offset>0x10</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_DATA_CMD</csr:typeName>
        <csr:description>
         <csr:p>I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.</csr:p>
         <csr:p></csr:p>
         <csr:p>The size of the register changes as follows:</csr:p>
         <csr:p></csr:p>
         <csr:p>Write:</csr:p>
         <csr:p> - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1</csr:p>
         <csr:p> - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0</csr:p>
         <csr:p>Read:</csr:p>
         <csr:p> - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1</csr:p>
         <csr:p> - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0</csr:p>
         <csr:p>Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be</csr:p>
         <csr:p>written for every byte that is to be received; otherwise the DW_apb_i2c will stop</csr:p>
         <csr:p>acknowledging.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DAT</csr:identifier>
         <csr:widthMacro>I2C_IC_DATA_CMD_DAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_DATA_CMD_DAT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_DATA_CMD_DAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_DATA_CMD_DAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_DATA_CMD_DAT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_DATA_CMD_DAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_DATA_CMD_DAT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_DATA_CMD_DAT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>688</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This register contains the data to be transmitted or received on the I2C bus.</csr:p>
         <csr:p>If you are writing to this register and want to perform a read,</csr:p>
         <csr:p>bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read</csr:p>
         <csr:p>this register, these bits return the value of data received on the</csr:p>
         <csr:p>DW_apb_i2c interface.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CMD</csr:identifier>
         <csr:widthMacro>I2C_IC_DATA_CMD_CMD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_DATA_CMD_CMD_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_DATA_CMD_CMD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_DATA_CMD_CMD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_DATA_CMD_CMD_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_DATA_CMD_CMD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_DATA_CMD_CMD_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_DATA_CMD_CMD_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>734</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit controls whether a read or a write is performed.</csr:p>
         <csr:p>This bit does not control the direction when the DW_apb_i2c</csr:p>
         <csr:p>acts as a slave. It controls only the direction</csr:p>
         <csr:p>when it acts as a master.</csr:p>
         <csr:p></csr:p>
         <csr:p>When a command is entered in the TX FIFO, this bit distinguishes the write</csr:p>
         <csr:p>and read commands. In slave-receiver mode, this bit is a "don't care"</csr:p>
         <csr:p>because writes to this register are not required. In slave-transmitter mode, a</csr:p>
         <csr:p>"0" indicates that the data in IC_DATA_CMD is to be transmitted.</csr:p>
         <csr:p></csr:p>
         <csr:p>When programming this bit, you should remember the following: attempting</csr:p>
         <csr:p>to perform a read operation after a General Call command has been sent</csr:p>
         <csr:p>results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register),</csr:p>
         <csr:p>unless bit 11 (SPECIAL) in the IC_TAR register has been cleared.</csr:p>
         <csr:p>If a "1" is written to this bit after receiving a RD_REQ interrupt, then a</csr:p>
         <csr:p>TX_ABRT interrupt occurs.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>READ</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master Read  Command</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>WRITE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master Write Command</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>STOP</csr:identifier>
         <csr:widthMacro>I2C_IC_DATA_CMD_STOP_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_DATA_CMD_STOP_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_DATA_CMD_STOP_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_DATA_CMD_STOP_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_DATA_CMD_STOP_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_DATA_CMD_STOP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_DATA_CMD_STOP_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_DATA_CMD_STOP_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>768</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit controls whether a STOP is issued after the byte is sent or received.</csr:p>
         <csr:p>This bit is available only if IC_EMPTYFIFO_HOLD_MASTER_EN is configured to 1.</csr:p>
         <csr:p> - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus.</csr:p>
         <csr:p> - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Donot Issue STOP after this command</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Issue STOP after this command</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RESTART</csr:identifier>
         <csr:widthMacro>I2C_IC_DATA_CMD_RESTART_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_DATA_CMD_RESTART_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_DATA_CMD_RESTART_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_DATA_CMD_RESTART_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_DATA_CMD_RESTART_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_DATA_CMD_RESTART_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_DATA_CMD_RESTART_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_DATA_CMD_RESTART_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>803</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit controls whether a RESTART is issued before the byte is sent or received.</csr:p>
         <csr:p>This bit is available only if IC_EMPTYFIFO_HOLD_MASTER_EN is configured to 1.</csr:p>
         <csr:p></csr:p>
         <csr:p>1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</csr:p>
         <csr:p></csr:p>
         <csr:p>0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Donot Issue RESTART before this command</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Issue RESTART before this command</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_FIRST_DATA_BYTE</csr:identifier>
         <csr:widthMacro>I2C_IC_DATA_CMD_RSVD_FIRST_DATA_BYTE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_DATA_CMD_RSVD_FIRST_DATA_BYTE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_DATA_CMD_RSVD_FIRST_DATA_BYTE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_DATA_CMD_RSVD_FIRST_DATA_BYTE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_DATA_CMD_RSVD_FIRST_DATA_BYTE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_DATA_CMD_RSVD_FIRST_DATA_BYTE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_DATA_CMD_RSVD_FIRST_DATA_BYTE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_DATA_CMD_RSVD_FIRST_DATA_BYTE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>810</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>FIRST_DATA_BYTE Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_DATA_CMD</csr:identifier>
         <csr:widthMacro>I2C_IC_DATA_CMD_RSVD_IC_DATA_CMD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_DATA_CMD_RSVD_IC_DATA_CMD_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_DATA_CMD_RSVD_IC_DATA_CMD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_DATA_CMD_RSVD_IC_DATA_CMD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_DATA_CMD_RSVD_IC_DATA_CMD_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_DATA_CMD_RSVD_IC_DATA_CMD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_DATA_CMD_RSVD_IC_DATA_CMD_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_DATA_CMD_RSVD_IC_DATA_CMD_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>817</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_DATA_CMD Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SS_SCL_HCNT</csr:referenceName>
       <csr:identifier>IC_SS_SCL_HCNT</csr:identifier>
       <csr:addressMacro>I2C_IC_SS_SCL_HCNT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SS_SCL_HCNT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SS_SCL_HCNT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SS_SCL_HCNT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>872</csr:linenumber>
       <csr:title>Standard Speed I2C Clock SCL High Count Register</csr:title>
       <csr:offset>0x14</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000028</csr:registerResetValue>
       <csr:typeName>I2c_IC_SS_SCL_HCNT</csr:typeName>
        <csr:description>
         <csr:p>Standard Speed I2C Clock SCL High Count Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_SS_SCL_HCNT</csr:identifier>
         <csr:widthMacro>I2C_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>864</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This register must be set before any I2C bus transaction can take place to</csr:p>
         <csr:p>ensure proper I/O timing. This register sets the SCL clock high-period</csr:p>
         <csr:p>count for standard speed. For more information, refer to "IC_CLK Frequency Configuration".</csr:p>
         <csr:p>  </csr:p>
         <csr:p>This register can be written only when the I2C interface is disabled which</csr:p>
         <csr:p>corresponds to the IC_ENABLE[0] register being set to 0. Writes at other</csr:p>
         <csr:p>times have no effect.</csr:p>
         <csr:p></csr:p>
         <csr:p>The minimum valid value is 6; hardware prevents values less than this</csr:p>
         <csr:p>being written, and if attempted results in 6 being set. For designs with</csr:p>
         <csr:p>APB_DATA_WIDTH = 8, the order of programming is important to ensure</csr:p>
         <csr:p>the correct operation of the DW_apb_i2c. The lower byte must be</csr:p>
         <csr:p>programmed first. Then the upper byte is programmed.</csr:p>
         <csr:p></csr:p>
         <csr:p>When the configuration parameter IC_HC_COUNT_VALUES is set to 1,</csr:p>
         <csr:p>this register is read only.</csr:p>
         <csr:p></csr:p>
         <csr:p>NOTE: This register must not be programmed to a value higher than</csr:p>
         <csr:p>65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle</csr:p>
         <csr:p>condition when this counter reaches a value of IC_SS_SCL_HCNT + 10.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0028</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_SS_SCL_HIGH_COUNT</csr:identifier>
         <csr:widthMacro>I2C_IC_SS_SCL_HCNT_RSVD_IC_SS_SCL_HIGH_COUNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SS_SCL_HCNT_RSVD_IC_SS_SCL_HIGH_COUNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SS_SCL_HCNT_RSVD_IC_SS_SCL_HIGH_COUNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SS_SCL_HCNT_RSVD_IC_SS_SCL_HIGH_COUNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SS_SCL_HCNT_RSVD_IC_SS_SCL_HIGH_COUNT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SS_SCL_HCNT_RSVD_IC_SS_SCL_HIGH_COUNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SS_SCL_HCNT_RSVD_IC_SS_SCL_HIGH_COUNT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SS_SCL_HCNT_RSVD_IC_SS_SCL_HIGH_COUNT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>871</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_SS_SCL_HCNT Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SS_SCL_LCNT</csr:referenceName>
       <csr:identifier>IC_SS_SCL_LCNT</csr:identifier>
       <csr:addressMacro>I2C_IC_SS_SCL_LCNT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SS_SCL_LCNT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SS_SCL_LCNT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SS_SCL_LCNT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>919</csr:linenumber>
       <csr:title>Standard Speed I2C Clock SCL Low Count Register</csr:title>
       <csr:offset>0x18</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0000002f</csr:registerResetValue>
       <csr:typeName>I2c_IC_SS_SCL_LCNT</csr:typeName>
        <csr:description>
         <csr:p>Standard Speed I2C Clock SCL Low Count Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_SS_SCL_LCNT</csr:identifier>
         <csr:widthMacro>I2C_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>911</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This register must be set before any I2C bus transaction can take place to</csr:p>
         <csr:p>ensure proper I/O timing. This register sets the SCL clock low period</csr:p>
         <csr:p>count for standard speed. For more information, refer to "IC_CLK Frequency Configuration"</csr:p>
         <csr:p></csr:p>
         <csr:p>This register can be written only when the I2C interface is disabled which</csr:p>
         <csr:p>corresponds to the IC_ENABLE[0] register being set to 0. Writes at other</csr:p>
         <csr:p>times have no effect.</csr:p>
         <csr:p></csr:p>
         <csr:p>The minimum valid value is 8; hardware prevents values less than this</csr:p>
         <csr:p>being written, and if attempted, results in 8 being set. For designs with</csr:p>
         <csr:p>APB_DATA_WIDTH = 8, the order of programming is important to</csr:p>
         <csr:p>ensure the correct operation of DW_apb_i2c. The lower byte must be</csr:p>
         <csr:p>programmed first, and then the upper byte is programmed.</csr:p>
         <csr:p></csr:p>
         <csr:p>When the configuration parameter IC_HC_COUNT_VALUES is set to 1,</csr:p>
         <csr:p>this register is read only.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x002f</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_SS_SCL_LOW_COUNT</csr:identifier>
         <csr:widthMacro>I2C_IC_SS_SCL_LCNT_RSVD_IC_SS_SCL_LOW_COUNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SS_SCL_LCNT_RSVD_IC_SS_SCL_LOW_COUNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SS_SCL_LCNT_RSVD_IC_SS_SCL_LOW_COUNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SS_SCL_LCNT_RSVD_IC_SS_SCL_LOW_COUNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SS_SCL_LCNT_RSVD_IC_SS_SCL_LOW_COUNT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SS_SCL_LCNT_RSVD_IC_SS_SCL_LOW_COUNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SS_SCL_LCNT_RSVD_IC_SS_SCL_LOW_COUNT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SS_SCL_LCNT_RSVD_IC_SS_SCL_LOW_COUNT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>918</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RSVD_IC_SS_SCL_LOW_COUNT Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_FS_SCL_HCNT</csr:referenceName>
       <csr:identifier>IC_FS_SCL_HCNT</csr:identifier>
       <csr:addressMacro>I2C_IC_FS_SCL_HCNT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_FS_SCL_HCNT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_FS_SCL_HCNT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_FS_SCL_HCNT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>967</csr:linenumber>
       <csr:title>Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register</csr:title>
       <csr:offset>0x1C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000006</csr:registerResetValue>
       <csr:typeName>I2c_IC_FS_SCL_HCNT</csr:typeName>
        <csr:description>
         <csr:p>Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_FS_SCL_HCNT</csr:identifier>
         <csr:widthMacro>I2C_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>959</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This register must be set before any I2C bus transaction can take place to</csr:p>
         <csr:p>ensure proper I/O timing. This register sets the SCL clock high-period</csr:p>
         <csr:p>count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code</csr:p>
         <csr:p>and START BYTE or General CALL. For more information, refer</csr:p>
         <csr:p>to "IC_CLK Frequency Configuration".</csr:p>
         <csr:p></csr:p>
         <csr:p>This register goes away and becomes read-only returning 0s if</csr:p>
         <csr:p>IC_MAX_SPEED_MODE = standard. </csr:p>
         <csr:p>This register can be written only</csr:p>
         <csr:p>when the I2C interface is disabled, which corresponds to the IC_ENABLE[0]</csr:p>
         <csr:p>register being set to 0. Writes at other times have no effect.</csr:p>
         <csr:p></csr:p>
         <csr:p>The minimum valid value is 6; hardware prevents values less than this</csr:p>
         <csr:p>being written, and if attempted results in 6 being set. For designs with</csr:p>
         <csr:p>APB_DATA_WIDTH == 8 the order of programming is important to</csr:p>
         <csr:p>ensure the correct operation of the DW_apb_i2c. The lower byte must be</csr:p>
         <csr:p>programmed first. Then the upper byte is programmed.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0006</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_FS_SCL_HCNT</csr:identifier>
         <csr:widthMacro>I2C_IC_FS_SCL_HCNT_RSVD_IC_FS_SCL_HCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_FS_SCL_HCNT_RSVD_IC_FS_SCL_HCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_FS_SCL_HCNT_RSVD_IC_FS_SCL_HCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_FS_SCL_HCNT_RSVD_IC_FS_SCL_HCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_FS_SCL_HCNT_RSVD_IC_FS_SCL_HCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_FS_SCL_HCNT_RSVD_IC_FS_SCL_HCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_FS_SCL_HCNT_RSVD_IC_FS_SCL_HCNT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_FS_SCL_HCNT_RSVD_IC_FS_SCL_HCNT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>966</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_FS_SCL_HCNT Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_FS_SCL_LCNT</csr:referenceName>
       <csr:identifier>IC_FS_SCL_LCNT</csr:identifier>
       <csr:addressMacro>I2C_IC_FS_SCL_LCNT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_FS_SCL_LCNT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_FS_SCL_LCNT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_FS_SCL_LCNT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>1021</csr:linenumber>
       <csr:title>Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register</csr:title>
       <csr:offset>0x20</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0000000d</csr:registerResetValue>
       <csr:typeName>I2c_IC_FS_SCL_LCNT</csr:typeName>
        <csr:description>
         <csr:p>Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_FS_SCL_LCNT</csr:identifier>
         <csr:widthMacro>I2C_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1013</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This register must be set before any I2C bus transaction can take place to</csr:p>
         <csr:p>ensure proper I/O timing. This register sets the SCL clock low period count</csr:p>
         <csr:p>for fast speed. It is used in high-speed mode to send the Master Code and</csr:p>
         <csr:p>START BYTE or General CALL. For more information, refer</csr:p>
         <csr:p>to "IC_CLK Frequency Configuration".</csr:p>
         <csr:p></csr:p>
         <csr:p>This register goes away and becomes read-only returning 0s if</csr:p>
         <csr:p>IC_MAX_SPEED_MODE = standard.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register can be written only when the I2C interface is disabled, which</csr:p>
         <csr:p>corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times</csr:p>
         <csr:p>have no effect.</csr:p>
         <csr:p></csr:p>
         <csr:p>The minimum valid value is 8; hardware prevents values less than this</csr:p>
         <csr:p>being written, and if attempted results in 8 being set. For designs with</csr:p>
         <csr:p>APB_DATA_WIDTH = 8 the order of programming is important to ensure</csr:p>
         <csr:p>the correct operation of the DW_apb_i2c. The lower byte must be</csr:p>
         <csr:p>programmed first. Then the upper byte is programmed. If the value is less</csr:p>
         <csr:p>than 8 then the count value gets changed to 8.</csr:p>
         <csr:p></csr:p>
         <csr:p>When the configuration parameter IC_HC_COUNT_VALUES is set to 1,</csr:p>
         <csr:p>this register is read only.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000d</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_FS_SCL_LCNT</csr:identifier>
         <csr:widthMacro>I2C_IC_FS_SCL_LCNT_RSVD_IC_FS_SCL_LCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_FS_SCL_LCNT_RSVD_IC_FS_SCL_LCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_FS_SCL_LCNT_RSVD_IC_FS_SCL_LCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_FS_SCL_LCNT_RSVD_IC_FS_SCL_LCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_FS_SCL_LCNT_RSVD_IC_FS_SCL_LCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_FS_SCL_LCNT_RSVD_IC_FS_SCL_LCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_FS_SCL_LCNT_RSVD_IC_FS_SCL_LCNT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_FS_SCL_LCNT_RSVD_IC_FS_SCL_LCNT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1020</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_FS_SCL_LCNT Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_INTR_STAT</csr:referenceName>
       <csr:identifier>IC_INTR_STAT</csr:identifier>
       <csr:addressMacro>I2C_IC_INTR_STAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_INTR_STAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_INTR_STAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_INTR_STAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>1356</csr:linenumber>
       <csr:title>I2C Interrupt Status Register</csr:title>
       <csr:offset>0x2C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_INTR_STAT</csr:typeName>
        <csr:description>
         <csr:p>I2C Interrupt Status Register</csr:p>
         <csr:p></csr:p>
         <csr:p>Each bit in this register has a corresponding mask bit</csr:p>
         <csr:p>in the IC_INTR_MASK register. These bits are cleared by reading the matching</csr:p>
         <csr:p>interrupt clear register. The unmasked raw versions of these bits are</csr:p>
         <csr:p>available in the IC_RAW_INTR_STAT register.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>R_RX_UNDER</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_RX_UNDER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_RX_UNDER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_RX_UNDER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_RX_UNDER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_RX_UNDER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_RX_UNDER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_RX_UNDER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_RX_UNDER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1055</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RX_UNDER interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RX_UNDER interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_RX_OVER</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_RX_OVER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_RX_OVER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_RX_OVER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_RX_OVER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_RX_OVER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_RX_OVER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_RX_OVER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_RX_OVER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1076</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_RX_OVER interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_RX_OVER interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_RX_FULL</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_RX_FULL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_RX_FULL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_RX_FULL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_RX_FULL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_RX_FULL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_RX_FULL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_RX_FULL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_RX_FULL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1097</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_RX_FULL interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_RX_FULL interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_TX_OVER</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_TX_OVER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_TX_OVER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_TX_OVER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_TX_OVER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_TX_OVER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_TX_OVER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_TX_OVER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_TX_OVER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1118</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_TX_OVER interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_TX_OVER interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_TX_EMPTY</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_TX_EMPTY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_TX_EMPTY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_TX_EMPTY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_TX_EMPTY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_TX_EMPTY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_TX_EMPTY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_TX_EMPTY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_TX_EMPTY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1139</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_TX_EMPTY interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_TX_EMPTY interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_RD_REQ</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_RD_REQ_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_RD_REQ_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_RD_REQ_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_RD_REQ_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_RD_REQ_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_RD_REQ_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_RD_REQ_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_RD_REQ_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1160</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_RD_REQ interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_RD_REQ interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_TX_ABRT</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_TX_ABRT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_TX_ABRT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_TX_ABRT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_TX_ABRT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_TX_ABRT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_TX_ABRT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_TX_ABRT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_TX_ABRT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1181</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_TX_ABRT interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_TX_ABRT interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_RX_DONE</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_RX_DONE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_RX_DONE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_RX_DONE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_RX_DONE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_RX_DONE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_RX_DONE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_RX_DONE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_RX_DONE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1202</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_RX_DONE interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_RX_DONE interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_ACTIVITY</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_ACTIVITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_ACTIVITY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_ACTIVITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_ACTIVITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_ACTIVITY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_ACTIVITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_ACTIVITY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_ACTIVITY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1223</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_ACTIVITY interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_ACTIVITY interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_STOP_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_STOP_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_STOP_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_STOP_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_STOP_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_STOP_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_STOP_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_STOP_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_STOP_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1244</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_STOP_DET interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_STOP_DET interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_START_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_START_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_START_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_START_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_START_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_START_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_START_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_START_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_START_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1265</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_START_DET interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_START_DET interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_GEN_CALL</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_GEN_CALL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_GEN_CALL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_GEN_CALL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_GEN_CALL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_GEN_CALL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_GEN_CALL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_GEN_CALL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_GEN_CALL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1286</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_GEN_CALL interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_GEN_CALL interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_RESTART_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_RESTART_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_RESTART_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_RESTART_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_RESTART_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_RESTART_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_RESTART_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_RESTART_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_RESTART_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1307</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_RESTART_DET interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_RESTART_DET interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_MASTER_ON_HOLD</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_MASTER_ON_HOLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_MASTER_ON_HOLD_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_MASTER_ON_HOLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_MASTER_ON_HOLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_MASTER_ON_HOLD_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_MASTER_ON_HOLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_MASTER_ON_HOLD_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_MASTER_ON_HOLD_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1328</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_MASTER_ON_HOLD bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_MASTER_ON_HOLD interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_MASTER_ON_HOLD interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_SCL_STUCK_AT_LOW</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_R_SCL_STUCK_AT_LOW_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_R_SCL_STUCK_AT_LOW_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_R_SCL_STUCK_AT_LOW_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_R_SCL_STUCK_AT_LOW_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_R_SCL_STUCK_AT_LOW_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_R_SCL_STUCK_AT_LOW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_R_SCL_STUCK_AT_LOW_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_R_SCL_STUCK_AT_LOW_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1349</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_RAW_INTR_STAT for a detailed description of R_SCL_STUCK_AT_LOW bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>14</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>R_SCL_STUCK_AT_LOW interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>R_SCL_STUCK_AT_LOW interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_INTR_STAT</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_STAT_RSVD_IC_INTR_STAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_STAT_RSVD_IC_INTR_STAT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_STAT_RSVD_IC_INTR_STAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_STAT_RSVD_IC_INTR_STAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_STAT_RSVD_IC_INTR_STAT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_STAT_RSVD_IC_INTR_STAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_STAT_RSVD_IC_INTR_STAT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_STAT_RSVD_IC_INTR_STAT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1355</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_INTR_STAT Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_INTR_MASK</csr:referenceName>
       <csr:identifier>IC_INTR_MASK</csr:identifier>
       <csr:addressMacro>I2C_IC_INTR_MASK_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_INTR_MASK_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_INTR_MASK_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_INTR_MASK_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>1676</csr:linenumber>
       <csr:title>I2C Interrupt Mask Register</csr:title>
       <csr:offset>0x30</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x000048ff</csr:registerResetValue>
       <csr:typeName>I2c_IC_INTR_MASK</csr:typeName>
        <csr:description>
         <csr:p>I2C Interrupt Mask Register.</csr:p>
         <csr:p></csr:p>
         <csr:p>These bits mask their corresponding interrupt status bits. This register is active low; </csr:p>
         <csr:p>a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>M_RX_UNDER</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_RX_UNDER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_RX_UNDER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_RX_UNDER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_RX_UNDER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_RX_UNDER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_RX_UNDER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_RX_UNDER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_RX_UNDER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1387</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RX_UNDER interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RX_UNDER interrupt is masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_RX_OVER</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_RX_OVER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_RX_OVER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_RX_OVER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_RX_OVER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_RX_OVER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_RX_OVER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_RX_OVER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_RX_OVER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1407</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RX_OVER interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RX_OVER interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_RX_FULL</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_RX_FULL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_RX_FULL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_RX_FULL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_RX_FULL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_RX_FULL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_RX_FULL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_RX_FULL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_RX_FULL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1427</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RX_FULL interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RX_FULL interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_TX_OVER</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_TX_OVER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_TX_OVER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_TX_OVER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_TX_OVER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_TX_OVER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_TX_OVER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_TX_OVER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_TX_OVER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1447</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>TX_OVER interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>TX_OVER interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_TX_EMPTY</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_TX_EMPTY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_TX_EMPTY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_TX_EMPTY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_TX_EMPTY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_TX_EMPTY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_TX_EMPTY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_TX_EMPTY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_TX_EMPTY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1467</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>TX_EMPTY interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>TX_EMPTY interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_RD_REQ</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_RD_REQ_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_RD_REQ_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_RD_REQ_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_RD_REQ_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_RD_REQ_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_RD_REQ_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_RD_REQ_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_RD_REQ_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1487</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RD_REQ interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RD_REQ interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_TX_ABRT</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_TX_ABRT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_TX_ABRT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_TX_ABRT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_TX_ABRT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_TX_ABRT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_TX_ABRT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_TX_ABRT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_TX_ABRT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1507</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>TX_ABORT interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>TX_ABORT interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_RX_DONE</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_RX_DONE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_RX_DONE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_RX_DONE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_RX_DONE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_RX_DONE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_RX_DONE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_RX_DONE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_RX_DONE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1527</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RX_DONE interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RX_DONE interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_ACTIVITY</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_ACTIVITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_ACTIVITY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_ACTIVITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_ACTIVITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_ACTIVITY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_ACTIVITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_ACTIVITY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_ACTIVITY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1547</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ACTIVITY interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ACTIVITY interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_STOP_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_STOP_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_STOP_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_STOP_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_STOP_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_STOP_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_STOP_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_STOP_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_STOP_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1567</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>STOP_DET interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>STOP_DET interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_START_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_START_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_START_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_START_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_START_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_START_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_START_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_START_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_START_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1587</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_START_DET interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>START_DET interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>START_DET interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_GEN_CALL</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_GEN_CALL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_GEN_CALL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_GEN_CALL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_GEN_CALL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_GEN_CALL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_GEN_CALL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_GEN_CALL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_GEN_CALL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1607</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>GEN_CALL interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>GEN_CALL interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_RESTART_DET_read_only</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_RESTART_DET_READ_ONLY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_RESTART_DET_READ_ONLY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_RESTART_DET_READ_ONLY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_RESTART_DET_READ_ONLY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_RESTART_DET_READ_ONLY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_RESTART_DET_READ_ONLY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_RESTART_DET_READ_ONLY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_RESTART_DET_READ_ONLY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1628</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This M_RESTART_DET_read_only bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RESTART_DET interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RESTART_DET interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_MASTER_ON_HOLD_read_only</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1648</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This M_MASTER_ON_HOLD_read_only bit masks the R_MASTER_ON_HOLD interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>MASTER_ON_HOLD interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>MASTER_ON_HOLD interrupt is   masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_SCL_STUCK_AT_LOW</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_M_SCL_STUCK_AT_LOW_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_M_SCL_STUCK_AT_LOW_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_M_SCL_STUCK_AT_LOW_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_M_SCL_STUCK_AT_LOW_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_M_SCL_STUCK_AT_LOW_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_M_SCL_STUCK_AT_LOW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_M_SCL_STUCK_AT_LOW_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_M_SCL_STUCK_AT_LOW_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1668</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_SCL_STUCK_AT_LOW interrupt in IC_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>14</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>SCL_STUCK_AT_LOW interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>SCL_STUCK_AT_LOW interrupt is masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_INTR_STAT</csr:identifier>
         <csr:widthMacro>I2C_IC_INTR_MASK_RSVD_IC_INTR_STAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_INTR_MASK_RSVD_IC_INTR_STAT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_INTR_MASK_RSVD_IC_INTR_STAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_INTR_MASK_RSVD_IC_INTR_STAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_INTR_MASK_RSVD_IC_INTR_STAT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_INTR_MASK_RSVD_IC_INTR_STAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_INTR_MASK_RSVD_IC_INTR_STAT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_INTR_MASK_RSVD_IC_INTR_STAT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1675</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_INTR_STAT Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_RAW_INTR_STAT</csr:referenceName>
       <csr:identifier>IC_RAW_INTR_STAT</csr:identifier>
       <csr:addressMacro>I2C_IC_RAW_INTR_STAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_RAW_INTR_STAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_RAW_INTR_STAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_RAW_INTR_STAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2139</csr:linenumber>
       <csr:title>I2C Raw Interrupt Status Register</csr:title>
       <csr:offset>0x34</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_RAW_INTR_STAT</csr:typeName>
        <csr:description>
         <csr:p>I2C Raw Interrupt Status Register</csr:p>
         <csr:p></csr:p>
         <csr:p>Unlike the IC_INTR_STAT register, these bits are not masked so they</csr:p>
         <csr:p>always show the true status of the DW_apb_i2c.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RX_UNDER</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_RX_UNDER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_RX_UNDER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_RX_UNDER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_RX_UNDER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_RX_UNDER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_RX_UNDER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_RX_UNDER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_RX_UNDER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1712</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Set if the processor attempts to read the receive buffer when it is empty by</csr:p>
         <csr:p>reading from the IC_DATA_CMD register. If the module is disabled</csr:p>
         <csr:p>(IC_ENABLE[0]=0), this bit keeps its level until the master or slave state</csr:p>
         <csr:p>machines go into idle, and when ic_en goes to 0, this interrupt is cleared.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RX_UNDER interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RX_UNDER interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_OVER</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_RX_OVER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_RX_OVER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_RX_OVER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_RX_OVER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_RX_OVER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_RX_OVER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_RX_OVER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_RX_OVER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1749</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and</csr:p>
         <csr:p>an additional byte is received from an external I2C device. The DW_apb_i2c</csr:p>
         <csr:p>acknowledges this, but any data bytes received after the FIFO is full are lost. If</csr:p>
         <csr:p>the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the</csr:p>
         <csr:p>master or slave state machines go into idle, and when ic_en goes to 0, this</csr:p>
         <csr:p>interrupt is cleared.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note:  If the configuration parameter IC_RX_FULL_HLD_BUS_EN is enabled</csr:p>
         <csr:p>and bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is</csr:p>
         <csr:p>programmed to HIGH, then the RX_OVER interrupt never occurs, because the</csr:p>
         <csr:p>Rx FIFO never overflows.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RX_OVER interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RX_OVER interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_FULL</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_RX_FULL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_RX_FULL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_RX_FULL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_RX_FULL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_RX_FULL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_RX_FULL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_RX_FULL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_RX_FULL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1778</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Set when the receive buffer reaches or goes above the RX_TL threshold in the</csr:p>
         <csr:p>IC_RX_TL register. It is automatically cleared by hardware when buffer level</csr:p>
         <csr:p>goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the</csr:p>
         <csr:p>RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this</csr:p>
         <csr:p>bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of</csr:p>
         <csr:p>the activity that continues.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RX_FULL interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RX_FULL interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TX_OVER</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_TX_OVER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_TX_OVER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_TX_OVER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_TX_OVER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_TX_OVER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_TX_OVER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_TX_OVER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_TX_OVER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1805</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH</csr:p>
         <csr:p>and the processor attempts to issue another I2C command by writing to the</csr:p>
         <csr:p>IC_DATA_CMD register. When the module is disabled, this bit keeps its level</csr:p>
         <csr:p>until the master or slave state machines go into idle, and when ic_en goes to 0,</csr:p>
         <csr:p>this interrupt is cleared.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>TX_OVER interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>TX_OVER interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TX_EMPTY</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_TX_EMPTY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_TX_EMPTY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_TX_EMPTY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_TX_EMPTY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_TX_EMPTY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_TX_EMPTY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_TX_EMPTY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_TX_EMPTY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1845</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The behavior of the TX_EMPTY interrupt status </csr:p>
         <csr:p>differs based on the TX_EMPTY_CTRL selection in the IC_CON register.</csr:p>
         <csr:p> - When TX_EMPTY_CTRL = 0:</csr:p>
         <csr:p>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register.</csr:p>
         <csr:p> - When TX_EMPTY_CTRL = 1:</csr:p>
         <csr:p>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed.</csr:p>
         <csr:p>It is automatically cleared by hardware when the buffer level goes above the</csr:p>
         <csr:p>threshold. When IC_ENABLE[0] is set to 0, the TX FIFO is flushed and held in</csr:p>
         <csr:p>reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1,</csr:p>
         <csr:p>provided there is activity in the master or slave state machines. When there is no</csr:p>
         <csr:p>longer any activity, then with ic_en=0, this bit is set to 0.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>TX_EMPTY interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>TX_EMPTY interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RD_REQ</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_RD_REQ_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_RD_REQ_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_RD_REQ_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_RD_REQ_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_RD_REQ_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_RD_REQ_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_RD_REQ_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_RD_REQ_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1875</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C</csr:p>
         <csr:p>master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds</csr:p>
         <csr:p>the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means</csr:p>
         <csr:p>that the slave has been addressed by a remote master that is asking for data to</csr:p>
         <csr:p>be transferred. The processor must respond to this interrupt and then write the</csr:p>
         <csr:p>requested data to the IC_DATA_CMD register. This bit is set to 0 just after the</csr:p>
         <csr:p>processor reads the IC_CLR_RD_REQ register.</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RD_REQ interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RD_REQ interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TX_ABRT</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_TX_ABRT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_TX_ABRT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_TX_ABRT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_TX_ABRT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_TX_ABRT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_TX_ABRT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_TX_ABRT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_TX_ABRT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1914</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit indicates if DW_apb_i2c, as an I2C transmitter,</csr:p>
         <csr:p>is unable to complete the intended actions on the</csr:p>
         <csr:p>contents of the transmit FIFO. This situation can</csr:p>
         <csr:p>occur both as an I2C master or an I2C slave, and is</csr:p>
         <csr:p>referred to as a 'transmit abort'.</csr:p>
         <csr:p>When this bit is set to 1, the IC_TX_ABRT_SOURCE register</csr:p>
         <csr:p>indicates the reason why the transmit abort takes places.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note:  The DW_apb_i2c flushes/resets/empties only the TX_FIFO whenever</csr:p>
         <csr:p>there is a transmit abort caused by any of the events tracked by the</csr:p>
         <csr:p>IC_TX_ABRT_SOURCE register. The Tx FIFO remains in this flushed state</csr:p>
         <csr:p>until the register IC_CLR_TX_ABRT is read. Once this read is performed, the</csr:p>
         <csr:p>Tx FIFO is then ready to accept more data bytes from the APB interface. RX</csr:p>
         <csr:p>FIFO flush because of TX_ABRT is controlled by the coreConsultant parameter IC_AVOID_RX_FIFO_FLUSH_ON_TX_ABRT.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>TX_ABRT interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>TX_ABRT interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_DONE</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_RX_DONE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_RX_DONE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_RX_DONE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_RX_DONE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_RX_DONE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_RX_DONE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_RX_DONE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_RX_DONE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1937</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>When the DW_apb_i2c is acting as a slave-transmitter,</csr:p>
         <csr:p>this bit is set to 1 if the master does not acknowledge</csr:p>
         <csr:p>a transmitted byte. This occurs on the last byte of</csr:p>
         <csr:p>the transmission, indicating that the transmission is done.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RX_DONE interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RX_DONE interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ACTIVITY</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_ACTIVITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_ACTIVITY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_ACTIVITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_ACTIVITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_ACTIVITY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_ACTIVITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_ACTIVITY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_ACTIVITY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>1966</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit captures DW_apb_i2c activity and stays set until it is cleared. There</csr:p>
         <csr:p>are four ways to clear it:</csr:p>
         <csr:p> - Disabling the DW_apb_i2c</csr:p>
         <csr:p> - Reading the IC_CLR_ACTIVITY register</csr:p>
         <csr:p> - Reading the IC_CLR_INTR register</csr:p>
         <csr:p> - System reset</csr:p>
         <csr:p>Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RAW_INTR_ACTIVITY interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RAW_INTR_ACTIVITY interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>STOP_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_STOP_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_STOP_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_STOP_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_STOP_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_STOP_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_STOP_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_STOP_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_STOP_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2007</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.</csr:p>
         <csr:p></csr:p>
         <csr:p>In Slave Mode:</csr:p>
         <csr:p> - If IC_CON[7]=1'b1  (STOP_DET_IFADDRESSED), the STOP_DET interrupt will be issued only if slave is addressed.</csr:p>
         <csr:p>Note: During a general call address, this slave does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).</csr:p>
         <csr:p> - If IC_CON[7]=1'b0 (STOP_DET_IFADDRESSED), the STOP_DET interrupt is issued irrespective of whether it is being addressed.</csr:p>
         <csr:p>In Master Mode:</csr:p>
         <csr:p> - If IC_CON[10]=1'b1  (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will be issued only if Master is active.</csr:p>
         <csr:p> - If IC_CON[10]=1'b0  (STOP_DET_IFADDRESSED),the STOP_DET interrupt will be issued irrespective of whether master is active or not.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>STOP_DET interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>STOP_DET interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>START_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_START_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_START_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_START_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_START_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_START_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_START_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_START_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_START_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2030</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates whether a START or RESTART condition has occurred on the I2C</csr:p>
         <csr:p>interface regardless of whether DW_apb_i2c is operating in slave or master</csr:p>
         <csr:p>mode.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>START_DET interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>START_DET interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>GEN_CALL</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_GEN_CALL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_GEN_CALL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_GEN_CALL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_GEN_CALL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_GEN_CALL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_GEN_CALL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_GEN_CALL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_GEN_CALL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2055</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Set only when a General Call address is received and it is acknowledged. It</csr:p>
         <csr:p>stays set until it is cleared either by disabling DW_apb_i2c or when the CPU</csr:p>
         <csr:p>reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the</csr:p>
         <csr:p>received data in the Rx buffer.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>GEN_CALL interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>GEN_CALL interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RESTART_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_RESTART_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_RESTART_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_RESTART_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_RESTART_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_RESTART_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_RESTART_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_RESTART_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_RESTART_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2085</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates whether a RESTART condition has occurred on the I2C interface </csr:p>
         <csr:p>when DW_apb_i2c is operating in Slave mode and the slave is being addressed.</csr:p>
         <csr:p> Enabled only when IC_SLV_RESTART_DET_EN=1.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as </csr:p>
         <csr:p>per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c </csr:p>
         <csr:p>does not generate the RESTART_DET interrupt.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>RESTART_DET interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>RESTART_DET interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>MASTER_ON_HOLD</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_MASTER_ON_HOLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_MASTER_ON_HOLD_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_MASTER_ON_HOLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_MASTER_ON_HOLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_MASTER_ON_HOLD_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_MASTER_ON_HOLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_MASTER_ON_HOLD_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_MASTER_ON_HOLD_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2107</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates whether master is holding the bus and TX FIFO is empty.</csr:p>
         <csr:p>Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>MASTER_ON_HOLD interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>MASTER_ON_HOLD interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SCL_STUCK_AT_LOW</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_SCL_STUCK_AT_LOW_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_SCL_STUCK_AT_LOW_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_SCL_STUCK_AT_LOW_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_SCL_STUCK_AT_LOW_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_SCL_STUCK_AT_LOW_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_SCL_STUCK_AT_LOW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_SCL_STUCK_AT_LOW_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_SCL_STUCK_AT_LOW_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2132</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Indicates</csr:p>
         <csr:p>whether the SCL Line is stuck at low for the IC_SCL_STUCK_LOW_TIMEOUT number of ic_clk periods.</csr:p>
         <csr:p></csr:p>
         <csr:p>Enabled only when IC_BUS_CLEAR_FEATURE=1 and IC_ULTRA_FAST_MODE=0.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>14</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>SCL_STUCK_AT_LOW interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>SCL_STUCK_AT_LOW interrupt is inactive.</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_RAW_INTR_STAT</csr:identifier>
         <csr:widthMacro>I2C_IC_RAW_INTR_STAT_RSVD_IC_RAW_INTR_STAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RAW_INTR_STAT_RSVD_IC_RAW_INTR_STAT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RAW_INTR_STAT_RSVD_IC_RAW_INTR_STAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RAW_INTR_STAT_RSVD_IC_RAW_INTR_STAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RAW_INTR_STAT_RSVD_IC_RAW_INTR_STAT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RAW_INTR_STAT_RSVD_IC_RAW_INTR_STAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RAW_INTR_STAT_RSVD_IC_RAW_INTR_STAT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RAW_INTR_STAT_RSVD_IC_RAW_INTR_STAT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2138</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_RAW_INTR_STAT Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_RX_TL</csr:referenceName>
       <csr:identifier>IC_RX_TL</csr:identifier>
       <csr:addressMacro>I2C_IC_RX_TL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_RX_TL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_RX_TL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_RX_TL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2175</csr:linenumber>
       <csr:title>I2C Receive FIFO Threshold Register</csr:title>
       <csr:offset>0x38</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_RX_TL</csr:typeName>
        <csr:description>
         <csr:p>I2C Receive FIFO Threshold Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RX_TL</csr:identifier>
         <csr:widthMacro>I2C_IC_RX_TL_RX_TL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RX_TL_RX_TL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RX_TL_RX_TL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RX_TL_RX_TL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RX_TL_RX_TL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RX_TL_RX_TL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RX_TL_RX_TL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RX_TL_RX_TL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2167</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Threshold Level.</csr:p>
         <csr:p></csr:p>
         <csr:p>Controls the level of entries (or above) that triggers</csr:p>
         <csr:p>the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register).</csr:p>
         <csr:p>The valid range is 0-255, with the additional restriction that</csr:p>
         <csr:p>hardware does not allow this value to be set to a value larger</csr:p>
         <csr:p>than the depth of the buffer. If an attempt is made to do that,</csr:p>
         <csr:p>the actual value set will be the maximum depth of the buffer.</csr:p>
         <csr:p>A value of 0 sets the threshold for 1 entry, and a value of 255</csr:p>
         <csr:p>sets the threshold for 256 entries.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_RX_TL</csr:identifier>
         <csr:widthMacro>I2C_IC_RX_TL_RSVD_IC_RX_TL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RX_TL_RSVD_IC_RX_TL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RX_TL_RSVD_IC_RX_TL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RX_TL_RSVD_IC_RX_TL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RX_TL_RSVD_IC_RX_TL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RX_TL_RSVD_IC_RX_TL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RX_TL_RSVD_IC_RX_TL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RX_TL_RSVD_IC_RX_TL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2174</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_RX_TL Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_TX_TL</csr:referenceName>
       <csr:identifier>IC_TX_TL</csr:identifier>
       <csr:addressMacro>I2C_IC_TX_TL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_TX_TL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_TX_TL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_TX_TL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2210</csr:linenumber>
       <csr:title>I2C Transmit FIFO Threshold Register</csr:title>
       <csr:offset>0x3C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_TX_TL</csr:typeName>
        <csr:description>
         <csr:p>I2C Transmit FIFO Threshold Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TX_TL</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_TL_TX_TL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_TL_TX_TL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_TL_TX_TL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_TL_TX_TL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_TL_TX_TL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_TL_TX_TL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_TL_TX_TL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_TL_TX_TL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2202</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Threshold Level.</csr:p>
         <csr:p></csr:p>
         <csr:p>Controls the level of entries (or below) that trigger</csr:p>
         <csr:p>the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register).</csr:p>
         <csr:p>The valid range is 0-255, with the additional restriction that</csr:p>
         <csr:p>it may not be set to value larger than the depth of the buffer.</csr:p>
         <csr:p>If an attempt is made to do that, the actual value set will be</csr:p>
         <csr:p>the maximum depth of the buffer.</csr:p>
         <csr:p>A value of 0 sets the threshold for 0 entries, and a value of 255</csr:p>
         <csr:p>sets the threshold for 255 entries.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_TX_TL</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_TL_RSVD_IC_TX_TL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_TL_RSVD_IC_TX_TL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_TL_RSVD_IC_TX_TL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_TL_RSVD_IC_TX_TL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_TL_RSVD_IC_TX_TL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_TL_RSVD_IC_TX_TL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_TL_RSVD_IC_TX_TL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_TL_RSVD_IC_TX_TL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2209</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_TX_TL Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_INTR</csr:referenceName>
       <csr:identifier>IC_CLR_INTR</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_INTR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_INTR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_INTR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_INTR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2238</csr:linenumber>
       <csr:title>Clear Combined and Individual Interrupt Register</csr:title>
       <csr:offset>0x40</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_INTR</csr:typeName>
        <csr:description>
         <csr:p>Clear Combined and Individual Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_INTR</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_INTR_CLR_INTR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_INTR_CLR_INTR_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_INTR_CLR_INTR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_INTR_CLR_INTR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_INTR_CLR_INTR_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_INTR_CLR_INTR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_INTR_CLR_INTR_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_INTR_CLR_INTR_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2231</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read this register to clear the combined interrupt,</csr:p>
         <csr:p>all individual interrupts, and the IC_TX_ABRT_SOURCE register.</csr:p>
         <csr:p>This bit does not clear hardware clearable interrupts but software</csr:p>
         <csr:p>clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register</csr:p>
         <csr:p>for an exception to clearing IC_TX_ABRT_SOURCE.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CLR_INTR</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_INTR_RSVD_IC_CLR_INTR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_INTR_RSVD_IC_CLR_INTR_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_INTR_RSVD_IC_CLR_INTR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_INTR_RSVD_IC_CLR_INTR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_INTR_RSVD_IC_CLR_INTR_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_INTR_RSVD_IC_CLR_INTR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_INTR_RSVD_IC_CLR_INTR_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_INTR_RSVD_IC_CLR_INTR_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2237</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CLR_INTR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_RX_UNDER</csr:referenceName>
       <csr:identifier>IC_CLR_RX_UNDER</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_RX_UNDER_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_RX_UNDER_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_RX_UNDER_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_RX_UNDER_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2260</csr:linenumber>
       <csr:title>Clear RX_UNDER Interrupt Register</csr:title>
       <csr:offset>0x44</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_RX_UNDER</csr:typeName>
        <csr:description>
         <csr:p>Clear RX_UNDER Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_RX_UNDER</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_RX_UNDER_CLR_RX_UNDER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_RX_UNDER_CLR_RX_UNDER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_RX_UNDER_CLR_RX_UNDER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_RX_UNDER_CLR_RX_UNDER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_RX_UNDER_CLR_RX_UNDER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_RX_UNDER_CLR_RX_UNDER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_RX_UNDER_CLR_RX_UNDER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_RX_UNDER_CLR_RX_UNDER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2253</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read this register to clear the RX_UNDER</csr:p>
         <csr:p>interrupt (bit 0) of the IC_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CLR_RX_UNDER</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_RX_UNDER_RSVD_IC_CLR_RX_UNDER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_RX_UNDER_RSVD_IC_CLR_RX_UNDER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_RX_UNDER_RSVD_IC_CLR_RX_UNDER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_RX_UNDER_RSVD_IC_CLR_RX_UNDER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_RX_UNDER_RSVD_IC_CLR_RX_UNDER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_RX_UNDER_RSVD_IC_CLR_RX_UNDER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_RX_UNDER_RSVD_IC_CLR_RX_UNDER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_RX_UNDER_RSVD_IC_CLR_RX_UNDER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2259</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CLR_RX_UNDER Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_RX_OVER</csr:referenceName>
       <csr:identifier>IC_CLR_RX_OVER</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_RX_OVER_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_RX_OVER_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_RX_OVER_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_RX_OVER_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2282</csr:linenumber>
       <csr:title>Clear RX_OVER Interrupt Register</csr:title>
       <csr:offset>0x48</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_RX_OVER</csr:typeName>
        <csr:description>
         <csr:p>Clear RX_OVER Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_RX_OVER</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_RX_OVER_CLR_RX_OVER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_RX_OVER_CLR_RX_OVER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_RX_OVER_CLR_RX_OVER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_RX_OVER_CLR_RX_OVER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_RX_OVER_CLR_RX_OVER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_RX_OVER_CLR_RX_OVER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_RX_OVER_CLR_RX_OVER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_RX_OVER_CLR_RX_OVER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2275</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read this register to clear the RX_OVER</csr:p>
         <csr:p>interrupt (bit 1) of the IC_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CLR_RX_OVER</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_RX_OVER_RSVD_IC_CLR_RX_OVER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_RX_OVER_RSVD_IC_CLR_RX_OVER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_RX_OVER_RSVD_IC_CLR_RX_OVER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_RX_OVER_RSVD_IC_CLR_RX_OVER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_RX_OVER_RSVD_IC_CLR_RX_OVER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_RX_OVER_RSVD_IC_CLR_RX_OVER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_RX_OVER_RSVD_IC_CLR_RX_OVER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_RX_OVER_RSVD_IC_CLR_RX_OVER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2281</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CLR_RX_OVER Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_TX_OVER</csr:referenceName>
       <csr:identifier>IC_CLR_TX_OVER</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_TX_OVER_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_TX_OVER_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_TX_OVER_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_TX_OVER_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2303</csr:linenumber>
       <csr:title>Clear TX_OVER Interrupt Register</csr:title>
       <csr:offset>0x4C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_TX_OVER</csr:typeName>
        <csr:description>
         <csr:p>Clear TX_OVER Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_TX_OVER</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_TX_OVER_CLR_TX_OVER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_TX_OVER_CLR_TX_OVER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_TX_OVER_CLR_TX_OVER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_TX_OVER_CLR_TX_OVER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_TX_OVER_CLR_TX_OVER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_TX_OVER_CLR_TX_OVER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_TX_OVER_CLR_TX_OVER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_TX_OVER_CLR_TX_OVER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2296</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read this register to clear the TX_OVER</csr:p>
         <csr:p>interrupt (bit 3) of the IC_RAW_INTR_STAT register.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CLR_TX_OVER</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_TX_OVER_RSVD_IC_CLR_TX_OVER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_TX_OVER_RSVD_IC_CLR_TX_OVER_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_TX_OVER_RSVD_IC_CLR_TX_OVER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_TX_OVER_RSVD_IC_CLR_TX_OVER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_TX_OVER_RSVD_IC_CLR_TX_OVER_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_TX_OVER_RSVD_IC_CLR_TX_OVER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_TX_OVER_RSVD_IC_CLR_TX_OVER_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_TX_OVER_RSVD_IC_CLR_TX_OVER_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2302</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CLR_TX_OVER Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_RD_REQ</csr:referenceName>
       <csr:identifier>IC_CLR_RD_REQ</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_RD_REQ_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_RD_REQ_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_RD_REQ_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_RD_REQ_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2325</csr:linenumber>
       <csr:title>Clear RD_REQ Interrupt Register</csr:title>
       <csr:offset>0x50</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_RD_REQ</csr:typeName>
        <csr:description>
         <csr:p>Clear RD_REQ Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_RD_REQ</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_RD_REQ_CLR_RD_REQ_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_RD_REQ_CLR_RD_REQ_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_RD_REQ_CLR_RD_REQ_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_RD_REQ_CLR_RD_REQ_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_RD_REQ_CLR_RD_REQ_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_RD_REQ_CLR_RD_REQ_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_RD_REQ_CLR_RD_REQ_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_RD_REQ_CLR_RD_REQ_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2318</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read this register to clear the RD_REQ</csr:p>
         <csr:p>interrupt (bit 5) of the IC_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CLR_RD_REQ</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_RD_REQ_RSVD_IC_CLR_RD_REQ_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_RD_REQ_RSVD_IC_CLR_RD_REQ_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_RD_REQ_RSVD_IC_CLR_RD_REQ_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_RD_REQ_RSVD_IC_CLR_RD_REQ_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_RD_REQ_RSVD_IC_CLR_RD_REQ_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_RD_REQ_RSVD_IC_CLR_RD_REQ_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_RD_REQ_RSVD_IC_CLR_RD_REQ_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_RD_REQ_RSVD_IC_CLR_RD_REQ_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2324</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CLR_RD_REQ Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_TX_ABRT</csr:referenceName>
       <csr:identifier>IC_CLR_TX_ABRT</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_TX_ABRT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_TX_ABRT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_TX_ABRT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_TX_ABRT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2353</csr:linenumber>
       <csr:title>Clear TX_ABRT Interrupt Register</csr:title>
       <csr:offset>0x54</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_TX_ABRT</csr:typeName>
        <csr:description>
         <csr:p>Clear TX_ABRT Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_TX_ABRT</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_TX_ABRT_CLR_TX_ABRT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_TX_ABRT_CLR_TX_ABRT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_TX_ABRT_CLR_TX_ABRT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_TX_ABRT_CLR_TX_ABRT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_TX_ABRT_CLR_TX_ABRT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_TX_ABRT_CLR_TX_ABRT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_TX_ABRT_CLR_TX_ABRT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_TX_ABRT_CLR_TX_ABRT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2345</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read this register to clear the TX_ABRT</csr:p>
         <csr:p>interrupt (bit 6) of the IC_RAW_INTR_STAT register,</csr:p>
         <csr:p>and the IC_TX_ABRT_SOURCE register.</csr:p>
         <csr:p>This also releases the TX FIFO from the flushed/reset</csr:p>
         <csr:p>state, allowing more writes to the TX FIFO.</csr:p>
         <csr:p>Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for</csr:p>
         <csr:p>an exception to clearing IC_TX_ABRT_SOURCE.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CLR_TX_ABRT</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_TX_ABRT_RSVD_IC_CLR_TX_ABRT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_TX_ABRT_RSVD_IC_CLR_TX_ABRT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_TX_ABRT_RSVD_IC_CLR_TX_ABRT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_TX_ABRT_RSVD_IC_CLR_TX_ABRT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_TX_ABRT_RSVD_IC_CLR_TX_ABRT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_TX_ABRT_RSVD_IC_CLR_TX_ABRT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_TX_ABRT_RSVD_IC_CLR_TX_ABRT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_TX_ABRT_RSVD_IC_CLR_TX_ABRT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2352</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CLR_TX_ABRT Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_RX_DONE</csr:referenceName>
       <csr:identifier>IC_CLR_RX_DONE</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_RX_DONE_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_RX_DONE_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_RX_DONE_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_RX_DONE_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2375</csr:linenumber>
       <csr:title>Clear RX_DONE Interrupt Register</csr:title>
       <csr:offset>0x58</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_RX_DONE</csr:typeName>
        <csr:description>
         <csr:p>Clear RX_DONE Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_RX_DONE</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_RX_DONE_CLR_RX_DONE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_RX_DONE_CLR_RX_DONE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_RX_DONE_CLR_RX_DONE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_RX_DONE_CLR_RX_DONE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_RX_DONE_CLR_RX_DONE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_RX_DONE_CLR_RX_DONE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_RX_DONE_CLR_RX_DONE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_RX_DONE_CLR_RX_DONE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2368</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read this register to clear the RX_DONE</csr:p>
         <csr:p>interrupt (bit 7) of the IC_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CLR_RX_DONE</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_RX_DONE_RSVD_IC_CLR_RX_DONE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_RX_DONE_RSVD_IC_CLR_RX_DONE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_RX_DONE_RSVD_IC_CLR_RX_DONE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_RX_DONE_RSVD_IC_CLR_RX_DONE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_RX_DONE_RSVD_IC_CLR_RX_DONE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_RX_DONE_RSVD_IC_CLR_RX_DONE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_RX_DONE_RSVD_IC_CLR_RX_DONE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_RX_DONE_RSVD_IC_CLR_RX_DONE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2374</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CLR_RX_DONE Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_ACTIVITY</csr:referenceName>
       <csr:identifier>IC_CLR_ACTIVITY</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_ACTIVITY_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_ACTIVITY_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_ACTIVITY_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_ACTIVITY_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2403</csr:linenumber>
       <csr:title>Clear ACTIVITY Interrupt Register</csr:title>
       <csr:offset>0x5C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_ACTIVITY</csr:typeName>
        <csr:description>
         <csr:p>Clear ACTIVITY Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_ACTIVITY</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_ACTIVITY_CLR_ACTIVITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_ACTIVITY_CLR_ACTIVITY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_ACTIVITY_CLR_ACTIVITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_ACTIVITY_CLR_ACTIVITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_ACTIVITY_CLR_ACTIVITY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_ACTIVITY_CLR_ACTIVITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_ACTIVITY_CLR_ACTIVITY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_ACTIVITY_CLR_ACTIVITY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2396</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Reading this register clears the ACTIVITY</csr:p>
         <csr:p>interrupt if the I2C is not active anymore. If the</csr:p>
         <csr:p>I2C module is still active on the bus, the ACTIVITY</csr:p>
         <csr:p>interrupt bit continues to be set. It is automatically</csr:p>
         <csr:p>cleared by hardware if the module is disabled and if</csr:p>
         <csr:p>there is no further activity on the bus. The value read</csr:p>
         <csr:p>from this register to get status of the ACTIVITY interrupt</csr:p>
         <csr:p>(bit 8) of the IC_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CLR_ACTIVITY</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_ACTIVITY_RSVD_IC_CLR_ACTIVITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_ACTIVITY_RSVD_IC_CLR_ACTIVITY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_ACTIVITY_RSVD_IC_CLR_ACTIVITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_ACTIVITY_RSVD_IC_CLR_ACTIVITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_ACTIVITY_RSVD_IC_CLR_ACTIVITY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_ACTIVITY_RSVD_IC_CLR_ACTIVITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_ACTIVITY_RSVD_IC_CLR_ACTIVITY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_ACTIVITY_RSVD_IC_CLR_ACTIVITY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2402</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CLR_ACTIVITY Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_STOP_DET</csr:referenceName>
       <csr:identifier>IC_CLR_STOP_DET</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_STOP_DET_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_STOP_DET_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_STOP_DET_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_STOP_DET_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2424</csr:linenumber>
       <csr:title>Clear STOP_DET Interrupt Register</csr:title>
       <csr:offset>0x60</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_STOP_DET</csr:typeName>
        <csr:description>
         <csr:p>Clear STOP_DET Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_STOP_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_STOP_DET_CLR_STOP_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_STOP_DET_CLR_STOP_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_STOP_DET_CLR_STOP_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_STOP_DET_CLR_STOP_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_STOP_DET_CLR_STOP_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_STOP_DET_CLR_STOP_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_STOP_DET_CLR_STOP_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_STOP_DET_CLR_STOP_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2417</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read this register to clear the STOP_DET</csr:p>
         <csr:p>interrupt (bit 9) of the IC_RAW_INTR_STAT register.</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CLR_STOP_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_STOP_DET_RSVD_IC_CLR_STOP_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_STOP_DET_RSVD_IC_CLR_STOP_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_STOP_DET_RSVD_IC_CLR_STOP_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_STOP_DET_RSVD_IC_CLR_STOP_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_STOP_DET_RSVD_IC_CLR_STOP_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_STOP_DET_RSVD_IC_CLR_STOP_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_STOP_DET_RSVD_IC_CLR_STOP_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_STOP_DET_RSVD_IC_CLR_STOP_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2423</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CLR_STOP_DET Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_START_DET</csr:referenceName>
       <csr:identifier>IC_CLR_START_DET</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_START_DET_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_START_DET_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_START_DET_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_START_DET_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2446</csr:linenumber>
       <csr:title>Clear START_DET Interrupt Register</csr:title>
       <csr:offset>0x64</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_START_DET</csr:typeName>
        <csr:description>
         <csr:p>Clear START_DET Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_START_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_START_DET_CLR_START_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_START_DET_CLR_START_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_START_DET_CLR_START_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_START_DET_CLR_START_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_START_DET_CLR_START_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_START_DET_CLR_START_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_START_DET_CLR_START_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_START_DET_CLR_START_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2439</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read this register to clear the START_DET</csr:p>
         <csr:p>interrupt (bit 10) of the IC_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CLR_START_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_START_DET_RSVD_IC_CLR_START_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_START_DET_RSVD_IC_CLR_START_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_START_DET_RSVD_IC_CLR_START_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_START_DET_RSVD_IC_CLR_START_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_START_DET_RSVD_IC_CLR_START_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_START_DET_RSVD_IC_CLR_START_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_START_DET_RSVD_IC_CLR_START_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_START_DET_RSVD_IC_CLR_START_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2445</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CLR_START_DET Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_GEN_CALL</csr:referenceName>
       <csr:identifier>IC_CLR_GEN_CALL</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_GEN_CALL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_GEN_CALL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_GEN_CALL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_GEN_CALL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2468</csr:linenumber>
       <csr:title>Clear GEN_CALL Interrupt Register</csr:title>
       <csr:offset>0x68</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_GEN_CALL</csr:typeName>
        <csr:description>
         <csr:p>Clear GEN_CALL Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_GEN_CALL</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_GEN_CALL_CLR_GEN_CALL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_GEN_CALL_CLR_GEN_CALL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_GEN_CALL_CLR_GEN_CALL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_GEN_CALL_CLR_GEN_CALL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_GEN_CALL_CLR_GEN_CALL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_GEN_CALL_CLR_GEN_CALL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_GEN_CALL_CLR_GEN_CALL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_GEN_CALL_CLR_GEN_CALL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2461</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read this register to clear the GEN_CALL</csr:p>
         <csr:p>interrupt (bit 11) of IC_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CLR_GEN_CALL</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_GEN_CALL_RSVD_IC_CLR_GEN_CALL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_GEN_CALL_RSVD_IC_CLR_GEN_CALL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_GEN_CALL_RSVD_IC_CLR_GEN_CALL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_GEN_CALL_RSVD_IC_CLR_GEN_CALL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_GEN_CALL_RSVD_IC_CLR_GEN_CALL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_GEN_CALL_RSVD_IC_CLR_GEN_CALL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_GEN_CALL_RSVD_IC_CLR_GEN_CALL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_GEN_CALL_RSVD_IC_CLR_GEN_CALL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2467</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CLR_GEN_CALL Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_ENABLE</csr:referenceName>
       <csr:identifier>IC_ENABLE</csr:identifier>
       <csr:addressMacro>I2C_IC_ENABLE_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_ENABLE_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_ENABLE_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_ENABLE_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2670</csr:linenumber>
       <csr:title>I2C ENABLE Register</csr:title>
       <csr:offset>0x6C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_ENABLE</csr:typeName>
        <csr:description>
         <csr:p>I2C Enable Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ENABLE</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_ENABLE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_ENABLE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_ENABLE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_ENABLE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_ENABLE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_ENABLE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_ENABLE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_ENABLE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2522</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Controls whether the DW_apb_i2c is enabled.</csr:p>
         <csr:p> - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state)</csr:p>
         <csr:p> - 1: Enables DW_apb_i2c</csr:p>
         <csr:p>Software can disable DW_apb_i2c while it is active.</csr:p>
         <csr:p>However, it is important that care be taken to ensure</csr:p>
         <csr:p>that DW_apb_i2c is disabled properly. A recommended procedure is </csr:p>
         <csr:p>described in "Disabling DW_apb_i2c".</csr:p>
         <csr:p></csr:p>
         <csr:p>When DW_apb_i2c is disabled, the following occurs:</csr:p>
         <csr:p> - The TX FIFO and RX FIFO get flushed.</csr:p>
         <csr:p> - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state.</csr:p>
         <csr:p>If the module is transmitting, it stops as well as deletes</csr:p>
         <csr:p>the contents of the transmit buffer after the current transfer</csr:p>
         <csr:p>is complete. If the module is receiving, the DW_apb_i2c stops</csr:p>
         <csr:p>the current transfer at the end of the current byte and does not</csr:p>
         <csr:p>acknowledge the transfer.</csr:p>
         <csr:p></csr:p>
         <csr:p>In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE</csr:p>
         <csr:p>parameter set to asynchronous (1), there is a two ic_clk delay</csr:p>
         <csr:p>when enabling or disabling the DW_apb_i2c.</csr:p>
         <csr:p>For a detailed description on how to disable DW_apb_i2c, refer to "Disabling</csr:p>
         <csr:p>DW_apb_i2c"</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>I2C is disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>I2C is enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABORT</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_ABORT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_ABORT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_ABORT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_ABORT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_ABORT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_ABORT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_ABORT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_ABORT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2559</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>When set, the controller initiates the transfer abort.</csr:p>
         <csr:p> - 0: ABORT not initiated or ABORT done</csr:p>
         <csr:p> - 1: ABORT operation in progress</csr:p>
         <csr:p>The software can abort the I2C transfer in master mode by setting this bit. The software </csr:p>
         <csr:p>can set this bit only when ENABLE is already set; otherwise, the controller ignores any </csr:p>
         <csr:p>write to ABORT bit. The software cannot clear the ABORT bit once set. In response to </csr:p>
         <csr:p>an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the </csr:p>
         <csr:p>current transfer, then sets the TX_ABORT interrupt after the abort operation. The </csr:p>
         <csr:p>ABORT bit is cleared automatically after the abort operation. </csr:p>
         <csr:p></csr:p>
         <csr:p>For a detailed description on how to abort I2C transfers, refer to "Aborting I2C Transfers".</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ABORT operation not in progress</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ABORT operation in progress</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TX_CMD_BLOCK</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_TX_CMD_BLOCK_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_TX_CMD_BLOCK_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_TX_CMD_BLOCK_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_TX_CMD_BLOCK_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_TX_CMD_BLOCK_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_TX_CMD_BLOCK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_TX_CMD_BLOCK_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_TX_CMD_BLOCK_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2589</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>In Master mode:</csr:p>
         <csr:p> - 1'b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit.</csr:p>
         <csr:p> - 1'b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO.</csr:p>
         <csr:p>Note: To block the execution of Master commands,</csr:p>
         <csr:p>set the TX_CMD_BLOCK bit only when  Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). </csr:p>
         <csr:p>Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>BLOCKED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Tx Command execution blocked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_BLOCKED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Tx Command execution not blocked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SDA_STUCK_RECOVERY_ENABLE</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_SDA_STUCK_RECOVERY_ENABLE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_SDA_STUCK_RECOVERY_ENABLE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_SDA_STUCK_RECOVERY_ENABLE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_SDA_STUCK_RECOVERY_ENABLE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_SDA_STUCK_RECOVERY_ENABLE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_SDA_STUCK_RECOVERY_ENABLE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_SDA_STUCK_RECOVERY_ENABLE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_SDA_STUCK_RECOVERY_ENABLE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2615</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>If SDA is stuck at low indicated through the TX_ABORT interrupt</csr:p>
         <csr:p>(IC_TX_ABRT_SOURCE[17]), then this bit is used as a control knob to initiate</csr:p>
         <csr:p>the SDA Recovery Mechanism (that is, send at most 9 SCL clocks and STOP</csr:p>
         <csr:p>to release the SDA line) and then this bit gets auto clear</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>SDA_STUCK_RECOVERY_DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master disabled the SDA stuck at low recovery mechanism.</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SDA_STUCK_RECOVERY_ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master initates the SDA stuck at low recovery mechanism.</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_ENABLE_1</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_1_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_1_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_1_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_1_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_1_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_1_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_1_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2622</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RSVD_IC_ENABLE_1 Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SMBUS_CLK_RESET</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_SMBUS_CLK_RESET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_SMBUS_CLK_RESET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_SMBUS_CLK_RESET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_SMBUS_CLK_RESET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_SMBUS_CLK_RESET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_SMBUS_CLK_RESET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_SMBUS_CLK_RESET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_SMBUS_CLK_RESET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2648</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This bit is used in SMBus Host mode to initiate the SMBus Master Clock Reset. </csr:p>
         <csr:p>This bit should be enabled only when Master is in idle. Whenever this bit is enabled,</csr:p>
         <csr:p>the SMBCLK is held low for the IC_SCL_STUCK_TIMEOUT ic_clk cycles to reset the SMBus slave devices.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master will not initates SMBUS Clock Reset Mechanism.</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master initates the SMBUS Clock Reset Mechanism.</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SMBUS_SUSPEND_EN</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_RSVD_SMBUS_SUSPEND_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_RSVD_SMBUS_SUSPEND_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_RSVD_SMBUS_SUSPEND_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_RSVD_SMBUS_SUSPEND_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_RSVD_SMBUS_SUSPEND_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_RSVD_SMBUS_SUSPEND_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_RSVD_SMBUS_SUSPEND_EN_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_RSVD_SMBUS_SUSPEND_EN_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2655</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SMBUS_SUSPEND_EN Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SMBUS_ALERT_EN</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_RSVD_SMBUS_ALERT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_RSVD_SMBUS_ALERT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_RSVD_SMBUS_ALERT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_RSVD_SMBUS_ALERT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_RSVD_SMBUS_ALERT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_RSVD_SMBUS_ALERT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_RSVD_SMBUS_ALERT_EN_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_RSVD_SMBUS_ALERT_EN_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2662</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SMBUS_ALERT_EN Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>18</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_ENABLE_2</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_2_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_2_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_2_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_2_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_2_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_2_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_RSVD_IC_ENABLE_2_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2669</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_ENABLE Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>19</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_STATUS</csr:referenceName>
       <csr:identifier>IC_STATUS</csr:identifier>
       <csr:addressMacro>I2C_IC_STATUS_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_STATUS_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_STATUS_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_STATUS_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>2972</csr:linenumber>
       <csr:title>I2C STATUS Register</csr:title>
       <csr:offset>0x70</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000006</csr:registerResetValue>
       <csr:typeName>I2c_IC_STATUS</csr:typeName>
        <csr:description>
         <csr:p>I2C Status Register </csr:p>
         <csr:p></csr:p>
         <csr:p>This is a read-only register used to indicate the current</csr:p>
         <csr:p>transfer status and FIFO status. The status register may be</csr:p>
         <csr:p>read at any time. None of the bits in this register request</csr:p>
         <csr:p>an interrupt.</csr:p>
         <csr:p></csr:p>
         <csr:p>When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register:</csr:p>
         <csr:p> - Bits 1 and 2 are set to 1</csr:p>
         <csr:p> - Bits 3 and 10 are set to 0</csr:p>
         <csr:p>When the master or slave state machines goes to idle and ic_en=0:</csr:p>
         <csr:p> - Bits 5 and 6 are set to 0</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ACTIVITY</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_ACTIVITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_ACTIVITY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_ACTIVITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_ACTIVITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_ACTIVITY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_ACTIVITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_ACTIVITY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_ACTIVITY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2708</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>I2C Activity Status.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>I2C is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>I2C is idle</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TFNF</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_TFNF_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_TFNF_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_TFNF_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_TFNF_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_TFNF_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_TFNF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_TFNF_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_TFNF_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2731</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Not Full.</csr:p>
         <csr:p>Set when the transmit FIFO contains one or more</csr:p>
         <csr:p>empty locations, and is cleared when the FIFO is full.</csr:p>
         <csr:p> - 0: Transmit FIFO is full</csr:p>
         <csr:p> - 1: Transmit FIFO is not full</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FULL</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Tx FIFO is full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_FULL</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Tx FIFO not full</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TFE</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_TFE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_TFE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_TFE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_TFE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_TFE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_TFE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_TFE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_TFE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2756</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Completely Empty.</csr:p>
         <csr:p>When the transmit FIFO is completely empty, this bit is set.</csr:p>
         <csr:p>When it contains one or more valid entries, this bit is</csr:p>
         <csr:p>cleared. This bit field does not request an interrupt.</csr:p>
         <csr:p> - 0: Transmit FIFO is not empty</csr:p>
         <csr:p> - 1: Transmit FIFO is empty</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>EMPTY</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Tx FIFO is empty</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NON_EMPTY</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Tx FIFO not empty</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RFNE</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_RFNE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_RFNE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_RFNE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_RFNE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_RFNE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_RFNE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_RFNE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_RFNE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2780</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Not Empty.</csr:p>
         <csr:p>This bit is set when the receive FIFO contains one or</csr:p>
         <csr:p>more entries; it is cleared when the receive FIFO is empty.</csr:p>
         <csr:p> - 0: Receive FIFO is empty</csr:p>
         <csr:p> - 1: Receive FIFO is not empty</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>EMPTY</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Rx FIFO is empty</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_EMPTY</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Rx FIFO not empty</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RFF</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_RFF_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_RFF_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_RFF_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_RFF_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_RFF_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_RFF_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_RFF_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_RFF_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2804</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Completely Full.</csr:p>
         <csr:p>When the receive FIFO is completely full, this</csr:p>
         <csr:p>bit is set. When the receive FIFO contains one</csr:p>
         <csr:p>or more empty location, this bit is cleared.</csr:p>
         <csr:p> - 0: Receive FIFO is not full</csr:p>
         <csr:p> - 1: Receive FIFO is full</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FULL</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Rx FIFO is full</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_FULL</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Rx FIFO not full</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>MST_ACTIVITY</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_MST_ACTIVITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_MST_ACTIVITY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_MST_ACTIVITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_MST_ACTIVITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_MST_ACTIVITY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_MST_ACTIVITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_MST_ACTIVITY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_MST_ACTIVITY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2832</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Master FSM Activity Status.</csr:p>
         <csr:p>When the Master Finite State Machine (FSM) is</csr:p>
         <csr:p>not in the IDLE state, this bit is set.</csr:p>
         <csr:p> - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active</csr:p>
         <csr:p> - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active</csr:p>
         <csr:p>Note: </csr:p>
         <csr:p>IC_STATUS[0]-that is, ACTIVITY bit-is the OR of</csr:p>
         <csr:p>SLV_ACTIVITY and MST_ACTIVITY bits.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master not idle</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>IDLE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master is  idle</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SLV_ACTIVITY</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_SLV_ACTIVITY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_SLV_ACTIVITY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_SLV_ACTIVITY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_SLV_ACTIVITY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_SLV_ACTIVITY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_SLV_ACTIVITY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_SLV_ACTIVITY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_SLV_ACTIVITY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2857</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Slave FSM Activity Status.</csr:p>
         <csr:p>When the Slave Finite State Machine (FSM) is not</csr:p>
         <csr:p>in the IDLE state, this bit is set.</csr:p>
         <csr:p> - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active</csr:p>
         <csr:p> - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Slave not idle</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>IDLE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Slave is  idle</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_MST_HOLD_TX_FIFO_EMPTY</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_RSVD_MST_HOLD_TX_FIFO_EMPTY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_RSVD_MST_HOLD_TX_FIFO_EMPTY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_RSVD_MST_HOLD_TX_FIFO_EMPTY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_RSVD_MST_HOLD_TX_FIFO_EMPTY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_RSVD_MST_HOLD_TX_FIFO_EMPTY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_RSVD_MST_HOLD_TX_FIFO_EMPTY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_RSVD_MST_HOLD_TX_FIFO_EMPTY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_RSVD_MST_HOLD_TX_FIFO_EMPTY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2864</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>MST_HOLD_TX_FIFO_EMPTY Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_MST_HOLD_RX_FIFO_FULL</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_RSVD_MST_HOLD_RX_FIFO_FULL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_RSVD_MST_HOLD_RX_FIFO_FULL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_RSVD_MST_HOLD_RX_FIFO_FULL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_RSVD_MST_HOLD_RX_FIFO_FULL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_RSVD_MST_HOLD_RX_FIFO_FULL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_RSVD_MST_HOLD_RX_FIFO_FULL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_RSVD_MST_HOLD_RX_FIFO_FULL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_RSVD_MST_HOLD_RX_FIFO_FULL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2871</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>MST_HOLD_RX_FIFO_FULL Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SLV_HOLD_TX_FIFO_EMPTY</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_TX_FIFO_EMPTY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_TX_FIFO_EMPTY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_TX_FIFO_EMPTY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_TX_FIFO_EMPTY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_TX_FIFO_EMPTY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_TX_FIFO_EMPTY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_TX_FIFO_EMPTY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_TX_FIFO_EMPTY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2878</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SLV_HOLD_TX_FIFO_EMPTY Regsiter field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SLV_HOLD_RX_FIFO_FULL</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_RX_FIFO_FULL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_RX_FIFO_FULL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_RX_FIFO_FULL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_RX_FIFO_FULL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_RX_FIFO_FULL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_RX_FIFO_FULL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_RX_FIFO_FULL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_RSVD_SLV_HOLD_RX_FIFO_FULL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2885</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SLV_HOLD_RX_FIFO_FULL Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SDA_STUCK_NOT_RECOVERED</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_SDA_STUCK_NOT_RECOVERED_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_SDA_STUCK_NOT_RECOVERED_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_SDA_STUCK_NOT_RECOVERED_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_SDA_STUCK_NOT_RECOVERED_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_SDA_STUCK_NOT_RECOVERED_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_SDA_STUCK_NOT_RECOVERED_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_SDA_STUCK_NOT_RECOVERED_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_SDA_STUCK_NOT_RECOVERED_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2908</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit indicates that SDA stuck at low is not recovered after the recovery mechanism.</csr:p>
         <csr:p>In Slave mode, this register bit is not applicable.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>SDA Stuck at low is recovered after recovery mechanism.</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>SDA Stuck at low is not recovered after recovery mechanism.</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_STATUS_1</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_RSVD_IC_STATUS_1_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_RSVD_IC_STATUS_1_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_RSVD_IC_STATUS_1_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_RSVD_IC_STATUS_1_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_RSVD_IC_STATUS_1_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_RSVD_IC_STATUS_1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_RSVD_IC_STATUS_1_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_RSVD_IC_STATUS_1_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2914</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RSVD_IC_STATUS_1 Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SMBUS_QUICK_CMD_BIT</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_SMBUS_QUICK_CMD_BIT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_SMBUS_QUICK_CMD_BIT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_SMBUS_QUICK_CMD_BIT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_SMBUS_QUICK_CMD_BIT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_SMBUS_QUICK_CMD_BIT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_SMBUS_QUICK_CMD_BIT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_SMBUS_QUICK_CMD_BIT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_SMBUS_QUICK_CMD_BIT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2937</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This bit indicates the R/W bit of the Quick command received. </csr:p>
         <csr:p>This bit will be cleared after the user has read this bit.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>SMBUS QUICK CMD Read/write is set to 1.</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>SMBUS QUICK CMD Read/write is set to 0.</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SMBUS_SLAVE_ADDR_VALID</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_VALID_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_VALID_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_VALID_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_VALID_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_VALID_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_VALID_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_VALID_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_VALID_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2944</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SMBUS_SLAVE_ADDR_VALID Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SMBUS_SLAVE_ADDR_RESOLVED</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_RESOLVED_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_RESOLVED_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_RESOLVED_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_RESOLVED_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_RESOLVED_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_RESOLVED_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_RESOLVED_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_RSVD_SMBUS_SLAVE_ADDR_RESOLVED_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2951</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SMBUS_SLAVE_ADDR_RESOLVED Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>18</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SMBUS_SUSPEND_STATUS</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_RSVD_SMBUS_SUSPEND_STATUS_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_RSVD_SMBUS_SUSPEND_STATUS_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_RSVD_SMBUS_SUSPEND_STATUS_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_RSVD_SMBUS_SUSPEND_STATUS_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_RSVD_SMBUS_SUSPEND_STATUS_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_RSVD_SMBUS_SUSPEND_STATUS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_RSVD_SMBUS_SUSPEND_STATUS_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_RSVD_SMBUS_SUSPEND_STATUS_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2958</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SMBUS_SUSPEND_STATUS Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>19</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SMBUS_ALERT_STATUS</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_RSVD_SMBUS_ALERT_STATUS_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_RSVD_SMBUS_ALERT_STATUS_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_RSVD_SMBUS_ALERT_STATUS_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_RSVD_SMBUS_ALERT_STATUS_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_RSVD_SMBUS_ALERT_STATUS_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_RSVD_SMBUS_ALERT_STATUS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_RSVD_SMBUS_ALERT_STATUS_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_RSVD_SMBUS_ALERT_STATUS_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2965</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SMBUS_ALERT_STATUS Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>20</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_STATUS_2</csr:identifier>
         <csr:widthMacro>I2C_IC_STATUS_RSVD_IC_STATUS_2_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_STATUS_RSVD_IC_STATUS_2_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_STATUS_RSVD_IC_STATUS_2_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_STATUS_RSVD_IC_STATUS_2_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_STATUS_RSVD_IC_STATUS_2_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_STATUS_RSVD_IC_STATUS_2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_STATUS_RSVD_IC_STATUS_2_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_STATUS_RSVD_IC_STATUS_2_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2971</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_STATUS Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>21</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_TXFLR</csr:referenceName>
       <csr:identifier>IC_TXFLR</csr:identifier>
       <csr:addressMacro>I2C_IC_TXFLR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_TXFLR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_TXFLR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_TXFLR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>3004</csr:linenumber>
       <csr:title>I2C Transmit FIFO Level Register</csr:title>
       <csr:offset>0x74</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_TXFLR</csr:typeName>
        <csr:description>
         <csr:p>I2C Transmit FIFO Level Register</csr:p>
         <csr:p>This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever:</csr:p>
         <csr:p> - The I2C is disabled</csr:p>
         <csr:p> - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register</csr:p>
         <csr:p> - The slave bulk transmit mode is aborted</csr:p>
         <csr:p>The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TXFLR</csr:identifier>
         <csr:widthMacro>I2C_IC_TXFLR_TXFLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TXFLR_TXFLR_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TXFLR_TXFLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TXFLR_TXFLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TXFLR_TXFLR_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TXFLR_TXFLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TXFLR_TXFLR_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TXFLR_TXFLR_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>2997</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Transmit FIFO Level.</csr:p>
         <csr:p>Contains the number of valid data entries in the</csr:p>
         <csr:p>transmit FIFO.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_TXFLR</csr:identifier>
         <csr:widthMacro>I2C_IC_TXFLR_RSVD_TXFLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TXFLR_RSVD_TXFLR_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TXFLR_RSVD_TXFLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TXFLR_RSVD_TXFLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TXFLR_RSVD_TXFLR_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TXFLR_RSVD_TXFLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TXFLR_RSVD_TXFLR_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TXFLR_RSVD_TXFLR_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3003</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>TXFLR Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_RXFLR</csr:referenceName>
       <csr:identifier>IC_RXFLR</csr:identifier>
       <csr:addressMacro>I2C_IC_RXFLR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_RXFLR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_RXFLR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_RXFLR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>3035</csr:linenumber>
       <csr:title>I2C Receive FIFO Level Register</csr:title>
       <csr:offset>0x78</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_RXFLR</csr:typeName>
        <csr:description>
         <csr:p>I2C Receive FIFO Level Register</csr:p>
         <csr:p>This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever:</csr:p>
         <csr:p> - The I2C is disabled</csr:p>
         <csr:p> - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE</csr:p>
         <csr:p>The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RXFLR</csr:identifier>
         <csr:widthMacro>I2C_IC_RXFLR_RXFLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RXFLR_RXFLR_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RXFLR_RXFLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RXFLR_RXFLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RXFLR_RXFLR_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RXFLR_RXFLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RXFLR_RXFLR_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RXFLR_RXFLR_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3028</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Receive FIFO Level.</csr:p>
         <csr:p>Contains the number of valid data entries in the</csr:p>
         <csr:p>receive FIFO.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_RXFLR</csr:identifier>
         <csr:widthMacro>I2C_IC_RXFLR_RSVD_RXFLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_RXFLR_RSVD_RXFLR_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_RXFLR_RSVD_RXFLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_RXFLR_RSVD_RXFLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_RXFLR_RSVD_RXFLR_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_RXFLR_RSVD_RXFLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_RXFLR_RSVD_RXFLR_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_RXFLR_RSVD_RXFLR_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3034</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RXFLR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SDA_HOLD</csr:referenceName>
       <csr:identifier>IC_SDA_HOLD</csr:identifier>
       <csr:addressMacro>I2C_IC_SDA_HOLD_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SDA_HOLD_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SDA_HOLD_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SDA_HOLD_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>3097</csr:linenumber>
       <csr:title>I2C SDA Hold Time Length Register</csr:title>
       <csr:offset>0x7C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000001</csr:registerResetValue>
       <csr:typeName>I2c_IC_SDA_HOLD</csr:typeName>
        <csr:description>
         <csr:p>I2C SDA Hold Time Length Register</csr:p>
         <csr:p></csr:p>
         <csr:p>The bits [15:0] of this register are used to control the hold time of SDA during</csr:p>
         <csr:p>transmit in both slave and master mode (after SCL goes from HIGH to LOW).</csr:p>
         <csr:p></csr:p>
         <csr:p>The bits [23:16] of this register are used to extend the SDA transition (if any) </csr:p>
         <csr:p>whenever SCL is HIGH in the receiver in either master or slave mode.</csr:p>
         <csr:p></csr:p>
         <csr:p>Writes to this register succeed only when IC_ENABLE[0]=0.</csr:p>
         <csr:p></csr:p>
         <csr:p>The values in this register are in units of ic_clk period. The value programmed </csr:p>
         <csr:p>in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode one </csr:p>
         <csr:p>cycle in master mode, seven cycles in slave mode for the value to be implemented.</csr:p>
         <csr:p></csr:p>
         <csr:p>The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any </csr:p>
         <csr:p>time the duration of the low part of scl. Therefore the programmed value cannot be </csr:p>
         <csr:p>larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl </csr:p>
         <csr:p>period measured in ic_clk cycles.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_SDA_TX_HOLD</csr:identifier>
         <csr:widthMacro>I2C_IC_SDA_HOLD_IC_SDA_TX_HOLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SDA_HOLD_IC_SDA_TX_HOLD_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SDA_HOLD_IC_SDA_TX_HOLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SDA_HOLD_IC_SDA_TX_HOLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SDA_HOLD_IC_SDA_TX_HOLD_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SDA_HOLD_IC_SDA_TX_HOLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SDA_HOLD_IC_SDA_TX_HOLD_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SDA_HOLD_IC_SDA_TX_HOLD_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3079</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Sets the required SDA hold time </csr:p>
         <csr:p>in units of ic_clk period, when DW_apb_i2c acts as a transmitter.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0001</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IC_SDA_RX_HOLD</csr:identifier>
         <csr:widthMacro>I2C_IC_SDA_HOLD_IC_SDA_RX_HOLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SDA_HOLD_IC_SDA_RX_HOLD_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SDA_HOLD_IC_SDA_RX_HOLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SDA_HOLD_IC_SDA_RX_HOLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SDA_HOLD_IC_SDA_RX_HOLD_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SDA_HOLD_IC_SDA_RX_HOLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SDA_HOLD_IC_SDA_RX_HOLD_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SDA_HOLD_IC_SDA_RX_HOLD_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3089</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Sets the required SDA hold time </csr:p>
         <csr:p>in units of ic_clk period, when DW_apb_i2c acts as a receiver.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_SDA_HOLD</csr:identifier>
         <csr:widthMacro>I2C_IC_SDA_HOLD_RSVD_IC_SDA_HOLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SDA_HOLD_RSVD_IC_SDA_HOLD_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SDA_HOLD_RSVD_IC_SDA_HOLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SDA_HOLD_RSVD_IC_SDA_HOLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SDA_HOLD_RSVD_IC_SDA_HOLD_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SDA_HOLD_RSVD_IC_SDA_HOLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SDA_HOLD_RSVD_IC_SDA_HOLD_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SDA_HOLD_RSVD_IC_SDA_HOLD_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3096</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_SDA_HOLD Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_TX_ABRT_SOURCE</csr:referenceName>
       <csr:identifier>IC_TX_ABRT_SOURCE</csr:identifier>
       <csr:addressMacro>I2C_IC_TX_ABRT_SOURCE_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_TX_ABRT_SOURCE_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_TX_ABRT_SOURCE_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_TX_ABRT_SOURCE_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>3590</csr:linenumber>
       <csr:title>I2C Transmit Abort Source Register</csr:title>
       <csr:offset>0x80</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_TX_ABRT_SOURCE</csr:typeName>
        <csr:description>
         <csr:p>I2C Transmit Abort Source Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This register has 32 bits that indicate the source</csr:p>
         <csr:p>of the TX_ABRT bit. Except for Bit 9, this register is</csr:p>
         <csr:p>cleared whenever the IC_CLR_TX_ABRT register or the</csr:p>
         <csr:p>IC_CLR_INTR register is read. To clear Bit 9, the source</csr:p>
         <csr:p>of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must</csr:p>
         <csr:p>be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared</csr:p>
         <csr:p>(IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).</csr:p>
         <csr:p></csr:p>
         <csr:p>Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this</csr:p>
         <csr:p>bit can be cleared in the same manner as other bits in this</csr:p>
         <csr:p>register. If the source of the ABRT_SBYTE_NORSTRT is not fixed</csr:p>
         <csr:p>before attempting to clear this bit, Bit 9 clears for one cycle</csr:p>
         <csr:p>and is then re-asserted.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ABRT_7B_ADDR_NOACK</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3143</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>This abort is generated because of NOACK for 7-bit address</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>This abort is not generated</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_10ADDR1_NOACK</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3166</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.</csr:p>
         <csr:p></csr:p>
         <csr:p>Reset value: 0x0</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Byte 1 of 10Bit Address not ACKed by any slave</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>This abort is not generated</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_10ADDR2_NOACK</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3188</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave.</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver</csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Byte 2 of 10Bit Address not ACKed by any slave</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>This abort is not generated</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_TXDATA_NOACK</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3213</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master-Transmitter</csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_TXDATA_NOACK_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Transmitted data not ACKed by addressed slave</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_TXDATA_NOACK_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Transmitted data non-ACKed by addressed slave-scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_GCALL_NOACK</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3236</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master-Transmitter</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_GCALL_NOACK_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>GCALL not ACKed by any slave</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_GCALL_NOACK_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>GCALL not ACKed by any slave-scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_GCALL_READ</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3261</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master-Transmitter</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_GCALL_READ_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>GCALL is followed by read from bus</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_GCALL_READ_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>GCALL is followed by read from bus-scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_HS_ACKDET</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3285</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_HS_ACK_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>HS Master code ACKed in HS Mode</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_HS_ACK_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>HS Master code ACKed in HS Mode- scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_SBYTE_ACKDET</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3306</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_SBYTE_ACKDET_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>ACK detected for START byte</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_SBYTE_ACKDET_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>ACK detected for START byte- scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_HS_NORSTRT</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3330</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode.</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_HS_NORSTRT_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>User trying to switch Master to HS mode when RESTART disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_HS_NORSTRT_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>User trying to switch Master to HS mode when RESTART disabled- scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_SBYTE_NORSTRT</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3365</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>To clear Bit 9, the source of the</csr:p>
         <csr:p>ABRT_SBYTE_NORSTRT must be fixed first;</csr:p>
         <csr:p>restart must be enabled (IC_CON[5]=1),</csr:p>
         <csr:p>the SPECIAL bit must be cleared (IC_TAR[11]),</csr:p>
         <csr:p>or the GC_OR_START bit must be cleared</csr:p>
         <csr:p>(IC_TAR[10]). Once the source of the</csr:p>
         <csr:p>ABRT_SBYTE_NORSTRT is fixed,</csr:p>
         <csr:p>then this bit can be cleared in the same</csr:p>
         <csr:p>manner as other bits in this register. If</csr:p>
         <csr:p>the source of the ABRT_SBYTE_NORSTRT is not fixed</csr:p>
         <csr:p>before attempting to clear this bit, bit 9</csr:p>
         <csr:p>clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a START Byte.</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_SBYTE_NORSTRT_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>User trying to send START byte when RESTART disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_SBYTE_NORSTRT_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>User trying to send START byte when RESTART disabled- scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_10B_RD_NORSTRT</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3389</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode.</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master-Receiver</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_10B_RD_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master trying to read in 10Bit addressing mode when RESTART disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_10B_RD_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master not trying to read in 10Bit addressing mode when RESTART disabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_MASTER_DIS</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3412</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates that the User tries to initiate a Master operation with the Master mode disabled.</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver</csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_MASTER_DIS_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>User intitating master operation when MASTER disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_MASTER_DIS_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>User initiating master operation when MASTER disabled- scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ARB_LOST</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ARB_LOST_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ARB_LOST_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ARB_LOST_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ARB_LOST_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ARB_LOST_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ARB_LOST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ARB_LOST_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ARB_LOST_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3436</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration.</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master-Transmitter or Slave-Transmitter</csr:p>
        </csr:description>
         <csr:msb>12</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_LOST_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master or Slave-Transmitter lost arbitration</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_LOST_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master or Slave-Transmitter lost arbitration- scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_SLVFLUSH_TXFIFO</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3460</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Slave-Transmitter</csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>13</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_SLVFLUSH_TXFIFO_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Slave flushes existing data in TX-FIFO upon getting read command</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_SLVFLUSH_TXFIFO_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Slave flushes existing data in TX-FIFO upon getting read command- scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_SLV_ARBLOST</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3492</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time.</csr:p>
         <csr:p>Note:  Even though the slave never</csr:p>
         <csr:p>'owns' the bus, something could go</csr:p>
         <csr:p>wrong on the bus. This is a fail safe</csr:p>
         <csr:p>check. For instance, during a data</csr:p>
         <csr:p>transmission at the low-to-high</csr:p>
         <csr:p>transition of SCL, if what is on the data</csr:p>
         <csr:p>bus is not what is supposed to be</csr:p>
         <csr:p>transmitted, then DW_apb_i2c no</csr:p>
         <csr:p>longer own the bus.</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Slave-Transmitter</csr:p>
        </csr:description>
         <csr:msb>14</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_SLV_ARBLOST_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Slave lost arbitration to remote master</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_SLV_ARBLOST_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Slave lost arbitration to remote master- scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_SLVRD_INTX</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3518</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>1: When the processor side responds to</csr:p>
         <csr:p>a slave mode request for data to be</csr:p>
         <csr:p>transmitted to a remote master and user</csr:p>
         <csr:p>writes a 1 in CMD (bit 8) of</csr:p>
         <csr:p>IC_DATA_CMD register.</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Slave-Transmitter</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>15</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_SLVRD_INTX_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Slave trying to transmit to remote master in read mode</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_SLVRD_INTX_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Slave trying to transmit to remote master in read mode- scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_USER_ABRT</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3540</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This is a master-mode-only bit. Master has </csr:p>
         <csr:p>detected the transfer abort (IC_ENABLE[1])</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master-Transmitter</csr:p>
        </csr:description>
         <csr:msb>16</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ABRT_USER_ABRT_GENERATED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Transfer abort detected by master</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ABRT_USER_ABRT_VOID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Transfer abort detected by master- scenario not present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABRT_SDA_STUCK_AT_LOW</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SDA_STUCK_AT_LOW_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SDA_STUCK_AT_LOW_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SDA_STUCK_AT_LOW_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SDA_STUCK_AT_LOW_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SDA_STUCK_AT_LOW_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SDA_STUCK_AT_LOW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SDA_STUCK_AT_LOW_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_ABRT_SDA_STUCK_AT_LOW_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3564</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This is a master-mode-only bit. Master detects the SDA Stuck at low for </csr:p>
         <csr:p>the IC_SDA_STUCK_AT_LOW_TIMEOUT value of ic_clks.</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master</csr:p>
        </csr:description>
         <csr:msb>17</csr:msb>
         <csr:lsb>17</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>This abort is generated because of Sda stuck at low for IC_SDA_STUCK_AT_LOW_TIMEOUT value of ic_clks</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>This abort is not generated</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_ABRT_DEVICE_WRITE</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_ABRT_DEVICE_WRITE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_ABRT_DEVICE_WRITE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_ABRT_DEVICE_WRITE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_ABRT_DEVICE_WRITE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_ABRT_DEVICE_WRITE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_ABRT_DEVICE_WRITE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_ABRT_DEVICE_WRITE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_ABRT_DEVICE_WRITE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3570</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ABRT_DEVICE_WRITE Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>20</csr:msb>
         <csr:lsb>18</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_TX_ABRT_SOURCE</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_IC_TX_ABRT_SOURCE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_IC_TX_ABRT_SOURCE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_IC_TX_ABRT_SOURCE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_IC_TX_ABRT_SOURCE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_IC_TX_ABRT_SOURCE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_IC_TX_ABRT_SOURCE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_IC_TX_ABRT_SOURCE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_RSVD_IC_TX_ABRT_SOURCE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3576</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_TX_ABRT_SOURCE Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>22</csr:msb>
         <csr:lsb>21</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TX_FLUSH_CNT</csr:identifier>
         <csr:widthMacro>I2C_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3589</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field indicates the </csr:p>
         <csr:p>number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. </csr:p>
         <csr:p>It is cleared whenever I2C is disabled.</csr:p>
         <csr:p></csr:p>
         <csr:p>Role of DW_apb_i2c:  Master-Transmitter or Slave-Transmitter</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>23</csr:lsb>
         <csr:resetValue>0x000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SDA_SETUP</csr:referenceName>
       <csr:identifier>IC_SDA_SETUP</csr:identifier>
       <csr:addressMacro>I2C_IC_SDA_SETUP_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SDA_SETUP_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SDA_SETUP_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SDA_SETUP_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>3636</csr:linenumber>
       <csr:title>I2C SDA Setup Register</csr:title>
       <csr:offset>0x94</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000064</csr:registerResetValue>
       <csr:typeName>I2c_IC_SDA_SETUP</csr:typeName>
        <csr:description>
         <csr:p>I2C SDA Setup Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This register controls the amount of time delay</csr:p>
         <csr:p>(in terms of number of ic_clk clock periods) introduced</csr:p>
         <csr:p>in the rising edge of SCL - relative to SDA changing - when</csr:p>
         <csr:p>DW_apb_i2c services a read request in a slave-transmitter operation.</csr:p>
         <csr:p>The relevant I2C requirement is tSU:DAT (note 4) as detailed in the</csr:p>
         <csr:p>I2C Bus Specification.</csr:p>
         <csr:p>This register must be programmed with a value equal to or greater than 2. </csr:p>
         <csr:p></csr:p>
         <csr:p>Writes to this register succeed only when IC_ENABLE[0] = 0.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the</csr:p>
         <csr:p>user requires 10 ic_clk periods of setup time, they should program a value of 11.</csr:p>
         <csr:p>The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave</csr:p>
         <csr:p>transmitter.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SDA_SETUP</csr:identifier>
         <csr:widthMacro>I2C_IC_SDA_SETUP_SDA_SETUP_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SDA_SETUP_SDA_SETUP_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SDA_SETUP_SDA_SETUP_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SDA_SETUP_SDA_SETUP_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SDA_SETUP_SDA_SETUP_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SDA_SETUP_SDA_SETUP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SDA_SETUP_SDA_SETUP_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SDA_SETUP_SDA_SETUP_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3628</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SDA Setup.</csr:p>
         <csr:p>It is recommended that if the required delay is 1000ns,</csr:p>
         <csr:p>then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP</csr:p>
         <csr:p>should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2.</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x64</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_SDA_SETUP</csr:identifier>
         <csr:widthMacro>I2C_IC_SDA_SETUP_RSVD_IC_SDA_SETUP_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SDA_SETUP_RSVD_IC_SDA_SETUP_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SDA_SETUP_RSVD_IC_SDA_SETUP_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SDA_SETUP_RSVD_IC_SDA_SETUP_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SDA_SETUP_RSVD_IC_SDA_SETUP_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SDA_SETUP_RSVD_IC_SDA_SETUP_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SDA_SETUP_RSVD_IC_SDA_SETUP_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SDA_SETUP_RSVD_IC_SDA_SETUP_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3635</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_SDA_SETUP Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_ACK_GENERAL_CALL</csr:referenceName>
       <csr:identifier>IC_ACK_GENERAL_CALL</csr:identifier>
       <csr:addressMacro>I2C_IC_ACK_GENERAL_CALL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_ACK_GENERAL_CALL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_ACK_GENERAL_CALL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_ACK_GENERAL_CALL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>3679</csr:linenumber>
       <csr:title>I2C ACK General Call Register</csr:title>
       <csr:offset>0x98</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000001</csr:registerResetValue>
       <csr:typeName>I2c_IC_ACK_GENERAL_CALL</csr:typeName>
        <csr:description>
         <csr:p>I2C ACK General Call Register</csr:p>
         <csr:p></csr:p>
         <csr:p>The register controls whether DW_apb_i2c responds</csr:p>
         <csr:p>with a ACK or NACK when it receives an I2C</csr:p>
         <csr:p>General Call address.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is applicable only when the DW_apb_i2c is in slave mode.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>ACK_GEN_CALL</csr:identifier>
         <csr:widthMacro>I2C_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3671</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ACK General Call.</csr:p>
         <csr:p>When set to 1, DW_apb_i2c responds with a ACK</csr:p>
         <csr:p>(by asserting ic_data_oe) when it receives a General Call.</csr:p>
         <csr:p>Otherwise, DW_apb_i2c responds with a NACK</csr:p>
         <csr:p>(by negating ic_data_oe).</csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Generate NACK for  General Call</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Generate ACK for a General Call</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_ACK_GEN_1_31</csr:identifier>
         <csr:widthMacro>I2C_IC_ACK_GENERAL_CALL_RSVD_IC_ACK_GEN_1_31_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ACK_GENERAL_CALL_RSVD_IC_ACK_GEN_1_31_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ACK_GENERAL_CALL_RSVD_IC_ACK_GEN_1_31_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ACK_GENERAL_CALL_RSVD_IC_ACK_GEN_1_31_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ACK_GENERAL_CALL_RSVD_IC_ACK_GEN_1_31_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ACK_GENERAL_CALL_RSVD_IC_ACK_GEN_1_31_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ACK_GENERAL_CALL_RSVD_IC_ACK_GEN_1_31_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ACK_GENERAL_CALL_RSVD_IC_ACK_GEN_1_31_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3678</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RSVD_IC_ACK_GEN_1_31 Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_ENABLE_STATUS</csr:referenceName>
       <csr:identifier>IC_ENABLE_STATUS</csr:identifier>
       <csr:addressMacro>I2C_IC_ENABLE_STATUS_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_ENABLE_STATUS_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_ENABLE_STATUS_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_ENABLE_STATUS_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>3835</csr:linenumber>
       <csr:title>I2C Enable Status Register</csr:title>
       <csr:offset>0x9C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_ENABLE_STATUS</csr:typeName>
        <csr:description>
         <csr:p>I2C Enable Status Register</csr:p>
         <csr:p></csr:p>
         <csr:p>The register is used to report the DW_apb_i2c hardware</csr:p>
         <csr:p>status when the IC_ENABLE[0] register is set from 1 to 0;</csr:p>
         <csr:p>that is, when DW_apb_i2c is disabled.</csr:p>
         <csr:p></csr:p>
         <csr:p>If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0,</csr:p>
         <csr:p>and bit 0 is forced to 1.</csr:p>
         <csr:p></csr:p>
         <csr:p>If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid</csr:p>
         <csr:p>as soon as bit 0 is read as '0'.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note: </csr:p>
         <csr:p>When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because</csr:p>
         <csr:p>disabling the DW_apb_i2c depends on I2C bus activities.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_EN</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_STATUS_IC_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_STATUS_IC_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_STATUS_IC_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_STATUS_IC_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_STATUS_IC_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_STATUS_IC_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_STATUS_IC_EN_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_STATUS_IC_EN_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3730</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ic_en Status.</csr:p>
         <csr:p>This bit always reflects the value driven</csr:p>
         <csr:p>on the output port ic_en.</csr:p>
         <csr:p> - When read as 1, DW_apb_i2c is deemed to be in an enabled state.</csr:p>
         <csr:p> - When read as 0, DW_apb_i2c is deemed completely inactive.</csr:p>
         <csr:p>Note:  The CPU can safely read this bit anytime.</csr:p>
         <csr:p>When this bit is read as 0, the CPU can safely</csr:p>
         <csr:p>read SLV_RX_DATA_LOST (bit 2) and</csr:p>
         <csr:p>SLV_DISABLED_WHILE_BUSY (bit 1).</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>I2C disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>I2C enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SLV_DISABLED_WHILE_BUSY</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3782</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Slave Disabled While Busy (Transmit, Receive).</csr:p>
         <csr:p>This bit indicates if a potential or active Slave</csr:p>
         <csr:p>operation has been aborted due to the setting bit 0 of</csr:p>
         <csr:p>the IC_ENABLE register from 1 to 0. This bit is set</csr:p>
         <csr:p>when the CPU writes a 0 to the IC_ENABLE register</csr:p>
         <csr:p>while:</csr:p>
         <csr:p> </csr:p>
         <csr:p>(a) DW_apb_i2c is receiving the address byte</csr:p>
         <csr:p>of the Slave-Transmitter operation from a remote master;</csr:p>
         <csr:p></csr:p>
         <csr:p>OR, </csr:p>
         <csr:p></csr:p>
         <csr:p>(b) address and data bytes of the Slave-Receiver</csr:p>
         <csr:p>operation from a remote master.</csr:p>
         <csr:p></csr:p>
         <csr:p>When read as 1, DW_apb_i2c is deemed to have forced a</csr:p>
         <csr:p>NACK during any part of an I2C transfer, irrespective</csr:p>
         <csr:p>of whether the I2C address matches the slave address set</csr:p>
         <csr:p>in DW_apb_i2c (IC_SAR register) OR if the transfer is</csr:p>
         <csr:p>completed before IC_ENABLE is set to 0 but has not</csr:p>
         <csr:p>taken effect.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note:  If the remote I2C master terminates the transfer</csr:p>
         <csr:p>with a STOP condition before the DW_apb_i2c has a chance</csr:p>
         <csr:p>to NACK a transfer, and IC_ENABLE[0] has been set to 0, then</csr:p>
         <csr:p>this bit will also be set to 1.</csr:p>
         <csr:p></csr:p>
         <csr:p>When read as 0, DW_apb_i2c is deemed to have been disabled</csr:p>
         <csr:p>when there is master activity, or when the I2C bus is idle.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note:  The CPU can safely read this bit when IC_EN (bit 0)</csr:p>
         <csr:p>is read as 0.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Slave is disabled when it is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Slave is disabled when it is idle</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SLV_RX_DATA_LOST</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3828</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Slave Received Data Lost.</csr:p>
         <csr:p>This bit indicates if a Slave-Receiver operation has been</csr:p>
         <csr:p>aborted with at least one data byte received from an</csr:p>
         <csr:p>I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0.</csr:p>
         <csr:p>When read as 1, DW_apb_i2c is deemed to have been actively engaged</csr:p>
         <csr:p>in an aborted I2C transfer (with matching address) and the</csr:p>
         <csr:p>data phase of the I2C transfer has been entered, even though</csr:p>
         <csr:p>a data byte has been responded with a NACK.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note:  If the remote I2C master terminates the transfer with a</csr:p>
         <csr:p>STOP condition before the DW_apb_i2c has a chance to NACK a</csr:p>
         <csr:p>transfer, and IC_ENABLE[0] has been set to 0, then this bit is</csr:p>
         <csr:p>also set to 1.</csr:p>
         <csr:p></csr:p>
         <csr:p>When read as 0, DW_apb_i2c is deemed to have been disabled without</csr:p>
         <csr:p>being actively involved in the data phase of a Slave-Receiver transfer.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note:  The CPU can safely read this bit when IC_EN (bit 0) is</csr:p>
         <csr:p>read as 0.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Slave RX Data is lost</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Slave RX Data is not lost</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_ENABLE_STATUS</csr:identifier>
         <csr:widthMacro>I2C_IC_ENABLE_STATUS_RSVD_IC_ENABLE_STATUS_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_ENABLE_STATUS_RSVD_IC_ENABLE_STATUS_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_ENABLE_STATUS_RSVD_IC_ENABLE_STATUS_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_ENABLE_STATUS_RSVD_IC_ENABLE_STATUS_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_ENABLE_STATUS_RSVD_IC_ENABLE_STATUS_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_ENABLE_STATUS_RSVD_IC_ENABLE_STATUS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_ENABLE_STATUS_RSVD_IC_ENABLE_STATUS_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_ENABLE_STATUS_RSVD_IC_ENABLE_STATUS_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3834</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_ENABLE_STATUS Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_FS_SPKLEN</csr:referenceName>
       <csr:identifier>IC_FS_SPKLEN</csr:identifier>
       <csr:addressMacro>I2C_IC_FS_SPKLEN_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_FS_SPKLEN_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_FS_SPKLEN_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_FS_SPKLEN_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>3882</csr:linenumber>
       <csr:title>I2C SS, FS or FM+  spike suppression limit</csr:title>
       <csr:offset>0xA0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000001</csr:registerResetValue>
       <csr:typeName>I2c_IC_FS_SPKLEN</csr:typeName>
        <csr:description>
         <csr:p>I2C SS, FS or FM+  spike suppression limit</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is used to store the duration, measured in ic_clk cycles,</csr:p>
         <csr:p>of the longest spike that is filtered out by the spike suppression logic w</csr:p>
         <csr:p>hen the component is operating in SS, FS or FM+ modes. </csr:p>
         <csr:p>The relevant I2C requirement is tSP (table 4) as detailed in the </csr:p>
         <csr:p>I2C Bus Specification. This register must be programmed with a minimum value of 1.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_FS_SPKLEN</csr:identifier>
         <csr:widthMacro>I2C_IC_FS_SPKLEN_IC_FS_SPKLEN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_FS_SPKLEN_IC_FS_SPKLEN_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_FS_SPKLEN_IC_FS_SPKLEN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_FS_SPKLEN_IC_FS_SPKLEN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_FS_SPKLEN_IC_FS_SPKLEN_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_FS_SPKLEN_IC_FS_SPKLEN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_FS_SPKLEN_IC_FS_SPKLEN_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_FS_SPKLEN_IC_FS_SPKLEN_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3874</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This register must be set before any I2C bus transaction can take place to</csr:p>
         <csr:p>ensure stable operation. This register sets the duration, measured in ic_clk cycles,</csr:p>
         <csr:p>of the longest spike in the SCL or SDA lines that will be filtered out by the spike </csr:p>
         <csr:p>suppression logic.</csr:p>
         <csr:p>This register can be written only when the I2C interface is disabled which</csr:p>
         <csr:p>corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times</csr:p>
         <csr:p>have no effect.</csr:p>
         <csr:p>The minimum valid value is 1; hardware prevents values less than this being</csr:p>
         <csr:p>written, and if attempted results in 1 being set. or more information, refer to "Spike Suppression".</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x01</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_FS_SPKLEN</csr:identifier>
         <csr:widthMacro>I2C_IC_FS_SPKLEN_RSVD_IC_FS_SPKLEN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_FS_SPKLEN_RSVD_IC_FS_SPKLEN_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_FS_SPKLEN_RSVD_IC_FS_SPKLEN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_FS_SPKLEN_RSVD_IC_FS_SPKLEN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_FS_SPKLEN_RSVD_IC_FS_SPKLEN_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_FS_SPKLEN_RSVD_IC_FS_SPKLEN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_FS_SPKLEN_RSVD_IC_FS_SPKLEN_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_FS_SPKLEN_RSVD_IC_FS_SPKLEN_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3881</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_FS_SPKLEN Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SCL_STUCK_AT_LOW_TIMEOUT</csr:referenceName>
       <csr:identifier>IC_SCL_STUCK_AT_LOW_TIMEOUT</csr:identifier>
       <csr:addressMacro>I2C_IC_SCL_STUCK_AT_LOW_TIMEOUT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SCL_STUCK_AT_LOW_TIMEOUT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SCL_STUCK_AT_LOW_TIMEOUT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SCL_STUCK_AT_LOW_TIMEOUT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>3910</csr:linenumber>
       <csr:title>I2C SCL Stuck at Low Timeout register</csr:title>
       <csr:offset>0xAC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0xffffffff</csr:registerResetValue>
       <csr:typeName>I2c_IC_SCL_STUCK_AT_LOW_TIMEOUT</csr:typeName>
        <csr:description>
         <csr:p>I2C SCL Stuck at Low Timeout</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is used to store the duration, measured in ic_clk cycles, used to</csr:p>
         <csr:p>Generate an Interrupt (SCL_STUCK_AT_LOW) if SCL is held low for the IC_SCL_STUCK_LOW_TIMEOUT duration.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_SCL_STUCK_LOW_TIMEOUT</csr:identifier>
         <csr:widthMacro>I2C_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3909</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>DW_apb_i2c generate the interrupt to indicate SCL stuck at low</csr:p>
         <csr:p>(SCL_STUCK_AT_LOW) if it detects the SCL stuck at low for the IC_SCL_STUCK_LOW_TIMEOUT in units of ic_clk period.</csr:p>
         <csr:p>This register can be written only when the I2C interface is disabled which</csr:p>
         <csr:p>corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times</csr:p>
         <csr:p>have no effect.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0xffffffff</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SDA_STUCK_AT_LOW_TIMEOUT</csr:referenceName>
       <csr:identifier>IC_SDA_STUCK_AT_LOW_TIMEOUT</csr:identifier>
       <csr:addressMacro>I2C_IC_SDA_STUCK_AT_LOW_TIMEOUT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SDA_STUCK_AT_LOW_TIMEOUT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SDA_STUCK_AT_LOW_TIMEOUT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SDA_STUCK_AT_LOW_TIMEOUT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>3936</csr:linenumber>
       <csr:title>I2C SDA Stuck at Low Timeout register</csr:title>
       <csr:offset>0xB0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0xffffffff</csr:registerResetValue>
       <csr:typeName>I2c_IC_SDA_STUCK_AT_LOW_TIMEOUT</csr:typeName>
        <csr:description>
         <csr:p>I2C SDA Stuck at Low Timeout</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is used to store the duration, measured in ic_clk cycles, used to</csr:p>
         <csr:p>Recover the Data (SDA) line through sending SCL pulses if SDA is held low for the mentioned duration.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_SDA_STUCK_LOW_TIMEOUT</csr:identifier>
         <csr:widthMacro>I2C_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3935</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>DW_apb_i2c initiates the recovery of SDA line through enabling the</csr:p>
         <csr:p>SDA_STUCK_RECOVERY_EN (IC_ENABLE[3]) register bit, if it</csr:p>
         <csr:p>detects the SDA stuck at low for the</csr:p>
         <csr:p>IC_SDA_STUCK_LOW_TIMEOUT in units of ic_clk period.    </csr:p>
         <csr:p>    </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0xffffffff</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_SCL_STUCK_DET</csr:referenceName>
       <csr:identifier>IC_CLR_SCL_STUCK_DET</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_SCL_STUCK_DET_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_SCL_STUCK_DET_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_SCL_STUCK_DET_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_SCL_STUCK_DET_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>3958</csr:linenumber>
       <csr:title>Clear SCL Stuck at Low Detect interrupt Register</csr:title>
       <csr:offset>0xB4</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_SCL_STUCK_DET</csr:typeName>
        <csr:description>
         <csr:p>Clear SCL Stuck at Low Detect Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_SCL_STUCK_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3951</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Read this register to clear the SCL_STUCT_AT_LOW interrupt (bit 15) of the IC_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CLR_SCL_STUCK_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SCL_STUCK_DET_RSVD_CLR_SCL_STUCK_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SCL_STUCK_DET_RSVD_CLR_SCL_STUCK_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SCL_STUCK_DET_RSVD_CLR_SCL_STUCK_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SCL_STUCK_DET_RSVD_CLR_SCL_STUCK_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SCL_STUCK_DET_RSVD_CLR_SCL_STUCK_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SCL_STUCK_DET_RSVD_CLR_SCL_STUCK_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SCL_STUCK_DET_RSVD_CLR_SCL_STUCK_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SCL_STUCK_DET_RSVD_CLR_SCL_STUCK_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3957</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CLR_SCL_STUCK_DET Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SMBUS_CLK_LOW_SEXT</csr:referenceName>
       <csr:identifier>IC_SMBUS_CLK_LOW_SEXT</csr:identifier>
       <csr:addressMacro>I2C_IC_SMBUS_CLK_LOW_SEXT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SMBUS_CLK_LOW_SEXT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SMBUS_CLK_LOW_SEXT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SMBUS_CLK_LOW_SEXT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>3989</csr:linenumber>
       <csr:title>SMBus Slave Clock Extend Timeout register</csr:title>
       <csr:offset>0xBC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0xffffffff</csr:registerResetValue>
       <csr:typeName>I2c_IC_SMBUS_CLK_LOW_SEXT</csr:typeName>
        <csr:description>
         <csr:p>SMBus Slave Clock Extend Timeout Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This Register contains the Timeout value used to determine the Slave Clock Extend Timeout </csr:p>
         <csr:p>in one transfer (from START to STOP).</csr:p>
         <csr:p>This Register can be written only when the DW_apb_i2c is disabled, which corresponds to IC_ENABLE[0] being set to 0. This register is present only if configuration parameter IC_SMBUS is set to 1.</csr:p>
         <csr:p>This register is used to store the duration, measured in ic_clk cycles, used to detect the slave clock extend timeout </csr:p>
         <csr:p>if slave extends the clock (SCL) for the mentioned duration.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SMBUS_CLK_LOW_SEXT_TIMEOUT</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_CLK_LOW_SEXT_SMBUS_CLK_LOW_SEXT_TIMEOUT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_CLK_LOW_SEXT_SMBUS_CLK_LOW_SEXT_TIMEOUT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_CLK_LOW_SEXT_SMBUS_CLK_LOW_SEXT_TIMEOUT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_CLK_LOW_SEXT_SMBUS_CLK_LOW_SEXT_TIMEOUT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_CLK_LOW_SEXT_SMBUS_CLK_LOW_SEXT_TIMEOUT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_CLK_LOW_SEXT_SMBUS_CLK_LOW_SEXT_TIMEOUT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_CLK_LOW_SEXT_SMBUS_CLK_LOW_SEXT_TIMEOUT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_CLK_LOW_SEXT_SMBUS_CLK_LOW_SEXT_TIMEOUT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>3988</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This field is used to detect the Slave Clock Extend timeout (tLOW:SEXT) in master mode</csr:p>
         <csr:p>extended by the slave device in one message from the initial START to the STOP.</csr:p>
         <csr:p>The values in this register are in units of ic_clk period.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0xffffffff</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SMBUS_CLK_LOW_MEXT</csr:referenceName>
       <csr:identifier>IC_SMBUS_CLK_LOW_MEXT</csr:identifier>
       <csr:addressMacro>I2C_IC_SMBUS_CLK_LOW_MEXT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SMBUS_CLK_LOW_MEXT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SMBUS_CLK_LOW_MEXT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SMBUS_CLK_LOW_MEXT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>4021</csr:linenumber>
       <csr:title>SMBus Master Clock Extend Timeout register</csr:title>
       <csr:offset>0xC0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0xffffffff</csr:registerResetValue>
       <csr:typeName>I2c_IC_SMBUS_CLK_LOW_MEXT</csr:typeName>
        <csr:description>
         <csr:p>SMBus Master Clock Extend Timeout Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This Register contains the Timeout value used to determine the Master Clock Extend Timeout </csr:p>
         <csr:p>in one byte of transfer.</csr:p>
         <csr:p>This Register can be written only when the DW_apb_i2c is disabled, which corresponds to IC_ENABLE[0] being set to 0.</csr:p>
         <csr:p>This register is present only if configuration parameter IC_SMBUS is set to 1. </csr:p>
         <csr:p>This register is used to store the duration, measured in ic_clk cycles, used to detect</csr:p>
         <csr:p>the Master clock extend timeout if Master extends the clock (SCL) for the mentioned duration.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SMBUS_CLK_LOW_MEXT_TIMEOUT</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_CLK_LOW_MEXT_SMBUS_CLK_LOW_MEXT_TIMEOUT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_CLK_LOW_MEXT_SMBUS_CLK_LOW_MEXT_TIMEOUT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_CLK_LOW_MEXT_SMBUS_CLK_LOW_MEXT_TIMEOUT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_CLK_LOW_MEXT_SMBUS_CLK_LOW_MEXT_TIMEOUT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_CLK_LOW_MEXT_SMBUS_CLK_LOW_MEXT_TIMEOUT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_CLK_LOW_MEXT_SMBUS_CLK_LOW_MEXT_TIMEOUT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_CLK_LOW_MEXT_SMBUS_CLK_LOW_MEXT_TIMEOUT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_CLK_LOW_MEXT_SMBUS_CLK_LOW_MEXT_TIMEOUT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4020</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This field is used to detect the Master extend SMBus clock (SCLK) timeout defined </csr:p>
         <csr:p>from START-to-ACK, ACK-to-ACK, or ACK-to-STOP in Master mode.</csr:p>
         <csr:p>The values in this register are in units of ic_clk period.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0xffffffff</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SMBUS_THIGH_MAX_IDLE_COUNT</csr:referenceName>
       <csr:identifier>IC_SMBUS_THIGH_MAX_IDLE_COUNT</csr:identifier>
       <csr:addressMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>4062</csr:linenumber>
       <csr:title>SMBus Master THigh MAX Bus-idle count Register</csr:title>
       <csr:offset>0xC4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0000ffff</csr:registerResetValue>
       <csr:typeName>I2c_IC_SMBUS_THIGH_MAX_IDLE_COUNT</csr:typeName>
        <csr:description>
         <csr:p>SMBus Master THigh MAX Bus-idle count Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This register programs the Bus-idle time period used when a master has been dynamically added to the </csr:p>
         <csr:p>bus or when a master has generated a clock reset on the bus. This register is used to store the duration, </csr:p>
         <csr:p>measured in ic_clk cycles, used to detect the Bus Idle condition if SCL and SDA are held high for the </csr:p>
         <csr:p>mentioned duration. This register can be written only when the DW_apb_i2c is disabled, which corresponds to </csr:p>
         <csr:p>IC_ENABLE[0] being set to 0. This register is present only if configuration parameter IC_SMBUS is set to 1.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SMBUS_THIGH_MAX_BUS_IDLE_CNT</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_SMBUS_THIGH_MAX_BUS_IDLE_CNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_SMBUS_THIGH_MAX_BUS_IDLE_CNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_SMBUS_THIGH_MAX_BUS_IDLE_CNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_SMBUS_THIGH_MAX_BUS_IDLE_CNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_SMBUS_THIGH_MAX_BUS_IDLE_CNT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_SMBUS_THIGH_MAX_BUS_IDLE_CNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_SMBUS_THIGH_MAX_BUS_IDLE_CNT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_SMBUS_THIGH_MAX_BUS_IDLE_CNT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4054</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This field is used to set the required Bus-Idle time period used when a master has been dynamically added to the bus and may</csr:p>
         <csr:p>not have detected a state transition on the SMBCLK or SMBDAT lines.</csr:p>
         <csr:p></csr:p>
         <csr:p>In this case, the master must wait long enough to ensure that a transfer is not currently in progress</csr:p>
         <csr:p>The values in this register are in units of ic_clk period.</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0xffff</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SMBUS_THIGH_MAX_BUS_IDLE_CNT</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_RSVD_SMBUS_THIGH_MAX_BUS_IDLE_CNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_RSVD_SMBUS_THIGH_MAX_BUS_IDLE_CNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_RSVD_SMBUS_THIGH_MAX_BUS_IDLE_CNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_RSVD_SMBUS_THIGH_MAX_BUS_IDLE_CNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_RSVD_SMBUS_THIGH_MAX_BUS_IDLE_CNT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_RSVD_SMBUS_THIGH_MAX_BUS_IDLE_CNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_RSVD_SMBUS_THIGH_MAX_BUS_IDLE_CNT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_THIGH_MAX_IDLE_COUNT_RSVD_SMBUS_THIGH_MAX_BUS_IDLE_CNT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4061</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SMBUS_THIGH_MAX_BUS_IDLE_CNT Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SMBUS_INTR_STAT</csr:referenceName>
       <csr:identifier>IC_SMBUS_INTR_STAT</csr:identifier>
       <csr:addressMacro>I2C_IC_SMBUS_INTR_STAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SMBUS_INTR_STAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SMBUS_INTR_STAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SMBUS_INTR_STAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>4213</csr:linenumber>
       <csr:title>SMBus Interrupt Status Register</csr:title>
       <csr:offset>0xC8</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_SMBUS_INTR_STAT</csr:typeName>
        <csr:description>
         <csr:p>SMBUS Interrupt Status Register</csr:p>
         <csr:p></csr:p>
         <csr:p>Each bit in this register has a corresponding mask bit</csr:p>
         <csr:p>in the IC_SMBUS_INTR_MASK register. These bits are cleared by writing the matching</csr:p>
         <csr:p>SMBus interrupt clear register(IC_CLR_SMBUS_INTR) bits. The unmasked raw versions of these bits are</csr:p>
         <csr:p>available in the IC_SMBUS_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>R_SLV_CLOCK_EXTND_TIMEOUT</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_STAT_R_SLV_CLOCK_EXTND_TIMEOUT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_STAT_R_SLV_CLOCK_EXTND_TIMEOUT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_STAT_R_SLV_CLOCK_EXTND_TIMEOUT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_STAT_R_SLV_CLOCK_EXTND_TIMEOUT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_STAT_R_SLV_CLOCK_EXTND_TIMEOUT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_STAT_R_SLV_CLOCK_EXTND_TIMEOUT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_STAT_R_SLV_CLOCK_EXTND_TIMEOUT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_STAT_R_SLV_CLOCK_EXTND_TIMEOUT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4097</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_SMBUS_INTR_RAW_STATUS for a detailed description of R_SLV_CLOCK_EXTND_TIMEOUT bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>SLV_CLOCK_EXTND_TIMEOUT interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>SLV_CLOCK_EXTND_TIMEOUT interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_MST_CLOCK_EXTND_TIMEOUT</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_STAT_R_MST_CLOCK_EXTND_TIMEOUT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_STAT_R_MST_CLOCK_EXTND_TIMEOUT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_STAT_R_MST_CLOCK_EXTND_TIMEOUT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_STAT_R_MST_CLOCK_EXTND_TIMEOUT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_STAT_R_MST_CLOCK_EXTND_TIMEOUT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_STAT_R_MST_CLOCK_EXTND_TIMEOUT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_STAT_R_MST_CLOCK_EXTND_TIMEOUT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_STAT_R_MST_CLOCK_EXTND_TIMEOUT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4118</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_SMBUS_INTR_RAW_STATUS for a detailed description of R_MST_CLOCK_EXTND_TIMEOUT bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>MST_CLOCK_EXTND_TIMEOUT interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>MST_CLOCK_EXTND_TIMEOUT interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_QUICK_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_STAT_R_QUICK_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_STAT_R_QUICK_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_STAT_R_QUICK_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_STAT_R_QUICK_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_STAT_R_QUICK_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_STAT_R_QUICK_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_STAT_R_QUICK_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_STAT_R_QUICK_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4139</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_SMBUS_INTR_RAW_STATUS for a detailed description of R_QUICK_CMD_DET bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>QUICK_CMD_DET interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>QUICK_CMD_DET interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>R_HOST_NOTIFY_MST_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_STAT_R_HOST_NOTIFY_MST_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_STAT_R_HOST_NOTIFY_MST_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_STAT_R_HOST_NOTIFY_MST_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_STAT_R_HOST_NOTIFY_MST_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_STAT_R_HOST_NOTIFY_MST_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_STAT_R_HOST_NOTIFY_MST_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_STAT_R_HOST_NOTIFY_MST_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_STAT_R_HOST_NOTIFY_MST_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4160</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>See IC_SMBUS_INTR_RAW_STATUS for a detailed description of R_HOST_NOTIFY_MST_DET bit.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>HOST_NOTIFY_MST_DET interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>HOST_NOTIFY_MST_DET interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_R_ARP_PREPARE_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_PREPARE_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_PREPARE_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_PREPARE_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_PREPARE_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_PREPARE_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_PREPARE_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_PREPARE_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_PREPARE_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4167</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>R_ARP_PREPARE_CMD_DET Regsiter field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_R_ARP_RST_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_RST_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_RST_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_RST_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_RST_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_RST_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_RST_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_RST_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_RST_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4173</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>R_ARP_RST_CMD_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_R_ARP_GET_UDID_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_GET_UDID_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_GET_UDID_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_GET_UDID_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_GET_UDID_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_GET_UDID_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_GET_UDID_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_GET_UDID_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_GET_UDID_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4180</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>R_ARP_GET_UDID_CMD_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_R_ARP_ASSGN_ADDR_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_ASSGN_ADDR_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_ASSGN_ADDR_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_ASSGN_ADDR_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_ASSGN_ADDR_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_ASSGN_ADDR_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_ASSGN_ADDR_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_ASSGN_ADDR_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_ARP_ASSGN_ADDR_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4187</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>R_ARP_ASSGN_ADDR_CMD_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_R_SLV_RX_PEC_NACK</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SLV_RX_PEC_NACK_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SLV_RX_PEC_NACK_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SLV_RX_PEC_NACK_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SLV_RX_PEC_NACK_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SLV_RX_PEC_NACK_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SLV_RX_PEC_NACK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SLV_RX_PEC_NACK_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SLV_RX_PEC_NACK_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4193</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>R_SLV_RX_PEC_NACK Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_R_SMBUS_SUSPEND_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_SUSPEND_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_SUSPEND_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_SUSPEND_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_SUSPEND_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_SUSPEND_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_SUSPEND_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_SUSPEND_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_SUSPEND_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4200</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>R_SMBUS_SUSPEND_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_R_SMBUS_ALERT_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_ALERT_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_ALERT_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_ALERT_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_ALERT_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_ALERT_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_ALERT_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_ALERT_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_R_SMBUS_ALERT_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4206</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>R_SMBUS_ALERT_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_SMBUS_INTR_STAT</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_IC_SMBUS_INTR_STAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_IC_SMBUS_INTR_STAT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_IC_SMBUS_INTR_STAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_IC_SMBUS_INTR_STAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_IC_SMBUS_INTR_STAT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_IC_SMBUS_INTR_STAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_IC_SMBUS_INTR_STAT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_STAT_RSVD_IC_SMBUS_INTR_STAT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4212</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_SMBUS_INTR_STAT Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SMBUS_INTR_MASK</csr:referenceName>
       <csr:identifier>IC_SMBUS_INTR_MASK</csr:identifier>
       <csr:addressMacro>I2C_IC_SMBUS_INTR_MASK_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SMBUS_INTR_MASK_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SMBUS_INTR_MASK_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SMBUS_INTR_MASK_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>4321</csr:linenumber>
       <csr:title>SMBus Interrupt Mask Register</csr:title>
       <csr:offset>0xCC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x0000000f</csr:registerResetValue>
       <csr:typeName>I2c_IC_SMBUS_INTR_MASK</csr:typeName>
        <csr:description>
         <csr:p>SMBus Interrupt Mask Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>M_SLV_CLOCK_EXTND_TIMEOUT</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_MASK_M_SLV_CLOCK_EXTND_TIMEOUT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_MASK_M_SLV_CLOCK_EXTND_TIMEOUT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_MASK_M_SLV_CLOCK_EXTND_TIMEOUT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_MASK_M_SLV_CLOCK_EXTND_TIMEOUT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_MASK_M_SLV_CLOCK_EXTND_TIMEOUT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_MASK_M_SLV_CLOCK_EXTND_TIMEOUT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_MASK_M_SLV_CLOCK_EXTND_TIMEOUT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_MASK_M_SLV_CLOCK_EXTND_TIMEOUT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4238</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_SLV_CLOCK_EXTND_TIMEOUT interrupt in IC_SMBUS_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>SLV_CLOCK_EXTND_TIMEOUT interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>SLV_CLOCK_EXTND_TIMEOUT interrupt is masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_MST_CLOCK_EXTND_TIMEOUT</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_MASK_M_MST_CLOCK_EXTND_TIMEOUT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_MASK_M_MST_CLOCK_EXTND_TIMEOUT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_MASK_M_MST_CLOCK_EXTND_TIMEOUT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_MASK_M_MST_CLOCK_EXTND_TIMEOUT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_MASK_M_MST_CLOCK_EXTND_TIMEOUT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_MASK_M_MST_CLOCK_EXTND_TIMEOUT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_MASK_M_MST_CLOCK_EXTND_TIMEOUT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_MASK_M_MST_CLOCK_EXTND_TIMEOUT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4258</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_MST_CLOCK_EXTND_TIMEOUT interrupt in IC_SMBUS_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>MST_CLOCK_EXTND_TIMEOUT interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>MST_CLOCK_EXTND_TIMEOUT interrupt is masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_QUICK_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_MASK_M_QUICK_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_MASK_M_QUICK_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_MASK_M_QUICK_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_MASK_M_QUICK_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_MASK_M_QUICK_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_MASK_M_QUICK_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_MASK_M_QUICK_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_MASK_M_QUICK_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4278</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_QUICK_CMD_DET interrupt in IC_SMBUS_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>QUICK_CMD_DET interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>QUICK_CMD_DET interrupt is masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>M_HOST_NOTIFY_MST_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_MASK_M_HOST_NOTIFY_MST_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_MASK_M_HOST_NOTIFY_MST_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_MASK_M_HOST_NOTIFY_MST_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_MASK_M_HOST_NOTIFY_MST_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_MASK_M_HOST_NOTIFY_MST_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_MASK_M_HOST_NOTIFY_MST_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_MASK_M_HOST_NOTIFY_MST_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_MASK_M_HOST_NOTIFY_MST_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4298</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This bit masks the R_HOST_NOTIFY_MST_DET interrupt in IC_SMBUS_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>HOST_NOTIFY_MST_DET interrupt is unmasked</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>HOST_NOTIFY_MST_DET interrupt is masked</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_M_ARP_4_8</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_M_ARP_4_8_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_M_ARP_4_8_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_M_ARP_4_8_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_M_ARP_4_8_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_M_ARP_4_8_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_M_ARP_4_8_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_M_ARP_4_8_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_M_ARP_4_8_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4306</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RSVD_M_ARP_4_8 Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_SMBUS_INTR_MASK_9_10</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_9_10_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_9_10_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_9_10_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_9_10_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_9_10_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_9_10_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_9_10_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_9_10_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4313</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>RSVD_IC_SMBUS_INTR_MASK_9_10 Register field Reserved bits.</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_SMBUS_INTR_MASK</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_INTR_MASK_RSVD_IC_SMBUS_INTR_MASK_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4320</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_SMBUS_INTR_MASK Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_SMBUS_RAW_INTR_STAT</csr:referenceName>
       <csr:identifier>IC_SMBUS_RAW_INTR_STAT</csr:identifier>
       <csr:addressMacro>I2C_IC_SMBUS_RAW_INTR_STAT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_SMBUS_RAW_INTR_STAT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>4482</csr:linenumber>
       <csr:title>SMBus Raw Interrupt Status Register</csr:title>
       <csr:offset>0xD0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_SMBUS_RAW_INTR_STAT</csr:typeName>
        <csr:description>
         <csr:p>SMBus Raw Interrupt Status Register</csr:p>
         <csr:p></csr:p>
         <csr:p>Unlike the IC_SMBUS_INTR_STAT register, these bits are not masked so they</csr:p>
         <csr:p>always show the true status of the DW_apb_i2c.</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SLV_CLOCK_EXTND_TIMEOUT</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_RAW_INTR_STAT_SLV_CLOCK_EXTND_TIMEOUT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_SLV_CLOCK_EXTND_TIMEOUT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_SLV_CLOCK_EXTND_TIMEOUT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_RAW_INTR_STAT_SLV_CLOCK_EXTND_TIMEOUT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_SLV_CLOCK_EXTND_TIMEOUT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_RAW_INTR_STAT_SLV_CLOCK_EXTND_TIMEOUT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_RAW_INTR_STAT_SLV_CLOCK_EXTND_TIMEOUT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_RAW_INTR_STAT_SLV_CLOCK_EXTND_TIMEOUT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4357</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Indicates whether the transaction from Slave (i.e from START to STOP) exceeds IC_SMBUS_CLK_LOW_SEXT time.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is enabled only when:</csr:p>
         <csr:p> - IC_SMBUS=1</csr:p>
         <csr:p> - IC_CON[0]=1</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Slave Clock Extend Timeout interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Slave Clock Extend Timeout interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>MST_CLOCK_EXTND_TIMEOUT</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_RAW_INTR_STAT_MST_CLOCK_EXTND_TIMEOUT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_MST_CLOCK_EXTND_TIMEOUT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_MST_CLOCK_EXTND_TIMEOUT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_RAW_INTR_STAT_MST_CLOCK_EXTND_TIMEOUT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_MST_CLOCK_EXTND_TIMEOUT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_RAW_INTR_STAT_MST_CLOCK_EXTND_TIMEOUT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_RAW_INTR_STAT_MST_CLOCK_EXTND_TIMEOUT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_RAW_INTR_STAT_MST_CLOCK_EXTND_TIMEOUT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4386</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Indicates whether the Master device transaction (START-to-ACK, ACK-to-ACK, or ACK-to-STOP) </csr:p>
         <csr:p>from START to STOP exceeds IC_SMBUS_CLOCK_LOW_MEXT time with in each byte of message.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is enabled only when:</csr:p>
         <csr:p> - IC_SMBUS=1</csr:p>
         <csr:p> - IC_CON[0]=1</csr:p>
         <csr:p> - IC_EMPTYFIFO_HOLD_MASTER_EN=1 or</csr:p>
         <csr:p> - IC_RX_FULL_HLD_BUS_EN=1</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master Clock Extend Timeout interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master Clock Extend Timeout interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>QUICK_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_RAW_INTR_STAT_QUICK_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_QUICK_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_QUICK_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_RAW_INTR_STAT_QUICK_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_QUICK_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_RAW_INTR_STAT_QUICK_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_RAW_INTR_STAT_QUICK_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_RAW_INTR_STAT_QUICK_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4409</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Indicates whether a Quick command has been received on the SMBus interface regardless of </csr:p>
         <csr:p>whether DW_apb_i2c is operating in slave or master mode.</csr:p>
         <csr:p>Enabled only when IC_SMBUS=1 is set to 1.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Quick Command interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Quick Command interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>HOST_NTFY_MST_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_RAW_INTR_STAT_HOST_NTFY_MST_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_HOST_NTFY_MST_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_HOST_NTFY_MST_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_RAW_INTR_STAT_HOST_NTFY_MST_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_HOST_NTFY_MST_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_RAW_INTR_STAT_HOST_NTFY_MST_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_RAW_INTR_STAT_HOST_NTFY_MST_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_RAW_INTR_STAT_HOST_NTFY_MST_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4430</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Indicates whether a Notify ARP Master ARP command has been received.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>ACTIVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>HOST_NTFY_MST_DET interrupt is active</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INACTIVE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>HOST_NTFY_MST_DET interrupt is inactive</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_ARP_PREPARE_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_PREPARE_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_PREPARE_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_PREPARE_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_PREPARE_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_PREPARE_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_PREPARE_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_PREPARE_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_PREPARE_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4437</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ARP_PREPARE_CMD_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_ARP_RST_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_RST_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_RST_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_RST_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_RST_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_RST_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_RST_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_RST_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_RST_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4443</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ARP_RST_CMD_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_ARP_GET_UDID_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_GET_UDID_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_GET_UDID_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_GET_UDID_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_GET_UDID_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_GET_UDID_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_GET_UDID_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_GET_UDID_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_GET_UDID_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4450</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ARP_GET_UDID_CMD_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_ARP_ASSGN_ADDR_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_ASSGN_ADDR_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_ASSGN_ADDR_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_ASSGN_ADDR_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_ASSGN_ADDR_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_ASSGN_ADDR_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_ASSGN_ADDR_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_ASSGN_ADDR_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_ARP_ASSGN_ADDR_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4457</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>ARP_ASSGN_ADDR_CMD_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SLV_RX_PEC_NACK</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SLV_RX_PEC_NACK_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SLV_RX_PEC_NACK_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SLV_RX_PEC_NACK_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SLV_RX_PEC_NACK_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SLV_RX_PEC_NACK_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SLV_RX_PEC_NACK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SLV_RX_PEC_NACK_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SLV_RX_PEC_NACK_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4463</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SLV_RX_PEC_NACK Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SMBUS_SUSPEND_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_SUSPEND_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_SUSPEND_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_SUSPEND_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_SUSPEND_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_SUSPEND_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_SUSPEND_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_SUSPEND_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_SUSPEND_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4469</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SMBUS_SUSPEND_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_SMBUS_ALERT_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_ALERT_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_ALERT_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_ALERT_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_ALERT_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_ALERT_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_ALERT_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_ALERT_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_SMBUS_ALERT_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4475</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>SMBUS_ALERT_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_SMBUS_RAW_INTR_STAT</csr:identifier>
         <csr:widthMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_IC_SMBUS_RAW_INTR_STAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_IC_SMBUS_RAW_INTR_STAT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_IC_SMBUS_RAW_INTR_STAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_IC_SMBUS_RAW_INTR_STAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_IC_SMBUS_RAW_INTR_STAT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_IC_SMBUS_RAW_INTR_STAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_IC_SMBUS_RAW_INTR_STAT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_SMBUS_RAW_INTR_STAT_RSVD_IC_SMBUS_RAW_INTR_STAT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4481</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_SMBUS_RAW_INTR_STAT Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_CLR_SMBUS_INTR</csr:referenceName>
       <csr:identifier>IC_CLR_SMBUS_INTR</csr:identifier>
       <csr:addressMacro>I2C_IC_CLR_SMBUS_INTR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_CLR_SMBUS_INTR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_CLR_SMBUS_INTR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_CLR_SMBUS_INTR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>4582</csr:linenumber>
       <csr:title>Clear SMBus Interrupt Register</csr:title>
       <csr:offset>0xD4</csr:offset>
       <csr:addressedAccess>W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I2c_IC_CLR_SMBUS_INTR</csr:typeName>
        <csr:description>
         <csr:p>SMBus Clear Interrupt Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CLR_SLV_CLOCK_EXTND_TIMEOUT</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SMBUS_INTR_CLR_SLV_CLOCK_EXTND_TIMEOUT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SMBUS_INTR_CLR_SLV_CLOCK_EXTND_TIMEOUT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SMBUS_INTR_CLR_SLV_CLOCK_EXTND_TIMEOUT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SMBUS_INTR_CLR_SLV_CLOCK_EXTND_TIMEOUT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SMBUS_INTR_CLR_SLV_CLOCK_EXTND_TIMEOUT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SMBUS_INTR_CLR_SLV_CLOCK_EXTND_TIMEOUT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SMBUS_INTR_CLR_SLV_CLOCK_EXTND_TIMEOUT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SMBUS_INTR_CLR_SLV_CLOCK_EXTND_TIMEOUT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4498</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Write this register bit to clear the SLV_CLOCK_EXTND_TIMEOUT</csr:p>
         <csr:p>interrupt (bit 0) of the IC_SMBUS_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CLR_MST_CLOCK_EXTND_TIMEOUT</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SMBUS_INTR_CLR_MST_CLOCK_EXTND_TIMEOUT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SMBUS_INTR_CLR_MST_CLOCK_EXTND_TIMEOUT_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SMBUS_INTR_CLR_MST_CLOCK_EXTND_TIMEOUT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SMBUS_INTR_CLR_MST_CLOCK_EXTND_TIMEOUT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SMBUS_INTR_CLR_MST_CLOCK_EXTND_TIMEOUT_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SMBUS_INTR_CLR_MST_CLOCK_EXTND_TIMEOUT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SMBUS_INTR_CLR_MST_CLOCK_EXTND_TIMEOUT_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SMBUS_INTR_CLR_MST_CLOCK_EXTND_TIMEOUT_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4508</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Write this register bit to clear the MST_CLOCK_EXTND_TIMEOUT</csr:p>
         <csr:p>interrupt (bit 1) of the IC_SMBUS_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CLR_QUICK_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SMBUS_INTR_CLR_QUICK_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SMBUS_INTR_CLR_QUICK_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SMBUS_INTR_CLR_QUICK_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SMBUS_INTR_CLR_QUICK_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SMBUS_INTR_CLR_QUICK_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SMBUS_INTR_CLR_QUICK_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SMBUS_INTR_CLR_QUICK_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SMBUS_INTR_CLR_QUICK_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4517</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Write this register bit to clear the QUICK_CMD_DET</csr:p>
         <csr:p>interrupt (bit 2) of the IC_SMBUS_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CLR_HOST_NOTIFY_MST_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SMBUS_INTR_CLR_HOST_NOTIFY_MST_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SMBUS_INTR_CLR_HOST_NOTIFY_MST_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SMBUS_INTR_CLR_HOST_NOTIFY_MST_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SMBUS_INTR_CLR_HOST_NOTIFY_MST_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SMBUS_INTR_CLR_HOST_NOTIFY_MST_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SMBUS_INTR_CLR_HOST_NOTIFY_MST_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SMBUS_INTR_CLR_HOST_NOTIFY_MST_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SMBUS_INTR_CLR_HOST_NOTIFY_MST_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4526</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Write this register bit to clear the HOST_NOTIFY_MST_DET</csr:p>
         <csr:p>interrupt (bit 3) of the IC_SMBUS_RAW_INTR_STAT register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CLR_ARP_PREPARE_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_PREPARE_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_PREPARE_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_PREPARE_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_PREPARE_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_PREPARE_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_PREPARE_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_PREPARE_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_PREPARE_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4533</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CLR_ARP_PREPARE_CMD_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CLR_ARP_RST_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_RST_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_RST_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_RST_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_RST_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_RST_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_RST_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_RST_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_RST_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4540</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CLR_ARP_RST_CMD_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CLR_ARP_GET_UDID_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_GET_UDID_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_GET_UDID_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_GET_UDID_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_GET_UDID_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_GET_UDID_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_GET_UDID_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_GET_UDID_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_GET_UDID_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4547</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CLR_ARP_GET_UDID_CMD_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CLR_ARP_ASSGN_ADDR_CMD_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_ASSGN_ADDR_CMD_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_ASSGN_ADDR_CMD_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_ASSGN_ADDR_CMD_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_ASSGN_ADDR_CMD_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_ASSGN_ADDR_CMD_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_ASSGN_ADDR_CMD_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_ASSGN_ADDR_CMD_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_ARP_ASSGN_ADDR_CMD_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4554</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CLR_ARP_ASSGN_ADDR_CMD_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CLR_SLV_RX_PEC_NACK</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SLV_RX_PEC_NACK_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SLV_RX_PEC_NACK_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SLV_RX_PEC_NACK_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SLV_RX_PEC_NACK_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SLV_RX_PEC_NACK_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SLV_RX_PEC_NACK_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SLV_RX_PEC_NACK_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SLV_RX_PEC_NACK_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4561</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CLR_SLV_RX_PEC_NACK Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CLR_SMBUS_SUSPEND_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_SUSPEND_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_SUSPEND_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_SUSPEND_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_SUSPEND_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_SUSPEND_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_SUSPEND_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_SUSPEND_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_SUSPEND_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4568</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CLR_SMBUS_SUSPEND_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_CLR_SMBUS_ALERT_DET</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_ALERT_DET_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_ALERT_DET_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_ALERT_DET_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_ALERT_DET_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_ALERT_DET_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_ALERT_DET_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_ALERT_DET_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_CLR_SMBUS_ALERT_DET_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4575</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>CLR_SMBUS_ALERT_DET Register field Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_CLR_SMBUS_INTR</csr:identifier>
         <csr:widthMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_IC_CLR_SMBUS_INTR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_IC_CLR_SMBUS_INTR_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_IC_CLR_SMBUS_INTR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_IC_CLR_SMBUS_INTR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_IC_CLR_SMBUS_INTR_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_IC_CLR_SMBUS_INTR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_IC_CLR_SMBUS_INTR_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_CLR_SMBUS_INTR_RSVD_IC_CLR_SMBUS_INTR_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4581</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_CLR_SMBUS_INTR Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:access>W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.REG_TIMEOUT_RST</csr:referenceName>
       <csr:identifier>REG_TIMEOUT_RST</csr:identifier>
       <csr:addressMacro>I2C_REG_TIMEOUT_RST_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_REG_TIMEOUT_RST_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_REG_TIMEOUT_RST_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_REG_TIMEOUT_RST_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>4616</csr:linenumber>
       <csr:title>Register timeout counter reset value</csr:title>
       <csr:offset>0xF0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000008</csr:registerResetValue>
       <csr:typeName>I2c_REG_TIMEOUT_RST</csr:typeName>
        <csr:description>
         <csr:p>Name: Register timeout counter reset register</csr:p>
         <csr:p>Size: REG_TIMEOUT_WIDTH bits</csr:p>
         <csr:p>Address: 0xF0</csr:p>
         <csr:p>Read/Write Access: Read/Write</csr:p>
         <csr:p>This register keeps the timeout value of register timer counter. The reset value of the register is REG_TIMEOUT_VALUE. The default reset value can be further modified if HC_REG_TIMEOUT_VALUE = 0. The</csr:p>
         <csr:p>final programmed value (or the default reset value if not programmed) determines from what value the register timeout counter starts counting down. A zero on this counter will break the waited</csr:p>
         <csr:p>transaction with PSLVERR as high.</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>REG_TIMEOUT_RST_rw</csr:identifier>
         <csr:widthMacro>I2C_REG_TIMEOUT_RST_REG_TIMEOUT_RST_RW_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_REG_TIMEOUT_RST_REG_TIMEOUT_RST_RW_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_REG_TIMEOUT_RST_REG_TIMEOUT_RST_RW_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_REG_TIMEOUT_RST_REG_TIMEOUT_RST_RW_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_REG_TIMEOUT_RST_REG_TIMEOUT_RST_RW_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_REG_TIMEOUT_RST_REG_TIMEOUT_RST_RW_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_REG_TIMEOUT_RST_REG_TIMEOUT_RST_RW_GET</csr:getMacro>
         <csr:setMacro>I2C_REG_TIMEOUT_RST_REG_TIMEOUT_RST_RW_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4608</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>This field holds reset value of REG_TIMEOUT counter register.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x8</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_REG_TIMEOUT_RST</csr:identifier>
         <csr:widthMacro>I2C_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_GET</csr:getMacro>
         <csr:setMacro>I2C_REG_TIMEOUT_RST_RSVD_REG_TIMEOUT_RST_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4615</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_COMP_PARAM_1</csr:referenceName>
       <csr:identifier>IC_COMP_PARAM_1</csr:identifier>
       <csr:addressMacro>I2C_IC_COMP_PARAM_1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_COMP_PARAM_1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_COMP_PARAM_1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_COMP_PARAM_1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>4810</csr:linenumber>
       <csr:title>Component Parameter Register 1</csr:title>
       <csr:offset>0xF4</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00ffffaa</csr:registerResetValue>
       <csr:typeName>I2c_IC_COMP_PARAM_1</csr:typeName>
        <csr:description>
         <csr:p>Component Parameter Register 1</csr:p>
         <csr:p></csr:p>
         <csr:p>Note</csr:p>
         <csr:p>This is a constant read-only register that contains</csr:p>
         <csr:p>encoded information about the component's parameter settings.</csr:p>
         <csr:p>The reset value depends on coreConsultant parameter(s).</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>APB_DATA_WIDTH</csr:identifier>
         <csr:widthMacro>I2C_IC_COMP_PARAM_1_APB_DATA_WIDTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_COMP_PARAM_1_APB_DATA_WIDTH_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_COMP_PARAM_1_APB_DATA_WIDTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_COMP_PARAM_1_APB_DATA_WIDTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_COMP_PARAM_1_APB_DATA_WIDTH_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_COMP_PARAM_1_APB_DATA_WIDTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_COMP_PARAM_1_APB_DATA_WIDTH_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_COMP_PARAM_1_APB_DATA_WIDTH_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4655</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The value of this register is</csr:p>
         <csr:p>derived from the APB_DATA_WIDTH coreConsultant</csr:p>
         <csr:p>parameter.</csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x2</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>APB_08BITS</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>APB data bus width is 08 bits</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>APB_16BITS</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>APB data bus width is 16 bits</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>APB_32BITS</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>APB data bus width is 32 bits</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>RESERVED</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>Reserved bits</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>MAX_SPEED_MODE</csr:identifier>
         <csr:widthMacro>I2C_IC_COMP_PARAM_1_MAX_SPEED_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_COMP_PARAM_1_MAX_SPEED_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_COMP_PARAM_1_MAX_SPEED_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_COMP_PARAM_1_MAX_SPEED_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_COMP_PARAM_1_MAX_SPEED_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_COMP_PARAM_1_MAX_SPEED_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_COMP_PARAM_1_MAX_SPEED_MODE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_COMP_PARAM_1_MAX_SPEED_MODE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4684</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The value of this register is</csr:p>
         <csr:p>derived from the IC_MAX_SPEED_MODE coreConsultant</csr:p>
         <csr:p>parameter.</csr:p>
         <csr:p> - 0x0: Reserved</csr:p>
         <csr:p> - 0x1: Standard</csr:p>
         <csr:p> - 0x2: Fast</csr:p>
         <csr:p> - 0x3: High</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x2</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>FAST</csr:identifier>
           <csr:value>0x2</csr:value>
           <csr:title>IC MAX SPEED is FAST MODE</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>HIGH</csr:identifier>
           <csr:value>0x3</csr:value>
           <csr:title>IC MAX SPEED is HIGH MODE</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>STANDARD</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>IC MAX SPEED is STANDARD MODE</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>HC_COUNT_VALUES</csr:identifier>
         <csr:widthMacro>I2C_IC_COMP_PARAM_1_HC_COUNT_VALUES_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_COMP_PARAM_1_HC_COUNT_VALUES_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_COMP_PARAM_1_HC_COUNT_VALUES_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_COMP_PARAM_1_HC_COUNT_VALUES_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_COMP_PARAM_1_HC_COUNT_VALUES_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_COMP_PARAM_1_HC_COUNT_VALUES_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_COMP_PARAM_1_HC_COUNT_VALUES_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_COMP_PARAM_1_HC_COUNT_VALUES_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4705</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The value of this register is</csr:p>
         <csr:p>derived from the IC_HC_COUNT VALUES coreConsultant</csr:p>
         <csr:p>parameter.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Programmable count values for each mode.</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Hard code the count values for each mode.</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>INTR_IO</csr:identifier>
         <csr:widthMacro>I2C_IC_COMP_PARAM_1_INTR_IO_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_COMP_PARAM_1_INTR_IO_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_COMP_PARAM_1_INTR_IO_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_COMP_PARAM_1_INTR_IO_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_COMP_PARAM_1_INTR_IO_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_COMP_PARAM_1_INTR_IO_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_COMP_PARAM_1_INTR_IO_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_COMP_PARAM_1_INTR_IO_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4726</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The value of this register is</csr:p>
         <csr:p>derived from the IC_INTR_IO coreConsultant</csr:p>
         <csr:p>parameter.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>COMBINED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>COMBINED   Interrupt outputs</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>INDIVIDUAL</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>INDIVIDUAL Interrupt outputs</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>HAS_DMA</csr:identifier>
         <csr:widthMacro>I2C_IC_COMP_PARAM_1_HAS_DMA_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_COMP_PARAM_1_HAS_DMA_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_COMP_PARAM_1_HAS_DMA_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_COMP_PARAM_1_HAS_DMA_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_COMP_PARAM_1_HAS_DMA_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_COMP_PARAM_1_HAS_DMA_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_COMP_PARAM_1_HAS_DMA_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_COMP_PARAM_1_HAS_DMA_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4747</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The value of this register is</csr:p>
         <csr:p>derived from the IC_HAS_DMA coreConsultant</csr:p>
         <csr:p>parameter.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>DMA handshaking signals are disabled</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>DMA handshaking signals are enabled</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ADD_ENCODED_PARAMS</csr:identifier>
         <csr:widthMacro>I2C_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4775</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The value of this register is derived</csr:p>
         <csr:p>from the IC_ADD_ENCODED_PARAMS coreConsultant</csr:p>
         <csr:p>parameter.</csr:p>
         <csr:p>Reading 1 in this bit means that the capability</csr:p>
         <csr:p>of reading these encoded parameters via software has been</csr:p>
         <csr:p>included. Otherwise, the entire register is 0 regardless of</csr:p>
         <csr:p>the setting of any other parameters that are encoded in the</csr:p>
         <csr:p>bits.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISBALED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Disables capability of reading encoded parameters</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Enables  capability of reading encoded parameters</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_BUFFER_DEPTH</csr:identifier>
         <csr:widthMacro>I2C_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4789</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The value of this register is</csr:p>
         <csr:p>derived from the IC_RX_BUFFER_DEPTH coreConsultant</csr:p>
         <csr:p>parameter.</csr:p>
         <csr:p> - 0x00: Reserved</csr:p>
         <csr:p> - 0x01: 2</csr:p>
         <csr:p> - 0x02: 3</csr:p>
         <csr:p> - ...</csr:p>
         <csr:p> - 0xFF: 256</csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0xff</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TX_BUFFER_DEPTH</csr:identifier>
         <csr:widthMacro>I2C_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4803</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>The value of this register is derived</csr:p>
         <csr:p>from the IC_TX_BUFFER_DEPTH coreConsultant</csr:p>
         <csr:p>parameter.</csr:p>
         <csr:p> - 0x00 = Reserved</csr:p>
         <csr:p> - 0x01 = 2</csr:p>
         <csr:p> - 0x02 = 3</csr:p>
         <csr:p> - ...</csr:p>
         <csr:p> - 0xFF = 256</csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0xff</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RSVD_IC_COMP_PARAM_1</csr:identifier>
         <csr:widthMacro>I2C_IC_COMP_PARAM_1_RSVD_IC_COMP_PARAM_1_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_COMP_PARAM_1_RSVD_IC_COMP_PARAM_1_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_COMP_PARAM_1_RSVD_IC_COMP_PARAM_1_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_COMP_PARAM_1_RSVD_IC_COMP_PARAM_1_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_COMP_PARAM_1_RSVD_IC_COMP_PARAM_1_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_COMP_PARAM_1_RSVD_IC_COMP_PARAM_1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_COMP_PARAM_1_RSVD_IC_COMP_PARAM_1_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_COMP_PARAM_1_RSVD_IC_COMP_PARAM_1_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4809</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>IC_COMP_PARAM_1 Reserved bits - Read Only</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_COMP_VERSION</csr:referenceName>
       <csr:identifier>IC_COMP_VERSION</csr:identifier>
       <csr:addressMacro>I2C_IC_COMP_VERSION_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_COMP_VERSION_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_COMP_VERSION_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_COMP_VERSION_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>4826</csr:linenumber>
       <csr:title>I2C Component Version Register</csr:title>
       <csr:offset>0xF8</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x3230322a</csr:registerResetValue>
       <csr:typeName>I2c_IC_COMP_VERSION</csr:typeName>
        <csr:description>
         <csr:p>I2C Component Version Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_COMP_VERSION</csr:identifier>
         <csr:widthMacro>I2C_IC_COMP_VERSION_IC_COMP_VERSION_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_COMP_VERSION_IC_COMP_VERSION_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_COMP_VERSION_IC_COMP_VERSION_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_COMP_VERSION_IC_COMP_VERSION_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_COMP_VERSION_IC_COMP_VERSION_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_COMP_VERSION_IC_COMP_VERSION_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_COMP_VERSION_IC_COMP_VERSION_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_COMP_VERSION_IC_COMP_VERSION_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4825</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Specific values for this register are</csr:p>
         <csr:p>described in the Releases Table in the</csr:p>
         <csr:p>DW_apb_i2c Release Notes</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x3230322a</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i2c.IC_COMP_TYPE</csr:referenceName>
       <csr:identifier>IC_COMP_TYPE</csr:identifier>
       <csr:addressMacro>I2C_IC_COMP_TYPE_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I2C_IC_COMP_TYPE_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I2C_IC_COMP_TYPE_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I2C_IC_COMP_TYPE_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>DW_apb_i2c.csr</csr:filename>
       <csr:linenumber>4844</csr:linenumber>
       <csr:title>I2C Component Type Register</csr:title>
       <csr:offset>0xFC</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x44570140</csr:registerResetValue>
       <csr:typeName>I2c_IC_COMP_TYPE</csr:typeName>
        <csr:description>
         <csr:p>I2C Component Type Register</csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IC_COMP_TYPE</csr:identifier>
         <csr:widthMacro>I2C_IC_COMP_TYPE_IC_COMP_TYPE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I2C_IC_COMP_TYPE_IC_COMP_TYPE_MSB</csr:msbMacro>
         <csr:lsbMacro>I2C_IC_COMP_TYPE_IC_COMP_TYPE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I2C_IC_COMP_TYPE_IC_COMP_TYPE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I2C_IC_COMP_TYPE_IC_COMP_TYPE_RESET</csr:resetMacro>
         <csr:maskMacro>I2C_IC_COMP_TYPE_IC_COMP_TYPE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I2C_IC_COMP_TYPE_IC_COMP_TYPE_GET</csr:getMacro>
         <csr:setMacro>I2C_IC_COMP_TYPE_IC_COMP_TYPE_SET</csr:setMacro>
         <csr:filename>DW_apb_i2c.csr</csr:filename>
         <csr:linenumber>4843</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p>Designware Component Type number</csr:p>
         <csr:p>= 0x44_57_01_40. This assigned unique</csr:p>
         <csr:p>hex value is constant and is derived</csr:p>
         <csr:p>from the two ASCII letters 'DW' followed</csr:p>
         <csr:p>by a 16-bit unsigned number.</csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x44570140</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
     </csr:definitions>
    </csr:csrObject>
   </csr:csrData>
  </xml>
  <div id="docheader">
   <h2>Addressmap Information for 'DW_apb_i2c'</h2>
   <table id="optiontable" border="1" cellpadding="1">
    <tr>
     <td>
      <div id="globalFileInfoCheckBoxDiv">
       <label for="globalFileInfoCheckBox">Input File Information</label>
       <input id="globalFileInfoCheckBox" type="checkbox" onclick="globalFileInfoCheckBox_click();"/>
      </div>
     </td>
     <td>
      <div id="globalHeaderFileInfoCheckBoxDiv">
       <label for="globalHeaderFileInfoCheckBox">Header File Information</label>
       <input id="globalHeaderFileInfoCheckBox" type="checkbox" onclick="globalHeaderFileInfoCheckBox_click();"/>
      </div>
     </td>
     <td>
      <div id="globalEnumInfoCheckBoxDiv">
       <label for="globalEnumInfoCheckBox">Enum Information</label>
       <input id="globalEnumInfoCheckBox" type="checkbox" onclick="globalEnumInfoCheckBox_click();"/>
      </div>
     </td>
    </tr>
   </table>
  </div>
  <div id="docinfo"></div>
  <div id="docroot"></div>
  <div id="docfooter"></div>
 </body>
</html>
