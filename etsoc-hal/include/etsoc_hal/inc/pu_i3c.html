<!--                                                                      -->
<!--                                                                      -->
<!-- Generated by Semifore, Inc. csrCompile                               -->
<!--    HTML output                                                       -->
<html>
 <head>
  <title>Addressmap Information for 'pu_i3c'</title>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
  <meta http-equiv="Expires" content="0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
   /*
    * Copyright (c) SEMIFORE, INC. 2006-2015. All rights reserved.
    *
    * This software and documentation constitute an unpublished work and
    * contain valuable trade secrets and proprietary information belonging
    * to Semifore, Inc.  None of the foregoing material may be copied,
    * duplicated or disclosed without the express written permission of
    * Semifore, Inc.
    * SEMIFORE, INC. EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING
    * THIS SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF
    * MERCHANTABILITY AND/OR FITNESS FOR ANY PARTICULAR PURPOSE,
    * AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY THAT
    * MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
    * TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT
    * TO THE USE OF THE SOFTWARE OR DOCUMENTATION.
    * Under no circumstances shall Semifore, Inc. be liable for incidental,
    * special, indirect, direct or consequential damages or loss of profits,
    * interruption of business, or related expenses which may arise from use
    * of this software or documentation, including but not limited to those
    * resulting from defects in software and/or documentation, or loss or
    * inaccuracy of data of any kind.
   */
   
   /*
    * csrStyles.css
    *
    * $Revision: 1.20 $
    * $Date: 2015/09/06 01:23:08 $
    *
    * @(#)$Id: csrStyles.css,v 1.20 2015/09/06 01:23:08 weber Exp $
    *
    * These are the CSS Styles attributes for the HTML pages
    *
   */
   
   body {
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   	margin: 0px;
           text-align: left;
           padding: 0px;
   	color: #4f6b72;
   	background-color: #e7e7e7;
   }
   
   a {
   	color: #c75f3e;
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   
   
   
   }
   
   div {
   	font: normal 10pt auto  Arial, Helvetica, sans-serif;
   }
   
   table {
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   	background-color: #fff;
   
   
   	border-collapse: collapse;
   	margin-top: 2px;
   	margin-bottom: 2px;
   }
   
   
   th {
   	font: bold 7pt  Arial, Helvetica, sans-serif;
   	color: #4f6b72;
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   
   	letter-spacing: 1px;
   	text-align: left;
   	padding: 6px 6px 6px 12px;
   	background-color: #CAE8EA;
   }
   
   th.component {
           background-color: #FFCCFF;
   }
   
   th.addressmap {
           background-color: #CAE8EA;
   }
   
   th.register {
   	background-color: #CCFFCC;
   }
   
   th.group {
   	background-color: #FFFFCC;
   }
   
   th.union {
   	background-color: #CCCC00;
   }
   
   th.wideregister {
   	background-color: #FFCCCC;
   }
   
   th.memory {
   	background-color: #CCCCFF;
   }
   
   th.widememory {
   	background-color: #FF88FF;
   }
   
   th.submemory {
   	background-color: #CCCCFF;
   }
   
   th.field {
   	background-color: #CCFFFF;
   }
   
   
   td {
   	border-right: 1px solid #C1DAD7;
   	border-left: 1px solid #C1DAD7;
   	border-bottom: 1px solid #C1DAD7;
   	border-top: 1px solid #C1DAD7;
   	background-color: #fff;
   	padding: 6px 6px 6px 12px;
   	color: #4f6b72;
   	text-align: left;
   }
   
   td.noborder {
   	border-right: 0px none #C1DAD7;
   	border-left: 0px none #C1DAD7;
   	border-bottom: 0px none #C1DAD7;
   	border-top: 0px none #C1DAD7;
   	background-color: #FFF;
   	text-align: left;
   }
   
   .addrMapClass
   {
   }
   
   
   .addrMapContent
   {
   }
   
   .frdiv {
   	float: right;
   }
   
   .fldiv {
   	float: left;
   	margin-right: 10px;
   }
   
   .window 
   {
     background-color: white; 
     border-color:  #7BA7E1;
     border-style: solid; 
     border-width: 1px;
     margin: 0px;
     padding: 0px;
     position: absolute;
     visibility: hidden;
   }
   
   .windowTitleBar 
   {
     background-color: #7BA7E1;
     border-style: none;
     color: white;
     font: bold 11pt auto  Arial, Helvetica, sans-serif;	
     margin-left: 6px;
     margin-right: 6px;
   }
   
   .windowList 
   {
     background-color: white;
     border-style: none; 
     border-width: 0px;
     margin: 0px;
     padding: 2px;
     position: absolute;
     left: 10px;
     top: 100px;
     width: 100px;
     height: 200px;
     visibility: hidden;
   }
   
   .windowListArea 
   {
     background-color: white;
     border-style: none; 
     border-width: 0px;
     text-align: center;
     margin: 0px 0px 0px 0px;
     overflow: auto;
     
   }
  </style>
  <script type="text/javascript">
   /*
    * Copyright (c) SEMIFORE, INC. 2006-2018. All rights reserved.
    *
    * This software and documentation constitute an unpublished work and
    * contain valuable trade secrets and proprietary information belonging
    * to Semifore, Inc.  None of the foregoing material may be copied,
    * duplicated or disclosed without the express written permission of
    * Semifore, Inc.
    * SEMIFORE, INC. EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING
    * THIS SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF
    * MERCHANTABILITY AND/OR FITNESS FOR ANY PARTICULAR PURPOSE,
    * AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY THAT
    * MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
    * TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT
    * TO THE USE OF THE SOFTWARE OR DOCUMENTATION.
    * Under no circumstances shall Semifore, Inc. be liable for incidental,
    * special, indirect, direct or consequential damages or loss of profits,
    * interruption of business, or related expenses which may arise from use
    * of this software or documentation, including but not limited to those
    * resulting from defects in software and/or documentation, or loss or
    * inaccuracy of data of any kind.
   */
   
   /*
    * csrJava.js
    *
    * $Revision: 1.75 $
    * $Date: 2018/02/22 02:35:02 $
    *
    * @(#)$Id: csrJava.js,v 1.75 2018/02/22 02:35:02 weber Exp $
    *
    * These are the Java Script functions for the HTML pages.
    *
   */
   
   var xmlDoc                   = 0;
   var debug                    = 0;
   var def_lookup_table         = new Array();
   var object_array             = new Array();
   var topDefinition_array      = new Array();
   var topObjectRefNames_array  = new Array();
   var definitions_array        = new Array();
   var csrNode_array            = new Array();
   var globalShowFileInfo       = false;
   var globalShowHeaderFileInfo = false;
   var globalShowEnumInfo       = false;
   var fileInfoDiv              = null;
   
   function csrNode() {
     this.referenceType = 0;
     this.referenceName = 0;
     this.definitionPtr = 0;
     this.objectIndex   = 0;
     this.divParent     = 0;
     this.divChild      = 0;
     this.visibility    = 0;
     this.addressMapWindow = 0;
     
     this.click = function() {
       if ( this.visibility == 0 )
       {
         //      alert('open ' + this.referenceName);
         printDefinition(this);
         this.visibility = 1;
         
         // window.location.hash = this.referenceName + 'Link';
         // if (mouseposy > 700 ) scrollBy(0,100);
       } else
       {
         //      alert('close' +  this.referenceName);
         this.divParent.removeChild(this.divChild);
         this.visibility = 0;
   
         //window.location.hash = this.referenceName + 'Link';
         
       }
     }
   
     this.expand = function() {
       if ( this.visibility == 0 )
       this.click();
     }
   
     this.collapse = function() {
       if (this.visibility == 1 )
       this.click();
     }
   
     this.showFileInfo = function () {
        return globalShowFileInfo;
     }
   
     this.showHeaderFileInfo = function () {
        return globalShowHeaderFileInfo;
     }
   
     this.showEnumInfo = function () {
        return globalShowEnumInfo;
     }
   }
   
   //debug alrets
   function alertd( msg ) 
   {
     if (debug) 
       alert(msg);
   }
   
   var mouseposx = 0;
   var mouseposy = 0;
   
   function getMousePos(e) {
     
   	if (!e) var e = window.event;
   	
   	if (e.pageX || e.pageY) 	{
   		mouseposx = e.pageX;
   		mouseposy = e.pageY;
   	}
   	else if (e.clientX || e.clientY) 	{
   		mouseposx = e.clientX + document.body.scrollLeft
   			+ document.documentElement.scrollLeft;
   		mouseposy = e.clientY + document.body.scrollTop
   			+ document.documentElement.scrollTop;
   	}
   }
   
   function redrawAll ()
   {
      var topObject;
   
      for (var i=0; i < topObjectRefNames_array.length; i++) {
         topObject = csrNodeLookup(i,topObjectRefNames_array[i]);
         if (topObject != null) {
            topObject.click();
            topObject.click();
         }
      }
   }
   
   function globalFileInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalFileInfoCheckBox');
   
      if (checkbox != null) {
         globalShowFileInfo = checkbox.checked;
   
         if (globalShowFileInfo) {
            printFileInfo();
         }
         else {
            var docinfo = document.getElementById('docinfo');
            if ((docinfo != null) && (fileInfoDiv != null)) {
               docinfo.removeChild(fileInfoDiv);
            }
         }
         redrawAll();
      }
   }
   
   function globalHeaderFileInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalHeaderFileInfoCheckBox');
   
      if (checkbox != null) {
         globalShowHeaderFileInfo = checkbox.checked;
         redrawAll();
      }
   }
   
   function globalEnumInfoCheckBox_click ()
   {
      var checkbox = document.getElementById('globalEnumInfoCheckBox');
   
      if (checkbox != null) {
         globalShowEnumInfo = checkbox.checked;
         redrawAll();
      }
   }
   
   //import XML
   function importXML(xmlId)
   {
      xmlDoc = document.getElementById(xmlId);
      if (xmlDoc) {
         init();
      }
   }
   
   
   //parser helpers
   function getNodes_tag(node, tag)
   {
      return node.getElementsByTagName('csr:' + tag);
   }
   
   function getNodeValue_tag(node, tag)
   {
      var nodelist;
   
      nodelist = node.getElementsByTagName('csr:' + tag);
      if (nodelist.length > 0) {
         if (nodelist[0].firstChild) {
            return nodelist[0].firstChild.nodeValue;
         }
         else {
            return '';
         }
      }
      else {
         return '';
      }
   }
   
   function getNodeValue(node)
   {
     for (var i=0; node[0].childNodes.length; i++ )
       {
         
         if (node[0].childNodes[i].nodeType != 1) continue;
         return node[0].childNodes[i].firstChild.nodeValue
   
       }
   }
   
   function getNodeValue_description(node) 
   {
     var description = getNodes_tag(node,'description');
   
     if (description.length < 1)
       return '';
   
     var ptags = getNodes_tag(description[0],'p');
     var ret_string = '';
     
     for (var i=0; i < ptags.length; i++) {
        if (ptags[i].firstChild) {
           ret_string += '<p>' + ptags[i].firstChild.nodeValue + '</p>';
        }
        else {
           ret_string += '<p></p>';
        }
     }
     
     return ret_string;
   }
   
   function getNodeValue_attributes(node)
   {
      var attributesTag = getNodes_tag(node,'attributes');
   
      if (attributesTag.length < 1)
         return '';
      var attributeTags = getNodes_tag(attributesTag[0],'attribute');
      var result = '';
      var i;
   
      for (i=0; i < attributeTags.length; i++) {
         if (attributeTags[i].firstChild) {
            result += attributeTags[i].firstChild.nodeValue + '<br>';
         }
      }
   
      return result;
   }
   
   function getNodeValue_fieldAttributes(node)
   {
      var attributesTag = getNodes_tag(node,'fieldAttributes');
   
      if (attributesTag.length < 1)
         return '';
      var attributeTags = getNodes_tag(attributesTag[0],'attribute');
      var result = '';
      var i;
   
      for (i=0; i < attributeTags.length; i++) {
         if (attributeTags[i].firstChild) {
            result += attributeTags[i].firstChild.nodeValue + '<br>';
         }
      }
   
      return result;
   }
   
   function init() 
   {
     setGlobals();
   
     if (globalShowFileInfo) {
        printFileInfo();
     }
     
     printTopObjects();
     
   }
   
   function printHeader() 
   {
     header = document.getElementById('docheader');
     //header.innerHTML = "Header Text Goes Here";
   }
   
   
   function printFooter() 
   {
     footer = document.getElementById('docfooter');
     //footer.innerHTML = "Footer Text Goes Here";
   }
   
   
   function setGlobals() 
   {
     var checkbox;
   
     alertd(xmlDoc);
   
     checkbox = document.getElementById('globalFileInfoCheckBox');
     if (checkbox != null) {
        globalShowFileInfo = checkbox.checked;
     }
     checkbox = document.getElementById('globalHeaderFileInfoCheckBox');
     if (checkbox != null) {
        globalShowHeaderFileInfo = checkbox.checked;
     }
     checkbox = document.getElementById('globalEnumInfoCheckBox');
     if (checkbox != null) {
        globalShowEnumInfo = checkbox.checked;
     }
   
     // get the object elements
     object_array = getNodes_tag(xmlDoc,'csrObject');
     alertd('number of object_array elements=' + object_array.length);
   
     // create 2D lookup table array
     for (var i=0; i < object_array.length; i++)
       {
         def_lookup_table[i] = new Object();
         csrNode_array[i] = new Object();
       }
   
     // get the top definition elements
     for (var i=0; i < object_array.length; i++ )
       {
         topDefinition_array[i] = getNodes_tag(object_array[i],'topDefinition'); 
       }
     alertd('number of topDefinition_array elements=' + topDefinition_array.length);
   
     // get the referenece names of the top level modules
     for (var i=0; i < topDefinition_array.length; i++)
       {
         topObjectRefNames_array[i] = getNodeValue(topDefinition_array[i]);
         alertd('topObjectRefNames_array[' + i + ']=' + topObjectRefNames_array[i]);
       }
     
      
     // get definition elements
     for (var i=0; i < object_array.length; i++) 
       {
         definitions_array[i] = getNodes_tag(object_array[i],'definition');
       }
     alertd('number of definitions_array element=' + definitions_array.length);
     //alertd('definitions_array[0] =' + definitions_array[0].length + ' elements');
   
     // populate the definitions lookup table
     for ( var i=0; i < object_array.length; i++) 
       {
         for (var j=0; j < definitions_array[i].length; j++)
   	{
   	  referenceName = getNodeValue_tag(definitions_array[i][j], "referenceName");
   	  referenceType = getNodeValue_tag(definitions_array[i][j], "referenceType");
   	  def_lookup_table[i][referenceName] = definitions_array[i][j];
   	  
   	  var csrNode_obj = new csrNode();
   
   	  csrNode_obj.referenceName = referenceName;
   	  csrNode_obj.referenceType = referenceType;
   	  csrNode_obj.definitionPtr = definitions_array[i][j];
   	  csrNode_obj.objectIndex   = i;
   	  
   	  csrNode_array[i][referenceName] = csrNode_obj;
   	}
       
       }
   }
   
   
   function printFileInfo()
   {
      var docinfo = document.getElementById('docinfo');
   
      if (docinfo != null) {
         var inputFilesNodes = getNodes_tag(xmlDoc,'inputFiles');
         var includedFilesNodes = getNodes_tag(xmlDoc,'includedFiles');
         var configurationFilesNodes = getNodes_tag(xmlDoc,'configurationFiles');
         var fileNodes;
         var filename;
         var fileversionNodes;
         var table;
         var body;
         var row;
         var cell;
   
         fileInfoDiv = document.createElement('DIV');
   
         if (inputFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Input Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(inputFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         if (includedFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Included Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(includedFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         if (configurationFilesNodes.length > 0) {
            table = document.createElement('TABLE');
            body = document.createElement('TBODY');
            row = document.createElement('TR');
            cell = document.createElement('TD');
            cell.innerHTML = 'Configuration Filename';
            row.appendChild(cell);
            cell = document.createElement('TD');
            cell.innerHTML = 'Version';
            row.appendChild(cell);
            body.appendChild(row);
            fileNodes = getNodes_tag(configurationFilesNodes[0],'file');
            for (var i = 0; i < fileNodes.length; i++) {
               filename = getNodeValue_tag(fileNodes[i],'filename');
               if (filename != '') {
                  row = document.createElement('TR');
                  cell = document.createElement('TD');
                  cell.innerHTML = filename;
                  row.appendChild(cell);
                  fileversion = getNodeValue_tag(fileNodes[i],'fileversion');
                  if (fileversion != '') {
                     cell = document.createElement('TD');
                     cell.innerHTML = fileversion;
                     row.appendChild(cell);
                  }
                  body.appendChild(row);
               }
            }
            table.appendChild(body);
            fileInfoDiv.appendChild(table);
         }
   
         docinfo.appendChild(fileInfoDiv);
      }
   }
   
   function printTopObjects()
   {
     var csrNode;
     //print top level modules
     for ( var i=0; i < topObjectRefNames_array.length; i++)
       {
         csrNode = csrNodeLookup(i,topObjectRefNames_array[i]);
         if (csrNode.referenceType == 'component') {
            printTopComponentTable(csrNode);
         }
         else {
            printTopAddressmapTable(csrNode);
         }
         csrNode.expand();
       }
   }
   
   function csrNodeLookup(objectIndex, referenceName)
   {
      return csrNode_array[objectIndex][referenceName];
   }
   
   function printDefinition(csrNode)
   {
     
     referenceType = csrNode.referenceType;
   
     //case  
     switch (referenceType) 
       {
       case "component":
         printComponentDefinition(csrNode);
         break;
       case "addressmap":
         printAddressmapDefinition(csrNode);
         break;
       case "group":
         printGroupDefinition(csrNode);
         break;
       case "union":
         printUnionDefinition(csrNode);
         break;
       case "register":
         printRegisterDefinition(csrNode);
         break;
       case "wideregister":
         printWideRegisterDefinition(csrNode);
         break;
       case "memory":
         printMemoryDefinition(csrNode);
         break;
       case "widememory":
         printWideMemoryDefinition(csrNode);
         break;
       default:
         alertd('No default referenceType!');
       }
   }
   
   function printLeafDefinition(csrNode) 
   {
     referenceName_array = csrNode.referenceName.split(".");
   
     //print the def top down
     var parent_ref = '';
     for( var i = 0; i < referenceName_array.length; i++ )
       {
         var refName    = parent_ref + referenceName_array[i];
         var csrNode = csrNodeLookup(csrNode.objectIndex, refName);
         //if ( csrNodeObj.visibility == 0 )
         csrNode.expand();
         parent_ref = refName + '.';
       }
   
     //jump the window the the leaf link
     window.location.hash = '#' + csrNode.referenceName + 'Link';
   
     //move the address map so it remains onscreen
     var parent_ref = '';
     for( var i = 0; i < referenceName_array.length; i++ )
       {
         var refName    = parent_ref + referenceName_array[i];
         var csrNode = csrNodeLookup(csrNode.objectIndex, refName);
         //if ( csrNodeObj.visibility == 0 )
         if (csrNode.addressMapWindow) {
            csrNode.addressMapWindow.window.style.top =
               document.body.scrollTop + 25; 
         }
         parent_ref = refName + '.';
       }
   
   
     //highlight the div
     //highLightDiv(csrNode.referenceName);
     unhighLightDiv(csrNode.referenceName);
   
   }
   
   
   function printTopComponentTable(csrNode)
   {
   
     var xmlNode = csrNode.definitionPtr;
     //div to enclose module
     var moduleDiv     = document.createElement('DIV');
     var referenceName = csrNode.referenceName;
     var referenceType = csrNode.referenceType;
     var identifier    = getNodeValue_tag(xmlNode,"identifier");
   
     //set the div ID to the referenceName
     moduleDiv.id      = referenceName;
   
     csrNode.divParent = moduleDiv;
   
   
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
     var row = document.createElement('TR');
   
     var container     = document.createElement('TH');
     var theData       = document.createElement("div");
     theData.innerHTML = referenceType; 
     container.appendChild(theData);
     container.className = referenceType;
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'Link';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'ExpandAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'ExpandAllLink" onclick="expandAllNodes(' + csrNode.objectIndex + ');">' + 'expand all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   	
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'CollapseAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'CollapseAllLink" onclick="collapseAllNodes(' + csrNode.objectIndex + ');">' + 'collapse all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     tmp.appendChild(row);
   
     //add elements to DOM
     moduleDiv.appendChild(tableEl);
     document.getElementById('docroot').appendChild(moduleDiv);
   }
   
   
   function printTopAddressmapTable(csrNode)
   {
   
     var xmlNode = csrNode.definitionPtr;
     //div to enclose module
     var moduleDiv     = document.createElement('DIV');
     var referenceName = csrNode.referenceName;
     var referenceType = csrNode.referenceType;
     var identifier    = getNodeValue_tag(xmlNode,"identifier");
   
     //set the div ID to the referenceName
     moduleDiv.id      = referenceName;
   
     csrNode.divParent = moduleDiv;
   
   
     var tableEl = document.createElement('TABLE');
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
     var row = document.createElement('TR');
   
     var container     = document.createElement('TH');
     var theData       = document.createElement("div");
     theData.innerHTML = referenceType; 
     container.appendChild(theData);
     container.className = csrNode.referenceType;
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'Link';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'AddrMapLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'AddrMapLink" onclick="printAddressMap(' + csrNode.objectIndex + ',\'' + referenceName + '\');">' + 'address map' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
     
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'ExpandAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'ExpandAllLink" onclick="expandAllNodes(' + csrNode.objectIndex + ');">' + 'expand all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   	
     var container     = document.createElement('TD');
     var theLink       = document.createElement("div");
     theLink.id        = referenceName + 'CollapseAllLink';
     theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'CollapseAllLink" onclick="collapseAllNodes(' + csrNode.objectIndex + ');">' + 'collapse all' + '</a>';
     container.appendChild(theLink) 
     row.appendChild(container);
   
     tmp.appendChild(row);
   
     //add elements to DOM
     moduleDiv.appendChild(tableEl);
     document.getElementById('docroot').appendChild(moduleDiv);
   }
   
   
   function printComponentDefinition(csrNode) 
   {
     var xmlNode = csrNode.definitionPtr;
     var componentDefContentDiv = document.createElement('DIV');
     componentDefContentDiv.style.marginLeft = "25px";
     componentDefContentDiv.id = csrNode.divParent.id+ 'DefContentDiv';
   
     csrNode.divChild = componentDefContentDiv;
   
     var identifier          = getNodeValue_tag(xmlNode,"identifier");
     var title               = getNodeValue_tag(xmlNode,"title");
     var description         = getNodeValue_description(xmlNode);
     var filename            = getNodeValue_tag(xmlNode,"filename");
     var linenumber          = getNodeValue_tag(xmlNode,"linenumber");
     var attributes          = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        if (filename != '') {
           tableData_array['Filename'] = filename;
        }
        if (linenumber != '') {
           tableData_array['Linenumber'] = linenumber;
        }
     }
     printRefInfoTable( tableData_array, componentDefContentDiv, csrNode);
     
     csrNode.divParent.appendChild( componentDefContentDiv );
   
     printComponentReference_links( csrNode );
   
   }
   
   function printAddressmapDefinition(csrNode) 
   {
     var xmlNode = csrNode.definitionPtr;
     var moduleDefContentDiv = document.createElement('DIV');
     moduleDefContentDiv.style.marginLeft = "25px";
     //moduleDefContentDiv.id = domParentNode.id + 'DefContentDiv';
     moduleDefContentDiv.id = csrNode.divParent.id+ 'DefContentDiv';
   
     csrNode.divChild = moduleDefContentDiv;
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var addressmapReference =
                           getNodeValue_tag(xmlNode,"addressmapReference");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (addressmapReference != '') {
        tableData_array['Reference']  = addressmapReference;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        if (filename != '') {
           tableData_array['Filename'] = filename;
        }
        if (linenumber != '') {
           tableData_array['Linenumber'] = linenumber;
        }
     }
     if (csrNode.showHeaderFileInfo()) {
        if (addressMacro != '') {
           tableData_array['Address Macro'] = addressMacro;
        }
        if (offsetMacro != '') {
           tableData_array['Offset Macro'] = offsetMacro;
        }
        if (typeName != '') {
           tableData_array['Type Name'] = typeName;
        }
     }
   
     printRefInfoTable( tableData_array, moduleDefContentDiv, csrNode);
     
     csrNode.divParent.appendChild( moduleDefContentDiv );
   
     printReference_links( csrNode );
   
   }
   
   
   function printReference_links(csrNode) {
   
    
     var objectIndex = csrNode.objectIndex;
     xmlNode         = csrNode.definitionPtr;
   
     var references = getNodes_tag(xmlNode,'reference');
   
     for (var i=0; i < references.length; i++ )
       {
         
         var referenceType = getNodeValue_tag(references[i],"referenceType");
         var referenceName = getNodeValue_tag(references[i],"referenceName");
   
         referencedCsrNode = csrNodeLookup(objectIndex, referenceName);
         var identifier    =
             getNodeValue_tag(referencedCsrNode.definitionPtr,"identifier");
   
         var referenceDiv  = document.createElement('DIV');
         referenceDiv.id = referenceName;
         var tableData_array = new Array();
   
         tableData_array[referenceType] = '<a id="' + referenceName + 'Link" name="'+ referenceName + 'Link" ' + 'href="javascript:void(0);" onclick="csrNodeLookup(' + objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
   
         //set parent of referenced node
         referencedCsrNode.divParent = referenceDiv;
   
         printRefInfoTable( tableData_array, referenceDiv, referencedCsrNode);
   
         csrNode.divChild.appendChild(referenceDiv);
     
         if ( referencedCsrNode.visibility == 1 )
   	printDefinition(referencedCsrNode);
       }
   }
   
   
   function printComponentReference_links(csrNode) {
   
    
     var objectIndex = csrNode.objectIndex;
     xmlNode         = csrNode.definitionPtr;
     var table;
     var body;
     var row;
     var cell;
     var theData;
     var theLink;
   
     var references = getNodes_tag(xmlNode,'reference');
   
     for (var i=0; i < references.length; i++ )
       {
         
         var referenceType = getNodeValue_tag(references[i],"referenceType");
         var referenceName = getNodeValue_tag(references[i],"referenceName");
   
         referencedCsrNode = csrNodeLookup(objectIndex, referenceName);
         var identifier    =
             getNodeValue_tag(referencedCsrNode.definitionPtr,"identifier");
   
         var referenceDiv  = document.createElement('DIV');
         referenceDiv.id = referenceName;
         var tableData_array = new Array();
   
         table = document.createElement('TABLE');
         body = document.createElement('TBODY');
         row = document.createElement('TR');
   
         cell              = document.createElement('TH');
         theData           = document.createElement("div");
         theData.innerHTML = referenceType; 
         cell.appendChild(theData);
         cell.className = referenceType;
         row.appendChild(cell);
   
         cell              = document.createElement('TD');
         theLink           = document.createElement("div");
         theLink.id        = referenceName + 'Link';
         theLink.innerHTML = '<a id="' + referenceName + 'Link" href="javascript:void(0);" name="' + referenceName + 'Link" onclick="csrNodeLookup(' + csrNode.objectIndex + ',\'' + referenceName + '\').click();">' + identifier + '</a>';
         cell.appendChild(theLink) 
         row.appendChild(cell);
   
         cell              = document.createElement('TD');
         theLink           = document.createElement("div");
         theLink.id        = referenceName + 'AddrMapLink';
         theLink.innerHTML = '<a href="javascript:void(0);" name="' + referenceName + 'AddrMapLink" onclick="printAddressMap(' + csrNode.objectIndex + ',\'' + referenceName + '\');">' + 'address map' + '</a>';
         cell.appendChild(theLink) 
         row.appendChild(cell);
   
         body.appendChild(row);
         table.appendChild(body);
         referenceDiv.appendChild(table);
   
         //set parent of referenced node
         referencedCsrNode.divParent = referenceDiv;
   
         csrNode.divChild.appendChild(referenceDiv);
     
         if ( referencedCsrNode.visibility == 1 )
   	printDefinition(referencedCsrNode);
       }
   }
   
   function printGroupDefinition(csrNode)
   {
   
     var groupReferenceName        = csrNode.referenceName;
     var groupParentDiv            = document.getElementById(groupReferenceName);
     
     csrNode.divParent = groupParentDiv;
     var xmlNode = csrNode.definitionPtr;
   
     var groupDiv                  = document.createElement('DIV');
     groupDiv.id               = groupParentDiv.id + "child";
     groupDiv.style.marginLeft = "25px";
     
     csrNode.divChild = groupDiv;
   
     groupParentDiv.appendChild(groupDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayMax        = getNodeValue_tag(xmlNode,"arrayMax");
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']   = filename;
        tableData_array['Linenumber'] = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, groupDiv, csrNode);
   
   
     printReference_links(csrNode);
   
   }
   
   function printUnionDefinition(csrNode)
   {
   
     var unionReferenceName        = csrNode.referenceName;
     var unionParentDiv            = document.getElementById(unionReferenceName);
     
     csrNode.divParent = unionParentDiv;
     var xmlNode = csrNode.definitionPtr;
   
     var unionDiv                  = document.createElement('DIV');
     unionDiv.id               = unionParentDiv.id + "child";
     unionDiv.style.marginLeft = "25px";
     
     csrNode.divChild = unionDiv;
   
     unionParentDiv.appendChild(unionDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayMax        = getNodeValue_tag(xmlNode,"arrayMax");
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
       tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']   = filename;
        tableData_array['Linenumber'] = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, unionDiv, csrNode);
   
     printReference_links(csrNode);
   
   }
   
   function printRegisterDefinition(csrNode) 
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var aliasOf         = getNodeValue_tag(xmlNode,"aliasOf");
     var aliases         = getNodes_tag(xmlNode,'aliases');
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var size            = getNodeValue_tag(xmlNode,"size");
     var byteSize        = getNodeValue_tag(xmlNode,"byteSize");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"registerResetValue");
     var resetMask       = getNodeValue_tag(xmlNode,"registerResetMask");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var isVolatile      = getNodeValue_tag(xmlNode,"volatile");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (size != '') {
        tableData_array['Size'] = size;
     }
     if (byteSize != '') {
        tableData_array['Byte Size'] = byteSize;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (aliasOf != '') {
        tableData_array['Alias Of'] = '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasOf + '\'));">' + aliasOf + '</a>';
     }
     if (aliases.length > 0) {
        var aliasList = getNodes_tag(aliases[0],'alias');
        var aliasesString = '';
        var aliasValue;
        if (aliasList[0].firstChild) {
              aliasValue = aliasList[0].firstChild.nodeValue;
              aliasesString += '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasValue + '\'));">' + aliasValue + '</a>';
        }
        for ( var i=1; i < aliasList.length; i++ ) {
           if (aliasList[i].firstChild) {
              aliasValue = aliasList[i].firstChild.nodeValue;
              aliasesString += '<br>';
              aliasesString += '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + csrNode.objectIndex + ',\'' + aliasValue + '\'));">' + aliasValue + '</a>';
           }
        }
        tableData_array['Aliases'] = aliasesString;
     }
     if (isVolatile != '') {
        tableData_array['Volatile'] = ((isVolatile == 'true') ? '1': '0');
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if ((resetValue != '') && (resetMask != '')) {
        tableData_array['Reset Mask'] = resetMask;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printCsrBitFields( csrNode );
   
   }
   
   function printCsrBitFields( csrNode )
   {
     var xmlNode = csrNode.definitionPtr;
    
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
     var fieldsHaveClockDomains =
        (getNodeValue_tag(xmlNode, "clockDomains") == 'true');
     var fieldsHaveSynchronizer =
        (getNodeValue_tag(xmlNode, "synchronizers") == 'true');
     var fieldsHaveAttributes =
        (getNodeValue_tag(xmlNode, "fieldsHaveAttributes") == 'true');
     var headers;
   
   //Header Row
     headers = ['Identifier', 'Title', 'Bit', 'Access', 'Reset'];
     if (fieldsHaveClockDomains) {
        headers.push('Clock Domain');
     }
     if (fieldsHaveSynchronizer) {
        headers.push('Synchronizer');
     }
     if (fieldsHaveAttributes) {
        headers.push('Attributes');
     }
     headers.push('Description');
   
     var row           = document.createElement('TR');
     for ( var i=0; i<headers.length; i++ ) 
       {
        
         var container     = document.createElement('TH');
         var theData       = document.createElement('DIV');
         theData.innerHTML = headers[i];
         container.className = csrNode.referenceType;
         container.appendChild(theData);
         row.appendChild(container);
       }
     tmp.appendChild(row);
   
     var bitfields = getNodes_tag(xmlNode,'bitfield');
   
     
   
     for ( var i=0; i < bitfields.length; i++ )
       {
         var identifier  = getNodeValue_tag(bitfields[i],"identifier");
         var title       = getNodeValue_tag(bitfields[i],"title");
         var msb         = getNodeValue_tag(bitfields[i],"msb");
         var lsb         = getNodeValue_tag(bitfields[i],"lsb");
   
         if (msb == lsb) 
   	var bit         = '[' + msb + ']';
         else 
   	var bit         = '[' + msb + ':' + lsb +']';
         
   
         var access      = getNodeValue_tag(bitfields[i],"access");
         var reset       = getNodeValue_tag(bitfields[i],"resetValue");
         var description = getNodeValue_description(bitfields[i]);
         var attributes  = getNodeValue_fieldAttributes(bitfields[i]);
   
         var clockDomain    = getNodeValue_tag(bitfields[i],"clockDomain");
         var synchronizer   = getNodeValue_tag(bitfields[i],"synchronizer");
   
         var widthMacro     = getNodeValue_tag(bitfields[i],"widthMacro");
         var msbMacro       = getNodeValue_tag(bitfields[i],"msbMacro");
         var lsbMacro       = getNodeValue_tag(bitfields[i],"lsbMacro");
         var rangeMacro     = getNodeValue_tag(bitfields[i],"rangeMacro");
         var resetMacro     = getNodeValue_tag(bitfields[i],"resetMacro");
         var getMacro       = getNodeValue_tag(bitfields[i],"getMacro");
         var setMacro       = getNodeValue_tag(bitfields[i],"setMacro");
   
         var filename       = getNodeValue_tag(bitfields[i],"filename");
         var linenumber     = getNodeValue_tag(bitfields[i],"linenumber");
         var enums          = getNodes_tag(bitfields[i], "enumeration");
   
         var row_data;
   
         row_data = [identifier, title, bit, access.toUpperCase(), reset];
         if (fieldsHaveClockDomains) {
            row_data.push(clockDomain);
         }
         if (fieldsHaveSynchronizer) {
            row_data.push(synchronizer);
         }
         if (fieldsHaveAttributes) {
            row_data.push(attributes);
         }
         row_data.push(description);
         row         = document.createElement('TR');
         
         for ( var j=0; j<row_data.length; j++ ) {
            var container     = document.createElement('TD');
            var theData       = document.createElement('DIV');
            theData.innerHTML = row_data[j];
            container.appendChild(theData);
            row.appendChild(container);
         }
         tmp.appendChild(row);
   
         //FIX ME SNPS title check not cool (there for reserved fields)
         if (
            (
               csrNode.showFileInfo() ||
               csrNode.showHeaderFileInfo() ||
               (csrNode.showEnumInfo() && enums && (enums.length > 0))
               ) &&
            (title != "-") &&
            (csrNode.referenceType != 'wideregister')
            ) {
            row         = document.createElement('TR');
            var container     = document.createElement('TD');
            container.colSpan = row_data.length;
            container.style.backgroundColor = "#e7e7e7";
           
            if (csrNode.showFileInfo()) {
              var tableData_array = new Array();
              var theData       = document.createElement('DIV');
              theData.className = "fldiv";
              tableData_array['Filename']   = filename;
              tableData_array['Linenumber'] = linenumber;
              printRefInfoTable(tableData_array, theData, csrNode);
              container.appendChild(theData);
            }
   
            if (csrNode.showHeaderFileInfo()) {
              var tableData_array = new Array();
              var theData       = document.createElement('DIV');
              theData.className = "fldiv";
              tableData_array['Width Macro']   = widthMacro;
              tableData_array['Range Macro']   = rangeMacro;
              tableData_array['Msb Macro']     = msbMacro;
              tableData_array['Lsb Macro']     = lsbMacro;
              tableData_array['Reset Macro']   = resetMacro;
              tableData_array['Set Macro']     = setMacro;
              tableData_array['Get Macro']     = getMacro;
              printRefInfoTable(tableData_array, theData, csrNode);
              container.appendChild(theData);
            }
   
            if (csrNode.showEnumInfo() && enums && (enums.length > 0)) {
              var enumDiv = printFieldEnumTable(csrNode, enums);
              container.appendChild(enumDiv);
            }
   
            row.appendChild(container);
   
            tmp.appendChild(row);
         }
         
   
         
       }
     
     csrNode.divChild.appendChild(tableEl);
     
   }
   
   function printFieldEnumTable( csrNode, enums )
   {
     var enumDiv       = document.createElement('DIV');
     enumDiv.className = "fldiv";
     var table = document.createElement('TABLE');
     var body = document.createElement('TBODY');
   
     var titles = (getNodeValue_tag(enums[0], "titles") == 'true');
     var descriptions = (getNodeValue_tag(enums[0], "descriptions") == 'true');
     var hasPartialAccess =
        (getNodeValue_tag(enums[0], "enumeratorsHavePartialAccess") == 'true');
   
     var headerCells = [];
     if (titles) {
        headerCells.push('Title');
     }
     headerCells.push('Identifier');
     headerCells.push('Value');
     if (hasPartialAccess) {
        headerCells.push('Access')
     }
     if (descriptions) {
        headerCells.push('Description')
     }
   
     var headerRow = document.createElement('TR');
     for ( var i=0; i < headerCells.length; i++ ) {
       var container     = document.createElement('TH');
       var theData       = document.createElement('DIV');
       theData.innerHTML = headerCells[i];
       container.appendChild(theData);
       container.className = csrNode.referenceType;
       container.className = 'field';
       headerRow.appendChild(container);
     }
     body.appendChild(headerRow);
   
     var enumerators = getNodes_tag(enums[0], "enumerator");
     for (var e=0; e < enumerators.length; e++) {
       var row = document.createElement('TR');
       var identifier = getNodeValue_tag(enumerators[e], "identifier");
       var value = getNodeValue_tag(enumerators[e], "value");
       var title;
       var description;
       var access;
       var cells = [];
       if (titles) {
         title = getNodeValue_tag(enumerators[e], "title");
         cells.push(title);
       }
       cells.push(identifier);
       cells.push(value);
       if (hasPartialAccess) {
         access = getNodeValue_tag(enumerators[e], "enumeratorAccess");
         cells.push(access);
       }
       if (descriptions) {
         description = getNodeValue_tag(enumerators[e], "description");
         cells.push(description);
       }
         
       for ( var i=0; i < cells.length; i++ ) {
         var container     = document.createElement('TD');
         var theData       = document.createElement('DIV');
         theData.innerHTML = cells[i];
         container.appendChild(theData);
         row.appendChild(container);
       }
       body.appendChild(row);
     }
   
     table.appendChild(body);
     enumDiv.appendChild(table);
     return enumDiv;
   }
   
   function printWideRegisterDefinition( csrNode )
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"resetValue");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var isVolatile      = getNodeValue_tag(xmlNode,"volatile");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier'] = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions']     = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (isVolatile != '') {
        tableData_array['Volatile'] = ((isVolatile == 'true') ? "1": "0");
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printCsrBitFields( csrNode );
   
     printReference_links( csrNode );
     
   
   }
   
   function printMemoryDefinition(csrNode) 
   {
     var memoryReferenceName = csrNode.referenceName;
     var memoryParentDiv     = document.getElementById(memoryReferenceName);
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = memoryParentDiv;
   
     var memoryDiv              = document.createElement('DIV');
   
     memoryDiv.id               = memoryParentDiv.id + "child";
     memoryDiv.style.marginLeft = "25px";
     csrNode.divChild = memoryDiv;
     memoryParentDiv.appendChild(memoryDiv);
   
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var resetValue      = getNodeValue_tag(xmlNode,"resetValue");
     var resetMask       = getNodeValue_tag(xmlNode,"resetMask");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var memoryWidth     = getNodeValue_tag(xmlNode,"memoryWidth");
     var memoryWordCount = getNodeValue_tag(xmlNode,"memoryWordCount");
     var attributes      = getNodeValue_attributes(xmlNode);
   
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier']  = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions'] = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (memoryWidth != '') {
        tableData_array['Width'] = memoryWidth;
     }
     if (memoryWordCount != '') {
        tableData_array['Word Count'] = memoryWordCount;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (resetValue != '') {
        tableData_array['Reset Value'] = resetValue;
     }
     if ((resetValue != '') && (resetMask != '')) {
        tableData_array['Reset Mask'] = resetMask;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, memoryDiv, csrNode);
   
     printReference_links(csrNode);
   }
   
   function printWideMemoryDefinition( csrNode )
   {
     var csrReferenceName        = csrNode.referenceName;
     var csrParentDiv            = document.getElementById(csrReferenceName);
     
     var xmlNode             = csrNode.definitionPtr;
     csrNode.divParent       = csrParentDiv;
   
     var csrDiv                  = document.createElement('DIV');
     csrDiv.id               = csrParentDiv.id + "child";
     csrDiv.style.marginLeft = "25px";
   
     csrNode.divChild = csrDiv;
     
     csrParentDiv.appendChild(csrDiv);
   
     
     var identifier      = getNodeValue_tag(xmlNode,"identifier");
     var hierarchicalIdentifier =
                           getNodeValue_tag(xmlNode,"hierarchicalIdentifier");
     var title           = getNodeValue_tag(xmlNode,"title");
     var description     = getNodeValue_description(xmlNode);
     var arrayDimensions = getNodeValue_tag(xmlNode,"arrayDimensions");
     var access          = getNodeValue_tag(xmlNode,"addressedAccess");
     var offset          = getNodeValue_tag(xmlNode,"offset");
     var byteOffset      = getNodeValue_tag(xmlNode,"byteOffset");
     var address         = getNodeValue_tag(xmlNode,"address");
     var byteAddress     = getNodeValue_tag(xmlNode,"byteAddress");
     var atomicAccess    = getNodeValue_tag(xmlNode,"atomicAccess");
     var filename        = getNodeValue_tag(xmlNode,"filename");
     var linenumber      = getNodeValue_tag(xmlNode,"linenumber");
     var typeName        = getNodeValue_tag(xmlNode,"typeName");
     var addressMacro    = getNodeValue_tag(xmlNode,"addressMacro");
     var offsetMacro     = getNodeValue_tag(xmlNode,"offsetMacro");
     var memoryWidth     = getNodeValue_tag(xmlNode,"memoryWidth");
     var memoryWordCount = getNodeValue_tag(xmlNode,"memoryWordCount");
     var attributes      = getNodeValue_attributes(xmlNode);
   
     var tableData_array = new Array();
   
     if (identifier != '') {
        tableData_array['Identifier'] = identifier;
     }
     if (hierarchicalIdentifier != '') {
        tableData_array['Hierarchical Identifier']  = hierarchicalIdentifier;
     }
     if (title != '') {
        tableData_array['Title'] = title;
     }
     if (description != '') {
        tableData_array['Description'] = description;
     }
     if (arrayDimensions != '') {
        tableData_array['Array Dimensions']     = arrayDimensions;
     }
     if (offset != '') {
        tableData_array['Offset'] = offset;
     }
     if (byteOffset != '') {
        tableData_array['Byte Offset'] = byteOffset;
     }
     if (address != '') {
        tableData_array['Address'] = address;
     }
     if (byteAddress != '') {
        tableData_array['Byte Address'] = byteAddress;
     }
     if (memoryWidth != '') {
        tableData_array['Width'] = memoryWidth;
     }
     if (memoryWordCount != '') {
        tableData_array['Word Count'] = memoryWordCount;
     }
     if (access != '') {
        tableData_array['Access'] = access;
     }
     if (atomicAccess != '') {
        tableData_array['Atomic Access'] = atomicAccess;
     }
     if (attributes != '') {
        tableData_array['Attributes'] = attributes;
     }
     if (csrNode.showFileInfo()) {
        tableData_array['Filename']        = filename;
        tableData_array['Linenumber']      = linenumber;
     }
     if (csrNode.showHeaderFileInfo()) {
        tableData_array['Address Macro'] = addressMacro;
        tableData_array['Offset Macro']  = offsetMacro;
        tableData_array['Type Name'] = typeName;
     }
   
     printRefInfoTable( tableData_array, csrDiv, csrNode);
     
     printReference_links( csrNode );
   
   }
   
   
   function printRefInfoTable( refArray, domParentNode, csrNode ) 
   {
     var tableEl = document.createElement('TABLE');
     //  tableEl.setAttribute('cellPadding',5);
     //  tableEl.setAttribute('border',1);
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
   
     for ( var type in refArray )
       {
         var row = document.createElement('TR');
         
         //headings
         var container = document.createElement('TH');
         //     var theData   = document.createTextNode(node);
         var theData = document.createElement('DIV');
         theData.innerHTML = type;
   
         container.className = csrNode.referenceType;
   
         container.appendChild(theData);
         row.appendChild(container);
         
         //values
         container     = document.createElement('TD');
         container.className = "noborder";
         //      theData       = document.createTextNode(refArray[type]);
         var theData = document.createElement('DIV');
         theData.innerHTML = refArray[type];
   
         container.appendChild(theData);
         row.appendChild(container);
         
         tmp.appendChild(row);
       }
     
     domParentNode.appendChild(tableEl);
   }
   
   function printAddressMap(objectIndex, referenceName)
   {
     var csrNode;
    
     csrNode = csrNodeLookup(objectIndex, referenceName);
   
     //if window is already open, close it
     if (csrNode.addressMapWindow) {
       if (csrNode.addressMapWindow.opened)
         return;
       else csrNode.addressMapWindow.open()
     }
   
     csrNode.addressMapWindow = new Window( document.body.clientWidth - 625, 25, 600, 400, 'AddrMap' + objectIndex );
   
     var addrMapDiv       = document.createElement('DIV');
     addrMapDiv.id        = 'AddrMap' + objectIndex;
     addrMapDiv.style.marginLeft = "10px";
     addrMapDiv.style.marginRight = "10px";
     addrMapDiv.style.marginTop = "10px";
     addrMapDiv.style.marginBottom = "10px";
   
     
     csrNode.addressMapWindow.changeTitle( 'Address Map for ' + referenceName );
   
     addressMapEntries = getNodes_tag(csrNode.definitionPtr,'addressMapEntry');
   
     alertd('addressMapEntries=' + addressMapEntries.length);
   
     var tableEl = document.createElement('TABLE');
     tableEl.width = "550px";
     var tmp = document.createElement('TBODY');
     tableEl.appendChild(tmp);
   
     var headers = ['Address', 'Instance Name'];
   
      var row           = document.createElement('TR');
     for ( var i=0; i<headers.length; i++ ) 
       {
         var container        = document.createElement('TH');
         var theData          = document.createElement('DIV');
         theData.innerHTML    = headers[i];
         container.appendChild(theData);
         row.appendChild(container);
       }
     tmp.appendChild(row);
   
   
     for ( var i=0; i < addressMapEntries.length; i++)
       {
         var print = false;
         var referenceName = getNodeValue_tag(addressMapEntries[i],"referenceName");
         var instanceName  = getNodeValue_tag(addressMapEntries[i],"instanceName");
         var referencedObj = csrNodeLookup(objectIndex, referenceName);
   
   
         var addressLow    = getNodeValue_tag(addressMapEntries[i],"addressLow");
         var addressHigh   = getNodeValue_tag(addressMapEntries[i],"addressHigh");
         
         if (addressLow == addressHigh) 
   	var addressRange = addressHigh;
         else
   	var addressRange = addressLow + ' - ' + addressHigh;
         
         if ( referencedObj ) 
   	{
   	  if (
                (referencedObj.referenceType == "register") ||
                (referencedObj.referenceType == "wideregister") ||
                (referencedObj.referenceType == "memory") ||
                (referencedObj.referenceType == "widememory")
             )
   	    {
   	      print = true;
   	      referenceName = '<a href="javascript:void(0)" onclick="printLeafDefinition(csrNodeLookup(' + objectIndex + ',\'' + referenceName + '\'));">' + instanceName + '</a>';
   	    }
   	}
         else if ( referenceName == '' )
   	{
   	print = true;
   	referenceName = 'reserved';
   	}
   
         if ( print ) 
   	{
   	  var row_data = [ addressRange, referenceName];
   	  row          = document.createElement('TR');
   	  
   	  for ( var j=0; j<row_data.length; j++ ) 
   	    {
   	      var container     = document.createElement('TD');
   	      var theData       = document.createElement('DIV');
   	      theData.innerHTML = row_data[j];
   	      container.appendChild(theData);
   	      row.appendChild(container);
   	    }
   	  tmp.appendChild(row);
   	}
       }
   
     addrMapDiv.appendChild(tableEl);
   
     csrNode.addressMapWindow.appendDomEl(addrMapDiv);
     csrNode.addressMapWindow.open();
   }
   
   
   //expand nodes
   function expandAllNodes( objectIndex )
   {
     for ( var obj in csrNode_array[objectIndex] )
       {  
         var csrNodeObj = csrNodeLookup(objectIndex,obj);
         csrNodeObj.expand();
       }
   }
   
   function collapseAllNodes( objectIndex )
   {
      for ( var obj in csrNode_array[objectIndex] )
       {  
         var csrNodeObj = csrNodeLookup(objectIndex,obj);
         csrNodeObj.collapse();
       }
   }
   
   // Graphics Functions
   
   function highLightDiv( id )
   {
     fade(0xe7, 0xe7, 0xe7, 0xff, 0xff, 0x33, 100, id);  
   }
   
   function unhighLightDiv( id )
   {
     fade(0xff, 0xff, 0x33, 0xe7, 0xe7, 0xe7, 100, id);
   }
   
   function makearray(n)
   {
     this.length = n;
     for(var i = 1; i <= n; i++)
       this[i] = 0;
     return this;
   }
   
   hexa = new makearray(16);
   
   for(var i = 0; i < 10; i++) 
        hexa[i] = i;
   hexa[10]="a"; hexa[11]="b"; hexa[12]="c";
   hexa[13]="d"; hexa[14]="e"; hexa[15]="f";
   
   function hex(i)
   {
     if (i < 0) return "00";
     else if (i >255) return "ff";
     else return "" + hexa[Math.floor(i/16)] + hexa[i%16];
   }
   
   var fade_timer = 100;
   function setbgColor(r, g, b, id)
   {
     var hr = hex(r); var hg = hex(g); var hb = hex(b);
     document.getElementById(id).style.backgroundColor = "#"+hr+hg+hb;
     var timeOutString = 'document.getElementById("' + id + '").style.backgroundColor=' +  '"#'+hr+hg+hb +'"';
     fade_timer = fade_timer + 25;
     setTimeout(timeOutString, fade_timer);
   
   }
   
   function fade(sr, sg, sb, er, eg, eb, step, id)
   {
     fade_timer = 100;
     for(var i = 0; i <= step; i++){
       setbgColor(Math.floor(sr * ((step-i)/step) + er * (i/step)),Math.floor(sg * ((step-i)/step) + eg * (i/step)),Math.floor(sb * ((step-i)/step) + eb * (i/step)),id);
     }
   }
   
   // Browser Detect
   
   // Determine browser and version.
   
   function Browser() 
   {
   
     var ua, s, i;
   
     this.isIE    = false;
     this.isNS    = false;
     this.version = null;
   
     ua = navigator.userAgent;
   
     s = "MSIE";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isIE = true;
       this.version = parseFloat(ua.substr(i + s.length));
       return;
     }
   
     s = "Netscape6/";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isNS = true;
       this.version = parseFloat(ua.substr(i + s.length));
       return;
     }
   
     // Treat any other "Gecko" browser as NS 6.1.
   
     s = "Gecko";
     if ((i = ua.indexOf(s)) >= 0) {
       this.isNS = true;
       this.version = 6.1;
       return;
     }
   }
   
   var browser = new Browser();
   
   //DHTML Windows Below
   
   var myWindow = new Object();
   var globalWindowZIndex = 500;
   
   // Window Class
   function Window(x,y,w,h,dom_id) 
   {
     
     // CLASS TAG ELEMENT VARAIBLES
     this.window             = 0;
     this.title              = 0;
     this.titleBar           = 0;
     this.titleBarText       = 0;
     this.titleBarButtons    = 0;
     this.clientArea         = 0;
     this.titleBarMap        = 0;
     this.left               = x;
     this.top                = y;
     this.width              = w;
     this.height             = h;
     this.opened             = false; 
     this.dom_id             = dom_id;
   
     if (browser.isNS) 
       {
         this.ca_width       = this.width - 2;
         this.ca_height      = this.height - 40;
       }
     if (browser.isIE) 
       {
         this.ca_width       = this.width - 2;
         this.ca_height      = this.height - 40;
     }
     this.inMoveDrag   = false;
   
     // CLASS METHOD FUNCTIONS
     this.create        = windowCreate;
     this.init          = windowInit;
     this.open          = windowOpen;
     this.makeActive    = windowMakeActive;
     this.insertHTML    = windowInsertHTML; 
     this.appendHTML    = windowAppendHTML;
     this.appendDomEl   = windowAppendDomEl;
     this.close         = windowClose;
     this.windowColor   = windowChangeColor;
   
     this.changeTitle = function(title) {
       this.title.innerHTML = title;
     }
   
     this.wallpaper = function(img) {
        this.windowArea.style.backgroundImage    = img;
        this.windowArea.style.backgroundPosition = "center";
        this.windowArea.style.backgroundRepeat   = "no-repeat";
     }
   
     this.create();
     this.init();
   }
   
   //
   // Create WINDOW DOM object Tree
   //
   // body
   //  |
   //  | -- div ( window )
   //        |
   //        | -- div ( titlebar )
   //              |
   //              | -- span ( title )
   //              |
   //        | -- div ( text window area )
   //
   
   function windowCreate() 
   {
     // Find the main Body Tag.  Only one should exist in page 
     var bodyEl = document.getElementsByTagName("body");
   
     //WINDOW DIV
     var windowEl          = document.createElement("div");
     windowEl.className    = "window";
     windowEl.style.left   = this.left + "px";
     windowEl.style.top    = this.top + "px";
     windowEl.style.width  = this.width + "px"; 
     windowEl.style.height = this.height + "px";
     windowEl.id           = "window" + this.dom_id;
     windowEl.parent       = this;
   
   
     //TOP TITLE DIV
   
     var titleBarEl         = document.createElement("div");
     //  titleBarEl.className   = "windowTitleBar";
     titleBarEl.id          = "titleBar"; 
     titleBarEl.onmousedown = windowMove;
     titleBarEl.parent      = this;
   
     // Put the title into a table
   
     var tableTitleEl       = document.createElement("table");
     tableTitleEl.width     = "100%";
     var tbodyTitleEl       = document.createElement("tbody");
     var trTitleEl          = document.createElement("tr");
     var tdTitlePinIconEl   = document.createElement("td");
     tdTitlePinIconEl.width = "10%";
     tdTitlePinIconEl.algin = "right";
     tdTitlePinIconEl.className = "windowTitleBar";
     var tdTitleTitleEl     = document.createElement("td");
     tdTitleTitleEl.width   = "90%";
     tdTitleTitleEl.algin   = "right";
     tdTitleTitleEl.className = "windowTitleBar";
     tdTitleTitleEl.innerHTML   = 'WINDOW TITLE';
     tdTitleTitleEl.parent      = this;
     tdTitleTitleEl.onmouseover = windowMoveCursorSet;
     tdTitleTitleEl.onmouseout  = windowDefaultCursorSet;
     
     this.title  = tdTitleTitleEl;
     
     // CLOSE DIV
     var closeLink       = document.createElement("a");
     closeLink.setAttribute('href', 'javascript:void(0);');
     closeLink.onclick    = this.close;
     closeLink.parent    = this;
     var linkText = document.createTextNode('close');
     closeLink.appendChild(linkText);
     closeLink.style.color = "white";
   
   
     // Window List Area
     var windowAreaEl = document.createElement("div");
     windowAreaEl.className    = "windowListArea";
     
     windowAreaEl.style.width  = this.ca_width + "px";
     windowAreaEl.style.height = this.ca_height + "px";
     
     // Build DOM
     tdTitlePinIconEl.appendChild(closeLink);
   
     trTitleEl.appendChild(tdTitleTitleEl);
     trTitleEl.appendChild(tdTitlePinIconEl);
     tbodyTitleEl.appendChild(trTitleEl);
     tableTitleEl.appendChild(tbodyTitleEl);
     titleBarEl.appendChild(tableTitleEl);
     
     windowEl.appendChild(titleBarEl);
     
     windowEl.appendChild(windowAreaEl);
     document.body.appendChild(windowEl);
     
     this.window           = windowEl;
     this.windowArea       = windowAreaEl; 
     this.title            = tdTitleTitleEl;
   
   }
   
   function windowInit() 
   {
   
   }
   
   function windowChangeColor(color) 
   {
     this.window.style.backgroundColor = color;
     this.windowArea.style.backgroundColor = color;
   }
   
   function windowInsertHTML(html) 
   {
     this.windowArea.innerHTML = html;
   }
   
   function windowAppendHTML(html) 
   {
     this.windowArea.innerHTML = this.windowArea.innerHTML + html;
   }
   
   function windowAppendDomEl(el)
   {
     this.windowArea.appendChild(el);
   }
   
   function windowOpen() 
   {
     if (this.isOpen)
       return;
   
     this.opened = true;
   
     // Restore the Window and make it visible.
     this.makeActive();
     this.isOpen = true;
     this.window.style.visibility = "visible";
   }
   
   
   function windowMakeActive() 
   {
     if (myWindow == this)
       return;
   
     this.window.style.zIndex = globalWindowZIndex;
     globalWindowZIndex++;
     myWindow = this;
   
   }
   
   //
   // Event handlers.
   //
   
   
   function windowClientAreaClick(event) 
   {
   
     // Make this Window the active one.
   
      myWindow.makeActive();
   }
   
   function windowMove(event) 
   {
     var target;
     var x, y;
   
     if (browser.isIE)
       target = window.event.srcElement.tagName;
     if (browser.isNS)
       target = event.target.tagName;
   
     if (target == "AREA")
       return;
   
     p = this.parent;
     p.makeActive();
     // Get cursor offset from Window window.
   
     if (browser.isIE) {
       x = window.event.x;
       y = window.event.y;
     }
     if (browser.isNS) {
       x = event.pageX;
       y = event.pageY;
     }
     myWindow.xOffset = myWindow.window.offsetLeft - x;
     myWindow.yOffset = myWindow.window.offsetTop  - y;
   
     // Set document to capture mousemove and mouseup events.
   
     if (browser.isIE) {
       document.onmousemove = windowMoveDragStart;
       document.onmouseup   = windowMoveDragStop;
     }
     if (browser.isNS) {
       document.addEventListener("mousemove", windowMoveDragStart,   true);
       document.addEventListener("mouseup",   windowMoveDragStop, true);
       event.preventDefault();
     }
     myWindow.inMoveDrag = true;
     
   }
   
   
   
   function windowClose() 
   {
     this.parent.opened = false;
     document.body.removeChild(this.parent.window);
   }
   
   
   function windowMoveDragStart(event) 
   {
   
     var x, y;
   
     if (!myWindow.inMoveDrag)
       return;
   
     // Get cursor position.
   
     if (browser.isIE) {
       x = window.event.x;
       y = window.event.y;
       window.event.cancelBubble = true;
       window.event.returnValue = false;
     }
     if (browser.isNS) {
       x = event.pageX;
       y = event.pageY;
       event.preventDefault();
     }
   
     // Move Window window based on offset from cursor.
    
     nx = ( x + myWindow.xOffset );
     ny = ( y + myWindow.yOffset );
   
     if ( (nx<0) || (ny<0) ) {
   
     } else {
       myWindow.window.style.left = (x + myWindow.xOffset) + "px";
       myWindow.window.style.top  = (y + myWindow.yOffset) + "px";
     }
   }
   
   
   function windowMoveDragStop(event) 
   {
     myWindow.inMoveDrag = false;
   
     // Remove mousemove and mouseup event captures on document.
   
     if (browser.isIE) {
       document.onmousemove = null;
       document.onmouseup   = null;
     }
     if (browser.isNS) {
       document.removeEventListener("mousemove", windowMoveDragStart,   true);
       document.removeEventListener("mouseup",   windowMoveDragStop, true);
     }
   }
   
   
   function windowMoveCursorSet(event) 
   {
      this.style.cursor = "move";
   }
   
   function windowDefaultCursorSet(event) 
   {
      this.style.cursor = "move";
   }
   
   // End of Java Script
  </script>
  <noscript>
   <div class="noscript">
    <h2>JavaScript required</h2>
    <p>csrCompiler HTML pages require JavaScript.</p>
    <p>Your web browser does not support JavaScript or it has been disabled.</p>
   <div>
  </noscript>
 </head>
 <body onload="importXML('xmlData')">
  <xml id="xmlData" style="display:none;">
   <?xml version="1.0" encoding="UTF-8" ?>
   <csr:csrData
    xmlns:csr="http://www.semifore.com/schema/csrXmlHtml"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.semifore.com/schema/csrXmlHtml http://www.semifore.com/schema/csrXmlHtml.xsd"
    >
    <csr:fileInfo>
     <csr:inputFiles>
      <csr:file>
       <csr:filename>pu_i3c.csr</csr:filename>
      </csr:file>
     </csr:inputFiles>
     <csr:configurationFiles>
       <csr:file>
       <csr:filename>/project/jenkins/workspace/Esperanto_DV/soc_hal/esperanto-soc/dv/common/scripts/semifore_css/etsoc_esr.css</csr:filename>
      </csr:file>
     </csr:configurationFiles>
    </csr:fileInfo>
    <csr:csrObject>
     <csr:topDefinition>
      <csr:referenceName>i3c</csr:referenceName>
     </csr:topDefinition>
     <csr:definitions>
      <csr:definition>
       <csr:referenceType>addressmap</csr:referenceType>
       <csr:referenceName>i3c</csr:referenceName>
       <csr:identifier>i3c</csr:identifier>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2613</csr:linenumber>
       <csr:title></csr:title>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>I3c</csr:typeName>
        <csr:description>
         <csr:p>DWC MIPI I3C Memory Map</csr:p>
        </csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEVICE_CTRL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEVICE_ADDR</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.HW_CAPABILITY</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.COMMAND_QUEUE_PORT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.RESPONSE_QUEUE_PORT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>i3c.TX_DATA_PORT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>union</csr:referenceType>
         <csr:referenceName>i3c.IBI_QUEUE_STATUS</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.QUEUE_THLD_CTRL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DATA_BUFFER_THLD_CTRL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.IBI_QUEUE_CTRL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.IBI_SIR_REQ_REJECT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.RESET_CTRL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.SLV_EVENT_CTRL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.INTR_STATUS</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.INTR_STATUS_EN</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.INTR_SIGNAL_EN</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.INTR_FORCE</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.QUEUE_STATUS_LEVEL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DATA_BUFFER_STATUS_LEVEL</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.PRESENT_STATE</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEVICE_ADDR_TABLE_POINTER</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEV_CHAR_TABLE_POINTER</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.VENDOR_SPECIFIC_REG_POINTER</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEVICE_CTRL_EXTENDED</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.SCL_I3C_OD_TIMING</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.SCL_I3C_PP_TIMING</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.SCL_I2C_FM_TIMING</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.SCL_I2C_FMP_TIMING</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.SCL_EXT_LCNT_TIMING</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.SCL_EXT_TERMN_LCNT_TIMING</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.BUS_FREE_TIMING</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.I3C_VER_ID</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.I3C_VER_TYPE</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.EXTENDED_CAPABILITY</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEV_CHAR_TABLE1_LOC1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEV_CHAR_TABLE1_LOC2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEV_CHAR_TABLE1_LOC3</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEV_CHAR_TABLE1_LOC4</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEV_CHAR_TABLE2_LOC1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEV_CHAR_TABLE2_LOC2</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEV_CHAR_TABLE2_LOC3</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEV_CHAR_TABLE2_LOC4</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEV_ADDR_TABLE_LOC1</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.DEV_ADDR_TABLE_LOC2</csr:referenceName>
        </csr:reference>
       </csr:references>
       <csr:addressMap>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0x227</csr:addressHigh>
         <csr:instanceName>i3c</csr:instanceName>
         <csr:referenceName>i3c</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x0</csr:addressLow>
         <csr:addressHigh>0x0</csr:addressHigh>
         <csr:instanceName>i3c.DEVICE_CTRL</csr:instanceName>
         <csr:referenceName>i3c.DEVICE_CTRL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4</csr:addressLow>
         <csr:addressHigh>0x4</csr:addressHigh>
         <csr:instanceName>i3c.DEVICE_ADDR</csr:instanceName>
         <csr:referenceName>i3c.DEVICE_ADDR</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x8</csr:addressLow>
         <csr:addressHigh>0x8</csr:addressHigh>
         <csr:instanceName>i3c.HW_CAPABILITY</csr:instanceName>
         <csr:referenceName>i3c.HW_CAPABILITY</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC</csr:addressLow>
         <csr:addressHigh>0xC</csr:addressHigh>
         <csr:instanceName>i3c.COMMAND_QUEUE_PORT</csr:instanceName>
         <csr:referenceName>i3c.COMMAND_QUEUE_PORT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x10</csr:addressLow>
         <csr:addressHigh>0x10</csr:addressHigh>
         <csr:instanceName>i3c.RESPONSE_QUEUE_PORT</csr:instanceName>
         <csr:referenceName>i3c.RESPONSE_QUEUE_PORT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x14</csr:addressLow>
         <csr:addressHigh>0x14</csr:addressHigh>
         <csr:instanceName>i3c.TX_DATA_PORT.TX_DATA_PORT</csr:instanceName>
         <csr:referenceName>i3c.TX_DATA_PORT.TX_DATA_PORT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x14</csr:addressLow>
         <csr:addressHigh>0x14</csr:addressHigh>
         <csr:instanceName>i3c.TX_DATA_PORT.RX_DATA_PORT</csr:instanceName>
         <csr:referenceName>i3c.TX_DATA_PORT.RX_DATA_PORT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x18</csr:addressLow>
         <csr:addressHigh>0x18</csr:addressHigh>
         <csr:instanceName>i3c.IBI_QUEUE_STATUS.IBI_QUEUE_STATUS</csr:instanceName>
         <csr:referenceName>i3c.IBI_QUEUE_STATUS.IBI_QUEUE_STATUS</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x18</csr:addressLow>
         <csr:addressHigh>0x18</csr:addressHigh>
         <csr:instanceName>i3c.IBI_QUEUE_STATUS.IBI_QUEUE_DATA</csr:instanceName>
         <csr:referenceName>i3c.IBI_QUEUE_STATUS.IBI_QUEUE_DATA</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x1C</csr:addressLow>
         <csr:addressHigh>0x1C</csr:addressHigh>
         <csr:instanceName>i3c.QUEUE_THLD_CTRL</csr:instanceName>
         <csr:referenceName>i3c.QUEUE_THLD_CTRL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x20</csr:addressLow>
         <csr:addressHigh>0x20</csr:addressHigh>
         <csr:instanceName>i3c.DATA_BUFFER_THLD_CTRL</csr:instanceName>
         <csr:referenceName>i3c.DATA_BUFFER_THLD_CTRL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x24</csr:addressLow>
         <csr:addressHigh>0x24</csr:addressHigh>
         <csr:instanceName>i3c.IBI_QUEUE_CTRL</csr:instanceName>
         <csr:referenceName>i3c.IBI_QUEUE_CTRL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x28</csr:addressLow>
         <csr:addressHigh>0x2F</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x30</csr:addressLow>
         <csr:addressHigh>0x30</csr:addressHigh>
         <csr:instanceName>i3c.IBI_SIR_REQ_REJECT</csr:instanceName>
         <csr:referenceName>i3c.IBI_SIR_REQ_REJECT</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x34</csr:addressLow>
         <csr:addressHigh>0x34</csr:addressHigh>
         <csr:instanceName>i3c.RESET_CTRL</csr:instanceName>
         <csr:referenceName>i3c.RESET_CTRL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x38</csr:addressLow>
         <csr:addressHigh>0x38</csr:addressHigh>
         <csr:instanceName>i3c.SLV_EVENT_CTRL</csr:instanceName>
         <csr:referenceName>i3c.SLV_EVENT_CTRL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x3C</csr:addressLow>
         <csr:addressHigh>0x3C</csr:addressHigh>
         <csr:instanceName>i3c.INTR_STATUS</csr:instanceName>
         <csr:referenceName>i3c.INTR_STATUS</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x40</csr:addressLow>
         <csr:addressHigh>0x40</csr:addressHigh>
         <csr:instanceName>i3c.INTR_STATUS_EN</csr:instanceName>
         <csr:referenceName>i3c.INTR_STATUS_EN</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x44</csr:addressLow>
         <csr:addressHigh>0x44</csr:addressHigh>
         <csr:instanceName>i3c.INTR_SIGNAL_EN</csr:instanceName>
         <csr:referenceName>i3c.INTR_SIGNAL_EN</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x48</csr:addressLow>
         <csr:addressHigh>0x48</csr:addressHigh>
         <csr:instanceName>i3c.INTR_FORCE</csr:instanceName>
         <csr:referenceName>i3c.INTR_FORCE</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x4C</csr:addressLow>
         <csr:addressHigh>0x4C</csr:addressHigh>
         <csr:instanceName>i3c.QUEUE_STATUS_LEVEL</csr:instanceName>
         <csr:referenceName>i3c.QUEUE_STATUS_LEVEL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x50</csr:addressLow>
         <csr:addressHigh>0x50</csr:addressHigh>
         <csr:instanceName>i3c.DATA_BUFFER_STATUS_LEVEL</csr:instanceName>
         <csr:referenceName>i3c.DATA_BUFFER_STATUS_LEVEL</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x54</csr:addressLow>
         <csr:addressHigh>0x54</csr:addressHigh>
         <csr:instanceName>i3c.PRESENT_STATE</csr:instanceName>
         <csr:referenceName>i3c.PRESENT_STATE</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x58</csr:addressLow>
         <csr:addressHigh>0x5B</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x5C</csr:addressLow>
         <csr:addressHigh>0x5C</csr:addressHigh>
         <csr:instanceName>i3c.DEVICE_ADDR_TABLE_POINTER</csr:instanceName>
         <csr:referenceName>i3c.DEVICE_ADDR_TABLE_POINTER</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x60</csr:addressLow>
         <csr:addressHigh>0x60</csr:addressHigh>
         <csr:instanceName>i3c.DEV_CHAR_TABLE_POINTER</csr:instanceName>
         <csr:referenceName>i3c.DEV_CHAR_TABLE_POINTER</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x64</csr:addressLow>
         <csr:addressHigh>0x6B</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x6C</csr:addressLow>
         <csr:addressHigh>0x6C</csr:addressHigh>
         <csr:instanceName>i3c.VENDOR_SPECIFIC_REG_POINTER</csr:instanceName>
         <csr:referenceName>i3c.VENDOR_SPECIFIC_REG_POINTER</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x70</csr:addressLow>
         <csr:addressHigh>0xAF</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xB0</csr:addressLow>
         <csr:addressHigh>0xB0</csr:addressHigh>
         <csr:instanceName>i3c.DEVICE_CTRL_EXTENDED</csr:instanceName>
         <csr:referenceName>i3c.DEVICE_CTRL_EXTENDED</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xB4</csr:addressLow>
         <csr:addressHigh>0xB4</csr:addressHigh>
         <csr:instanceName>i3c.SCL_I3C_OD_TIMING</csr:instanceName>
         <csr:referenceName>i3c.SCL_I3C_OD_TIMING</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xB8</csr:addressLow>
         <csr:addressHigh>0xB8</csr:addressHigh>
         <csr:instanceName>i3c.SCL_I3C_PP_TIMING</csr:instanceName>
         <csr:referenceName>i3c.SCL_I3C_PP_TIMING</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xBC</csr:addressLow>
         <csr:addressHigh>0xBC</csr:addressHigh>
         <csr:instanceName>i3c.SCL_I2C_FM_TIMING</csr:instanceName>
         <csr:referenceName>i3c.SCL_I2C_FM_TIMING</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC0</csr:addressLow>
         <csr:addressHigh>0xC0</csr:addressHigh>
         <csr:instanceName>i3c.SCL_I2C_FMP_TIMING</csr:instanceName>
         <csr:referenceName>i3c.SCL_I2C_FMP_TIMING</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC4</csr:addressLow>
         <csr:addressHigh>0xC7</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xC8</csr:addressLow>
         <csr:addressHigh>0xC8</csr:addressHigh>
         <csr:instanceName>i3c.SCL_EXT_LCNT_TIMING</csr:instanceName>
         <csr:referenceName>i3c.SCL_EXT_LCNT_TIMING</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xCC</csr:addressLow>
         <csr:addressHigh>0xCC</csr:addressHigh>
         <csr:instanceName>i3c.SCL_EXT_TERMN_LCNT_TIMING</csr:instanceName>
         <csr:referenceName>i3c.SCL_EXT_TERMN_LCNT_TIMING</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD0</csr:addressLow>
         <csr:addressHigh>0xD3</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD4</csr:addressLow>
         <csr:addressHigh>0xD4</csr:addressHigh>
         <csr:instanceName>i3c.BUS_FREE_TIMING</csr:instanceName>
         <csr:referenceName>i3c.BUS_FREE_TIMING</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xD8</csr:addressLow>
         <csr:addressHigh>0xDF</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xE0</csr:addressLow>
         <csr:addressHigh>0xE0</csr:addressHigh>
         <csr:instanceName>i3c.I3C_VER_ID</csr:instanceName>
         <csr:referenceName>i3c.I3C_VER_ID</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xE4</csr:addressLow>
         <csr:addressHigh>0xE4</csr:addressHigh>
         <csr:instanceName>i3c.I3C_VER_TYPE</csr:instanceName>
         <csr:referenceName>i3c.I3C_VER_TYPE</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xE8</csr:addressLow>
         <csr:addressHigh>0xE8</csr:addressHigh>
         <csr:instanceName>i3c.EXTENDED_CAPABILITY</csr:instanceName>
         <csr:referenceName>i3c.EXTENDED_CAPABILITY</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0xEC</csr:addressLow>
         <csr:addressHigh>0x1FF</csr:addressHigh>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x200</csr:addressLow>
         <csr:addressHigh>0x200</csr:addressHigh>
         <csr:instanceName>i3c.DEV_CHAR_TABLE1_LOC1</csr:instanceName>
         <csr:referenceName>i3c.DEV_CHAR_TABLE1_LOC1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x204</csr:addressLow>
         <csr:addressHigh>0x204</csr:addressHigh>
         <csr:instanceName>i3c.DEV_CHAR_TABLE1_LOC2</csr:instanceName>
         <csr:referenceName>i3c.DEV_CHAR_TABLE1_LOC2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x208</csr:addressLow>
         <csr:addressHigh>0x208</csr:addressHigh>
         <csr:instanceName>i3c.DEV_CHAR_TABLE1_LOC3</csr:instanceName>
         <csr:referenceName>i3c.DEV_CHAR_TABLE1_LOC3</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x20C</csr:addressLow>
         <csr:addressHigh>0x20C</csr:addressHigh>
         <csr:instanceName>i3c.DEV_CHAR_TABLE1_LOC4</csr:instanceName>
         <csr:referenceName>i3c.DEV_CHAR_TABLE1_LOC4</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x210</csr:addressLow>
         <csr:addressHigh>0x210</csr:addressHigh>
         <csr:instanceName>i3c.DEV_CHAR_TABLE2_LOC1</csr:instanceName>
         <csr:referenceName>i3c.DEV_CHAR_TABLE2_LOC1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x214</csr:addressLow>
         <csr:addressHigh>0x214</csr:addressHigh>
         <csr:instanceName>i3c.DEV_CHAR_TABLE2_LOC2</csr:instanceName>
         <csr:referenceName>i3c.DEV_CHAR_TABLE2_LOC2</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x218</csr:addressLow>
         <csr:addressHigh>0x218</csr:addressHigh>
         <csr:instanceName>i3c.DEV_CHAR_TABLE2_LOC3</csr:instanceName>
         <csr:referenceName>i3c.DEV_CHAR_TABLE2_LOC3</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x21C</csr:addressLow>
         <csr:addressHigh>0x21C</csr:addressHigh>
         <csr:instanceName>i3c.DEV_CHAR_TABLE2_LOC4</csr:instanceName>
         <csr:referenceName>i3c.DEV_CHAR_TABLE2_LOC4</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x220</csr:addressLow>
         <csr:addressHigh>0x220</csr:addressHigh>
         <csr:instanceName>i3c.DEV_ADDR_TABLE_LOC1</csr:instanceName>
         <csr:referenceName>i3c.DEV_ADDR_TABLE_LOC1</csr:referenceName>
        </csr:addressMapEntry>
        <csr:addressMapEntry>
         <csr:addressLow>0x224</csr:addressLow>
         <csr:addressHigh>0x224</csr:addressHigh>
         <csr:instanceName>i3c.DEV_ADDR_TABLE_LOC2</csr:instanceName>
         <csr:referenceName>i3c.DEV_ADDR_TABLE_LOC2</csr:referenceName>
        </csr:addressMapEntry>
       </csr:addressMap>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEVICE_CTRL</csr:referenceName>
       <csr:identifier>DEVICE_CTRL</csr:identifier>
       <csr:addressMacro>I3C_DEVICE_CTRL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEVICE_CTRL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEVICE_CTRL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEVICE_CTRL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>205</csr:linenumber>
       <csr:title>Device Control Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_DEVICE_CTRL</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>This Register is used to program the bits which decides the transfer properties and controller's response to events</csr:p>
         <csr:p>like IBI, Hot-Join, and so-on in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IBA_INCLUDE</csr:identifier>
         <csr:widthMacro>I3C_DEVICE_CTRL_IBA_INCLUDE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEVICE_CTRL_IBA_INCLUDE_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEVICE_CTRL_IBA_INCLUDE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEVICE_CTRL_IBA_INCLUDE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEVICE_CTRL_IBA_INCLUDE_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEVICE_CTRL_IBA_INCLUDE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEVICE_CTRL_IBA_INCLUDE_GET</csr:getMacro>
         <csr:setMacro>I3C_DEVICE_CTRL_IBA_INCLUDE_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>67</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I3C Broadcast Address include.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is used in master mode of operation. </csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is used to include I3C broadcast address (0x7E) for private transfer.</csr:p>
         <csr:p></csr:p>
         <csr:p>Note: If I3C broadcast address is not included for the private transfers, In-band Interrupts (IBI)</csr:p>
         <csr:p>driven from Slaves may not win address arbitration. Hence, the IBIs will get delayed.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>INCLUDED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>I3C Broadcast Address is included for Private Transfers</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_INCLUDED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>I3C Broadcast Address is not included for Private Transfers</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>6</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>I2C_SLAVE_PRESENT</csr:identifier>
         <csr:widthMacro>I3C_DEVICE_CTRL_I2C_SLAVE_PRESENT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEVICE_CTRL_I2C_SLAVE_PRESENT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEVICE_CTRL_I2C_SLAVE_PRESENT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEVICE_CTRL_I2C_SLAVE_PRESENT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEVICE_CTRL_I2C_SLAVE_PRESENT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEVICE_CTRL_I2C_SLAVE_PRESENT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEVICE_CTRL_I2C_SLAVE_PRESENT_GET</csr:getMacro>
         <csr:setMacro>I3C_DEVICE_CTRL_I2C_SLAVE_PRESENT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>101</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I2C Slave Present</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is used in master mode of operation. </csr:p>
         <csr:p></csr:p>
         <csr:p>This Bit indicates whether any Legacy I2C Devices are present in the system.</csr:p>
         <csr:p></csr:p>
         <csr:p>When this bit is set, controller uses I2C_OD_LCNT as the minimum time to start a transfer after stop condition, else it uses</csr:p>
         <csr:p>I3C_MST_FREE for this.</csr:p>
         <csr:p></csr:p>
         <csr:p>In HDR mode, this field is used to select TSL over TSP in mixed bus configuration.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>I2C Slave not present</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>I2C Slave present</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>HOT_JOIN_CTRL</csr:identifier>
         <csr:widthMacro>I3C_DEVICE_CTRL_HOT_JOIN_CTRL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEVICE_CTRL_HOT_JOIN_CTRL_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEVICE_CTRL_HOT_JOIN_CTRL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEVICE_CTRL_HOT_JOIN_CTRL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEVICE_CTRL_HOT_JOIN_CTRL_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEVICE_CTRL_HOT_JOIN_CTRL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEVICE_CTRL_HOT_JOIN_CTRL_GET</csr:getMacro>
         <csr:setMacro>I3C_DEVICE_CTRL_HOT_JOIN_CTRL_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>132</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Hot-Join Ack/Nack Control</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is used in master mode of operation. </csr:p>
         <csr:p></csr:p>
         <csr:p>This bit acts as global control to ACK/NACK the Hot-Join Request from the devices. The DWC_mipi_i3c Master</csr:p>
         <csr:p>will ACK/NACK the Hot-Join request from other devices connected on the I3C Bus, based on programming of this bit.</csr:p>
         <csr:p> - 0: ACK the Hot-join request.</csr:p>
         <csr:p> - 1: NACK and send broadcast CCC to disable Hot-join.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Ack Hot-Join requests</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Nack and auto-disable Hot-Join request</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>28</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ABORT</csr:identifier>
         <csr:widthMacro>I3C_DEVICE_CTRL_ABORT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEVICE_CTRL_ABORT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEVICE_CTRL_ABORT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEVICE_CTRL_ABORT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEVICE_CTRL_ABORT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEVICE_CTRL_ABORT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEVICE_CTRL_ABORT_GET</csr:getMacro>
         <csr:setMacro>I3C_DEVICE_CTRL_ABORT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>154</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>DWC_mipi_i3c Abort.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is used in master mode of operation. </csr:p>
         <csr:p></csr:p>
         <csr:p>This bit allows the user to relinquish the I3C Bus before completing the issued transfer.</csr:p>
         <csr:p></csr:p>
         <csr:p>In response to an ABORT request, the controller issues the STOP condition after the complete</csr:p>
         <csr:p>data byte is transferred or received.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is auto-cleared once the transfer is aborted and controller issues a 'Transfer Abort' interrupt.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>29</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RESUME</csr:identifier>
         <csr:widthMacro>I3C_DEVICE_CTRL_RESUME_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEVICE_CTRL_RESUME_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEVICE_CTRL_RESUME_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEVICE_CTRL_RESUME_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEVICE_CTRL_RESUME_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEVICE_CTRL_RESUME_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEVICE_CTRL_RESUME_GET</csr:getMacro>
         <csr:setMacro>I3C_DEVICE_CTRL_RESUME_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>181</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>DWC_mipi_i3c Resume.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is used to resume the Controller after it goes to Halt state.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>In the master mode of operation the controller goes to the halt state (as indicated in PRESENT_STATE Register) due to any type of error</csr:p>
         <csr:p>in the transfer (the type of error is indicated by ERR_STATUS field in the RESPONSE_QUEUE_PORT register).</csr:p>
         <csr:p></csr:p>
         <csr:p>After the controller has gone to halt state, the application has to write 1'b1 to this bit to resume the controller.</csr:p>
         <csr:p>This bit is auto-cleared once the controller resumes the transfers by initiating the next command.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>30</csr:msb>
         <csr:lsb>30</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ENABLE</csr:identifier>
         <csr:widthMacro>I3C_DEVICE_CTRL_ENABLE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEVICE_CTRL_ENABLE_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEVICE_CTRL_ENABLE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEVICE_CTRL_ENABLE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEVICE_CTRL_ENABLE_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEVICE_CTRL_ENABLE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEVICE_CTRL_ENABLE_GET</csr:getMacro>
         <csr:setMacro>I3C_DEVICE_CTRL_ENABLE_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>204</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>Controls whether DWC_mipi_i3c is enabled in master mode of operation.</csr:p>
         <csr:p> - 1: Enables the DWC_mipi_i3c controller.</csr:p>
         <csr:p> - 0: Disables the DWC_mipi_i3c controller.</csr:p>
         <csr:p>Software can disable DWC_mipi_i3c while it is active. However, the disable happens after all the initiated commands are</csr:p>
         <csr:p>completed in the command queue and Master FSM is in IDLE state (as indicated in PRESENT_STATE Register). Software can read</csr:p>
         <csr:p>back 1'b0 from this field once disabling of DWC_mipi_i3c is completed.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEVICE_ADDR</csr:referenceName>
       <csr:identifier>DEVICE_ADDR</csr:identifier>
       <csr:addressMacro>I3C_DEVICE_ADDR_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEVICE_ADDR_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEVICE_ADDR_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEVICE_ADDR_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>269</csr:linenumber>
       <csr:title>Device Address Register</csr:title>
       <csr:offset>0x4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x80000000</csr:registerResetValue>
       <csr:typeName>I3c_DEVICE_ADDR</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>In the master mode of operation this Register is used to program the Device Dynamic Addresses and its respective valid bit.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DYNAMIC_ADDR</csr:identifier>
         <csr:widthMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>237</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Device Dynamic Address.</csr:p>
         <csr:p></csr:p>
         <csr:p>This field is used to program the Device Dynamic Address. The Controller uses this address for I3C transfers.</csr:p>
         <csr:p></csr:p>
         <csr:p> - In Main Master mode, the user/application has to program the Dynamic Address through the Slave interface as it self-assigns its Dynamic Address.</csr:p>
         <csr:p> - In all other modes, the Main Master assigns this address during ENTDAA or SETDASA mechanism.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>22</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>30</csr:msb>
         <csr:lsb>23</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DYNAMIC_ADDR_VALID</csr:identifier>
         <csr:widthMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_VALID_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_VALID_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_VALID_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_VALID_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_VALID_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_VALID_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_VALID_GET</csr:getMacro>
         <csr:setMacro>I3C_DEVICE_ADDR_DYNAMIC_ADDR_VALID_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>268</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Dynamic Address Valid</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is used to control whether the DYNAMIC_ADDR is valid or not.</csr:p>
         <csr:p></csr:p>
         <csr:p> - In I3C Main Master mode, the user sets this bit to 1 as it self-assigns its dynamic address.</csr:p>
         <csr:p> - In all other operation modes, the Controller sets this bit to 1 when Main Master assigns the Dynamic address during ENTDAA or SETDASA mechanism.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>INVALID</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Dynamic Address is invalid</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>VALID</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Dynamic Address is valid</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.HW_CAPABILITY</csr:referenceName>
       <csr:identifier>HW_CAPABILITY</csr:identifier>
       <csr:addressMacro>I3C_HW_CAPABILITY_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_HW_CAPABILITY_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_HW_CAPABILITY_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_HW_CAPABILITY_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>328</csr:linenumber>
       <csr:title>Hardware Capability register</csr:title>
       <csr:offset>0x8</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000001</csr:registerResetValue>
       <csr:typeName>I3c_HW_CAPABILITY</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Hardware Capabilities register </csr:p>
         <csr:p></csr:p>
         <csr:p>This register is used in master mode of operation</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DAA_EN</csr:identifier>
         <csr:widthMacro>I3C_HW_CAPABILITY_DAA_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_HW_CAPABILITY_DAA_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_HW_CAPABILITY_DAA_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_HW_CAPABILITY_DAA_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_HW_CAPABILITY_DAA_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_HW_CAPABILITY_DAA_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_HW_CAPABILITY_DAA_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_HW_CAPABILITY_DAA_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>297</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Reflects the IC_HAS_DAA Configurable Parameter.</csr:p>
         <csr:p></csr:p>
         <csr:p>Specifies whether the Master has the capability to assign dynamic address to devices through</csr:p>
         <csr:p>ENTDAA mechanism.</csr:p>
         <csr:p> - 0: Not capable of assigning dynamic address through ENTDAA</csr:p>
         <csr:p> - 1: Capable of assigning dynamic address through ENTDAA</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>HDR_DDR_EN</csr:identifier>
         <csr:widthMacro>I3C_HW_CAPABILITY_HDR_DDR_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_HW_CAPABILITY_HDR_DDR_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_HW_CAPABILITY_HDR_DDR_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_HW_CAPABILITY_HDR_DDR_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_HW_CAPABILITY_HDR_DDR_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_HW_CAPABILITY_HDR_DDR_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_HW_CAPABILITY_HDR_DDR_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_HW_CAPABILITY_HDR_DDR_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>312</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Reflects the IC_SPEED_HDR_DDR Configurable Parameter.</csr:p>
         <csr:p></csr:p>
         <csr:p>Specifies the Master's capability to initiate HDR-DDR transfers.</csr:p>
         <csr:p> - 0 : HDR-DDR not supported</csr:p>
         <csr:p> - 1 : HDR-DDR supported</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>8</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>HDR_TS_EN</csr:identifier>
         <csr:widthMacro>I3C_HW_CAPABILITY_HDR_TS_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_HW_CAPABILITY_HDR_TS_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_HW_CAPABILITY_HDR_TS_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_HW_CAPABILITY_HDR_TS_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_HW_CAPABILITY_HDR_TS_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_HW_CAPABILITY_HDR_TS_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_HW_CAPABILITY_HDR_TS_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_HW_CAPABILITY_HDR_TS_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>327</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Reflects the IC_SPEED_HDR_TS Configurable Parameter.</csr:p>
         <csr:p></csr:p>
         <csr:p>Specifies master's capability to initiate HDR-TS transfers.</csr:p>
         <csr:p> - 0 : HDR-TS not supported</csr:p>
         <csr:p> - 1 : HDR-TS supported</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.COMMAND_QUEUE_PORT</csr:referenceName>
       <csr:identifier>COMMAND_QUEUE_PORT</csr:identifier>
       <csr:addressMacro>I3C_COMMAND_QUEUE_PORT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_COMMAND_QUEUE_PORT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_COMMAND_QUEUE_PORT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_COMMAND_QUEUE_PORT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>363</csr:linenumber>
       <csr:title>COMMAND_QUEUE_PORT</csr:title>
       <csr:offset>0xC</csr:offset>
       <csr:addressedAccess>W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_COMMAND_QUEUE_PORT</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>COMMAND_QUEUE_PORT.</csr:p>
         <csr:p></csr:p>
         <csr:p>In Master mode of operation :</csr:p>
         <csr:p>Command Descriptor structure is used to schedule the command to devices on I3C bus.</csr:p>
         <csr:p>There are four types of commands defined</csr:p>
         <csr:p> - Transfer Command</csr:p>
         <csr:p> - Transfer Argument</csr:p>
         <csr:p> - Short Data Argument</csr:p>
         <csr:p> - Address Assignment Command</csr:p>
         <csr:p></csr:p>
         <csr:p>&lt;ct:cbc:1:IC_I3C_SLAVE_APB==1&gt;</csr:p>
         <csr:p>In Slave mode of operation :</csr:p>
         <csr:p>Command Queue Port is used to push commands which enables the controller to respond with data for a private read command</csr:p>
         <csr:p>from the current master.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>COMMAND</csr:identifier>
         <csr:widthMacro>I3C_COMMAND_QUEUE_PORT_COMMAND_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_COMMAND_QUEUE_PORT_COMMAND_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_COMMAND_QUEUE_PORT_COMMAND_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_COMMAND_QUEUE_PORT_COMMAND_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_COMMAND_QUEUE_PORT_COMMAND_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_COMMAND_QUEUE_PORT_COMMAND_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_COMMAND_QUEUE_PORT_COMMAND_GET</csr:getMacro>
         <csr:setMacro>I3C_COMMAND_QUEUE_PORT_COMMAND_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>362</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>32 bit command</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.RESPONSE_QUEUE_PORT</csr:referenceName>
       <csr:identifier>RESPONSE_QUEUE_PORT</csr:identifier>
       <csr:addressMacro>I3C_RESPONSE_QUEUE_PORT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_RESPONSE_QUEUE_PORT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_RESPONSE_QUEUE_PORT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_RESPONSE_QUEUE_PORT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>399</csr:linenumber>
       <csr:title>RESPONSE_QUEUE_PORT</csr:title>
       <csr:offset>0x10</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_RESPONSE_QUEUE_PORT</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>In Master mode of operation :</csr:p>
         <csr:p>The response status for each Command is written into the Response Queue if ROC (Response On Completion) bit is set or</csr:p>
         <csr:p>if transfer error has occured. The Response Queue can be read through this register. </csr:p>
         <csr:p>It is expected that this register</csr:p>
         <csr:p>will be read whenever RESP_READY_STAT_INTR bit is set in INTR_STATUS register. Not doing so, will result in stalling of</csr:p>
         <csr:p>command. A new command will be executed only if there is space available in Response Queue to push the corresponding response.</csr:p>
         <csr:p></csr:p>
         <csr:p>Reset value of this register is not defined as it is internally mapped to a queue.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RESPONSE</csr:identifier>
         <csr:widthMacro>I3C_RESPONSE_QUEUE_PORT_RESPONSE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_RESPONSE_QUEUE_PORT_RESPONSE_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_RESPONSE_QUEUE_PORT_RESPONSE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_RESPONSE_QUEUE_PORT_RESPONSE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_RESPONSE_QUEUE_PORT_RESPONSE_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_RESPONSE_QUEUE_PORT_RESPONSE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_RESPONSE_QUEUE_PORT_RESPONSE_GET</csr:getMacro>
         <csr:setMacro>I3C_RESPONSE_QUEUE_PORT_RESPONSE_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>398</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>32 bit Response</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>i3c.TX_DATA_PORT</csr:referenceName>
       <csr:identifier>TX_DATA_PORT</csr:identifier>
       <csr:addressMacro>I3C_TX_DATA_PORT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_TX_DATA_PORT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_TX_DATA_PORT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_TX_DATA_PORT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>470</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x14</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:typeName>I3c_TX_DATA_PORT</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.TX_DATA_PORT.TX_DATA_PORT</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.TX_DATA_PORT.RX_DATA_PORT</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.TX_DATA_PORT.TX_DATA_PORT</csr:referenceName>
       <csr:identifier>TX_DATA_PORT</csr:identifier>
       <csr:addressMacro>I3C_TX_DATA_PORT_TX_DATA_PORT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_TX_DATA_PORT_TX_DATA_PORT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_TX_DATA_PORT_TX_DATA_PORT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_TX_DATA_PORT_TX_DATA_PORT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>433</csr:linenumber>
       <csr:title>Transmit Data Port Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_TX_DATA_PORT_TX_DATA_PORT</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transmit Data Port Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This register when written into, writes data to the TX Buffer. This has the same offset as RX_DATA_PORT to provide a</csr:p>
         <csr:p>single bi-directional data port for transmitting or receiving the data from the DWC_mipi_i3c.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TX_DATA_PORT</csr:identifier>
         <csr:widthMacro>I3C_TX_DATA_PORT_TX_DATA_PORT_TX_DATA_PORT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_TX_DATA_PORT_TX_DATA_PORT_TX_DATA_PORT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_TX_DATA_PORT_TX_DATA_PORT_TX_DATA_PORT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_TX_DATA_PORT_TX_DATA_PORT_TX_DATA_PORT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_TX_DATA_PORT_TX_DATA_PORT_TX_DATA_PORT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_TX_DATA_PORT_TX_DATA_PORT_TX_DATA_PORT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_TX_DATA_PORT_TX_DATA_PORT_TX_DATA_PORT_GET</csr:getMacro>
         <csr:setMacro>I3C_TX_DATA_PORT_TX_DATA_PORT_TX_DATA_PORT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>432</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transmit Data Port.</csr:p>
         <csr:p></csr:p>
         <csr:p>The Transmit Data port is mapped to the Tx-Data Buffer.</csr:p>
         <csr:p></csr:p>
         <csr:p>The transmit data should always be packed as 4-byte aligned data words and written to the Transmit Data Port register.</csr:p>
         <csr:p>If the Command length is not aligned to 4-bytes, then the additional bytes will be ignored.</csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.TX_DATA_PORT.RX_DATA_PORT</csr:referenceName>
       <csr:identifier>RX_DATA_PORT</csr:identifier>
       <csr:addressMacro>I3C_TX_DATA_PORT_RX_DATA_PORT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_TX_DATA_PORT_RX_DATA_PORT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_TX_DATA_PORT_RX_DATA_PORT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_TX_DATA_PORT_RX_DATA_PORT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>469</csr:linenumber>
       <csr:title>Receive Data Port Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_TX_DATA_PORT_RX_DATA_PORT</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Receive Data Port Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This register when read from, reads data from the RX Buffer. This has the same offset as TX_DATA_PORT to provide a</csr:p>
         <csr:p>single bi-directional data port for transmitting or receiving the data from the DWC_mipi_i3c. Reset value of this</csr:p>
         <csr:p>register is not defined as it is mapped to External RAM.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>RX_DATA_PORT</csr:identifier>
         <csr:widthMacro>I3C_TX_DATA_PORT_RX_DATA_PORT_RX_DATA_PORT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_TX_DATA_PORT_RX_DATA_PORT_RX_DATA_PORT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_TX_DATA_PORT_RX_DATA_PORT_RX_DATA_PORT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_TX_DATA_PORT_RX_DATA_PORT_RX_DATA_PORT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_TX_DATA_PORT_RX_DATA_PORT_RX_DATA_PORT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_TX_DATA_PORT_RX_DATA_PORT_RX_DATA_PORT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_TX_DATA_PORT_RX_DATA_PORT_RX_DATA_PORT_GET</csr:getMacro>
         <csr:setMacro>I3C_TX_DATA_PORT_RX_DATA_PORT_RX_DATA_PORT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>468</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Receive Data Port.</csr:p>
         <csr:p></csr:p>
         <csr:p>The Receive data port is mapped to the Rx-Data Buffer.</csr:p>
         <csr:p></csr:p>
         <csr:p>The Receive data is always packed in 4-byte aligned data words and stored in the Rx-Data Buffer.</csr:p>
         <csr:p>If the command length is not aligned to the 4-bytes, then the additional data bytes have to be ignored.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>union</csr:referenceType>
       <csr:referenceName>i3c.IBI_QUEUE_STATUS</csr:referenceName>
       <csr:identifier>IBI_QUEUE_STATUS</csr:identifier>
       <csr:addressMacro>I3C_IBI_QUEUE_STATUS_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_IBI_QUEUE_STATUS_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_IBI_QUEUE_STATUS_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_IBI_QUEUE_STATUS_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>565</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x18</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:typeName>I3c_IBI_QUEUE_STATUS</csr:typeName>
        <csr:description></csr:description>
       <csr:references>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.IBI_QUEUE_STATUS.IBI_QUEUE_STATUS</csr:referenceName>
        </csr:reference>
        <csr:reference>
         <csr:referenceType>register</csr:referenceType>
         <csr:referenceName>i3c.IBI_QUEUE_STATUS.IBI_QUEUE_DATA</csr:referenceName>
        </csr:reference>
       </csr:references>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.IBI_QUEUE_STATUS.IBI_QUEUE_STATUS</csr:referenceName>
       <csr:identifier>IBI_QUEUE_STATUS</csr:identifier>
       <csr:addressMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>532</csr:linenumber>
       <csr:title>In-Band Interrupt Queue Status Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>In-Band Interrupt Queue Status Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is used in master mode of operation</csr:p>
         <csr:p></csr:p>
         <csr:p>This register when read from, reads the data from the IBI Queue. Reset value of this register is not available as it</csr:p>
         <csr:p>is internally mapped to a queue.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DATA_LENGTH</csr:identifier>
         <csr:widthMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_DATA_LENGTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_DATA_LENGTH_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_DATA_LENGTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_DATA_LENGTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_DATA_LENGTH_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_DATA_LENGTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_DATA_LENGTH_GET</csr:getMacro>
         <csr:setMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_DATA_LENGTH_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>499</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>In-Band Interrupt data length.</csr:p>
         <csr:p></csr:p>
         <csr:p>This field represents the length of data received along with the IBI, in bytes.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IBI_ID</csr:identifier>
         <csr:widthMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_ID_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_ID_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_ID_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_ID_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_ID_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_ID_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_ID_GET</csr:getMacro>
         <csr:setMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_ID_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>515</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>IBI Identifier. </csr:p>
         <csr:p></csr:p>
         <csr:p>The byte received after START which includes the address and the R/W bit.</csr:p>
         <csr:p> - Device address and R/W bit in case of Slave Interrupt or Master Request.</csr:p>
         <csr:p> - Hot-Join ID and R/W bit in case of Hot-Join IBI.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>27</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IBI_STS</csr:identifier>
         <csr:widthMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_STS_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_STS_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_STS_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_STS_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_STS_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_STS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_STS_GET</csr:getMacro>
         <csr:setMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_STATUS_IBI_STS_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>531</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>IBI Received Status.</csr:p>
         <csr:p></csr:p>
         <csr:p>Defines the master response for IBI received.</csr:p>
         <csr:p></csr:p>
         <csr:p> - 4'b0xxx: Responded with ACK</csr:p>
         <csr:p> - 4'b1xxx: Responded with NACK</csr:p>
         <csr:p> - Others : RESERVED</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.IBI_QUEUE_STATUS.IBI_QUEUE_DATA</csr:referenceName>
       <csr:identifier>IBI_QUEUE_DATA</csr:identifier>
       <csr:addressMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_DATA_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_DATA_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_DATA_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_DATA_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>564</csr:linenumber>
       <csr:title>In-Band Interrupt Queue Data Register</csr:title>
       <csr:offset>0x0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_IBI_QUEUE_STATUS_IBI_QUEUE_DATA</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>In-Band Interrupt Queue Data Register </csr:p>
         <csr:p></csr:p>
         <csr:p>This register is used in master mode of operation</csr:p>
         <csr:p></csr:p>
         <csr:p>This register when read from, reads the data from the IBI Queue. Reset value of this register is not available as it</csr:p>
         <csr:p>is internally mapped to a queue.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>IBI_DATA</csr:identifier>
         <csr:widthMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_DATA_IBI_DATA_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_DATA_IBI_DATA_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_DATA_IBI_DATA_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_DATA_IBI_DATA_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_DATA_IBI_DATA_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_DATA_IBI_DATA_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_DATA_IBI_DATA_GET</csr:getMacro>
         <csr:setMacro>I3C_IBI_QUEUE_STATUS_IBI_QUEUE_DATA_IBI_DATA_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>563</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>In-Band Interrupt Data.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is mapped to the IBI Queue.The IBI Data is always packed in 4-byte aligned and put to the IBI Queue.</csr:p>
         <csr:p>If the incoming data is not aligned to the 4-bytes, then there will be unused bytes in the end</csr:p>
         <csr:p>location of the IBI transfer.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.QUEUE_THLD_CTRL</csr:referenceName>
       <csr:identifier>QUEUE_THLD_CTRL</csr:identifier>
       <csr:addressMacro>I3C_QUEUE_THLD_CTRL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_QUEUE_THLD_CTRL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_QUEUE_THLD_CTRL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_QUEUE_THLD_CTRL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>632</csr:linenumber>
       <csr:title>Queue Threshold Control Register</csr:title>
       <csr:offset>0x1C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x01000101</csr:registerResetValue>
       <csr:typeName>I3c_QUEUE_THLD_CTRL</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Queue Threshold Control Register</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CMD_EMPTY_BUF_THLD</csr:identifier>
         <csr:widthMacro>I3C_QUEUE_THLD_CTRL_CMD_EMPTY_BUF_THLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_QUEUE_THLD_CTRL_CMD_EMPTY_BUF_THLD_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_QUEUE_THLD_CTRL_CMD_EMPTY_BUF_THLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_QUEUE_THLD_CTRL_CMD_EMPTY_BUF_THLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_QUEUE_THLD_CTRL_CMD_EMPTY_BUF_THLD_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_QUEUE_THLD_CTRL_CMD_EMPTY_BUF_THLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_QUEUE_THLD_CTRL_CMD_EMPTY_BUF_THLD_GET</csr:getMacro>
         <csr:setMacro>I3C_QUEUE_THLD_CTRL_CMD_EMPTY_BUF_THLD_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>592</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Command Buffer Empty Threshold Value.</csr:p>
         <csr:p>Controls the number of empty locations (or above) in the Command Queue that trigger CMD_QUEUE_READY_STAT interrupt.</csr:p>
         <csr:p></csr:p>
         <csr:p>The valid range is 0 to IC_CMD_BUF_DEPTH-1. The software shall program only valid values.</csr:p>
         <csr:p>Value of N ranging from 1 to IC_CMD_BUF_DEPTH-1 sets the threshold to N empty locations</csr:p>
         <csr:p>and a value of 0 sets the threshold to indicate that the queue is completely empty.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x01</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RESP_BUF_THLD</csr:identifier>
         <csr:widthMacro>I3C_QUEUE_THLD_CTRL_RESP_BUF_THLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_QUEUE_THLD_CTRL_RESP_BUF_THLD_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_QUEUE_THLD_CTRL_RESP_BUF_THLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_QUEUE_THLD_CTRL_RESP_BUF_THLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_QUEUE_THLD_CTRL_RESP_BUF_THLD_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_QUEUE_THLD_CTRL_RESP_BUF_THLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_QUEUE_THLD_CTRL_RESP_BUF_THLD_GET</csr:getMacro>
         <csr:setMacro>I3C_QUEUE_THLD_CTRL_RESP_BUF_THLD_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>610</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Response Buffer Threshold Value.</csr:p>
         <csr:p></csr:p>
         <csr:p>Controls the number of entries (or above) in the Response Queue  that trigger the RESP_READY_STAT_INTR interrupt.</csr:p>
         <csr:p></csr:p>
         <csr:p>The valid range is 0 to IC_RESP_BUF_DEPTH-1. The software shall program only valid values.</csr:p>
         <csr:p>A value of 0 sets the threshold for 1 entry, and a value of N sets the threshold for N+1 entries.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x01</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IBI_STATUS_THLD</csr:identifier>
         <csr:widthMacro>I3C_QUEUE_THLD_CTRL_IBI_STATUS_THLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_QUEUE_THLD_CTRL_IBI_STATUS_THLD_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_QUEUE_THLD_CTRL_IBI_STATUS_THLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_QUEUE_THLD_CTRL_IBI_STATUS_THLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_QUEUE_THLD_CTRL_IBI_STATUS_THLD_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_QUEUE_THLD_CTRL_IBI_STATUS_THLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_QUEUE_THLD_CTRL_IBI_STATUS_THLD_GET</csr:getMacro>
         <csr:setMacro>I3C_QUEUE_THLD_CTRL_IBI_STATUS_THLD_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>631</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>In-Band Interrupt Status Threshold Value.</csr:p>
         <csr:p></csr:p>
         <csr:p>Every In Band Interrupt received (with or without data) by I3C controller generates an IBI status. This field controls the number of IBI status</csr:p>
         <csr:p>entries (or above) in the IBI queue that trigger the IBI_THLD_STAT interrupt.</csr:p>
         <csr:p></csr:p>
         <csr:p>The valid range is 0 to IC_IBI_BUF_DEPTH-1. The software shall program only valid values.</csr:p>
         <csr:p>A value of 0 sets the threshold for 1 entry, and a value of N sets the threshold for N+1 entries.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x01</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DATA_BUFFER_THLD_CTRL</csr:referenceName>
       <csr:identifier>DATA_BUFFER_THLD_CTRL</csr:identifier>
       <csr:addressMacro>I3C_DATA_BUFFER_THLD_CTRL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DATA_BUFFER_THLD_CTRL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DATA_BUFFER_THLD_CTRL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DATA_BUFFER_THLD_CTRL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>755</csr:linenumber>
       <csr:title>Data Buffer Threshold Control Register</csr:title>
       <csr:offset>0x20</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x01010101</csr:registerResetValue>
       <csr:typeName>I3c_DATA_BUFFER_THLD_CTRL</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Data Buffer Threshold Control Register</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TX_EMPTY_BUF_THLD</csr:identifier>
         <csr:widthMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_EMPTY_BUF_THLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_EMPTY_BUF_THLD_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_EMPTY_BUF_THLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_EMPTY_BUF_THLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_EMPTY_BUF_THLD_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_EMPTY_BUF_THLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_EMPTY_BUF_THLD_GET</csr:getMacro>
         <csr:setMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_EMPTY_BUF_THLD_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>666</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transmit Buffer Threshold Value.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>In master mode of operation this field controls the number of empty locations (or above) in the Transmit FIFO that trigger the TX_THLD_STAT interrupt.</csr:p>
         <csr:p></csr:p>
         <csr:p>If the programmed value is greater than the buffer depth, then threshold will be set to IC_TX_BUF_DEPTH.</csr:p>
         <csr:p>The supported values for TX_BUF_THLD are</csr:p>
         <csr:p> - 000: 1</csr:p>
         <csr:p> - 001: 4</csr:p>
         <csr:p> - 010: 8</csr:p>
         <csr:p> - 011: 16</csr:p>
         <csr:p> - 100: 32</csr:p>
         <csr:p> - 101: 64</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_BUF_THLD</csr:identifier>
         <csr:widthMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_BUF_THLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_BUF_THLD_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_BUF_THLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_BUF_THLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_BUF_THLD_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_BUF_THLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_BUF_THLD_GET</csr:getMacro>
         <csr:setMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_BUF_THLD_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>692</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Receive Buffer Threshold Value.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>In master mode of operation this field controls the number of entries (or above) in the Receive FIFO that trigger the RX_THLD_STAT interrupt.</csr:p>
         <csr:p></csr:p>
         <csr:p>If the programmed value is greater than the buffer depth, then threshold will be set to IC_RX_BUF_DEPTH.</csr:p>
         <csr:p>The supported values for RX_BUF_THLD are</csr:p>
         <csr:p> - 000: 1</csr:p>
         <csr:p> - 001: 4</csr:p>
         <csr:p> - 010: 8</csr:p>
         <csr:p> - 011: 16</csr:p>
         <csr:p> - 100: 32</csr:p>
         <csr:p> - 101: 64</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>10</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>11</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TX_START_THLD</csr:identifier>
         <csr:widthMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_START_THLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_START_THLD_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_START_THLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_START_THLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_START_THLD_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_START_THLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_START_THLD_GET</csr:getMacro>
         <csr:setMacro>I3C_DATA_BUFFER_THLD_CTRL_TX_START_THLD_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>723</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transfer Start Threshold Value.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>In master mode of operation when the controller is set up to initiate a write transfer, it waits until either one of the following conditions are met before it initiates the write transfer on the I3C Interface. </csr:p>
         <csr:p></csr:p>
         <csr:p> - Data length (as specified in the command) number of locations are filled  in the Transmit FIFO </csr:p>
         <csr:p></csr:p>
         <csr:p> - Threshold number of entries (or more) are available in the Transmit FIFO </csr:p>
         <csr:p></csr:p>
         <csr:p> The supported values for TX_START_THLD are:</csr:p>
         <csr:p> - 000: 1</csr:p>
         <csr:p> - 001: 4</csr:p>
         <csr:p> - 010: 8</csr:p>
         <csr:p> - 011: 16</csr:p>
         <csr:p> - 100: 32</csr:p>
         <csr:p> - 101: 64</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>18</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>19</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_START_THLD</csr:identifier>
         <csr:widthMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_START_THLD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_START_THLD_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_START_THLD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_START_THLD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_START_THLD_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_START_THLD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_START_THLD_GET</csr:getMacro>
         <csr:setMacro>I3C_DATA_BUFFER_THLD_CTRL_RX_START_THLD_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>754</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Receive Start Threshold Value.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>In master mode of operation when the controller is set up to initiate a read transfer, it waits until either one of the conditions are met before it initiates the read transfer on the I3C Interface. </csr:p>
         <csr:p></csr:p>
         <csr:p> - Data length (as specified in the command) number of locations are empty in the Receive FIFO.</csr:p>
         <csr:p></csr:p>
         <csr:p> - Threshold number of locations (or more) are empty  in the Receive FIFO.</csr:p>
         <csr:p></csr:p>
         <csr:p> The supported values for RX_START_THLD are:</csr:p>
         <csr:p> - 000 - 1</csr:p>
         <csr:p> - 001 - 4</csr:p>
         <csr:p> - 010 - 8</csr:p>
         <csr:p> - 011 - 16</csr:p>
         <csr:p> - 100 - 32</csr:p>
         <csr:p> - 101 - 64</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>26</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>27</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.IBI_QUEUE_CTRL</csr:referenceName>
       <csr:identifier>IBI_QUEUE_CTRL</csr:identifier>
       <csr:addressMacro>I3C_IBI_QUEUE_CTRL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_IBI_QUEUE_CTRL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_IBI_QUEUE_CTRL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_IBI_QUEUE_CTRL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>832</csr:linenumber>
       <csr:title>IBI Queue Control Register</csr:title>
       <csr:offset>0x24</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_IBI_QUEUE_CTRL</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This Register is used to control whether to intimate the application if an IBI request is rejected (Nacked).</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is only used in master mode of operation</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>NOTIFY_HJ_REJECTED</csr:identifier>
         <csr:widthMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_HJ_REJECTED_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_HJ_REJECTED_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_HJ_REJECTED_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_HJ_REJECTED_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_HJ_REJECTED_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_HJ_REJECTED_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_HJ_REJECTED_GET</csr:getMacro>
         <csr:setMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_HJ_REJECTED_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>799</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Notify Rejected Hot-Join Control.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is used to suppress the reporting to the application about Hot-Join request rejected (NACK and Auto Disable).</csr:p>
         <csr:p> - 0: Suppress passing the IBI Data to the IBI FIFO to intimate the application, if Hot-Join is NACKed and auto-disabled based on the</csr:p>
         <csr:p> HJ_AUTO_DISABLE bit set to 1.</csr:p>
         <csr:p> - 1: Pass the IBI Data to the IBI FIFO to intimate the application, if Hot-Join is NACKed and auto-disabled based on the HJ_AUTO_DIABLE bit</csr:p>
         <csr:p>set to 1.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Notify Hot-Join Rejected Disable</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Notify Hot-Join Rejected Enable</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>2</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>NOTIFY_SIR_REJECTED</csr:identifier>
         <csr:widthMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_SIR_REJECTED_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_SIR_REJECTED_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_SIR_REJECTED_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_SIR_REJECTED_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_SIR_REJECTED_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_SIR_REJECTED_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_SIR_REJECTED_GET</csr:getMacro>
         <csr:setMacro>I3C_IBI_QUEUE_CTRL_NOTIFY_SIR_REJECTED_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>831</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Notify Rejected Slave Interrupt Request Control.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is used to suppress the reporting to the application about individual SIR request rejected.</csr:p>
         <csr:p> - 0: Suppress passing the IBI Data to the IBI FIFO to intimate the application, if Individual Slave Interrupt Request is NACKed and auto-disabled based on the IBI_SIR_REQ_REJECT Register.</csr:p>
         <csr:p> - 1: Pass the IBI Data to the IBI FIFO to intimate the application, if Individual Slave Interrupt Request is NACKed and auto-disabled based on the</csr:p>
         <csr:p>IBI_SIR_REQ_REJECT Register.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>DISABLED</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Notify SIR Rejected Disable</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>ENABLED</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Notify SIR Rejected Enable</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.IBI_SIR_REQ_REJECT</csr:referenceName>
       <csr:identifier>IBI_SIR_REQ_REJECT</csr:identifier>
       <csr:addressMacro>I3C_IBI_SIR_REQ_REJECT_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_IBI_SIR_REQ_REJECT_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_IBI_SIR_REQ_REJECT_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_IBI_SIR_REQ_REJECT_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>865</csr:linenumber>
       <csr:title>IBI SIR Request Rejection Control Register</csr:title>
       <csr:offset>0x30</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_IBI_SIR_REQ_REJECT</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>IBI SIR Request Rejection Control </csr:p>
         <csr:p></csr:p>
         <csr:p>This register is only used in master mode of operation</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SIR_REQ_REJECT</csr:identifier>
         <csr:widthMacro>I3C_IBI_SIR_REQ_REJECT_SIR_REQ_REJECT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_IBI_SIR_REQ_REJECT_SIR_REQ_REJECT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_IBI_SIR_REQ_REJECT_SIR_REQ_REJECT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_IBI_SIR_REQ_REJECT_SIR_REQ_REJECT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_IBI_SIR_REQ_REJECT_SIR_REQ_REJECT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_IBI_SIR_REQ_REJECT_SIR_REQ_REJECT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_IBI_SIR_REQ_REJECT_SIR_REQ_REJECT_GET</csr:getMacro>
         <csr:setMacro>I3C_IBI_SIR_REQ_REJECT_SIR_REQ_REJECT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>864</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>In-band Slave Interrupt Request Reject.</csr:p>
         <csr:p></csr:p>
         <csr:p>The application of the DWC_mipi_i3c can decide whether to send ACK or NACK for a Slave request received from any I3C device.</csr:p>
         <csr:p></csr:p>
         <csr:p>A device specific response control bit is provided to select the response option. Master will ACK/NACK the Master Request based</csr:p>
         <csr:p>on programming of control bit, corresponding to the interrupting device.</csr:p>
         <csr:p> - 0 - ACK the SIR Request</csr:p>
         <csr:p> - 1 - NACK and send directed auto disable CCC</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.RESET_CTRL</csr:referenceName>
       <csr:identifier>RESET_CTRL</csr:identifier>
       <csr:addressMacro>I3C_RESET_CTRL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_RESET_CTRL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_RESET_CTRL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_RESET_CTRL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>963</csr:linenumber>
       <csr:title>Reset Control Register</csr:title>
       <csr:offset>0x34</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_RESET_CTRL</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This Register is used for general software reset and for individual buffer reset.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SOFT_RST</csr:identifier>
         <csr:widthMacro>I3C_RESET_CTRL_SOFT_RST_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_RESET_CTRL_SOFT_RST_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_RESET_CTRL_SOFT_RST_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_RESET_CTRL_SOFT_RST_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_RESET_CTRL_SOFT_RST_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_RESET_CTRL_SOFT_RST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_RESET_CTRL_SOFT_RST_GET</csr:getMacro>
         <csr:setMacro>I3C_RESET_CTRL_SOFT_RST_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>890</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Core Software Reset. </csr:p>
         <csr:p></csr:p>
         <csr:p>Write 1'b1 to this bit to exercise software reset.</csr:p>
         <csr:p>This will reset all Buffers - Receive, Transmit, Command and Response</csr:p>
         <csr:p>This bit will be cleared automatically once the core reset is completed.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CMD_QUEUE_RST</csr:identifier>
         <csr:widthMacro>I3C_RESET_CTRL_CMD_QUEUE_RST_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_RESET_CTRL_CMD_QUEUE_RST_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_RESET_CTRL_CMD_QUEUE_RST_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_RESET_CTRL_CMD_QUEUE_RST_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_RESET_CTRL_CMD_QUEUE_RST_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_RESET_CTRL_CMD_QUEUE_RST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_RESET_CTRL_CMD_QUEUE_RST_GET</csr:getMacro>
         <csr:setMacro>I3C_RESET_CTRL_CMD_QUEUE_RST_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>904</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Command Queue Software Reset. </csr:p>
         <csr:p></csr:p>
         <csr:p>Write 1'b1 to this bit to exercise Command Queue reset.</csr:p>
         <csr:p>This bit will the cleared automatically once the Command Queue reset is completed.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RESP_QUEUE_RST</csr:identifier>
         <csr:widthMacro>I3C_RESET_CTRL_RESP_QUEUE_RST_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_RESET_CTRL_RESP_QUEUE_RST_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_RESET_CTRL_RESP_QUEUE_RST_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_RESET_CTRL_RESP_QUEUE_RST_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_RESET_CTRL_RESP_QUEUE_RST_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_RESET_CTRL_RESP_QUEUE_RST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_RESET_CTRL_RESP_QUEUE_RST_GET</csr:getMacro>
         <csr:setMacro>I3C_RESET_CTRL_RESP_QUEUE_RST_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>918</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Response Queue Software Reset.</csr:p>
         <csr:p></csr:p>
         <csr:p>Write 1'b1 to this bit to exercise Response Queue reset.</csr:p>
         <csr:p>This bit will be cleared automatically once the Response Queue reset is completed.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TX_FIFO_RST</csr:identifier>
         <csr:widthMacro>I3C_RESET_CTRL_TX_FIFO_RST_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_RESET_CTRL_TX_FIFO_RST_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_RESET_CTRL_TX_FIFO_RST_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_RESET_CTRL_TX_FIFO_RST_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_RESET_CTRL_TX_FIFO_RST_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_RESET_CTRL_TX_FIFO_RST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_RESET_CTRL_TX_FIFO_RST_GET</csr:getMacro>
         <csr:setMacro>I3C_RESET_CTRL_TX_FIFO_RST_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>932</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transmit Buffer Software Reset.</csr:p>
         <csr:p></csr:p>
         <csr:p>Write 1'b1 to this bit to exercise Transmit Buffer reset.</csr:p>
         <csr:p>This bit will be cleared automatically once the Transmit Buffer reset is completed.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_FIFO_RST</csr:identifier>
         <csr:widthMacro>I3C_RESET_CTRL_RX_FIFO_RST_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_RESET_CTRL_RX_FIFO_RST_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_RESET_CTRL_RX_FIFO_RST_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_RESET_CTRL_RX_FIFO_RST_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_RESET_CTRL_RX_FIFO_RST_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_RESET_CTRL_RX_FIFO_RST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_RESET_CTRL_RX_FIFO_RST_GET</csr:getMacro>
         <csr:setMacro>I3C_RESET_CTRL_RX_FIFO_RST_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>946</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Receive Buffer Software Reset.</csr:p>
         <csr:p></csr:p>
         <csr:p>Write 1'b1 to this bit to exercise Receive Buffer reset.</csr:p>
         <csr:p>This bit will be cleared automatically once the Receive buffer reset is completed.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IBI_QUEUE_RST</csr:identifier>
         <csr:widthMacro>I3C_RESET_CTRL_IBI_QUEUE_RST_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_RESET_CTRL_IBI_QUEUE_RST_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_RESET_CTRL_IBI_QUEUE_RST_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_RESET_CTRL_IBI_QUEUE_RST_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_RESET_CTRL_IBI_QUEUE_RST_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_RESET_CTRL_IBI_QUEUE_RST_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_RESET_CTRL_IBI_QUEUE_RST_GET</csr:getMacro>
         <csr:setMacro>I3C_RESET_CTRL_IBI_QUEUE_RST_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>962</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>IBI Queue Software Reset.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit is only used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p>Write 1'b1 to this bit to exercise IBI Queue reset</csr:p>
         <csr:p>This bit will be cleared automatically once the IBI Queue reset is completed.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.SLV_EVENT_CTRL</csr:referenceName>
       <csr:identifier>SLV_EVENT_CTRL</csr:identifier>
       <csr:addressMacro>I3C_SLV_EVENT_CTRL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_SLV_EVENT_CTRL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_SLV_EVENT_CTRL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_SLV_EVENT_CTRL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1033</csr:linenumber>
       <csr:title>Slave Event Control Register</csr:title>
       <csr:offset>0x38</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_SLV_EVENT_CTRL</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This register indicates the status of the Slave Initiated traffic commands controlled by Master.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register will be updated by the Current Master through CCC commands.</csr:p>
         <csr:p>This register is used only in slave mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>ACTIVITY_STATE</csr:identifier>
         <csr:widthMacro>I3C_SLV_EVENT_CTRL_ACTIVITY_STATE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SLV_EVENT_CTRL_ACTIVITY_STATE_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SLV_EVENT_CTRL_ACTIVITY_STATE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SLV_EVENT_CTRL_ACTIVITY_STATE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SLV_EVENT_CTRL_ACTIVITY_STATE_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SLV_EVENT_CTRL_ACTIVITY_STATE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SLV_EVENT_CTRL_ACTIVITY_STATE_GET</csr:getMacro>
         <csr:setMacro>I3C_SLV_EVENT_CTRL_ACTIVITY_STATE_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>998</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Activity State Status.</csr:p>
         <csr:p></csr:p>
         <csr:p> - ENTAS0 - 00 </csr:p>
         <csr:p></csr:p>
         <csr:p> - ENTAS1 - 01 </csr:p>
         <csr:p></csr:p>
         <csr:p> - ENTAS2 - 10 </csr:p>
         <csr:p></csr:p>
         <csr:p> - ENTAS3 - 11 </csr:p>
         <csr:p></csr:p>
         <csr:p>This bit reflects the Activity State of slave set by the Master.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>MRL_UPDATED</csr:identifier>
         <csr:widthMacro>I3C_SLV_EVENT_CTRL_MRL_UPDATED_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SLV_EVENT_CTRL_MRL_UPDATED_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SLV_EVENT_CTRL_MRL_UPDATED_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SLV_EVENT_CTRL_MRL_UPDATED_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SLV_EVENT_CTRL_MRL_UPDATED_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SLV_EVENT_CTRL_MRL_UPDATED_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SLV_EVENT_CTRL_MRL_UPDATED_GET</csr:getMacro>
         <csr:setMacro>I3C_SLV_EVENT_CTRL_MRL_UPDATED_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1015</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>MRL Updated Status.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit indicates a SETMRL CCC is received by the slave. The updated MRL value can be read from SLV_MAX_LEN register.</csr:p>
         <csr:p>This status can be cleared by writing 1'b1 to this field after reading the updated MRL.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>MWL_UPDATED</csr:identifier>
         <csr:widthMacro>I3C_SLV_EVENT_CTRL_MWL_UPDATED_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SLV_EVENT_CTRL_MWL_UPDATED_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SLV_EVENT_CTRL_MWL_UPDATED_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SLV_EVENT_CTRL_MWL_UPDATED_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SLV_EVENT_CTRL_MWL_UPDATED_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SLV_EVENT_CTRL_MWL_UPDATED_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SLV_EVENT_CTRL_MWL_UPDATED_GET</csr:getMacro>
         <csr:setMacro>I3C_SLV_EVENT_CTRL_MWL_UPDATED_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1032</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>MWL Updated Status.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit indicates a SETMWL CCC is received by the slave. The updated MWL value can be read from SLV_MAX_LEN register.</csr:p>
         <csr:p>This status can be cleared by writing 1'b1 to this field after reading the updated MWL.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.INTR_STATUS</csr:referenceName>
       <csr:identifier>INTR_STATUS</csr:identifier>
       <csr:addressMacro>I3C_INTR_STATUS_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_INTR_STATUS_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_INTR_STATUS_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_INTR_STATUS_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1165</csr:linenumber>
       <csr:title>Interrupt Status Register</csr:title>
       <csr:offset>0x3C</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_INTR_STATUS</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Interrupt Status Register</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TX_THLD_STAT</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_TX_THLD_STAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_TX_THLD_STAT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_TX_THLD_STAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_TX_THLD_STAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_TX_THLD_STAT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_TX_THLD_STAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_TX_THLD_STAT_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_TX_THLD_STAT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1059</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transmit Buffer Threshold Status.</csr:p>
         <csr:p></csr:p>
         <csr:p>This interrupt is generated when number of empty locations in transmit buffer is greater than or equal to</csr:p>
         <csr:p>threshold value specified by TX_EMPTY_BUF_THLD field in DATA_BUFFER_THLD_CTRL register. This interrupt will</csr:p>
         <csr:p>be cleared automatically when number of empty locations in transmit buffer is less than threshold value</csr:p>
         <csr:p>specified.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_THLD_STAT</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_RX_THLD_STAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_RX_THLD_STAT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_RX_THLD_STAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_RX_THLD_STAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_RX_THLD_STAT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_RX_THLD_STAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_RX_THLD_STAT_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_RX_THLD_STAT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1077</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Receive Buffer Threshold Status. </csr:p>
         <csr:p></csr:p>
         <csr:p>This interrupt is generated when number of entries in receive buffer is greater than or equal to threshold</csr:p>
         <csr:p>value specified by RX_BUF_THLD field in DATA_BUFFER_THLD_CTRL register. This interrupt will be cleared</csr:p>
         <csr:p>automatically when number of entries in receive buffer is less than threshold value specified.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IBI_THLD_STAT</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_IBI_THLD_STAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_IBI_THLD_STAT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_IBI_THLD_STAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_IBI_THLD_STAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_IBI_THLD_STAT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_IBI_THLD_STAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_IBI_THLD_STAT_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_IBI_THLD_STAT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1095</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>IBI Buffer Threshold Status. </csr:p>
         <csr:p></csr:p>
         <csr:p>This field is only used in master mode of operation</csr:p>
         <csr:p>This interrupt is generated when number of entries in IBI buffer is greater than or equal to threshold value</csr:p>
         <csr:p>specified by IBI_BUF_THLD field in QUEUE_THLD_CTRL register. This interrupt will be cleared automatically</csr:p>
         <csr:p>when number of entries in IBI buffer is less than threshold value specified.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CMD_QUEUE_READY_STAT</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_CMD_QUEUE_READY_STAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_CMD_QUEUE_READY_STAT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_CMD_QUEUE_READY_STAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_CMD_QUEUE_READY_STAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_CMD_QUEUE_READY_STAT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_CMD_QUEUE_READY_STAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_CMD_QUEUE_READY_STAT_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_CMD_QUEUE_READY_STAT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1113</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Command Queue Ready. </csr:p>
         <csr:p></csr:p>
         <csr:p>This interrupt is generated when number of empty locations in command queue is greater than or equal to threshold</csr:p>
         <csr:p>value specified by CMD_EMPTY_BUF_THLD field in QUEUE_THLD_CTRL register. This interrupt will be cleared automatically</csr:p>
         <csr:p>when number of empty locations in command buffer is less than threshold value specified.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RESP_READY_STAT_INTR</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_RESP_READY_STAT_INTR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_RESP_READY_STAT_INTR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_RESP_READY_STAT_INTR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_RESP_READY_STAT_INTR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_RESP_READY_STAT_INTR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_RESP_READY_STAT_INTR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_RESP_READY_STAT_INTR_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_RESP_READY_STAT_INTR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1131</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Response Queue Ready Status.</csr:p>
         <csr:p></csr:p>
         <csr:p>This interrupt is generated when number of entries in response queue is greater than or equal to threshold value</csr:p>
         <csr:p>specified by RESP_BUF_THLD field in QUEUE_THLD_CTRL register. This interrupt will be cleared automatically when</csr:p>
         <csr:p>number of entries in response buffer is less than threshold value specified.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TRANSFER_ABORT_STAT</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_TRANSFER_ABORT_STAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_TRANSFER_ABORT_STAT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_TRANSFER_ABORT_STAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_TRANSFER_ABORT_STAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_TRANSFER_ABORT_STAT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_TRANSFER_ABORT_STAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_TRANSFER_ABORT_STAT_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_TRANSFER_ABORT_STAT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1147</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transfer Abort Status.</csr:p>
         <csr:p></csr:p>
         <csr:p>This field is used only in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p>This interrupt is generated if transfer is aborted. This interrupt can be cleared by writing 1'b1.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>8</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TRANSFER_ERR_STAT</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_TRANSFER_ERR_STAT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_TRANSFER_ERR_STAT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_TRANSFER_ERR_STAT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_TRANSFER_ERR_STAT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_TRANSFER_ERR_STAT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_TRANSFER_ERR_STAT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_TRANSFER_ERR_STAT_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_TRANSFER_ERR_STAT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1164</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transfer Error Status. </csr:p>
         <csr:p></csr:p>
         <csr:p>This interrupt is generated if any error occurs during transfer. The error type will be specified in</csr:p>
         <csr:p>the response packet associated with the command (in ERR_STATUS field of RESPONSE_QUEUE_PORT register).</csr:p>
         <csr:p>This bit can be cleared by writing 1'b1.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W1C</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.INTR_STATUS_EN</csr:referenceName>
       <csr:identifier>INTR_STATUS_EN</csr:identifier>
       <csr:addressMacro>I3C_INTR_STATUS_EN_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_INTR_STATUS_EN_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_INTR_STATUS_EN_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_INTR_STATUS_EN_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1253</csr:linenumber>
       <csr:title>Interrupt Status Enable Register</csr:title>
       <csr:offset>0x40</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_INTR_STATUS_EN</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Interrupt Status Enable Register.</csr:p>
         <csr:p></csr:p>
         <csr:p>The interrupt status will be updated in INTR_STATUS register only if corresponding Status Enable bit is set.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TX_THLD_STAT_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_EN_TX_THLD_STAT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_EN_TX_THLD_STAT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_EN_TX_THLD_STAT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_EN_TX_THLD_STAT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_EN_TX_THLD_STAT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_EN_TX_THLD_STAT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_EN_TX_THLD_STAT_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_EN_TX_THLD_STAT_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1186</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transmit Buffer Threshold Status Enable.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_THLD_STAT_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_EN_RX_THLD_STAT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_EN_RX_THLD_STAT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_EN_RX_THLD_STAT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_EN_RX_THLD_STAT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_EN_RX_THLD_STAT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_EN_RX_THLD_STAT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_EN_RX_THLD_STAT_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_EN_RX_THLD_STAT_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1196</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Receive Buffer Threshold Status Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IBI_THLD_STAT_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_EN_IBI_THLD_STAT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_EN_IBI_THLD_STAT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_EN_IBI_THLD_STAT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_EN_IBI_THLD_STAT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_EN_IBI_THLD_STAT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_EN_IBI_THLD_STAT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_EN_IBI_THLD_STAT_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_EN_IBI_THLD_STAT_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1209</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>IBI Buffer Threshold Status Enable.</csr:p>
         <csr:p></csr:p>
         <csr:p>This field is used only in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CMD_QUEUE_READY_STAT_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_EN_CMD_QUEUE_READY_STAT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_EN_CMD_QUEUE_READY_STAT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_EN_CMD_QUEUE_READY_STAT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_EN_CMD_QUEUE_READY_STAT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_EN_CMD_QUEUE_READY_STAT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_EN_CMD_QUEUE_READY_STAT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_EN_CMD_QUEUE_READY_STAT_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_EN_CMD_QUEUE_READY_STAT_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1219</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Command Queue Ready Status Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RESP_READY_STAT_INTR_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_EN_RESP_READY_STAT_INTR_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_EN_RESP_READY_STAT_INTR_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_EN_RESP_READY_STAT_INTR_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_EN_RESP_READY_STAT_INTR_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_EN_RESP_READY_STAT_INTR_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_EN_RESP_READY_STAT_INTR_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_EN_RESP_READY_STAT_INTR_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_EN_RESP_READY_STAT_INTR_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1229</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Response Queue Ready Status Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TRANSFER_ABORT_STAT_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_EN_TRANSFER_ABORT_STAT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_EN_TRANSFER_ABORT_STAT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_EN_TRANSFER_ABORT_STAT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_EN_TRANSFER_ABORT_STAT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_EN_TRANSFER_ABORT_STAT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_EN_TRANSFER_ABORT_STAT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_EN_TRANSFER_ABORT_STAT_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_EN_TRANSFER_ABORT_STAT_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1242</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transfer Abort Status Enable.</csr:p>
         <csr:p></csr:p>
         <csr:p>This field is used only in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>8</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TRANSFER_ERR_STAT_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_STATUS_EN_TRANSFER_ERR_STAT_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_STATUS_EN_TRANSFER_ERR_STAT_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_STATUS_EN_TRANSFER_ERR_STAT_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_STATUS_EN_TRANSFER_ERR_STAT_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_STATUS_EN_TRANSFER_ERR_STAT_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_STATUS_EN_TRANSFER_ERR_STAT_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_STATUS_EN_TRANSFER_ERR_STAT_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_STATUS_EN_TRANSFER_ERR_STAT_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1252</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transfer Error Status Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.INTR_SIGNAL_EN</csr:referenceName>
       <csr:identifier>INTR_SIGNAL_EN</csr:identifier>
       <csr:addressMacro>I3C_INTR_SIGNAL_EN_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_INTR_SIGNAL_EN_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_INTR_SIGNAL_EN_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_INTR_SIGNAL_EN_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1337</csr:linenumber>
       <csr:title>Interrupt Signal Enable Register</csr:title>
       <csr:offset>0x44</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_INTR_SIGNAL_EN</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Interrupt Signal Enable Register</csr:p>
         <csr:p></csr:p>
         <csr:p>The interrupt pin will be triggered based on INTR_STATUS only if corresponding Signal Enable bit is set.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TX_THLD_SIGNAL_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_SIGNAL_EN_TX_THLD_SIGNAL_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_SIGNAL_EN_TX_THLD_SIGNAL_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_SIGNAL_EN_TX_THLD_SIGNAL_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_SIGNAL_EN_TX_THLD_SIGNAL_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_SIGNAL_EN_TX_THLD_SIGNAL_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_SIGNAL_EN_TX_THLD_SIGNAL_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_SIGNAL_EN_TX_THLD_SIGNAL_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_SIGNAL_EN_TX_THLD_SIGNAL_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1274</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transmit Buffer Threshold Signal Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_THLD_SIGNAL_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_SIGNAL_EN_RX_THLD_SIGNAL_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_SIGNAL_EN_RX_THLD_SIGNAL_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_SIGNAL_EN_RX_THLD_SIGNAL_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_SIGNAL_EN_RX_THLD_SIGNAL_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_SIGNAL_EN_RX_THLD_SIGNAL_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_SIGNAL_EN_RX_THLD_SIGNAL_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_SIGNAL_EN_RX_THLD_SIGNAL_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_SIGNAL_EN_RX_THLD_SIGNAL_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1284</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Receive Buffer Threshold Signal Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IBI_THLD_SIGNAL_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_SIGNAL_EN_IBI_THLD_SIGNAL_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_SIGNAL_EN_IBI_THLD_SIGNAL_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_SIGNAL_EN_IBI_THLD_SIGNAL_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_SIGNAL_EN_IBI_THLD_SIGNAL_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_SIGNAL_EN_IBI_THLD_SIGNAL_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_SIGNAL_EN_IBI_THLD_SIGNAL_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_SIGNAL_EN_IBI_THLD_SIGNAL_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_SIGNAL_EN_IBI_THLD_SIGNAL_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1295</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>IBI Buffer Threshold Signal Enable</csr:p>
         <csr:p>This field is used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CMD_QUEUE_READY_SIGNAL_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_SIGNAL_EN_CMD_QUEUE_READY_SIGNAL_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_SIGNAL_EN_CMD_QUEUE_READY_SIGNAL_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_SIGNAL_EN_CMD_QUEUE_READY_SIGNAL_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_SIGNAL_EN_CMD_QUEUE_READY_SIGNAL_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_SIGNAL_EN_CMD_QUEUE_READY_SIGNAL_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_SIGNAL_EN_CMD_QUEUE_READY_SIGNAL_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_SIGNAL_EN_CMD_QUEUE_READY_SIGNAL_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_SIGNAL_EN_CMD_QUEUE_READY_SIGNAL_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1305</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Command Queue Ready Signal Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RESP_READY_SIGNAL_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_SIGNAL_EN_RESP_READY_SIGNAL_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_SIGNAL_EN_RESP_READY_SIGNAL_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_SIGNAL_EN_RESP_READY_SIGNAL_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_SIGNAL_EN_RESP_READY_SIGNAL_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_SIGNAL_EN_RESP_READY_SIGNAL_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_SIGNAL_EN_RESP_READY_SIGNAL_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_SIGNAL_EN_RESP_READY_SIGNAL_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_SIGNAL_EN_RESP_READY_SIGNAL_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1315</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Response Queue Ready Signal Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TRANSFER_ABORT_SIGNAL_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ABORT_SIGNAL_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ABORT_SIGNAL_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ABORT_SIGNAL_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ABORT_SIGNAL_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ABORT_SIGNAL_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ABORT_SIGNAL_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ABORT_SIGNAL_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ABORT_SIGNAL_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1326</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transfer Abort Signal Enable</csr:p>
         <csr:p>This field is used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>8</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TRANSFER_ERR_SIGNAL_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ERR_SIGNAL_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ERR_SIGNAL_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ERR_SIGNAL_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ERR_SIGNAL_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ERR_SIGNAL_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ERR_SIGNAL_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ERR_SIGNAL_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_SIGNAL_EN_TRANSFER_ERR_SIGNAL_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1336</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transfer Error Signal Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.INTR_FORCE</csr:referenceName>
       <csr:identifier>INTR_FORCE</csr:identifier>
       <csr:addressMacro>I3C_INTR_FORCE_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_INTR_FORCE_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_INTR_FORCE_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_INTR_FORCE_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1423</csr:linenumber>
       <csr:title>Interrupt Force Enable Register</csr:title>
       <csr:offset>0x48</csr:offset>
       <csr:addressedAccess>W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_INTR_FORCE</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Interrupt Force Enable Register</csr:p>
         <csr:p></csr:p>
         <csr:p>Individual interrupts can be forcefully triggered if corresponding Force Enable bit is set, provided</csr:p>
         <csr:p>the corresponding bit in the INTR_STATUS_EN register is set.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TX_THLD_FORCE_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_FORCE_TX_THLD_FORCE_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_FORCE_TX_THLD_FORCE_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_FORCE_TX_THLD_FORCE_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_FORCE_TX_THLD_FORCE_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_FORCE_TX_THLD_FORCE_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_FORCE_TX_THLD_FORCE_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_FORCE_TX_THLD_FORCE_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_FORCE_TX_THLD_FORCE_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1360</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transmit Buffer Threshold Force Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_THLD_FORCE_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_FORCE_RX_THLD_FORCE_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_FORCE_RX_THLD_FORCE_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_FORCE_RX_THLD_FORCE_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_FORCE_RX_THLD_FORCE_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_FORCE_RX_THLD_FORCE_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_FORCE_RX_THLD_FORCE_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_FORCE_RX_THLD_FORCE_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_FORCE_RX_THLD_FORCE_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1370</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Receive Buffer Threshold Force Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IBI_THLD_FORCE_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_FORCE_IBI_THLD_FORCE_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_FORCE_IBI_THLD_FORCE_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_FORCE_IBI_THLD_FORCE_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_FORCE_IBI_THLD_FORCE_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_FORCE_IBI_THLD_FORCE_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_FORCE_IBI_THLD_FORCE_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_FORCE_IBI_THLD_FORCE_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_FORCE_IBI_THLD_FORCE_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1381</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>IBI Buffer Threshold Force Enable</csr:p>
         <csr:p>This field is used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CMD_QUEUE_READY_FORCE_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_FORCE_CMD_QUEUE_READY_FORCE_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_FORCE_CMD_QUEUE_READY_FORCE_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_FORCE_CMD_QUEUE_READY_FORCE_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_FORCE_CMD_QUEUE_READY_FORCE_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_FORCE_CMD_QUEUE_READY_FORCE_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_FORCE_CMD_QUEUE_READY_FORCE_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_FORCE_CMD_QUEUE_READY_FORCE_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_FORCE_CMD_QUEUE_READY_FORCE_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1391</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Command Queue Ready Force Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RESP_READY_FORCE_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_FORCE_RESP_READY_FORCE_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_FORCE_RESP_READY_FORCE_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_FORCE_RESP_READY_FORCE_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_FORCE_RESP_READY_FORCE_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_FORCE_RESP_READY_FORCE_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_FORCE_RESP_READY_FORCE_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_FORCE_RESP_READY_FORCE_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_FORCE_RESP_READY_FORCE_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1401</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Response Queue Ready Force Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>4</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TRANSFER_ABORT_FORCE_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_FORCE_TRANSFER_ABORT_FORCE_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_FORCE_TRANSFER_ABORT_FORCE_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_FORCE_TRANSFER_ABORT_FORCE_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_FORCE_TRANSFER_ABORT_FORCE_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_FORCE_TRANSFER_ABORT_FORCE_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_FORCE_TRANSFER_ABORT_FORCE_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_FORCE_TRANSFER_ABORT_FORCE_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_FORCE_TRANSFER_ABORT_FORCE_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1412</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transfer Abort Force Enable</csr:p>
         <csr:p>This field is used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>5</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>8</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>TRANSFER_ERR_FORCE_EN</csr:identifier>
         <csr:widthMacro>I3C_INTR_FORCE_TRANSFER_ERR_FORCE_EN_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_INTR_FORCE_TRANSFER_ERR_FORCE_EN_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_INTR_FORCE_TRANSFER_ERR_FORCE_EN_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_INTR_FORCE_TRANSFER_ERR_FORCE_EN_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_INTR_FORCE_TRANSFER_ERR_FORCE_EN_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_INTR_FORCE_TRANSFER_ERR_FORCE_EN_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_INTR_FORCE_TRANSFER_ERR_FORCE_EN_GET</csr:getMacro>
         <csr:setMacro>I3C_INTR_FORCE_TRANSFER_ERR_FORCE_EN_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1422</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transfer Error Force Enable</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>9</csr:msb>
         <csr:lsb>9</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>10</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.QUEUE_STATUS_LEVEL</csr:referenceName>
       <csr:identifier>QUEUE_STATUS_LEVEL</csr:identifier>
       <csr:addressMacro>I3C_QUEUE_STATUS_LEVEL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_QUEUE_STATUS_LEVEL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_QUEUE_STATUS_LEVEL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_QUEUE_STATUS_LEVEL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1488</csr:linenumber>
       <csr:title>Queue Status Level Register</csr:title>
       <csr:offset>0x4C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000002</csr:registerResetValue>
       <csr:typeName>I3c_QUEUE_STATUS_LEVEL</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Queue Status Level Register.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>CMD_QUEUE_EMPTY_LOC</csr:identifier>
         <csr:widthMacro>I3C_QUEUE_STATUS_LEVEL_CMD_QUEUE_EMPTY_LOC_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_QUEUE_STATUS_LEVEL_CMD_QUEUE_EMPTY_LOC_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_QUEUE_STATUS_LEVEL_CMD_QUEUE_EMPTY_LOC_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_QUEUE_STATUS_LEVEL_CMD_QUEUE_EMPTY_LOC_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_QUEUE_STATUS_LEVEL_CMD_QUEUE_EMPTY_LOC_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_QUEUE_STATUS_LEVEL_CMD_QUEUE_EMPTY_LOC_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_QUEUE_STATUS_LEVEL_CMD_QUEUE_EMPTY_LOC_GET</csr:getMacro>
         <csr:setMacro>I3C_QUEUE_STATUS_LEVEL_CMD_QUEUE_EMPTY_LOC_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1445</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Command Queue Empty Locations.</csr:p>
         <csr:p></csr:p>
         <csr:p>Contains the number of empty locations in the command Buffer.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x02</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RESP_BUF_BLR</csr:identifier>
         <csr:widthMacro>I3C_QUEUE_STATUS_LEVEL_RESP_BUF_BLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_QUEUE_STATUS_LEVEL_RESP_BUF_BLR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_QUEUE_STATUS_LEVEL_RESP_BUF_BLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_QUEUE_STATUS_LEVEL_RESP_BUF_BLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_QUEUE_STATUS_LEVEL_RESP_BUF_BLR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_QUEUE_STATUS_LEVEL_RESP_BUF_BLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_QUEUE_STATUS_LEVEL_RESP_BUF_BLR_GET</csr:getMacro>
         <csr:setMacro>I3C_QUEUE_STATUS_LEVEL_RESP_BUF_BLR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1458</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Response Buffer Level Value.</csr:p>
         <csr:p></csr:p>
         <csr:p>Contains the number of valid data entries in the response Buffer.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IBI_BUF_BLR</csr:identifier>
         <csr:widthMacro>I3C_QUEUE_STATUS_LEVEL_IBI_BUF_BLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_QUEUE_STATUS_LEVEL_IBI_BUF_BLR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_QUEUE_STATUS_LEVEL_IBI_BUF_BLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_QUEUE_STATUS_LEVEL_IBI_BUF_BLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_QUEUE_STATUS_LEVEL_IBI_BUF_BLR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_QUEUE_STATUS_LEVEL_IBI_BUF_BLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_QUEUE_STATUS_LEVEL_IBI_BUF_BLR_GET</csr:getMacro>
         <csr:setMacro>I3C_QUEUE_STATUS_LEVEL_IBI_BUF_BLR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1472</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>IBI Buffer Level Value.</csr:p>
         <csr:p></csr:p>
         <csr:p>Contains the number of valid entries in the IBI Buffer.</csr:p>
         <csr:p></csr:p>
         <csr:p>This field is used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>IBI_STATUS_CNT</csr:identifier>
         <csr:widthMacro>I3C_QUEUE_STATUS_LEVEL_IBI_STATUS_CNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_QUEUE_STATUS_LEVEL_IBI_STATUS_CNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_QUEUE_STATUS_LEVEL_IBI_STATUS_CNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_QUEUE_STATUS_LEVEL_IBI_STATUS_CNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_QUEUE_STATUS_LEVEL_IBI_STATUS_CNT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_QUEUE_STATUS_LEVEL_IBI_STATUS_CNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_QUEUE_STATUS_LEVEL_IBI_STATUS_CNT_GET</csr:getMacro>
         <csr:setMacro>I3C_QUEUE_STATUS_LEVEL_IBI_STATUS_CNT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1487</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>IBI Buffer Status Count.</csr:p>
         <csr:p></csr:p>
         <csr:p>Contains the number of IBI status entries in the IBI Buffer.</csr:p>
         <csr:p></csr:p>
         <csr:p>This field is used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>28</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DATA_BUFFER_STATUS_LEVEL</csr:referenceName>
       <csr:identifier>DATA_BUFFER_STATUS_LEVEL</csr:identifier>
       <csr:addressMacro>I3C_DATA_BUFFER_STATUS_LEVEL_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DATA_BUFFER_STATUS_LEVEL_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DATA_BUFFER_STATUS_LEVEL_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DATA_BUFFER_STATUS_LEVEL_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1524</csr:linenumber>
       <csr:title>Data Buffer Status Level Register</csr:title>
       <csr:offset>0x50</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000010</csr:registerResetValue>
       <csr:typeName>I3c_DATA_BUFFER_STATUS_LEVEL</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Data Buffer Status Level Register</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>TX_BUF_EMPTY_LOC</csr:identifier>
         <csr:widthMacro>I3C_DATA_BUFFER_STATUS_LEVEL_TX_BUF_EMPTY_LOC_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DATA_BUFFER_STATUS_LEVEL_TX_BUF_EMPTY_LOC_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DATA_BUFFER_STATUS_LEVEL_TX_BUF_EMPTY_LOC_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DATA_BUFFER_STATUS_LEVEL_TX_BUF_EMPTY_LOC_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DATA_BUFFER_STATUS_LEVEL_TX_BUF_EMPTY_LOC_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DATA_BUFFER_STATUS_LEVEL_TX_BUF_EMPTY_LOC_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DATA_BUFFER_STATUS_LEVEL_TX_BUF_EMPTY_LOC_GET</csr:getMacro>
         <csr:setMacro>I3C_DATA_BUFFER_STATUS_LEVEL_TX_BUF_EMPTY_LOC_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1510</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transmit Buffer Empty Level Value.</csr:p>
         <csr:p></csr:p>
         <csr:p>Contains the number of empty locations in the transmit Buffer.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x10</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>RX_BUF_BLR</csr:identifier>
         <csr:widthMacro>I3C_DATA_BUFFER_STATUS_LEVEL_RX_BUF_BLR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DATA_BUFFER_STATUS_LEVEL_RX_BUF_BLR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DATA_BUFFER_STATUS_LEVEL_RX_BUF_BLR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DATA_BUFFER_STATUS_LEVEL_RX_BUF_BLR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DATA_BUFFER_STATUS_LEVEL_RX_BUF_BLR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DATA_BUFFER_STATUS_LEVEL_RX_BUF_BLR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DATA_BUFFER_STATUS_LEVEL_RX_BUF_BLR_GET</csr:getMacro>
         <csr:setMacro>I3C_DATA_BUFFER_STATUS_LEVEL_RX_BUF_BLR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1523</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Receive Buffer Level Value.</csr:p>
         <csr:p></csr:p>
         <csr:p>Contains the number of valid data entries in the receive Buffer.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.PRESENT_STATE</csr:referenceName>
       <csr:identifier>PRESENT_STATE</csr:identifier>
       <csr:addressMacro>I3C_PRESENT_STATE_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_PRESENT_STATE_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_PRESENT_STATE_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_PRESENT_STATE_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1707</csr:linenumber>
       <csr:title>Present State Register</csr:title>
       <csr:offset>0x54</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x10000003</csr:registerResetValue>
       <csr:typeName>I3c_PRESENT_STATE</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This register is used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p>The user can get status of the DWC_mipi_i3c Controller from this 32-bit read only register.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>SCL_LINE_SIGNAL_LEVEL</csr:identifier>
         <csr:widthMacro>I3C_PRESENT_STATE_SCL_LINE_SIGNAL_LEVEL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_PRESENT_STATE_SCL_LINE_SIGNAL_LEVEL_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_PRESENT_STATE_SCL_LINE_SIGNAL_LEVEL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_PRESENT_STATE_SCL_LINE_SIGNAL_LEVEL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_PRESENT_STATE_SCL_LINE_SIGNAL_LEVEL_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_PRESENT_STATE_SCL_LINE_SIGNAL_LEVEL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_PRESENT_STATE_SCL_LINE_SIGNAL_LEVEL_GET</csr:getMacro>
         <csr:setMacro>I3C_PRESENT_STATE_SCL_LINE_SIGNAL_LEVEL_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1549</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This bit is used to check the SCL line level to recover from errors and for debugging. This bit</csr:p>
         <csr:p>reflects the value of synchronized scl_in_a signal.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>0</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>SDA_LINE_SIGNAL_LEVEL</csr:identifier>
         <csr:widthMacro>I3C_PRESENT_STATE_SDA_LINE_SIGNAL_LEVEL_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_PRESENT_STATE_SDA_LINE_SIGNAL_LEVEL_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_PRESENT_STATE_SDA_LINE_SIGNAL_LEVEL_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_PRESENT_STATE_SDA_LINE_SIGNAL_LEVEL_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_PRESENT_STATE_SDA_LINE_SIGNAL_LEVEL_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_PRESENT_STATE_SDA_LINE_SIGNAL_LEVEL_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_PRESENT_STATE_SDA_LINE_SIGNAL_LEVEL_GET</csr:getMacro>
         <csr:setMacro>I3C_PRESENT_STATE_SDA_LINE_SIGNAL_LEVEL_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1562</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This bit is used to check the SDA line level to recover from errors and for debugging. This bit</csr:p>
         <csr:p>reflects the value of synchronized sda_in_a signal.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>1</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CURRENT_MASTER</csr:identifier>
         <csr:widthMacro>I3C_PRESENT_STATE_CURRENT_MASTER_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_PRESENT_STATE_CURRENT_MASTER_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_PRESENT_STATE_CURRENT_MASTER_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_PRESENT_STATE_CURRENT_MASTER_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_PRESENT_STATE_CURRENT_MASTER_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_PRESENT_STATE_CURRENT_MASTER_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_PRESENT_STATE_CURRENT_MASTER_GET</csr:getMacro>
         <csr:setMacro>I3C_PRESENT_STATE_CURRENT_MASTER_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1595</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This Bit is used to check whether the Master is Current Master or not. The Current Master is the Master</csr:p>
         <csr:p>that owns the SCL line.</csr:p>
         <csr:p></csr:p>
         <csr:p>If this bit is set to 0, the Master is not Current Master and requires to request and the ownership</csr:p>
         <csr:p>before initiating any transfer on the line.</csr:p>
         <csr:p></csr:p>
         <csr:p>If this bit is set to 1, the Master is the Current Master and can initate the transfers on the line.</csr:p>
         <csr:p> - 0: Master is not Current Master</csr:p>
         <csr:p> - 1: Master is Current Master</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>2</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>BUS_OWNER</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master is Current Master</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>NOT_BUS_OWNER</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master is not a Current Master</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>7</csr:msb>
         <csr:lsb>3</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CM_TFR_STATUS</csr:identifier>
         <csr:widthMacro>I3C_PRESENT_STATE_CM_TFR_STATUS_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_PRESENT_STATE_CM_TFR_STATUS_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_PRESENT_STATE_CM_TFR_STATUS_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_PRESENT_STATE_CM_TFR_STATUS_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_PRESENT_STATE_CM_TFR_STATUS_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_PRESENT_STATE_CM_TFR_STATUS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_PRESENT_STATE_CM_TFR_STATUS_GET</csr:getMacro>
         <csr:setMacro>I3C_PRESENT_STATE_CM_TFR_STATUS_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1632</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Transfer Type Status.</csr:p>
         <csr:p></csr:p>
         <csr:p>Indicates the type of transfer currently executing by the DWC_mipi_i3c controller.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p>In Master mode of operation :</csr:p>
         <csr:p> - 6'h0: IDLE (Controller is in Idle state, waiting for commands from application or Slave initated In-band Interrupt)</csr:p>
         <csr:p> - 6'h1: Broadcast CCC Write Transfer.</csr:p>
         <csr:p> - 6'h2: Directed CCC Write Transfer.</csr:p>
         <csr:p> - 6'h3: Directed CCC Read Transfer.</csr:p>
         <csr:p> - 6'h4: ENTDAA Address Assignment Transfer.</csr:p>
         <csr:p> - 6'h5: SETDASA Address Assignment Transfer.</csr:p>
         <csr:p> - 6'h6: Private I3C SDR Write Transfer.</csr:p>
         <csr:p> - 6'h7: Private I3C SDR Read Transfer.</csr:p>
         <csr:p> - 6'h8: Private I2C SDR Write Transfer.</csr:p>
         <csr:p> - 6'h9: Private I2C SDR Read Transfer.</csr:p>
         <csr:p> - 6'hA: Private HDR Ternary Symbol(TS) Write Transfer.</csr:p>
         <csr:p> - 6'hB: Private HDR Ternary Symbol(TS) Read Transfer.</csr:p>
         <csr:p> - 6'hC: Private HDR Double-Data Rate(DDR) Write Transfer.</csr:p>
         <csr:p> - 6'hD: Private HDR Double-Data Rate(DDR) Read Transfer.</csr:p>
         <csr:p> - 6'hE: Servicing In-Band Interrupt Transfer.</csr:p>
         <csr:p> - 6'hF: Halt state (Controller is in Halt State, waiting for the application to resume through DEVICE_CTRL Register)</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>13</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>14</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CM_TFR_ST_STATUS</csr:identifier>
         <csr:widthMacro>I3C_PRESENT_STATE_CM_TFR_ST_STATUS_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_PRESENT_STATE_CM_TFR_ST_STATUS_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_PRESENT_STATE_CM_TFR_ST_STATUS_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_PRESENT_STATE_CM_TFR_ST_STATUS_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_PRESENT_STATE_CM_TFR_ST_STATUS_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_PRESENT_STATE_CM_TFR_ST_STATUS_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_PRESENT_STATE_CM_TFR_ST_STATUS_GET</csr:getMacro>
         <csr:setMacro>I3C_PRESENT_STATE_CM_TFR_ST_STATUS_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1669</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Current Master Transfer State Status. </csr:p>
         <csr:p></csr:p>
         <csr:p>Indicates the state of current transfer currently executing by the DWC_mipi_i3c controller.</csr:p>
         <csr:p></csr:p>
         <csr:p> - 6'h0: IDLE (Controller is Idle state, waiting for commands from application or Slave initated In-band Interrupt)</csr:p>
         <csr:p> - 6'h1: START Generation State.</csr:p>
         <csr:p> - 6'h2: RESTART Generation State.</csr:p>
         <csr:p> - 6'h3: STOP Generation State.</csr:p>
         <csr:p> - 6'h4: START Hold Generation for the Slave Initiated START State.</csr:p>
         <csr:p> - 6'h5: Broadcast Write Address Header(7'h7E,W) Generation State.</csr:p>
         <csr:p> - 6'h6: Broadcast Read Address Header(7'h7E,R) Generation State.</csr:p>
         <csr:p> - 6'h7: Dynamic Address Assignment State.</csr:p>
         <csr:p> - 6'h8: Slave Address Generation State.</csr:p>
         <csr:p> - 6'hB: CCC Byte Generation State.</csr:p>
         <csr:p> - 6'hC: HDR Command Generation State.</csr:p>
         <csr:p> - 6'hD: Write Data Transfer State.</csr:p>
         <csr:p> - 6'hE: Read Data Transfer State.</csr:p>
         <csr:p> - 6'hF: In-Band Interrupt(SIR) Read Data State.</csr:p>
         <csr:p> - 6'h10:  In-Band Interrupt Auto-Disable State</csr:p>
         <csr:p> - 6'h11: HDR-DDR CRC Data Generation/Receive State.</csr:p>
         <csr:p> - 6'h12: Clock Extension State.</csr:p>
         <csr:p> - 6'h13: Halt State.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>21</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>23</csr:msb>
         <csr:lsb>22</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CMD_TID</csr:identifier>
         <csr:widthMacro>I3C_PRESENT_STATE_CMD_TID_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_PRESENT_STATE_CMD_TID_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_PRESENT_STATE_CMD_TID_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_PRESENT_STATE_CMD_TID_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_PRESENT_STATE_CMD_TID_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_PRESENT_STATE_CMD_TID_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_PRESENT_STATE_CMD_TID_GET</csr:getMacro>
         <csr:setMacro>I3C_PRESENT_STATE_CMD_TID_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1680</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This field reflects the Transaction-ID of the current executing command.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>27</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>MASTER_IDLE</csr:identifier>
         <csr:widthMacro>I3C_PRESENT_STATE_MASTER_IDLE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_PRESENT_STATE_MASTER_IDLE_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_PRESENT_STATE_MASTER_IDLE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_PRESENT_STATE_MASTER_IDLE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_PRESENT_STATE_MASTER_IDLE_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_PRESENT_STATE_MASTER_IDLE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_PRESENT_STATE_MASTER_IDLE_GET</csr:getMacro>
         <csr:setMacro>I3C_PRESENT_STATE_MASTER_IDLE_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1706</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This field reflects whether the Master Controller is in Idle state or not. This bit will set when all the Queues(Command , Response, IBI) and Buffers(Transmit and Receive) are empty along with the Master State machine is in Idle state.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>28</csr:msb>
         <csr:lsb>28</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>MST_IDLE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Master Controller is in IDLE State.</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>MST_NOT_IDLE</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master Controller is not in IDLE State</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEVICE_ADDR_TABLE_POINTER</csr:referenceName>
       <csr:identifier>DEVICE_ADDR_TABLE_POINTER</csr:identifier>
       <csr:addressMacro>I3C_DEVICE_ADDR_TABLE_POINTER_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEVICE_ADDR_TABLE_POINTER_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEVICE_ADDR_TABLE_POINTER_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEVICE_ADDR_TABLE_POINTER_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1740</csr:linenumber>
       <csr:title>Pointer for Device Address Table Registers</csr:title>
       <csr:offset>0x5C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00020220</csr:registerResetValue>
       <csr:typeName>I3c_DEVICE_ADDR_TABLE_POINTER</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Pointer for Device Address Table</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>P_DEV_ADDR_TABLE_START_ADDR</csr:identifier>
         <csr:widthMacro>I3C_DEVICE_ADDR_TABLE_POINTER_P_DEV_ADDR_TABLE_START_ADDR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEVICE_ADDR_TABLE_POINTER_P_DEV_ADDR_TABLE_START_ADDR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEVICE_ADDR_TABLE_POINTER_P_DEV_ADDR_TABLE_START_ADDR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEVICE_ADDR_TABLE_POINTER_P_DEV_ADDR_TABLE_START_ADDR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEVICE_ADDR_TABLE_POINTER_P_DEV_ADDR_TABLE_START_ADDR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEVICE_ADDR_TABLE_POINTER_P_DEV_ADDR_TABLE_START_ADDR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEVICE_ADDR_TABLE_POINTER_P_DEV_ADDR_TABLE_START_ADDR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEVICE_ADDR_TABLE_POINTER_P_DEV_ADDR_TABLE_START_ADDR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1729</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Start Address of Device Address Table.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0220</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DEV_ADDR_TABLE_DEPTH</csr:identifier>
         <csr:widthMacro>I3C_DEVICE_ADDR_TABLE_POINTER_DEV_ADDR_TABLE_DEPTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEVICE_ADDR_TABLE_POINTER_DEV_ADDR_TABLE_DEPTH_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEVICE_ADDR_TABLE_POINTER_DEV_ADDR_TABLE_DEPTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEVICE_ADDR_TABLE_POINTER_DEV_ADDR_TABLE_DEPTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEVICE_ADDR_TABLE_POINTER_DEV_ADDR_TABLE_DEPTH_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEVICE_ADDR_TABLE_POINTER_DEV_ADDR_TABLE_DEPTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEVICE_ADDR_TABLE_POINTER_DEV_ADDR_TABLE_DEPTH_GET</csr:getMacro>
         <csr:setMacro>I3C_DEVICE_ADDR_TABLE_POINTER_DEV_ADDR_TABLE_DEPTH_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1739</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Depth of Device Address Table</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0002</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEV_CHAR_TABLE_POINTER</csr:referenceName>
       <csr:identifier>DEV_CHAR_TABLE_POINTER</csr:identifier>
       <csr:addressMacro>I3C_DEV_CHAR_TABLE_POINTER_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEV_CHAR_TABLE_POINTER_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEV_CHAR_TABLE_POINTER_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEV_CHAR_TABLE_POINTER_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1805</csr:linenumber>
       <csr:title>Pointer for Device Characteristics Table</csr:title>
       <csr:offset>0x60</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00008200</csr:registerResetValue>
       <csr:typeName>I3c_DEV_CHAR_TABLE_POINTER</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Pointer for Device Characteristics Table</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>P_DEV_CHAR_TABLE_START_ADDR</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE_POINTER_P_DEV_CHAR_TABLE_START_ADDR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE_POINTER_P_DEV_CHAR_TABLE_START_ADDR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE_POINTER_P_DEV_CHAR_TABLE_START_ADDR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE_POINTER_P_DEV_CHAR_TABLE_START_ADDR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE_POINTER_P_DEV_CHAR_TABLE_START_ADDR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE_POINTER_P_DEV_CHAR_TABLE_START_ADDR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE_POINTER_P_DEV_CHAR_TABLE_START_ADDR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE_POINTER_P_DEV_CHAR_TABLE_START_ADDR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1762</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Start Address of Device Characteristics Table.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x200</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DEV_CHAR_TABLE_DEPTH</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE_POINTER_DEV_CHAR_TABLE_DEPTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE_POINTER_DEV_CHAR_TABLE_DEPTH_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE_POINTER_DEV_CHAR_TABLE_DEPTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE_POINTER_DEV_CHAR_TABLE_DEPTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE_POINTER_DEV_CHAR_TABLE_DEPTH_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE_POINTER_DEV_CHAR_TABLE_DEPTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE_POINTER_DEV_CHAR_TABLE_DEPTH_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE_POINTER_DEV_CHAR_TABLE_DEPTH_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1773</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Depth of Device Characteristics Table</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>18</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x08</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>PRESENT_DEV_CHAR_TABLE_INDX</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE_POINTER_PRESENT_DEV_CHAR_TABLE_INDX_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE_POINTER_PRESENT_DEV_CHAR_TABLE_INDX_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE_POINTER_PRESENT_DEV_CHAR_TABLE_INDX_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE_POINTER_PRESENT_DEV_CHAR_TABLE_INDX_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE_POINTER_PRESENT_DEV_CHAR_TABLE_INDX_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE_POINTER_PRESENT_DEV_CHAR_TABLE_INDX_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE_POINTER_PRESENT_DEV_CHAR_TABLE_INDX_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE_POINTER_PRESENT_DEV_CHAR_TABLE_INDX_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1804</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Current index of Device Characteristics Table.</csr:p>
         <csr:p></csr:p>
         <csr:p>This field returns the current location of Device Characteristics Table index. Initially, this index points to 0.</csr:p>
         <csr:p></csr:p>
         <csr:p>Once the complete characteristics information of a Slave device is written into Device Characteristics Table during ENTDAA,</csr:p>
         <csr:p>this index increments by 1. The first winning device information is stored in Device Characteristics Table index 0,</csr:p>
         <csr:p>the second winning device information in index 1, and so on. </csr:p>
         <csr:p>If required, this index can be used to override the location, where</csr:p>
         <csr:p>characteristic information of Slave devices on the I3C bus are written during ENTDAA. Hence, this field is useful only if the</csr:p>
         <csr:p>device is Current Master. During DEFSLV CCC, the index always starts from 0. </csr:p>
         <csr:p>In Non-current Master, this field is always read-only.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>19</csr:msb>
         <csr:lsb>19</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>20</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.VENDOR_SPECIFIC_REG_POINTER</csr:referenceName>
       <csr:identifier>VENDOR_SPECIFIC_REG_POINTER</csr:identifier>
       <csr:addressMacro>I3C_VENDOR_SPECIFIC_REG_POINTER_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_VENDOR_SPECIFIC_REG_POINTER_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_VENDOR_SPECIFIC_REG_POINTER_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_VENDOR_SPECIFIC_REG_POINTER_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1828</csr:linenumber>
       <csr:title>Pointer for Vendor specific Registers</csr:title>
       <csr:offset>0x6C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x000000b0</csr:registerResetValue>
       <csr:typeName>I3c_VENDOR_SPECIFIC_REG_POINTER</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Pointer for Vendor Specific Registers.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>P_VENDOR_REG_START_ADDR</csr:identifier>
         <csr:widthMacro>I3C_VENDOR_SPECIFIC_REG_POINTER_P_VENDOR_REG_START_ADDR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_VENDOR_SPECIFIC_REG_POINTER_P_VENDOR_REG_START_ADDR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_VENDOR_SPECIFIC_REG_POINTER_P_VENDOR_REG_START_ADDR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_VENDOR_SPECIFIC_REG_POINTER_P_VENDOR_REG_START_ADDR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_VENDOR_SPECIFIC_REG_POINTER_P_VENDOR_REG_START_ADDR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_VENDOR_SPECIFIC_REG_POINTER_P_VENDOR_REG_START_ADDR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_VENDOR_SPECIFIC_REG_POINTER_P_VENDOR_REG_START_ADDR_GET</csr:getMacro>
         <csr:setMacro>I3C_VENDOR_SPECIFIC_REG_POINTER_P_VENDOR_REG_START_ADDR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1827</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Start Address of Vendor specific registers.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00b0</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEVICE_CTRL_EXTENDED</csr:referenceName>
       <csr:identifier>DEVICE_CTRL_EXTENDED</csr:identifier>
       <csr:addressMacro>I3C_DEVICE_CTRL_EXTENDED_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEVICE_CTRL_EXTENDED_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEVICE_CTRL_EXTENDED_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEVICE_CTRL_EXTENDED_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1866</csr:linenumber>
       <csr:title>Device Control Extended Register</csr:title>
       <csr:offset>0xB0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_DEVICE_CTRL_EXTENDED</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Device Control Extended register.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DEV_OPERATION_MODE</csr:identifier>
         <csr:widthMacro>I3C_DEVICE_CTRL_EXTENDED_DEV_OPERATION_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEVICE_CTRL_EXTENDED_DEV_OPERATION_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEVICE_CTRL_EXTENDED_DEV_OPERATION_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEVICE_CTRL_EXTENDED_DEV_OPERATION_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEVICE_CTRL_EXTENDED_DEV_OPERATION_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEVICE_CTRL_EXTENDED_DEV_OPERATION_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEVICE_CTRL_EXTENDED_DEV_OPERATION_MODE_GET</csr:getMacro>
         <csr:setMacro>I3C_DEVICE_CTRL_EXTENDED_DEV_OPERATION_MODE_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1865</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This bit is used to select the Device Operation Mode.</csr:p>
         <csr:p> - 0: Master</csr:p>
         <csr:p> - 1: Slave</csr:p>
         <csr:p> - 2: Reserved</csr:p>
         <csr:p> - 3: Reserved</csr:p>
         <csr:p>This bit will be automatically updated by the controller once the role change happens.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
         <csr:enumeration>
          <csr:titles>true</csr:titles>
          <csr:descriptions>false</csr:descriptions>
          <csr:enumeratorsHavePartialAccess>false</csr:enumeratorsHavePartialAccess>
          <csr:enumerator>
           <csr:identifier>MASTER</csr:identifier>
           <csr:value>0x0</csr:value>
           <csr:title>Master</csr:title>
          </csr:enumerator>
          <csr:enumerator>
           <csr:identifier>SLAVE</csr:identifier>
           <csr:value>0x1</csr:value>
           <csr:title>Slave</csr:title>
          </csr:enumerator>
         </csr:enumeration>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.SCL_I3C_OD_TIMING</csr:referenceName>
       <csr:identifier>SCL_I3C_OD_TIMING</csr:identifier>
       <csr:addressMacro>I3C_SCL_I3C_OD_TIMING_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_SCL_I3C_OD_TIMING_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_SCL_I3C_OD_TIMING_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_SCL_I3C_OD_TIMING_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1906</csr:linenumber>
       <csr:title>SCL I3C Open Drain Timing Register</csr:title>
       <csr:offset>0xB4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x000a0010</csr:registerResetValue>
       <csr:typeName>I3c_SCL_I3C_OD_TIMING</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>SCL I3C Open Drain Timing Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This register sets the SCL clock high period and low period count for I3C Open Drain transfers. The count value</csr:p>
         <csr:p>takes the number of core_clks to maintain the I/O SCL High/Low Period timing.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>I3C_OD_LCNT</csr:identifier>
         <csr:widthMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_LCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_LCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_LCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_LCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_LCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_LCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_LCNT_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_LCNT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1892</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I3C Open Drain Low Count. </csr:p>
         <csr:p></csr:p>
         <csr:p>SCL Open-drain low count for I3C transfers targeted to I3C devices.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x10</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>I3C_OD_HCNT</csr:identifier>
         <csr:widthMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_HCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_HCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_HCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_HCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_HCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_HCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_HCNT_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_I3C_OD_TIMING_I3C_OD_HCNT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1905</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I3C Open Drain High Count. </csr:p>
         <csr:p></csr:p>
         <csr:p>SCL open-drain High count (I3C) for I3C transfers targeted to I3C devices.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0a</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.SCL_I3C_PP_TIMING</csr:referenceName>
       <csr:identifier>SCL_I3C_PP_TIMING</csr:identifier>
       <csr:addressMacro>I3C_SCL_I3C_PP_TIMING_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_SCL_I3C_PP_TIMING_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_SCL_I3C_PP_TIMING_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_SCL_I3C_PP_TIMING_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1946</csr:linenumber>
       <csr:title>SCL I3C Push Pull Timing Register</csr:title>
       <csr:offset>0xB8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x000a000a</csr:registerResetValue>
       <csr:typeName>I3c_SCL_I3C_PP_TIMING</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>SCL I3C Push Pull Timing Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This register sets the SCL clock high period and low period count for I3C Push Pull transfers. The count value</csr:p>
         <csr:p>takes the number of core_clks to maintain the I/O SCL High/Low Period timing.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>I3C_PP_LCNT</csr:identifier>
         <csr:widthMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_LCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_LCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_LCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_LCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_LCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_LCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_LCNT_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_LCNT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1932</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I3C Push Pull Low Count. </csr:p>
         <csr:p></csr:p>
         <csr:p>SCL Push-pull low count for I3C transfers targeted to I3C devices.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0a</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>I3C_PP_HCNT</csr:identifier>
         <csr:widthMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_HCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_HCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_HCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_HCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_HCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_HCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_HCNT_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_I3C_PP_TIMING_I3C_PP_HCNT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1945</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I3C Push Pull High Count. </csr:p>
         <csr:p></csr:p>
         <csr:p>SCL push-pull High count for I3C transfers targeted to I3C devices.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0a</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.SCL_I2C_FM_TIMING</csr:referenceName>
       <csr:identifier>SCL_I2C_FM_TIMING</csr:identifier>
       <csr:addressMacro>I3C_SCL_I2C_FM_TIMING_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_SCL_I2C_FM_TIMING_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_SCL_I2C_FM_TIMING_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_SCL_I2C_FM_TIMING_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>1986</csr:linenumber>
       <csr:title>SCL I2C Fast Mode Timing Register</csr:title>
       <csr:offset>0xBC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00100010</csr:registerResetValue>
       <csr:typeName>I3c_SCL_I2C_FM_TIMING</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>SCL I2C Fast Mode Timing Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This register sets the SCL clock high period and low period count for I2C Fast Mode transfers. The count value</csr:p>
         <csr:p>takes the number of core_clks to maintain the I/O SCL Low/High period timing.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>I2C_FM_LCNT</csr:identifier>
         <csr:widthMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_LCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_LCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_LCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_LCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_LCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_LCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_LCNT_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_LCNT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1972</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I2C Fast Mode Low Count </csr:p>
         <csr:p></csr:p>
         <csr:p>The SCL open-drain low count timing for I2C fast mode transfers.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0010</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>I2C_FM_HCNT</csr:identifier>
         <csr:widthMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_HCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_HCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_HCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_HCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_HCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_HCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_HCNT_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_I2C_FM_TIMING_I2C_FM_HCNT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>1985</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I2C Fast Mode High Count </csr:p>
         <csr:p></csr:p>
         <csr:p>The SCL open-drain high count timing for I2C fast mode transfers.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0010</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.SCL_I2C_FMP_TIMING</csr:referenceName>
       <csr:identifier>SCL_I2C_FMP_TIMING</csr:identifier>
       <csr:addressMacro>I3C_SCL_I2C_FMP_TIMING_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_SCL_I2C_FMP_TIMING_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_SCL_I2C_FMP_TIMING_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_SCL_I2C_FMP_TIMING_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2026</csr:linenumber>
       <csr:title>SCL I2C Fast Mode Plus Timing Register</csr:title>
       <csr:offset>0xC0</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00100010</csr:registerResetValue>
       <csr:typeName>I3c_SCL_I2C_FMP_TIMING</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>SCL I2C Fast Mode Plus Timing Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This register sets the SCL clock high period and low period count for I2C Fast Mode Plus transfers. The count value</csr:p>
         <csr:p>takes the number of core_clks to maintain the I/O SCL Low/High period timing.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>I2C_FMP_LCNT</csr:identifier>
         <csr:widthMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_LCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_LCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_LCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_LCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_LCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_LCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_LCNT_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_LCNT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2012</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I2C Fast Mode Plus Low Count </csr:p>
         <csr:p></csr:p>
         <csr:p>The SCL open-drain low count timing for I2C fast mode plus transfers.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0010</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>I2C_FMP_HCNT</csr:identifier>
         <csr:widthMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_HCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_HCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_HCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_HCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_HCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_HCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_HCNT_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_I2C_FMP_TIMING_I2C_FMP_HCNT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2025</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I2C Fast Mode Plus High Count </csr:p>
         <csr:p></csr:p>
         <csr:p>The SCL open-drain high count timing for I2C fast mode plus transfers.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x10</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.SCL_EXT_LCNT_TIMING</csr:referenceName>
       <csr:identifier>SCL_EXT_LCNT_TIMING</csr:identifier>
       <csr:addressMacro>I3C_SCL_EXT_LCNT_TIMING_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_SCL_EXT_LCNT_TIMING_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_SCL_EXT_LCNT_TIMING_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_SCL_EXT_LCNT_TIMING_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2096</csr:linenumber>
       <csr:title>SCL Extended Low Count Timing Register</csr:title>
       <csr:offset>0xC8</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x20202020</csr:registerResetValue>
       <csr:typeName>I3c_SCL_EXT_LCNT_TIMING</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>SCL Extended Low Count Timing Register.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register sets the extended low periods for the I3C transfers to allow the low data rates of the Slave devices</csr:p>
         <csr:p>as specified in GETMXDS CCC.The Speed field of Transfer command (COMMAND_QUEUE_PORT_TRANSFER_COMMAND) decides the selection</csr:p>
         <csr:p>of extended low period to achieve the lower data rate for the transfers to Slave devices.</csr:p>
         <csr:p> - SDR1: Uses I3C_EXT_LCNT_1 field for the data transfer.</csr:p>
         <csr:p> - SDR2: Uses I3C_EXT_LCNT_2 field for the data transfer.</csr:p>
         <csr:p> - SDR3: Uses I3C_EXT_LCNT_3 field for the data transfer.</csr:p>
         <csr:p> - SDR4: Uses I3C_EXT_LCNT_4 field for the data transfer.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>I3C_EXT_LCNT_1</csr:identifier>
         <csr:widthMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_1_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_1_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_1_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_1_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_1_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_1_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_1_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_1_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2059</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I3C Extended Low Count Register 1 </csr:p>
         <csr:p></csr:p>
         <csr:p>SDR1 uses this register field for data transfer.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x20</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>I3C_EXT_LCNT_2</csr:identifier>
         <csr:widthMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_2_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_2_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_2_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_2_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_2_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_2_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_2_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_2_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2071</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I3C Extended Low Count Register 2 </csr:p>
         <csr:p></csr:p>
         <csr:p>SDR2 uses this register field for data transfer.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x20</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>I3C_EXT_LCNT_3</csr:identifier>
         <csr:widthMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_3_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_3_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_3_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_3_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_3_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_3_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_3_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_3_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2083</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I3C Extended Low Count Register 3 </csr:p>
         <csr:p></csr:p>
         <csr:p>SDR3 uses this register field for data transfer.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x20</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>I3C_EXT_LCNT_4</csr:identifier>
         <csr:widthMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_4_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_4_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_4_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_4_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_4_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_4_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_4_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_EXT_LCNT_TIMING_I3C_EXT_LCNT_4_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2095</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I3C Extended Low Count Register 4 </csr:p>
         <csr:p></csr:p>
         <csr:p>SDR4 uses this register field for data transfer.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x20</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.SCL_EXT_TERMN_LCNT_TIMING</csr:referenceName>
       <csr:identifier>SCL_EXT_TERMN_LCNT_TIMING</csr:identifier>
       <csr:addressMacro>I3C_SCL_EXT_TERMN_LCNT_TIMING_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_SCL_EXT_TERMN_LCNT_TIMING_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_SCL_EXT_TERMN_LCNT_TIMING_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_SCL_EXT_TERMN_LCNT_TIMING_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2128</csr:linenumber>
       <csr:title>SCL Termination Bit Low count Timing Register</csr:title>
       <csr:offset>0xCC</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_SCL_EXT_TERMN_LCNT_TIMING</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>SCL Termination Bit Low Count Timing Register</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is used to extend the SCL Low period for Read Termination Bit.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>I3C_EXT_TERMN_LCNT</csr:identifier>
         <csr:widthMacro>I3C_SCL_EXT_TERMN_LCNT_TIMING_I3C_EXT_TERMN_LCNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_SCL_EXT_TERMN_LCNT_TIMING_I3C_EXT_TERMN_LCNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_SCL_EXT_TERMN_LCNT_TIMING_I3C_EXT_TERMN_LCNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_SCL_EXT_TERMN_LCNT_TIMING_I3C_EXT_TERMN_LCNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_SCL_EXT_TERMN_LCNT_TIMING_I3C_EXT_TERMN_LCNT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_SCL_EXT_TERMN_LCNT_TIMING_I3C_EXT_TERMN_LCNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_SCL_EXT_TERMN_LCNT_TIMING_I3C_EXT_TERMN_LCNT_GET</csr:getMacro>
         <csr:setMacro>I3C_SCL_EXT_TERMN_LCNT_TIMING_I3C_EXT_TERMN_LCNT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2127</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>I3C Read Termination Bit Low count. </csr:p>
         <csr:p></csr:p>
         <csr:p>Extended I3C Read Termination Bit low count for I3C Read transfers.</csr:p>
         <csr:p>Effective Termination-Bit Low Period is derived based on the SDR speed as shown below</csr:p>
         <csr:p> - SDR0 speed: I3C_PP_LCNT + I3C_EXT_TERMN_LCNT</csr:p>
         <csr:p> - SDR1 speed: I3C_EXT_LCNT_1 + I3C_EXT_TERMN_LCNT</csr:p>
         <csr:p> - SDR2 speed: I3C_EXT_LCNT_2 + I3C_EXT_TERMN_LCNT</csr:p>
         <csr:p> - SDR3 speed: I3C_EXT_LCNT_3 + I3C_EXT_TERMN_LCNT</csr:p>
         <csr:p> - SDR4 speed: I3C_EXT_LCNT_4 + I3C_EXT_TERMN_LCNT</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.BUS_FREE_TIMING</csr:referenceName>
       <csr:identifier>BUS_FREE_TIMING</csr:identifier>
       <csr:addressMacro>I3C_BUS_FREE_TIMING_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_BUS_FREE_TIMING_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_BUS_FREE_TIMING_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_BUS_FREE_TIMING_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2159</csr:linenumber>
       <csr:title>Bus Free Timing Register</csr:title>
       <csr:offset>0xD4</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000020</csr:registerResetValue>
       <csr:typeName>I3c_BUS_FREE_TIMING</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Bus Free Timing Register </csr:p>
         <csr:p></csr:p>
         <csr:p>This register sets the Bus free time for initiating the transfer in master mode or generating IBI in non-current</csr:p>
         <csr:p>master mode.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>I3C_MST_FREE</csr:identifier>
         <csr:widthMacro>I3C_BUS_FREE_TIMING_I3C_MST_FREE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_BUS_FREE_TIMING_I3C_MST_FREE_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_BUS_FREE_TIMING_I3C_MST_FREE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_BUS_FREE_TIMING_I3C_MST_FREE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_BUS_FREE_TIMING_I3C_MST_FREE_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_BUS_FREE_TIMING_I3C_MST_FREE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_BUS_FREE_TIMING_I3C_MST_FREE_GET</csr:getMacro>
         <csr:setMacro>I3C_BUS_FREE_TIMING_I3C_MST_FREE_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2158</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This register field is used only in Master mode of operation </csr:p>
         <csr:p></csr:p>
         <csr:p>I3C Master Free Count Value.</csr:p>
         <csr:p></csr:p>
         <csr:p>In Pure Bus System, this field represents tCAS parameter. In Mixed Bus system, this field is expected to be programmed</csr:p>
         <csr:p>to tLOW of I2C Timing.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0020</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.I3C_VER_ID</csr:referenceName>
       <csr:identifier>I3C_VER_ID</csr:identifier>
       <csr:addressMacro>I3C_I3C_VER_ID_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_I3C_VER_ID_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_I3C_VER_ID_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_I3C_VER_ID_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2191</csr:linenumber>
       <csr:title>DWC_mipi_i3c Version ID Register</csr:title>
       <csr:offset>0xE0</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x3130302a</csr:registerResetValue>
       <csr:typeName>I3c_I3C_VER_ID</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This register reflects the current release number of DWC_mipi_i3c</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>I3C_VER_ID</csr:identifier>
         <csr:widthMacro>I3C_I3C_VER_ID_I3C_VER_ID_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_I3C_VER_ID_I3C_VER_ID_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_I3C_VER_ID_I3C_VER_ID_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_I3C_VER_ID_I3C_VER_ID_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_I3C_VER_ID_I3C_VER_ID_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_I3C_VER_ID_I3C_VER_ID_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_I3C_VER_ID_I3C_VER_ID_GET</csr:getMacro>
         <csr:setMacro>I3C_I3C_VER_ID_I3C_VER_ID_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2190</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Current release number </csr:p>
         <csr:p></csr:p>
         <csr:p>This field indicates the Synopsys DesignWare Cores DWC_mipi_i3c current release number that is read by an application.</csr:p>
         <csr:p></csr:p>
         <csr:p>For example, release number "1.00a" is represented in ASCII as 0x313030. Lower 8 bits read from this register can be</csr:p>
         <csr:p>ignored by the application. An application reading this register along with the I3C_VER_TYPE register, gathers</csr:p>
         <csr:p>details of the current release.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x3130302a</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.I3C_VER_TYPE</csr:referenceName>
       <csr:identifier>I3C_VER_TYPE</csr:identifier>
       <csr:addressMacro>I3C_I3C_VER_TYPE_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_I3C_VER_TYPE_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_I3C_VER_TYPE_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_I3C_VER_TYPE_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2227</csr:linenumber>
       <csr:title>DWC_mipi_i3c Version Type Register</csr:title>
       <csr:offset>0xE4</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x65613632</csr:registerResetValue>
       <csr:typeName>I3c_I3C_VER_TYPE</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This register reflects the current release type of DWC_mipi_i3c.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>I3C_VER_TYPE</csr:identifier>
         <csr:widthMacro>I3C_I3C_VER_TYPE_I3C_VER_TYPE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_I3C_VER_TYPE_I3C_VER_TYPE_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_I3C_VER_TYPE_I3C_VER_TYPE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_I3C_VER_TYPE_I3C_VER_TYPE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_I3C_VER_TYPE_I3C_VER_TYPE_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_I3C_VER_TYPE_I3C_VER_TYPE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_I3C_VER_TYPE_I3C_VER_TYPE_GET</csr:getMacro>
         <csr:setMacro>I3C_I3C_VER_TYPE_I3C_VER_TYPE_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2226</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Current release type </csr:p>
         <csr:p></csr:p>
         <csr:p>This field indicates the Synopsys DesignWare Cores DWC_mipi_i3c current release type that is read by an application.</csr:p>
         <csr:p></csr:p>
         <csr:p>For example, release type "ga" is represented in ASCII as 0x6761 and "ea" is represented as 0x6561. Lower 16 bits</csr:p>
         <csr:p>read from this register can be ignored by the application if release type is "ga". If release type is "ea" the lower</csr:p>
         <csr:p>16 bits represents the "ea" release version.</csr:p>
         <csr:p>An application reading this register along with the I3C_VER_ID</csr:p>
         <csr:p>register, gathers details of the current release.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x65613632</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.EXTENDED_CAPABILITY</csr:referenceName>
       <csr:identifier>EXTENDED_CAPABILITY</csr:identifier>
       <csr:addressMacro>I3C_EXTENDED_CAPABILITY_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_EXTENDED_CAPABILITY_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_EXTENDED_CAPABILITY_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_EXTENDED_CAPABILITY_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2288</csr:linenumber>
       <csr:title>DWC_mipi_i3c Extended Capabilities Register</csr:title>
       <csr:offset>0xE8</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000239</csr:registerResetValue>
       <csr:typeName>I3c_EXTENDED_CAPABILITY</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>DWC_mipi_i3c Extended Capbilities.</csr:p>
         <csr:p></csr:p>
         <csr:p>This register is used in master mode of operation.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>APP_IF_MODE</csr:identifier>
         <csr:widthMacro>I3C_EXTENDED_CAPABILITY_APP_IF_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_EXTENDED_CAPABILITY_APP_IF_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_EXTENDED_CAPABILITY_APP_IF_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_EXTENDED_CAPABILITY_APP_IF_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_EXTENDED_CAPABILITY_APP_IF_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_EXTENDED_CAPABILITY_APP_IF_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_EXTENDED_CAPABILITY_APP_IF_MODE_GET</csr:getMacro>
         <csr:setMacro>I3C_EXTENDED_CAPABILITY_APP_IF_MODE_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2249</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Reflects the IC_SLVIF_MODE Configurable Parameter</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>1</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x1</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>APP_IF_DATA_WIDTH</csr:identifier>
         <csr:widthMacro>I3C_EXTENDED_CAPABILITY_APP_IF_DATA_WIDTH_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_EXTENDED_CAPABILITY_APP_IF_DATA_WIDTH_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_EXTENDED_CAPABILITY_APP_IF_DATA_WIDTH_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_EXTENDED_CAPABILITY_APP_IF_DATA_WIDTH_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_EXTENDED_CAPABILITY_APP_IF_DATA_WIDTH_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_EXTENDED_CAPABILITY_APP_IF_DATA_WIDTH_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_EXTENDED_CAPABILITY_APP_IF_DATA_WIDTH_GET</csr:getMacro>
         <csr:setMacro>I3C_EXTENDED_CAPABILITY_APP_IF_DATA_WIDTH_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2264</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Reflects encoded value of the IC_SLVIF_DATA_WIDTH Configurable Parameter.</csr:p>
         <csr:p> - 0: 8bits</csr:p>
         <csr:p> - 1: 16bits</csr:p>
         <csr:p> - 2: 32bits</csr:p>
         <csr:p> - 3: 64bits</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>3</csr:msb>
         <csr:lsb>2</csr:lsb>
         <csr:resetValue>0x2</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>OPERATION_MODE</csr:identifier>
         <csr:widthMacro>I3C_EXTENDED_CAPABILITY_OPERATION_MODE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_EXTENDED_CAPABILITY_OPERATION_MODE_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_EXTENDED_CAPABILITY_OPERATION_MODE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_EXTENDED_CAPABILITY_OPERATION_MODE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_EXTENDED_CAPABILITY_OPERATION_MODE_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_EXTENDED_CAPABILITY_OPERATION_MODE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_EXTENDED_CAPABILITY_OPERATION_MODE_GET</csr:getMacro>
         <csr:setMacro>I3C_EXTENDED_CAPABILITY_OPERATION_MODE_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2274</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Reflects the OPERATION_MODE Configurable Parameter</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>5</csr:msb>
         <csr:lsb>4</csr:lsb>
         <csr:resetValue>0x3</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>CLK_PERIOD</csr:identifier>
         <csr:widthMacro>I3C_EXTENDED_CAPABILITY_CLK_PERIOD_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_EXTENDED_CAPABILITY_CLK_PERIOD_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_EXTENDED_CAPABILITY_CLK_PERIOD_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_EXTENDED_CAPABILITY_CLK_PERIOD_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_EXTENDED_CAPABILITY_CLK_PERIOD_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_EXTENDED_CAPABILITY_CLK_PERIOD_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_EXTENDED_CAPABILITY_CLK_PERIOD_GET</csr:getMacro>
         <csr:setMacro>I3C_EXTENDED_CAPABILITY_CLK_PERIOD_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2287</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Clock Period </csr:p>
         <csr:p></csr:p>
         <csr:p>This field returns the configuration parameter IC_CLK_PERIOD.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>11</csr:msb>
         <csr:lsb>6</csr:lsb>
         <csr:resetValue>0x08</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>12</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEV_CHAR_TABLE1_LOC1</csr:referenceName>
       <csr:identifier>DEV_CHAR_TABLE1_LOC1</csr:identifier>
       <csr:addressMacro>I3C_DEV_CHAR_TABLE1_LOC1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEV_CHAR_TABLE1_LOC1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEV_CHAR_TABLE1_LOC1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEV_CHAR_TABLE1_LOC1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2308</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x200</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_DEV_CHAR_TABLE1_LOC1</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Device Characteristic Table Location-1 of Device1</csr:p>
         <csr:p>  This register is used in master mode of operation.</csr:p>
         <csr:p>1</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>LSB_PROVISIONAL_ID</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE1_LOC1_LSB_PROVISIONAL_ID_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE1_LOC1_LSB_PROVISIONAL_ID_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE1_LOC1_LSB_PROVISIONAL_ID_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE1_LOC1_LSB_PROVISIONAL_ID_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE1_LOC1_LSB_PROVISIONAL_ID_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE1_LOC1_LSB_PROVISIONAL_ID_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE1_LOC1_LSB_PROVISIONAL_ID_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE1_LOC1_LSB_PROVISIONAL_ID_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2307</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  The LSB 32-bit value of Provisional-ID</csr:p>
         <csr:p>  </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEV_CHAR_TABLE1_LOC2</csr:referenceName>
       <csr:identifier>DEV_CHAR_TABLE1_LOC2</csr:identifier>
       <csr:addressMacro>I3C_DEV_CHAR_TABLE1_LOC2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEV_CHAR_TABLE1_LOC2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEV_CHAR_TABLE1_LOC2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEV_CHAR_TABLE1_LOC2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2328</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x204</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_DEV_CHAR_TABLE1_LOC2</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Device Characteristic Table Location-2 of Device1</csr:p>
         <csr:p>  This register is used in master mode of operation.</csr:p>
         <csr:p>1</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>MSB_PROVISIONAL_ID</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE1_LOC2_MSB_PROVISIONAL_ID_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE1_LOC2_MSB_PROVISIONAL_ID_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE1_LOC2_MSB_PROVISIONAL_ID_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE1_LOC2_MSB_PROVISIONAL_ID_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE1_LOC2_MSB_PROVISIONAL_ID_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE1_LOC2_MSB_PROVISIONAL_ID_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE1_LOC2_MSB_PROVISIONAL_ID_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE1_LOC2_MSB_PROVISIONAL_ID_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2327</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  The MSB 16-bit value of Provisional-ID</csr:p>
         <csr:p>  </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEV_CHAR_TABLE1_LOC3</csr:referenceName>
       <csr:identifier>DEV_CHAR_TABLE1_LOC3</csr:identifier>
       <csr:addressMacro>I3C_DEV_CHAR_TABLE1_LOC3_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEV_CHAR_TABLE1_LOC3_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEV_CHAR_TABLE1_LOC3_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEV_CHAR_TABLE1_LOC3_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2359</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x208</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_DEV_CHAR_TABLE1_LOC3</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Device Characteristic Table Location-3 of Device1</csr:p>
         <csr:p>  This register is used in master mode of operation.</csr:p>
         <csr:p>1</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DCR</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE1_LOC3_DCR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE1_LOC3_DCR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE1_LOC3_DCR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE1_LOC3_DCR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE1_LOC3_DCR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE1_LOC3_DCR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE1_LOC3_DCR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE1_LOC3_DCR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2347</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Device Characteristic Value</csr:p>
         <csr:p>  </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>BCR</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE1_LOC3_BCR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE1_LOC3_BCR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE1_LOC3_BCR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE1_LOC3_BCR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE1_LOC3_BCR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE1_LOC3_BCR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE1_LOC3_BCR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE1_LOC3_BCR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2358</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Bus Characteristic Value</csr:p>
         <csr:p>  </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEV_CHAR_TABLE1_LOC4</csr:referenceName>
       <csr:identifier>DEV_CHAR_TABLE1_LOC4</csr:identifier>
       <csr:addressMacro>I3C_DEV_CHAR_TABLE1_LOC4_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEV_CHAR_TABLE1_LOC4_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEV_CHAR_TABLE1_LOC4_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEV_CHAR_TABLE1_LOC4_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2379</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x20C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_DEV_CHAR_TABLE1_LOC4</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Device Characteristic Table Location-4 of Device1</csr:p>
         <csr:p>  This register is used in master mode of operation.</csr:p>
         <csr:p>1</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DEV_DYNAMIC_ADDR</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE1_LOC4_DEV_DYNAMIC_ADDR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE1_LOC4_DEV_DYNAMIC_ADDR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE1_LOC4_DEV_DYNAMIC_ADDR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE1_LOC4_DEV_DYNAMIC_ADDR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE1_LOC4_DEV_DYNAMIC_ADDR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE1_LOC4_DEV_DYNAMIC_ADDR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE1_LOC4_DEV_DYNAMIC_ADDR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE1_LOC4_DEV_DYNAMIC_ADDR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2378</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Device Dynamic Address assigned.</csr:p>
         <csr:p>  </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEV_CHAR_TABLE2_LOC1</csr:referenceName>
       <csr:identifier>DEV_CHAR_TABLE2_LOC1</csr:identifier>
       <csr:addressMacro>I3C_DEV_CHAR_TABLE2_LOC1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEV_CHAR_TABLE2_LOC1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEV_CHAR_TABLE2_LOC1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEV_CHAR_TABLE2_LOC1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2399</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x210</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_DEV_CHAR_TABLE2_LOC1</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Device Characteristic Table Location-1 of Device2</csr:p>
         <csr:p>  This register is used in master mode of operation.</csr:p>
         <csr:p>1</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>LSB_PROVISIONAL_ID</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE2_LOC1_LSB_PROVISIONAL_ID_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE2_LOC1_LSB_PROVISIONAL_ID_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE2_LOC1_LSB_PROVISIONAL_ID_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE2_LOC1_LSB_PROVISIONAL_ID_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE2_LOC1_LSB_PROVISIONAL_ID_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE2_LOC1_LSB_PROVISIONAL_ID_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE2_LOC1_LSB_PROVISIONAL_ID_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE2_LOC1_LSB_PROVISIONAL_ID_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2398</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  The LSB 32-bit value of Provisional-ID</csr:p>
         <csr:p>  </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00000000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEV_CHAR_TABLE2_LOC2</csr:referenceName>
       <csr:identifier>DEV_CHAR_TABLE2_LOC2</csr:identifier>
       <csr:addressMacro>I3C_DEV_CHAR_TABLE2_LOC2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEV_CHAR_TABLE2_LOC2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEV_CHAR_TABLE2_LOC2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEV_CHAR_TABLE2_LOC2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2419</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x214</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_DEV_CHAR_TABLE2_LOC2</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Device Characteristic Table Location-2 of Device2</csr:p>
         <csr:p>  This register is used in master mode of operation.</csr:p>
         <csr:p>1</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>MSB_PROVISIONAL_ID</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE2_LOC2_MSB_PROVISIONAL_ID_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE2_LOC2_MSB_PROVISIONAL_ID_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE2_LOC2_MSB_PROVISIONAL_ID_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE2_LOC2_MSB_PROVISIONAL_ID_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE2_LOC2_MSB_PROVISIONAL_ID_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE2_LOC2_MSB_PROVISIONAL_ID_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE2_LOC2_MSB_PROVISIONAL_ID_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE2_LOC2_MSB_PROVISIONAL_ID_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2418</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  The MSB 16-bit value of Provisional-ID</csr:p>
         <csr:p>  </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x0000</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEV_CHAR_TABLE2_LOC3</csr:referenceName>
       <csr:identifier>DEV_CHAR_TABLE2_LOC3</csr:identifier>
       <csr:addressMacro>I3C_DEV_CHAR_TABLE2_LOC3_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEV_CHAR_TABLE2_LOC3_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEV_CHAR_TABLE2_LOC3_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEV_CHAR_TABLE2_LOC3_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2450</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x218</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_DEV_CHAR_TABLE2_LOC3</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Device Characteristic Table Location-3 of Device2</csr:p>
         <csr:p>  This register is used in master mode of operation.</csr:p>
         <csr:p>1</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DCR</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE2_LOC3_DCR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE2_LOC3_DCR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE2_LOC3_DCR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE2_LOC3_DCR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE2_LOC3_DCR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE2_LOC3_DCR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE2_LOC3_DCR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE2_LOC3_DCR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2438</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Device Characteristic Value</csr:p>
         <csr:p>  </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>BCR</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE2_LOC3_BCR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE2_LOC3_BCR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE2_LOC3_BCR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE2_LOC3_BCR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE2_LOC3_BCR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE2_LOC3_BCR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE2_LOC3_BCR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE2_LOC3_BCR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2449</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Bus Characteristic Value</csr:p>
         <csr:p>  </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>15</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEV_CHAR_TABLE2_LOC4</csr:referenceName>
       <csr:identifier>DEV_CHAR_TABLE2_LOC4</csr:identifier>
       <csr:addressMacro>I3C_DEV_CHAR_TABLE2_LOC4_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEV_CHAR_TABLE2_LOC4_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEV_CHAR_TABLE2_LOC4_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEV_CHAR_TABLE2_LOC4_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2470</csr:linenumber>
       <csr:title></csr:title>
       <csr:offset>0x21C</csr:offset>
       <csr:addressedAccess>R</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_DEV_CHAR_TABLE2_LOC4</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Device Characteristic Table Location-4 of Device2</csr:p>
         <csr:p>  This register is used in master mode of operation.</csr:p>
         <csr:p>1</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DEV_DYNAMIC_ADDR</csr:identifier>
         <csr:widthMacro>I3C_DEV_CHAR_TABLE2_LOC4_DEV_DYNAMIC_ADDR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_CHAR_TABLE2_LOC4_DEV_DYNAMIC_ADDR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_CHAR_TABLE2_LOC4_DEV_DYNAMIC_ADDR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_CHAR_TABLE2_LOC4_DEV_DYNAMIC_ADDR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_CHAR_TABLE2_LOC4_DEV_DYNAMIC_ADDR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_CHAR_TABLE2_LOC4_DEV_DYNAMIC_ADDR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_CHAR_TABLE2_LOC4_DEV_DYNAMIC_ADDR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_CHAR_TABLE2_LOC4_DEV_DYNAMIC_ADDR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2469</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>  Device Dynamic Address assigned.</csr:p>
         <csr:p>  </csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>7</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>31</csr:msb>
         <csr:lsb>8</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEV_ADDR_TABLE_LOC1</csr:referenceName>
       <csr:identifier>DEV_ADDR_TABLE_LOC1</csr:identifier>
       <csr:addressMacro>I3C_DEV_ADDR_TABLE_LOC1_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEV_ADDR_TABLE_LOC1_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEV_ADDR_TABLE_LOC1_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEV_ADDR_TABLE_LOC1_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2542</csr:linenumber>
       <csr:title>Device Address Table of Device1</csr:title>
       <csr:offset>0x220</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_DEV_ADDR_TABLE_LOC1</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Device Address Table of Device1</csr:p>
         <csr:p>This register is used in master mode of operation.</csr:p>
         <csr:p>1</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DEV_STATIC_ADDR</csr:identifier>
         <csr:widthMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_STATIC_ADDR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_STATIC_ADDR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_STATIC_ADDR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_STATIC_ADDR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_STATIC_ADDR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_STATIC_ADDR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_STATIC_ADDR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_STATIC_ADDR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2490</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Device Static Address.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DEV_DYNAMIC_ADDR</csr:identifier>
         <csr:widthMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_DYNAMIC_ADDR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_DYNAMIC_ADDR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_DYNAMIC_ADDR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_DYNAMIC_ADDR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_DYNAMIC_ADDR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_DYNAMIC_ADDR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_DYNAMIC_ADDR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_DYNAMIC_ADDR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2503</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Device Dynamic Address with parity.</csr:p>
         <csr:p>The MSB, bit[23], should be programmed with parity of dynamic address.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>28</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DEV_NACK_RETRY_CNT</csr:identifier>
         <csr:widthMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_NACK_RETRY_CNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_NACK_RETRY_CNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_NACK_RETRY_CNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_NACK_RETRY_CNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_NACK_RETRY_CNT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_NACK_RETRY_CNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_NACK_RETRY_CNT_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_ADDR_TABLE_LOC1_DEV_NACK_RETRY_CNT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2527</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>This field is used to set the Device NACK Retry count for the particular device.</csr:p>
         <csr:p></csr:p>
         <csr:p>If the Device NACK's for the device address, the controller automatically retries the same device until</csr:p>
         <csr:p>this count expires. If the Slave does not ACK for the mentioned number of retries, then Controller</csr:p>
         <csr:p>generates an error response and move to the Halt state.</csr:p>
         <csr:p></csr:p>
         <csr:p>This feature is used for Retry Model for the following features mentioned in the I3C Specification:</csr:p>
         <csr:p> - Retry Model for Direct GET CCC Commands.</csr:p>
         <csr:p> - The incoming SIR-IBI matches with the slave address initated by the Master.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>30</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>LEGACY_I2C_DEVICE</csr:identifier>
         <csr:widthMacro>I3C_DEV_ADDR_TABLE_LOC1_LEGACY_I2C_DEVICE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_ADDR_TABLE_LOC1_LEGACY_I2C_DEVICE_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_ADDR_TABLE_LOC1_LEGACY_I2C_DEVICE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_ADDR_TABLE_LOC1_LEGACY_I2C_DEVICE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_ADDR_TABLE_LOC1_LEGACY_I2C_DEVICE_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_ADDR_TABLE_LOC1_LEGACY_I2C_DEVICE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_ADDR_TABLE_LOC1_LEGACY_I2C_DEVICE_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_ADDR_TABLE_LOC1_LEGACY_I2C_DEVICE_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2541</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Legacy I2C device or not.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit should be set to 1 if the device is a legacy I2C device.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
      <csr:definition>
       <csr:referenceType>register</csr:referenceType>
       <csr:referenceName>i3c.DEV_ADDR_TABLE_LOC2</csr:referenceName>
       <csr:identifier>DEV_ADDR_TABLE_LOC2</csr:identifier>
       <csr:addressMacro>I3C_DEV_ADDR_TABLE_LOC2_ADDRESS</csr:addressMacro>
       <csr:byteAddressMacro>I3C_DEV_ADDR_TABLE_LOC2_BYTE_ADDRESS</csr:byteAddressMacro>
       <csr:offsetMacro>I3C_DEV_ADDR_TABLE_LOC2_OFFSET</csr:offsetMacro>
       <csr:byteOffsetMacro>I3C_DEV_ADDR_TABLE_LOC2_BYTE_OFFSET</csr:byteOffsetMacro>
       <csr:filename>pu_i3c.csr</csr:filename>
       <csr:linenumber>2612</csr:linenumber>
       <csr:title>Device Address Table of Device2</csr:title>
       <csr:offset>0x224</csr:offset>
       <csr:addressedAccess>R/W</csr:addressedAccess>
       <csr:registerResetValue>0x00000000</csr:registerResetValue>
       <csr:typeName>I3c_DEV_ADDR_TABLE_LOC2</csr:typeName>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Device Address Table of Device2</csr:p>
         <csr:p>This register is used in master mode of operation.</csr:p>
         <csr:p>1</csr:p>
         <csr:p></csr:p>
        </csr:description>
       <csr:clockDomains>false</csr:clockDomains>
       <csr:synchronizers>false</csr:synchronizers>
       <csr:fieldsHaveAttributes>false</csr:fieldsHaveAttributes>
       <csr:fieldsHaveShortDescriptions>false</csr:fieldsHaveShortDescriptions>
       <csr:bitfields>
        <csr:bitfield>
         <csr:identifier>DEV_STATIC_ADDR</csr:identifier>
         <csr:widthMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_STATIC_ADDR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_STATIC_ADDR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_STATIC_ADDR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_STATIC_ADDR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_STATIC_ADDR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_STATIC_ADDR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_STATIC_ADDR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_STATIC_ADDR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2562</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Device Static Address.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>6</csr:msb>
         <csr:lsb>0</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>15</csr:msb>
         <csr:lsb>7</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DEV_DYNAMIC_ADDR</csr:identifier>
         <csr:widthMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_DYNAMIC_ADDR_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_DYNAMIC_ADDR_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_DYNAMIC_ADDR_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_DYNAMIC_ADDR_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_DYNAMIC_ADDR_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_DYNAMIC_ADDR_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_DYNAMIC_ADDR_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_DYNAMIC_ADDR_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2575</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Device Dynamic Address with parity.</csr:p>
         <csr:p>The MSB, bit[23], should be programmed with parity of dynamic address.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>23</csr:msb>
         <csr:lsb>16</csr:lsb>
         <csr:resetValue>0x00</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>-</csr:identifier>
         <csr:title>-</csr:title>
         <csr:msb>28</csr:msb>
         <csr:lsb>24</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>r</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>DEV_NACK_RETRY_CNT</csr:identifier>
         <csr:widthMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_NACK_RETRY_CNT_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_NACK_RETRY_CNT_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_NACK_RETRY_CNT_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_NACK_RETRY_CNT_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_NACK_RETRY_CNT_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_NACK_RETRY_CNT_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_NACK_RETRY_CNT_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_ADDR_TABLE_LOC2_DEV_NACK_RETRY_CNT_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2597</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>DEVICE_NACK_RETRY_CNT: These field is used to set the Device NACK Retry count for the particular device.</csr:p>
         <csr:p>If the Device NACK's for the device address, the controller automatically retries the same device until</csr:p>
         <csr:p>this count expires. If the slave doesn't ACK for the mentioned number of retries, then controller</csr:p>
         <csr:p>generates an error response and move to the Halt state.</csr:p>
         <csr:p>This feature is used for Retry Model for the following features mentioned in the specification:</csr:p>
         <csr:p> 1. Retry Model for Direct GET CCC Commands</csr:p>
         <csr:p> 2. If the incoming SIR-IBI matches with the slave address initated by the master.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>30</csr:msb>
         <csr:lsb>29</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
        <csr:bitfield>
         <csr:identifier>LEGACY_I2C_DEVICE</csr:identifier>
         <csr:widthMacro>I3C_DEV_ADDR_TABLE_LOC2_LEGACY_I2C_DEVICE_WIDTH</csr:widthMacro>
         <csr:msbMacro>I3C_DEV_ADDR_TABLE_LOC2_LEGACY_I2C_DEVICE_MSB</csr:msbMacro>
         <csr:lsbMacro>I3C_DEV_ADDR_TABLE_LOC2_LEGACY_I2C_DEVICE_LSB</csr:lsbMacro>
         <csr:rangeMacro>I3C_DEV_ADDR_TABLE_LOC2_LEGACY_I2C_DEVICE_RANGE</csr:rangeMacro>
         <csr:resetMacro>I3C_DEV_ADDR_TABLE_LOC2_LEGACY_I2C_DEVICE_RESET</csr:resetMacro>
         <csr:maskMacro>I3C_DEV_ADDR_TABLE_LOC2_LEGACY_I2C_DEVICE_FIELD_MASK</csr:maskMacro>
         <csr:getMacro>I3C_DEV_ADDR_TABLE_LOC2_LEGACY_I2C_DEVICE_GET</csr:getMacro>
         <csr:setMacro>I3C_DEV_ADDR_TABLE_LOC2_LEGACY_I2C_DEVICE_SET</csr:setMacro>
         <csr:filename>pu_i3c.csr</csr:filename>
         <csr:linenumber>2611</csr:linenumber>
         <csr:title></csr:title>
        <csr:description>
         <csr:p></csr:p>
         <csr:p>Legacy I2C device or not.</csr:p>
         <csr:p></csr:p>
         <csr:p>This bit should be set to 1 if the device is a legacy I2C device.</csr:p>
         <csr:p></csr:p>
         <csr:p></csr:p>
        </csr:description>
         <csr:msb>31</csr:msb>
         <csr:lsb>31</csr:lsb>
         <csr:resetValue>0x0</csr:resetValue>
         <csr:access>R/W</csr:access>
        </csr:bitfield>
       </csr:bitfields>
      </csr:definition>
     </csr:definitions>
    </csr:csrObject>
   </csr:csrData>
  </xml>
  <div id="docheader">
   <h2>Addressmap Information for 'pu_i3c'</h2>
   <table id="optiontable" border="1" cellpadding="1">
    <tr>
     <td>
      <div id="globalFileInfoCheckBoxDiv">
       <label for="globalFileInfoCheckBox">Input File Information</label>
       <input id="globalFileInfoCheckBox" type="checkbox" onclick="globalFileInfoCheckBox_click();"/>
      </div>
     </td>
     <td>
      <div id="globalHeaderFileInfoCheckBoxDiv">
       <label for="globalHeaderFileInfoCheckBox">Header File Information</label>
       <input id="globalHeaderFileInfoCheckBox" type="checkbox" onclick="globalHeaderFileInfoCheckBox_click();"/>
      </div>
     </td>
     <td>
      <div id="globalEnumInfoCheckBoxDiv">
       <label for="globalEnumInfoCheckBox">Enum Information</label>
       <input id="globalEnumInfoCheckBox" type="checkbox" onclick="globalEnumInfoCheckBox_click();"/>
      </div>
     </td>
    </tr>
   </table>
  </div>
  <div id="docinfo"></div>
  <div id="docroot"></div>
  <div id="docfooter"></div>
 </body>
</html>
