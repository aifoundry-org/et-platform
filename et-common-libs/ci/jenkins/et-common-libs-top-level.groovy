// Autogenerated
import hudson.model.*

def need_to_retrigger(Map args){
    if ( (env.FORCE_CHILD_RETRIGGER != null) && sh(returnStatus: true, script: "${FORCE_CHILD_RETRIGGER}") == 0 ){
        return true;
    }
    options = ''
    if (args.BRANCH != null){ options += ' --branch "' + args.BRANCH + '"'; }
    if (args.REPO_SSH_URL != null){ options += ' --repo_ssh_url "' + args.REPO_SSH_URL + '"'; }
    options += ' --parent_job_commitSHA1 "${GIT_COMMIT}" --parent_job_component_commits "${COMPONENT_COMMITS}" ' + args.JOB_NAME + ' \'{ ' 
    
    if (args.RUN_ID != null){ options += '"RUN_ID":"' + args.RUN_ID + '"'; }
    if (args.COMPONENT_COMMITS != null){ 
        if (args.RUN_ID != null){ options += ', '}
        options += '"COMPONENT_COMMITS":"' + args.COMPONENT_COMMITS + '"'; }
    options += ' }\''
    job_passed_for_branch_CMD = './ci/ci-tools/scripts/jenkins_scripts.py job_passed_for_branch' + options
    
    retrigger = ( sh(returnStatus: true, script: job_passed_for_branch_CMD) != 0 )
    if (! retrigger){
        sh 'echo Skipping job ' + args.JOB_NAME + ' because it already passed'
    }
    return retrigger;
}
def get_child_submodule_commits(Map args){
    options = ''
    if (args.BRANCH != null){ options += ' --branch "' + args.BRANCH + '"'; }
    if (args.REPO_SSH_URL != null){ options += ' --repo_ssh_url "' + args.REPO_SSH_URL + '"'; }
    if (args.COMPONENT_COMMITS != null){ options += ' --component_commits "' + args.COMPONENT_COMMITS + '"'; }
    options += ' --parent_job_commitSHA1 "${GIT_COMMIT}" --parent_job_component_commits "${COMPONENT_COMMITS}"'
    print_submodule_commits_CMD = './ci/ci-tools/scripts/jenkins_scripts.py print_submodule_commits' + options + ' ' + args.JOB_NAME
    
    def child_submodule_commits
    try {
        child_submodule_commits = sh(script: print_submodule_commits_CMD, returnStdout: true)
    }
    catch (Exception ex) {
        echo "Using unmatchable SUBMODULE_COMMITS for child job " + args.JOB_NAME + " as an error occurred while computing them: ${ex}"
        child_submodule_commits = '{ "unmatchable" : "submodule_commits" }'
    }
    echo "Computed submodule_commits for " + args.JOB_NAME + ": " + child_submodule_commits
    return child_submodule_commits
}

pipeline {
  parameters {
    string(name: 'BRANCH', defaultValue: '$gitlabSourceBranch', description: 'Branch name to checkout')
    string(name: 'REPO_SSH_URL', defaultValue: 'git@gitlab.esperanto.ai:software/et-common-libs.git', description: 'Repository URL')
    string(name: 'REPO_NAME', defaultValue: 'et-common-libs', description: 'Repository name')
    string(name: 'GITLAB_SOURCE_BRANCH', defaultValue: '', description: 'Name of the branch in Gitlab that triggered the current MR')
    string(name: 'GITLAB_TARGET_BRANCH', defaultValue: '', description: 'Target branch where the current branch will be merged')
    string(name: 'GITLAB_MR_ID', defaultValue: '', description: 'Identifier of the Gitlab MR that triggered the pipeline')
    string(name: 'COMPONENT_COMMITS', defaultValue: '', description: 'List of submodule-paths and their commits to checkout as part of the build. The formath is <SUBMODULE_PATH_1>:<COMMIT_1>,<SUBMODULE_PATH_2>:<COMMIT_2>')
    string(name: 'NODE', defaultValue: 'DISPATCHER', description: 'Node label where the job should run')
    string(name: 'TIMEOUT', defaultValue: '23', description: 'Timeout (in hours)')
    booleanParam(name: 'HARD_CLEAN', defaultValue: 'true', description: 'If set to 1, removes all the workspace at the end of the regression')
    booleanParam(name: 'EMAIL_CI_AUTHORS', defaultValue: 'true', description: 'This will enable email notifications on CI jobs back to the Authors of the Change. This will include all authors of a given change set.')
    string(name: 'EMAIL_CI_EXTRAS', defaultValue: '', description: 'Manually add this comma seperated list of email addresses to the recipients for a CI job')
    booleanParam(name: 'EMAIL_NIGHTLY_TEAM', defaultValue: 'false', description: 'Generates an email notification when a pipeline completes for Nightlies and regressions run against the branch specified by parameter EMAIL_NIGHTLY_BRANCH.')
    string(name: 'EMAIL_NIGHTLY_BRANCH', defaultValue: 'master', description: 'This specifies the branch that runs regressions and if EMAIL_NIGHTLY_TEAM is enabled emails will be sent to EMAIL_NIGHTLY_RECIPIENTS when the branch name matches this parameter.')
    string(name: 'EMAIL_NIGHTLY_RECIPIENTS', defaultValue: 'et-sw-infra@esperantotech.com', description: 'Comma seperated list of email recipients for a given project')
    string(name: 'CRON_STRING', defaultValue: '', description: 'Cron string to cause a job to execute automatically, Syntax is normal cron with %param_name=value at the end.  Additional details can be found at: https://plugins.jenkins.io/parameterized-scheduler/')
    string(name: 'RUN_ID', defaultValue: '1/1', description: '<job_id>/<total_jobs> In case this pipeline was triggered multiple time from its top-level pipeline by using the `njobs` attribute, this parameter indicates which id has the current build')
    booleanParam(name: 'FORCE_CHILD_RETRIGGER', defaultValue: 'true', description: 'Forces all child jobs of the current job to retrigger even if smart-retrigger is being used')
    string(name: 'SUBMODULE_COMMITS', defaultValue: '{ "default" : "value" }', description: 'json format dictionary containing the submodule commits (in SHA1 hash form) of COMPONENT_COMMITS that a build will use. Automatically filled by the parent job of a build when using smart-retrigger.')
    booleanParam(name: 'CHECK_ON_TOP_OF_MASTER', defaultValue: 'true', description: 'when true this executes checks that ensures Merge Request has merged origin/master with their MR at the time the MR was submiteted')
    booleanParam(name: 'CANCEL_OUTDATED_MR_CI', defaultValue: 'true', description: 'Whether to, if the pipeline has been triggered by a MR, cancel the previous pipeline (if it is still running) that was triggered by the same MR.')
    string(name: 'SW_PLATFORM_BRANCH', defaultValue: 'origin/develop/system-sw', description: 'SW-Platform branch to track')
    booleanParam(name: 'RUN_ZEBU', defaultValue: 'true', description: 'Run Zebu Job')
    string(name: 'INPUT_TAGS', defaultValue: '', description: 'Parameter to receive tags from parent pipelines')
  }
  agent {
    label "${params.NODE}"
  }
  options {
    buildDiscarder(logRotator(daysToKeepStr: '15', artifactDaysToKeepStr: '15'))
    gitLabConnection('Gitlab')
    timestamps()
    skipDefaultCheckout(true)
    ansiColor('xterm')
  }
  triggers {
    gitlab(triggerOnMergeRequest: true, branchFilterType: 'All')
    parameterizedCron( env.CRON_STRING )
  }
  environment {
    JOB_IDENTIFICATION_PARAMETERS = "{\"RUN_ID\": \"${RUN_ID}\", \"COMPONENT_COMMITS\": \"${COMPONENT_COMMITS}\"}"
    PIPELINE_TAGS = "${INPUT_TAGS},"
  }
  stages {
    stage('WRAPPER') {
      options {
        timeout(time: "${params.TIMEOUT}", unit: "HOURS")
      }
      stages {
        stage('CHECKOUT_SCM') {
          steps {
            updateGitlabCommitStatus name: JOB_NAME, state: 'pending'
            script {
              def seconds = -1
              retry(8) {
                seconds = seconds * 2 + 2
                sleep(time: seconds, unit: "SECONDS")
                scm_variables = checkout([
                  $class: 'GitSCM',
                  branches: [[name: BRANCH]],
                  doGenerateSubmoduleConfigurations: false,
                  extensions: [],
                  submoduleCfg: [],
                  userRemoteConfigs: [[
                    credentialsId: 'aws_private_key',
                    url: "${REPO_SSH_URL}"
                  ]]
                ])
                env.GIT_COMMIT = scm_variables.get('GIT_COMMIT')
              }
            }
          }
        }
        stage('INIT_UTILS') {
          steps {
            script {
              if (fileExists('./ci/ci-tools')){
                sh 'git submodule update --init ci/ci-tools'
              }
            }
          }
        }
        stage('PARALLEL0') {
          parallel {
            stage('CANCEL_OUTDATED_MR_CI') {
              when {
                expression {
                  return sh(returnStatus: true, script: "${CANCEL_OUTDATED_MR_CI}") == 0
                }
              }
              steps {
                script {
                  if ( env.gitlabMergeRequestId != null){
                    sh(returnStatus: true, script: './ci/ci-tools/scripts/jenkins_scripts.py cancel_previous_CI_of_Merge_Request "${JOB_NAME}" "${gitlabMergeRequestIid}" "${BUILD_ID}"')
                  }
                }
              }
            }
            stage('CHECK_MERGE_UP_TO_DATE') {
              when {
                expression {
                  return sh(returnStatus: true, script: "${CHECK_ON_TOP_OF_MASTER}") == 0
                }
              }
              steps {
                sh 'if [ ! -z \"${gitlabTargetBranch}\" ] ; then git fetch && git merge origin/$gitlabTargetBranch | grep Already && ( echo \"Branch is up to date with target branch proceeding...\" && exit 0 ) || ( echo \"Merge request is out of date with respect to target branch. Please, rebase it and re-submit merge request\" && exit 1 ); else echo \"Skipping branch up to date check as environment variable gitlabTargetBranch is not defined!\" ; fi'
              }
            }
          }
        }
        stage('DSL_JOB') {
          steps {
            script {
              if (need_to_retrigger(BRANCH: "${BRANCH}", REPO_SSH_URL: "${REPO_SSH_URL}", JOB_NAME: 'meta-job')) {
                script {
                  def child_submodule_commits = get_child_submodule_commits(BRANCH: "${BRANCH}", REPO_SSH_URL: "${REPO_SSH_URL}", JOB_NAME: 'meta-job')
                  build job:
                    'meta-job',
                    propagate: true,
                    parameters: [
                      string(name: 'BRANCH', value: "${BRANCH}"),
                      string(name: 'REPO_SSH_URL', value: "${REPO_SSH_URL}"),
                      string(name: 'REPO_NAME', value: "${REPO_NAME}"),
                      booleanParam(name: "FORCE_CHILD_RETRIGGER", value: "${FORCE_CHILD_RETRIGGER}"),
                      string(name: "SUBMODULE_COMMITS", value: child_submodule_commits),
                      string(name: 'INPUT_TAGS', value: "${env.PIPELINE_TAGS}")
                    ]
                }
              }
            }
          }
        }
        stage('CHECK_IN') {
          steps {
            script {
              if (need_to_retrigger(BRANCH: "${SW_PLATFORM_BRANCH}", JOB_NAME: 'sw-platform/system-sw-integration/pipelines/device-firmware-checkin-tests', COMPONENT_COMMITS: "${COMPONENT_COMMITS},device-software/et-common-libs:${BRANCH}")) {
                script {
                  def child_submodule_commits = get_child_submodule_commits(BRANCH: "${SW_PLATFORM_BRANCH}", COMPONENT_COMMITS: "${COMPONENT_COMMITS},device-software/et-common-libs:${BRANCH}", JOB_NAME: 'sw-platform/system-sw-integration/pipelines/device-firmware-checkin-tests')
                  build job:
                    'sw-platform/system-sw-integration/pipelines/device-firmware-checkin-tests',
                    propagate: true,
                    parameters: [
                      string(name: 'BRANCH', value: "${SW_PLATFORM_BRANCH}"),
                      string(name: 'COMPONENT_COMMITS', value: "${COMPONENT_COMMITS},device-software/et-common-libs:${BRANCH}"),
                      booleanParam(name: "FORCE_CHILD_RETRIGGER", value: "${FORCE_CHILD_RETRIGGER}"),
                      string(name: "SUBMODULE_COMMITS", value: child_submodule_commits),
                      string(name: 'INPUT_TAGS', value: "${env.PIPELINE_TAGS}")
                    ]
                }
              }
            }
          }
        }
        stage('PARALLEL1') {
          parallel {
            stage('FIRMWARE_AND_DM_TESTS_PCIE_SYSEMU') {
              steps {
                script {
                  if (need_to_retrigger(BRANCH: "${SW_PLATFORM_BRANCH}", JOB_NAME: 'sw-platform/virtual-platform/pipelines/firmware-and-dm-tests-pcie-sysemu-1dev', COMPONENT_COMMITS: "${COMPONENT_COMMITS},device-software/et-common-libs:${BRANCH}")) {
                    script {
                      def child_submodule_commits = get_child_submodule_commits(BRANCH: "${SW_PLATFORM_BRANCH}", COMPONENT_COMMITS: "${COMPONENT_COMMITS},device-software/et-common-libs:${BRANCH}", JOB_NAME: 'sw-platform/virtual-platform/pipelines/firmware-and-dm-tests-pcie-sysemu-1dev')
                      build job:
                        'sw-platform/virtual-platform/pipelines/firmware-and-dm-tests-pcie-sysemu-1dev',
                        propagate: true,
                        parameters: [
                          string(name: 'BRANCH', value: "${SW_PLATFORM_BRANCH}"),
                          string(name: 'COMPONENT_COMMITS', value: "${COMPONENT_COMMITS},device-software/et-common-libs:${BRANCH}"),
                          booleanParam(name: "FORCE_CHILD_RETRIGGER", value: "${FORCE_CHILD_RETRIGGER}"),
                          string(name: "SUBMODULE_COMMITS", value: child_submodule_commits),
                          string(name: 'INPUT_TAGS', value: "${env.PIPELINE_TAGS}")
                        ]
                    }
                  }
                }
              }
            }
            stage('FIRMWARE_TESTS_ZEBU_BEMU') {
              steps {
                script {
                  if (need_to_retrigger(BRANCH: "${SW_PLATFORM_BRANCH}", JOB_NAME: 'sw-platform/system-sw-integration/pipelines/firmware-tests-zebu-bemu', COMPONENT_COMMITS: "${COMPONENT_COMMITS},device-software/et-common-libs:${BRANCH}")) {
                    script {
                      def child_submodule_commits = get_child_submodule_commits(BRANCH: "${SW_PLATFORM_BRANCH}", COMPONENT_COMMITS: "${COMPONENT_COMMITS},device-software/et-common-libs:${BRANCH}", JOB_NAME: 'sw-platform/system-sw-integration/pipelines/firmware-tests-zebu-bemu')
                      build job:
                        'sw-platform/system-sw-integration/pipelines/firmware-tests-zebu-bemu',
                        propagate: true,
                        parameters: [
                          string(name: 'BRANCH', value: "${SW_PLATFORM_BRANCH}"),
                          string(name: 'COMPONENT_COMMITS', value: "${COMPONENT_COMMITS},device-software/et-common-libs:${BRANCH}"),
                          booleanParam(name: "FORCE_CHILD_RETRIGGER", value: "${FORCE_CHILD_RETRIGGER}"),
                          string(name: "SUBMODULE_COMMITS", value: child_submodule_commits),
                          string(name: 'INPUT_TAGS', value: "${env.PIPELINE_TAGS}")
                        ]
                    }
                  }
                }
              }
            }
            stage('JOB_RUNTIME') {
              steps {
                script {
                  if (need_to_retrigger(BRANCH: "${SW_PLATFORM_BRANCH}", JOB_NAME: 'sw-platform/runtime-integration/pipelines/runtime-checkin-tests-release', COMPONENT_COMMITS: "${COMPONENT_COMMITS},device-software/et-common-libs:${BRANCH}")) {
                    script {
                      def child_submodule_commits = get_child_submodule_commits(BRANCH: "${SW_PLATFORM_BRANCH}", COMPONENT_COMMITS: "${COMPONENT_COMMITS},device-software/et-common-libs:${BRANCH}", JOB_NAME: 'sw-platform/runtime-integration/pipelines/runtime-checkin-tests-release')
                      build job:
                        'sw-platform/runtime-integration/pipelines/runtime-checkin-tests-release',
                        propagate: true,
                        parameters: [
                          string(name: 'BRANCH', value: "${SW_PLATFORM_BRANCH}"),
                          string(name: 'COMPONENT_COMMITS', value: "${COMPONENT_COMMITS},device-software/et-common-libs:${BRANCH}"),
                          booleanParam(name: "FORCE_CHILD_RETRIGGER", value: "${FORCE_CHILD_RETRIGGER}"),
                          string(name: "SUBMODULE_COMMITS", value: child_submodule_commits),
                          string(name: 'INPUT_TAGS', value: "${env.PIPELINE_TAGS}")
                        ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  post {
    always {
      timeout(time: 1, unit: 'HOURS') {
        sh 'echo \"Sending metrics to InfluxDB\"'
        script {
           influxDbPublisher(selectedTarget: 'Influxdb-general-metrics')
        }
      }
    }
    success {
      timeout(time: 1, unit: 'HOURS') {
        updateGitlabCommitStatus name: JOB_NAME, state: 'success'
        script {
            if (env.EMAIL_CI_AUTHORS == 'true') {
              if (env.gitlabUserName) {
                emailext(subject: "PASSING CI Branch ${env.BRANCH} Job '${env.JOB_NAME}' (${env.BUILD_NUMBER})",
                    body: "  <p><font size='6' color='green'> CI PIPELINE SUCCEEDED :-)</font></p> \
                             <p> Build at <a href='${BUILD_URL}'>${JOB_NAME} [${BUILD_NUMBER}]</a></p> \
                             <p> Check console output at <a href='${BUILD_URL}consoleText'>${JOB_NAME} [${BUILD_NUMBER}]</a></p> \
                             <p> CI Pipeline Trigered by ${env.gitlabUserName}<${env.gitlabUserEmail}> into Repository <a href=\"${gitlabSourceRepoHomepage}\">${gitlabSourceRepoName}</a> </p> \
                             <p> Source Branch=<a href=\"${gitlabSourceRepoHomepage}/-/tree/${env.gitlabSourceBranch}\">${env.gitlabSourceBranch}</a> ->  \
                             Target Branch=<a href=\"${gitlabSourceRepoHomepage}/-/tree/${env.gitlabTargetBranch}\">${env.gitlabTargetBranch} </a> </p> \
                             <p> Merge Request=${gitlabSourceRepoHomepage}/-/merge_requests/${env.gitlabMergeRequestIid} </p>    \
                    ",
                    mimeType: 'text/html',
                    recipientProviders: [[$class:'UpstreamComitterRecipientProvider']],
                    to: env.gitlabUserEmail
                )
              } else {
                emailext(subject: "PASSING CI Branch ${env.BRANCH} Job '${env.JOB_NAME}' (${env.BUILD_NUMBER})",
                    body: "  <p><font size='6' color='green'> CI PIPELINE SUCCEEDED :-)</font></p> \
                             <p> Build at <a href='${BUILD_URL}'>${JOB_NAME} [${BUILD_NUMBER}]</a></p> \
                             <p> Check console output at <a href='${BUILD_URL}consoleText'>${JOB_NAME} [${BUILD_NUMBER}]</a></p> \
                    ",
                    mimeType: 'text/html',
                    recipientProviders: [[$class:'UpstreamComitterRecipientProvider']],
                    to: env.EMAIL_CI_EXTRAS
                )
              }
            }
            if (env.EMAIL_NIGHTLY_TEAM == 'true') {
              if (env.BRANCH == env.EMAIL_NIGHTLY_BRANCH) {
                emailext(subject: "PASSING NIGHTLY Job '${env.JOB_NAME}' (${env.BUILD_NUMBER})",
                    body: '''<p><font size="6" color="green"> NIGHTLY PIPELINE SUCCEEDED :-)</font></p>
                        <p> Build at <a href='${BUILD_URL}'>${JOB_NAME} [${BUILD_NUMBER}]</a></p>
                        <p> Check console output at <a href='${BUILD_URL}consoleText'>${JOB_NAME} [${BUILD_NUMBER}]</a></p>''',
                    mimeType: 'text/html',
                    to: env.EMAIL_NIGHTLY_RECIPIENTS
                )
              }
            }
        }
      }
    }
    failure {
      timeout(time: 1, unit: 'HOURS') {
        updateGitlabCommitStatus name: JOB_NAME, state: 'failed'
        script {
            if (env.EMAIL_CI_AUTHORS == 'true') {
              if (env.gitlabUserName) {
                emailext(subject: "FAILING CI Branch ${env.BRANCH} Job '${env.JOB_NAME}' (${env.BUILD_NUMBER})",
                    body: "  <p><font size='6' color='red'> CI PIPELINE FAILED :-(</font></p> \
                             <p> Build at <a href='${BUILD_URL}'>${JOB_NAME} [${BUILD_NUMBER}]</a></p> \
                             <p> Check console output at <a href='${BUILD_URL}consoleText'>${JOB_NAME} [${BUILD_NUMBER}]</a></p> \
                             <p> CI Pipeline Trigered by ${env.gitlabUserName}<${env.gitlabUserEmail}> into Repository <a href=\"${gitlabSourceRepoHomepage}\">${gitlabSourceRepoName}</a> </p> \
                             <p> Source Branch=<a href=\"${gitlabSourceRepoHomepage}/-/tree/${env.gitlabSourceBranch}\">${env.gitlabSourceBranch}</a> ->  \
                             Target Branch=<a href=\"${gitlabSourceRepoHomepage}/-/tree/${env.gitlabTargetBranch}\">${env.gitlabTargetBranch} </a> </p> \
                             <p> Merge Request=${gitlabSourceRepoHomepage}/-/merge_requests/${env.gitlabMergeRequestIid} </p>    \
                    ",
                    mimeType: 'text/html',
                    recipientProviders: [[$class:'UpstreamComitterRecipientProvider']],
                    to: env.gitlabUserEmail
                )
              } else {
                emailext(subject: "FAILING CI Branch ${env.BRANCH} Job '${env.JOB_NAME}' (${env.BUILD_NUMBER})",
                    body: "  <p><font size='6' color='red'> CI PIPELINE FAILED :-(</font></p> \
                             <p> Build at <a href='${BUILD_URL}'>${JOB_NAME} [${BUILD_NUMBER}]</a></p> \
                             <p> Check console output at <a href='${BUILD_URL}consoleText'>${JOB_NAME} [${BUILD_NUMBER}]</a></p> \
                    ",
                    mimeType: 'text/html',
                    recipientProviders: [[$class:'UpstreamComitterRecipientProvider']],
                    to: env.EMAIL_CI_EXTRAS
                )
              }
            }
            if (env.EMAIL_NIGHTLY_TEAM == 'true') {
              if (env.BRANCH == env.EMAIL_NIGHTLY_BRANCH) {
                emailext(subject: "FAILING NIGHTLY Job '${env.JOB_NAME}' (${env.BUILD_NUMBER})",
                    body: '''<p><font size="6" color="red"> NIGHTLY PIPELINE FAILED :-(</font></p>
                        <p> Build at <a href='${BUILD_URL}'>${JOB_NAME} [${BUILD_NUMBER}]</a></p>
                        <p> Check console output at <a href='${BUILD_URL}consoleText'>${JOB_NAME} [${BUILD_NUMBER}]</a></p>''',
                    mimeType: 'text/html',
                    to: env.EMAIL_NIGHTLY_RECIPIENTS
                )
              }
            }
        }
      }
    }
    aborted {
      timeout(time: 1, unit: 'HOURS') {
        updateGitlabCommitStatus name: JOB_NAME, state: 'canceled'
        script {
            if (env.EMAIL_CI_AUTHORS == 'true') {
              if (env.gitlabUserName) {
                emailext(subject: "ABORTED CI Branch ${env.BRANCH} Job '${env.JOB_NAME}' (${env.BUILD_NUMBER})",
                    body: "  <p><font size='6' color='red'> CI PIPELINE ABORTED :-(</font></p> \
                             <p> Build at <a href='${BUILD_URL}'>${JOB_NAME} [${BUILD_NUMBER}]</a></p> \
                             <p> Check console output at <a href='${BUILD_URL}consoleText'>${JOB_NAME} [${BUILD_NUMBER}]</a></p> \
                             <p> CI Pipeline Trigered by ${env.gitlabUserName}<${env.gitlabUserEmail}> into Repository <a href=\"${gitlabSourceRepoHomepage}\">${gitlabSourceRepoName}</a> </p> \
                             <p> Source Branch=<a href=\"${gitlabSourceRepoHomepage}/-/tree/${env.gitlabSourceBranch}\">${env.gitlabSourceBranch}</a> ->  \
                             Target Branch=<a href=\"${gitlabSourceRepoHomepage}/-/tree/${env.gitlabTargetBranch}\">${env.gitlabTargetBranch} </a> </p> \
                             <p> Merge Request=${gitlabSourceRepoHomepage}/-/merge_requests/${env.gitlabMergeRequestIid} </p>    \
                    ",
                    mimeType: 'text/html',
                    recipientProviders: [[$class:'UpstreamComitterRecipientProvider']],
                    to: env.gitlabUserEmail
                )
              } else {
                emailext(subject: "ABORTED CI Branch ${env.BRANCH} Job '${env.JOB_NAME}' (${env.BUILD_NUMBER})",
                    body: "  <p><font size='6' color='red'> CI PIPELINE ABORTED :-(</font></p> \
                             <p> Build at <a href='${BUILD_URL}'>${JOB_NAME} [${BUILD_NUMBER}]</a></p> \
                             <p> Check console output at <a href='${BUILD_URL}consoleText'>${JOB_NAME} [${BUILD_NUMBER}]</a></p> \
                    ",
                    mimeType: 'text/html',
                    recipientProviders: [[$class:'UpstreamComitterRecipientProvider']],
                    to: env.EMAIL_CI_EXTRAS
                )
              }
            }
            if (env.EMAIL_NIGHTLY_TEAM == 'true') {
              if (env.BRANCH == env.EMAIL_NIGHTLY_BRANCH) {
                emailext(subject: "ABORTED NIGHTLY Job '${env.JOB_NAME}' (${env.BUILD_NUMBER})",
                    body: '''<p><font size="6" color="red"> NIGHTLY PIPELINE ABORTED :-(</font></p>
                        <p> Build at <a href='${BUILD_URL}'>${JOB_NAME} [${BUILD_NUMBER}]</a></p>
                        <p> Check console output at <a href='${BUILD_URL}consoleText'>${JOB_NAME} [${BUILD_NUMBER}]</a></p>''',
                    mimeType: 'text/html',
                    to: env.EMAIL_NIGHTLY_RECIPIENTS
                )
              }
            }
        }
      }
    }
    cleanup {
      timeout(time: 1, unit: 'HOURS') {
        sh 'for pid in $(lsof +D . 2> /dev/null | grep .nfs | awk \"{print $2}\" ); do kill -9 $pid; done'
        sh "if [ ${HARD_CLEAN} = true ]; then rm -rf * && rm -rf .[^.]*; fi"
      }
    }
  }
}