import yaml
import random
import argparse

with open('table_config.yml', 'r') as lookup_table:
    instruction_table = yaml.safe_load(lookup_table)

parser = argparse.ArgumentParser(description='Generate random RISC-V instructions.')
parser.add_argument('-c', '--count', default=1)      # number of instructions 
args = parser.parse_args()


"""
Args: 
insn_count - the number of instructions we want to generate for this category
Write to file - this is an optional argument to write the sequence to a C file

Returns
instruction_list - list of strings(instructions)

This function retrieves the instructions from the global RISC V green book/look up table. It then constructs a template string that we will populate with the instruction operator and its associated operands. It will repeat this for the number of instructions we want to generate as specified. It will return a list of instruction strings that would be written to our instruction sequence which will be used to test SW simulator (SysEMU).
"""
def generate_insn(insn_count, category, include_c_code=True):
    instruction_set = instruction_table[category]
    operators = list(instruction_set.keys())
    instruction_list = []

    for count in range(insn_count):
        random_operator = random.choice(operators)
        instruction_string = ''

        if include_c_code:
            instruction_string += 'asm volatile("' + random_operator + ' '
        else:
            instruction_string += random_operator + ' '

        operand_count = len(instruction_set[random_operator])
        op_list = []

        # Create Template String
        for count in range(operand_count):
            if count == operand_count - 1:
                if include_c_code:
                    instruction_string += '{}");'
                else:
                    instruction_string += '{}'
            else:
                instruction_string += '{}, '

        # Match operands from lookup and populate with values
        for operand in instruction_set[random_operator]:
            if operand == 'rs1' or operand == 'rs2' or operand == 'rd':
                op_list.append(random.choice(instruction_table['registers']))
            elif operand == 'imm':
                op_list.append(random.randrange(0, 1500))
            elif operand == 'offset':
                op_list.append(random.choice(instruction_table['offsets']))

        instruction_list.append(instruction_string.format(*op_list))

    instruction_list.insert(0, category.upper())
    return instruction_list

"""
Args: 
instruction_groups_list - a list storing list(s) of instruction strings

This function writes our generate instruction sequence strings to a C file named
generated_inst_seq.c. Note that it will rewrite the contents each time.

Example usage:
  instruction_groups_list is the list of instruction sequences generated by generate_insn function
  Pass the generated instruction list to the write_to_test_file_C function to write to "generated_inst_seq.c" file.
  For example:
  instruction_groups_list = [generate_insn(5, 'example_category', include_c_code=True), generate_insn(5, 'another_category', include_c_code=True)]
  write_to_test_file_C(instruction_groups_list)
"""
def write_to_test_file_C(instruction_groups_list):
    with open("generated_inst_seq.c", "w") as test_file:
        test_file.write('#include "macros.h"\n\n')
        test_file.write('int main() {\n')

        for instruction_list in instruction_groups_list:
            category_comment = '/* {} */\n'.format(instruction_list[0])
            test_file.write(category_comment)
            
            for insn in instruction_list[1:]:
                indented_insn = '\t' + insn + '\n'
                test_file.write(indented_insn)

        test_file.write('}')


if __name__ == "__main__":
    # Create an empty list to store instruction groups
    instruction_groups_list = []

    # Get the total instruction count from command-line arguments (assuming 'args' is defined)
    total_insn = args.count

    # Generate instruction sequences for different instruction categories

    # RV64I
    # Base integer instructions
    instruction_groups_list.append(generate_insn(int(total_insn), 'rv64i'))

    # RV64M
    #Integer multiplication and division instructions.
    instruction_groups_list.append(generate_insn(int(total_insn), 'rv64m'))

    # RV64A
    #Atomic instructions for atomic memory operations.

    #RV64F
    #Single-precision floating-point instructions.

    #RV64D
    #Double-precision floating-point instructions.

    #RV64C
    #Compressed instructions for reduced code size.

    #RV64G
    #General extension that includes RV64I and the standard extensions (M, A, F, D, C).

    #RV64IM
    #Integer base and integer multiplication/division extension.

    #RV64GC
    #General extension with compressed instructions.

    #RV64GC_F
    #General extension with compressed and single-precision floating-point instructions.

    #RV64GC_D
    #General extension with compressed and double-precision floating-point instructions.

    # Write the generated instruction sequences to "generated_inst_seq.c" file
    write_to_test_file_C(instruction_groups_list)
