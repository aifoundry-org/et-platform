\hypertarget{classrt_1_1IRuntime}{}\doxysection{rt\+::I\+Runtime Class Reference}
\label{classrt_1_1IRuntime}\index{rt::IRuntime@{rt::IRuntime}}


Facade Runtime interface declaration, all runtime interactions should be made using this interface. There is a static method \mbox{\hyperlink{classrt_1_1IRuntime_a2026e8a4e067c85cb82a52d60c2f7872}{create}} to make runtime instances (factory method)  




{\ttfamily \#include $<$I\+Runtime.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ Device\+Id $>$ \mbox{\hyperlink{classrt_1_1IRuntime_a0ccd044349fb81c6c94eafa28b977c95}{get\+Devices}} ()
\begin{DoxyCompactList}\small\item\em Returns all devices. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structrt_1_1DeviceProperties}{Device\+Properties}} \mbox{\hyperlink{classrt_1_1IRuntime_a44e1ef24b9d683cc0a51ef250fb8123e}{get\+Device\+Properties}} (Device\+Id device) const
\begin{DoxyCompactList}\small\item\em Returns the properties of a given device. \end{DoxyCompactList}\item 
std\+::byte $\ast$ \mbox{\hyperlink{classrt_1_1IRuntime_a40cded710ad5ed5b69107b2a72fadb2e}{malloc\+Device}} (Device\+Id device, size\+\_\+t size, uint32\+\_\+t alignment=k\+Cache\+Line\+Size)
\begin{DoxyCompactList}\small\item\em Allocates memory in the device, returns a device memory pointer. One can\textquotesingle{}t use this pointer directly from the host, this pointer is intended to be used for memory operations between the host and the device. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classrt_1_1IRuntime_a114f89ceff8d1154d389404c6ec57f39}{free\+Device}} (Device\+Id device, std\+::byte $\ast$buffer)
\begin{DoxyCompactList}\small\item\em Deallocates previously allocated memory on the given device. \end{DoxyCompactList}\item 
Stream\+Id \mbox{\hyperlink{classrt_1_1IRuntime_a0e3a36b976e629594a7ba6e82817505b}{create\+Stream}} (Device\+Id device)
\begin{DoxyCompactList}\small\item\em Creates a new stream and associates it to the given device. A stream is an abstraction of a \char`\"{}pipeline\char`\"{} where you can push operations (mem copies or kernel launches) and enforce the dependencies between these operations. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classrt_1_1IRuntime_ab5356f8b2d41f61c4d76706ec9704ee4}{destroy\+Stream}} (Stream\+Id stream)
\begin{DoxyCompactList}\small\item\em Destroys a previously created stream. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structrt_1_1LoadCodeResult}{Load\+Code\+Result}} \mbox{\hyperlink{classrt_1_1IRuntime_a3091bd0f4aa2efa99c93da9ea186226b}{load\+Code}} (Stream\+Id stream, const std\+::byte $\ast$elf, size\+\_\+t elf\+\_\+size)
\begin{DoxyCompactList}\small\item\em Loads an elf into the device. The caller will provide a byte code containing the elf representation and its size. Host memory. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classrt_1_1IRuntime_a160e7929d069773d59940e8b9e50dce6}{unload\+Code}} (Kernel\+Id kernel)
\begin{DoxyCompactList}\small\item\em Unloads a previously loaded elf code, identified by the kernel handler. \end{DoxyCompactList}\item 
Event\+Id \mbox{\hyperlink{classrt_1_1IRuntime_a5e95aab372520fc3d5e0de092562452f}{kernel\+Launch}} (Stream\+Id stream, Kernel\+Id kernel, const std\+::byte $\ast$kernel\+\_\+args, size\+\_\+t kernel\+\_\+args\+\_\+size, uint64\+\_\+t shire\+\_\+mask, bool barrier=true, bool flush\+L3=false, std\+::optional$<$ \mbox{\hyperlink{structrt_1_1UserTrace}{User\+Trace}} $>$ user\+Trace\+Config=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Queues a execution work into a stream. The work is identified by the kernel handler, which has been previously loaded into the device which is associated to the stream. The parameters of the kernel are given by kernel\+\_\+args and kernel\+\_\+args\+\_\+size; these parameters will be copied from the host memory to the device memory by the runtime. The firmware will load these parameters into RA register, the kernel code should cast this register to the expected types. The kernel execution is always asynchronous. \end{DoxyCompactList}\item 
Event\+Id \mbox{\hyperlink{classrt_1_1IRuntime_a7501a6f2e7959b283fd801ac6aeb0f8b}{memcpy\+Host\+To\+Device}} (Stream\+Id stream, const std\+::byte $\ast$h\+\_\+src, std\+::byte $\ast$d\+\_\+dst, size\+\_\+t size, bool barrier=false, const Cma\+Copy\+Function \&cma\+Copy\+Function=default\+Cma\+Copy\+Function)
\begin{DoxyCompactList}\small\item\em Queues a memcpy operation from host memory to device memory. The device memory must be previously allocated by a malloc\+Device. \end{DoxyCompactList}\item 
Event\+Id \mbox{\hyperlink{classrt_1_1IRuntime_a5f1038d3f71b63a7bd0d6f66c10647ff}{memcpy\+Device\+To\+Host}} (Stream\+Id stream, const std\+::byte $\ast$d\+\_\+src, std\+::byte $\ast$h\+\_\+dst, size\+\_\+t size, bool barrier=true, const Cma\+Copy\+Function \&cma\+Copy\+Function=default\+Cma\+Copy\+Function)
\begin{DoxyCompactList}\small\item\em Queues a memcpy operation from device memory to host memory. The device memory must be a valid region previously allocated by a malloc\+Device; the host memory must be a previously allocated memory in the host by the conventional means (for example the heap) \end{DoxyCompactList}\item 
Event\+Id \mbox{\hyperlink{classrt_1_1IRuntime_af018821132fe5309fb9e72e4e62bb25b}{memcpy\+Host\+To\+Device}} (Stream\+Id stream, \mbox{\hyperlink{structrt_1_1MemcpyList}{Memcpy\+List}} memcpy\+List, bool barrier=false, const Cma\+Copy\+Function \&cma\+Copy\+Function=default\+Cma\+Copy\+Function)
\begin{DoxyCompactList}\small\item\em Queues many memcpy operations from host memory to device memory. These operations are defined in struct \mbox{\hyperlink{structrt_1_1MemcpyList}{Memcpy\+List}}. The device memory must be a valid region previously allocated by a malloc\+Device; the host memory must be a previously allocated memory in the host by the conventional means (for example the heap). \end{DoxyCompactList}\item 
Event\+Id \mbox{\hyperlink{classrt_1_1IRuntime_ac473c3770b8cadafb406fe63534011b8}{memcpy\+Device\+To\+Host}} (Stream\+Id stream, \mbox{\hyperlink{structrt_1_1MemcpyList}{Memcpy\+List}} memcpy\+List, bool barrier=true, const Cma\+Copy\+Function \&cma\+Copy\+Function=default\+Cma\+Copy\+Function)
\begin{DoxyCompactList}\small\item\em Queues many memcpy operations from device memory to host memory. These operations are defined in struct \mbox{\hyperlink{structrt_1_1MemcpyList}{Memcpy\+List}}. The device memory must be a valid region previously allocated by a malloc\+Device; the host memory must be a previously allocated memory in the host by the conventional means (for example the heap). \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classrt_1_1IRuntime_a51538d6474b88062aba71ff8d8c959a2}{wait\+For\+Event}} (Event\+Id event, std\+::chrono\+::seconds timeout=std\+::chrono\+::hours(24))
\begin{DoxyCompactList}\small\item\em This will block the caller thread until the given event is dispatched or the timeout is reached. This primitive allows to synchronize with the device execution. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classrt_1_1IRuntime_a83b06e67256ef740f73b2019f78974f1}{wait\+For\+Stream}} (Stream\+Id stream, std\+::chrono\+::seconds timeout=std\+::chrono\+::hours(24))
\begin{DoxyCompactList}\small\item\em This will block the caller thread until all commands issued to the given stream finish or if the timeout is reached. This primitive allows to synchronize with the device execution. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{structrt_1_1StreamError}{Stream\+Error}} $>$ \mbox{\hyperlink{classrt_1_1IRuntime_a25b55dad27d716b53901b35399040ff8}{retrieve\+Stream\+Errors}} (Stream\+Id stream)
\begin{DoxyCompactList}\small\item\em This will return a list of errors and their execution context (if any) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classrt_1_1IRuntime_ae7d60310e5fc9b7807a964cbbaf50a2a}{set\+On\+Kernel\+Aborted\+Error\+Callback}} (const Kernel\+Aborted\+Callback \&callback)
\begin{DoxyCompactList}\small\item\em This callback (when set) will be automatically called when a kernel abort happens. This is implemented as a workaround (S\+W-\/13045). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classrt_1_1IRuntime_af5041e57ed0f533a32b1d12fa1bcf15d}{set\+On\+Stream\+Errors\+Callback}} (Stream\+Error\+Callback callback)
\begin{DoxyCompactList}\small\item\em This callback (when set) will be automatically called when a new \mbox{\hyperlink{structrt_1_1StreamError}{Stream\+Error}} occurs, making the polling through retrieve\+Stream\+Errors unnecessary. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrt_1_1IRuntime_aea977b0f35ff1a0e7d43b7cf5dc1303b}\label{classrt_1_1IRuntime_aea977b0f35ff1a0e7d43b7cf5dc1303b}} 
void \mbox{\hyperlink{classrt_1_1IRuntime_aea977b0f35ff1a0e7d43b7cf5dc1303b}{set\+Profiler}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classrt_1_1profiling_1_1IProfilerRecorder}{profiling\+::\+I\+Profiler\+Recorder}} $>$ profiler)
\begin{DoxyCompactList}\small\item\em Sets a profiler to be used by runtime. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classrt_1_1profiling_1_1IProfilerRecorder}{profiling\+::\+I\+Profiler\+Recorder}} $\ast$ \mbox{\hyperlink{classrt_1_1IRuntime_a145044ba3d9ed62b320a296b0e1f143c}{get\+Profiler}} () const
\begin{DoxyCompactList}\small\item\em Returns a pointer to the profiler interface; don\textquotesingle{}t delete/free this pointer since this is owned by the runtime itself. \end{DoxyCompactList}\item 
Event\+Id \mbox{\hyperlink{classrt_1_1IRuntime_a7cee724ef99f41ffc5830851f7633237}{abort\+Command}} (Event\+Id command\+Id, std\+::chrono\+::milliseconds timeout=std\+::chrono\+::milliseconds(5000))
\begin{DoxyCompactList}\small\item\em Instructs the device to abort given command. N\+O\+TE\+: as per current firmware implementation, aborting a command will have undesirable side effects on the rest of the submitted commands to the same virtual queue. So, after aborting a command it could potentially affect the rest of the executions B\+UG\+: individual memcpy\+Host\+To\+Device and memcpy\+Device\+To\+Host commands can not be aborted individually right now. The could be aborted through \mbox{\hyperlink{classrt_1_1IRuntime_aeb8243996204585371f98baedd98a9a2}{abort\+Stream}}. \end{DoxyCompactList}\item 
Event\+Id \mbox{\hyperlink{classrt_1_1IRuntime_aeb8243996204585371f98baedd98a9a2}{abort\+Stream}} (Stream\+Id stream\+Id)
\begin{DoxyCompactList}\small\item\em Instructs the device to abort all outstanding commands on a given stream. This will affect to all commands previously issued to given stream, later commands will execute normally. N\+O\+TE\+: as per current firmware implementation, aborting a command will have undesirable side effects on the rest of the submitted commands to the same virtual queue. So, after aborting a command it could potentially affect the rest of the executions. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structrt_1_1DmaInfo}{Dma\+Info}} \mbox{\hyperlink{classrt_1_1IRuntime_ab16570e7e5c31f16be7b377b14ace61b}{get\+Dma\+Info}} (Device\+Id device\+Id) const
\begin{DoxyCompactList}\small\item\em Returns the \mbox{\hyperlink{structrt_1_1DmaInfo}{Dma\+Info}} of given device (see \mbox{\hyperlink{structrt_1_1DmaInfo}{Dma\+Info}}). This \mbox{\hyperlink{structrt_1_1DmaInfo}{Dma\+Info}} contains max size for each operation in a memcpy list command and max number of operations allowed in a single memcpy list command. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrt_1_1IRuntime_ace5a0b9c8f1ffef2c946bf63c3323940}\label{classrt_1_1IRuntime_ace5a0b9c8f1ffef2c946bf63c3323940}} 
virtual \mbox{\hyperlink{classrt_1_1IRuntime_ace5a0b9c8f1ffef2c946bf63c3323940}{$\sim$\+I\+Runtime}} ()=default
\begin{DoxyCompactList}\small\item\em Virtual Destructor to enable polymorphic release of the runtime instances. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrt_1_1IRuntime_a32c12e62c1b46e2c1d6d899f8ca63969}\label{classrt_1_1IRuntime_a32c12e62c1b46e2c1d6d899f8ca63969}} 
\mbox{\hyperlink{classrt_1_1IRuntime_a32c12e62c1b46e2c1d6d899f8ca63969}{I\+Runtime}} ()
\begin{DoxyCompactList}\small\item\em Constructor to initialize with a dummy profiler. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static Runtime\+Ptr \mbox{\hyperlink{classrt_1_1IRuntime_a2026e8a4e067c85cb82a52d60c2f7872}{create}} (dev\+::\+I\+Device\+Layer $\ast$device\+Layer, \mbox{\hyperlink{structrt_1_1Options}{Options}} options=get\+Default\+Options())
\begin{DoxyCompactList}\small\item\em Factory method to instantiate a standalone \mbox{\hyperlink{classrt_1_1IRuntime}{I\+Runtime}} implementation. \end{DoxyCompactList}\item 
static Runtime\+Ptr \mbox{\hyperlink{classrt_1_1IRuntime_aae2a650983154b987478145777b7bb6b}{create}} (const std\+::string \&socket\+Path)
\begin{DoxyCompactList}\small\item\em Factory method to instantiate a client \mbox{\hyperlink{classrt_1_1IRuntime}{I\+Runtime}} implementation. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Facade Runtime interface declaration, all runtime interactions should be made using this interface. There is a static method \mbox{\hyperlink{classrt_1_1IRuntime_a2026e8a4e067c85cb82a52d60c2f7872}{create}} to make runtime instances (factory method) 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classrt_1_1IRuntime_a7cee724ef99f41ffc5830851f7633237}\label{classrt_1_1IRuntime_a7cee724ef99f41ffc5830851f7633237}} 
\index{rt::IRuntime@{rt::IRuntime}!abortCommand@{abortCommand}}
\index{abortCommand@{abortCommand}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{abortCommand()}{abortCommand()}}
{\footnotesize\ttfamily Event\+Id rt\+::\+I\+Runtime\+::abort\+Command (\begin{DoxyParamCaption}\item[{Event\+Id}]{command\+Id,  }\item[{std\+::chrono\+::milliseconds}]{timeout = {\ttfamily std\+:\+:chrono\+:\+:milliseconds(5000)} }\end{DoxyParamCaption})}



Instructs the device to abort given command. N\+O\+TE\+: as per current firmware implementation, aborting a command will have undesirable side effects on the rest of the submitted commands to the same virtual queue. So, after aborting a command it could potentially affect the rest of the executions B\+UG\+: individual memcpy\+Host\+To\+Device and memcpy\+Device\+To\+Host commands can not be aborted individually right now. The could be aborted through \mbox{\hyperlink{classrt_1_1IRuntime_aeb8243996204585371f98baedd98a9a2}{abort\+Stream}}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em command\+Id} & indicates the command\textquotesingle{}s event\+Id to abort \\
\hline
\mbox{\texttt{ in}}  & {\em timeout} & indicates the maximum time trying to Q\+U\+E\+UE an abort command into the device. If the timeout is reached and the runtime was not able to push the command into the device, an \mbox{\hyperlink{classrt_1_1Exception}{Exception}} will be thrown\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Event\+Id is a handler of the abort command itself which can be waited for (wait\+For\+Event\+Id) to synchronize. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_aeb8243996204585371f98baedd98a9a2}\label{classrt_1_1IRuntime_aeb8243996204585371f98baedd98a9a2}} 
\index{rt::IRuntime@{rt::IRuntime}!abortStream@{abortStream}}
\index{abortStream@{abortStream}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{abortStream()}{abortStream()}}
{\footnotesize\ttfamily Event\+Id rt\+::\+I\+Runtime\+::abort\+Stream (\begin{DoxyParamCaption}\item[{Stream\+Id}]{stream\+Id }\end{DoxyParamCaption})}



Instructs the device to abort all outstanding commands on a given stream. This will affect to all commands previously issued to given stream, later commands will execute normally. N\+O\+TE\+: as per current firmware implementation, aborting a command will have undesirable side effects on the rest of the submitted commands to the same virtual queue. So, after aborting a command it could potentially affect the rest of the executions. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em stream\+Id} & indicates the stream to abort commands\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Event\+Id is a handler of the abort\+Stream which can be waited for (wait\+For\+Event\+Id) to synchronize. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_aae2a650983154b987478145777b7bb6b}\label{classrt_1_1IRuntime_aae2a650983154b987478145777b7bb6b}} 
\index{rt::IRuntime@{rt::IRuntime}!create@{create}}
\index{create@{create}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{create()}{create()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static Runtime\+Ptr rt\+::\+I\+Runtime\+::create (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{socket\+Path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Factory method to instantiate a client \mbox{\hyperlink{classrt_1_1IRuntime}{I\+Runtime}} implementation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em socket\+Path} & indicates which socket the Client will connect to\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Runtime\+Ptr an \mbox{\hyperlink{classrt_1_1IRuntime}{I\+Runtime}} instance. See dev\+::\+I\+Device\+Layer 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_a2026e8a4e067c85cb82a52d60c2f7872}\label{classrt_1_1IRuntime_a2026e8a4e067c85cb82a52d60c2f7872}} 
\index{rt::IRuntime@{rt::IRuntime}!create@{create}}
\index{create@{create}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{create()}{create()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static Runtime\+Ptr rt\+::\+I\+Runtime\+::create (\begin{DoxyParamCaption}\item[{dev\+::\+I\+Device\+Layer $\ast$}]{device\+Layer,  }\item[{\mbox{\hyperlink{structrt_1_1Options}{Options}}}]{options = {\ttfamily getDefaultOptions()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Factory method to instantiate a standalone \mbox{\hyperlink{classrt_1_1IRuntime}{I\+Runtime}} implementation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em \mbox{\hyperlink{structrt_1_1Options}{Options}}} & can set some runtime parameters. See \mbox{\hyperlink{structrt_1_1Options}{Options}}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Runtime\+Ptr an \mbox{\hyperlink{classrt_1_1IRuntime}{I\+Runtime}} instance. See dev\+::\+I\+Device\+Layer 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_a0e3a36b976e629594a7ba6e82817505b}\label{classrt_1_1IRuntime_a0e3a36b976e629594a7ba6e82817505b}} 
\index{rt::IRuntime@{rt::IRuntime}!createStream@{createStream}}
\index{createStream@{createStream}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{createStream()}{createStream()}}
{\footnotesize\ttfamily Stream\+Id rt\+::\+I\+Runtime\+::create\+Stream (\begin{DoxyParamCaption}\item[{Device\+Id}]{device }\end{DoxyParamCaption})}



Creates a new stream and associates it to the given device. A stream is an abstraction of a \char`\"{}pipeline\char`\"{} where you can push operations (mem copies or kernel launches) and enforce the dependencies between these operations. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em device} & handler indicating in which device to associate the stream\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a stream handler 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_ab5356f8b2d41f61c4d76706ec9704ee4}\label{classrt_1_1IRuntime_ab5356f8b2d41f61c4d76706ec9704ee4}} 
\index{rt::IRuntime@{rt::IRuntime}!destroyStream@{destroyStream}}
\index{destroyStream@{destroyStream}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{destroyStream()}{destroyStream()}}
{\footnotesize\ttfamily void rt\+::\+I\+Runtime\+::destroy\+Stream (\begin{DoxyParamCaption}\item[{Stream\+Id}]{stream }\end{DoxyParamCaption})}



Destroys a previously created stream. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em stream} & handler to the stream to be destroyed \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classrt_1_1IRuntime_a114f89ceff8d1154d389404c6ec57f39}\label{classrt_1_1IRuntime_a114f89ceff8d1154d389404c6ec57f39}} 
\index{rt::IRuntime@{rt::IRuntime}!freeDevice@{freeDevice}}
\index{freeDevice@{freeDevice}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{freeDevice()}{freeDevice()}}
{\footnotesize\ttfamily void rt\+::\+I\+Runtime\+::free\+Device (\begin{DoxyParamCaption}\item[{Device\+Id}]{device,  }\item[{std\+::byte $\ast$}]{buffer }\end{DoxyParamCaption})}



Deallocates previously allocated memory on the given device. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em device} & handler indicating in which device to deallocate the memory \\
\hline
\mbox{\texttt{ in}}  & {\em buffer} & device memory pointer previously allocated with malloc\+Device to be deallocated \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classrt_1_1IRuntime_a44e1ef24b9d683cc0a51ef250fb8123e}\label{classrt_1_1IRuntime_a44e1ef24b9d683cc0a51ef250fb8123e}} 
\index{rt::IRuntime@{rt::IRuntime}!getDeviceProperties@{getDeviceProperties}}
\index{getDeviceProperties@{getDeviceProperties}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{getDeviceProperties()}{getDeviceProperties()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structrt_1_1DeviceProperties}{Device\+Properties}} rt\+::\+I\+Runtime\+::get\+Device\+Properties (\begin{DoxyParamCaption}\item[{Device\+Id}]{device }\end{DoxyParamCaption}) const}



Returns the properties of a given device. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em device} & handler indicating the device\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the properties for the requested device 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_a0ccd044349fb81c6c94eafa28b977c95}\label{classrt_1_1IRuntime_a0ccd044349fb81c6c94eafa28b977c95}} 
\index{rt::IRuntime@{rt::IRuntime}!getDevices@{getDevices}}
\index{getDevices@{getDevices}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{getDevices()}{getDevices()}}
{\footnotesize\ttfamily std\+::vector$<$Device\+Id$>$ rt\+::\+I\+Runtime\+::get\+Devices (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Returns all devices. 

\begin{DoxyReturn}{Returns}
a vector containing all device handlers 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_ab16570e7e5c31f16be7b377b14ace61b}\label{classrt_1_1IRuntime_ab16570e7e5c31f16be7b377b14ace61b}} 
\index{rt::IRuntime@{rt::IRuntime}!getDmaInfo@{getDmaInfo}}
\index{getDmaInfo@{getDmaInfo}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{getDmaInfo()}{getDmaInfo()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structrt_1_1DmaInfo}{Dma\+Info}} rt\+::\+I\+Runtime\+::get\+Dma\+Info (\begin{DoxyParamCaption}\item[{Device\+Id}]{device\+Id }\end{DoxyParamCaption}) const}



Returns the \mbox{\hyperlink{structrt_1_1DmaInfo}{Dma\+Info}} of given device (see \mbox{\hyperlink{structrt_1_1DmaInfo}{Dma\+Info}}). This \mbox{\hyperlink{structrt_1_1DmaInfo}{Dma\+Info}} contains max size for each operation in a memcpy list command and max number of operations allowed in a single memcpy list command. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em device\+Id} & indicates the device to get the D\+MA configuration from.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{structrt_1_1DmaInfo}{Dma\+Info}} contains max number of operations allowed in a single memcpy list command and max size for each operation. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_a145044ba3d9ed62b320a296b0e1f143c}\label{classrt_1_1IRuntime_a145044ba3d9ed62b320a296b0e1f143c}} 
\index{rt::IRuntime@{rt::IRuntime}!getProfiler@{getProfiler}}
\index{getProfiler@{getProfiler}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{getProfiler()}{getProfiler()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classrt_1_1profiling_1_1IProfilerRecorder}{profiling\+::\+I\+Profiler\+Recorder}}$\ast$ rt\+::\+I\+Runtime\+::get\+Profiler (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns a pointer to the profiler interface; don\textquotesingle{}t delete/free this pointer since this is owned by the runtime itself. 

\begin{DoxyReturn}{Returns}
I\+Profiler\+Recorder an interface to the profiler. See I\+Profiler\+Recorder 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_a5e95aab372520fc3d5e0de092562452f}\label{classrt_1_1IRuntime_a5e95aab372520fc3d5e0de092562452f}} 
\index{rt::IRuntime@{rt::IRuntime}!kernelLaunch@{kernelLaunch}}
\index{kernelLaunch@{kernelLaunch}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{kernelLaunch()}{kernelLaunch()}}
{\footnotesize\ttfamily Event\+Id rt\+::\+I\+Runtime\+::kernel\+Launch (\begin{DoxyParamCaption}\item[{Stream\+Id}]{stream,  }\item[{Kernel\+Id}]{kernel,  }\item[{const std\+::byte $\ast$}]{kernel\+\_\+args,  }\item[{size\+\_\+t}]{kernel\+\_\+args\+\_\+size,  }\item[{uint64\+\_\+t}]{shire\+\_\+mask,  }\item[{bool}]{barrier = {\ttfamily true},  }\item[{bool}]{flush\+L3 = {\ttfamily false},  }\item[{std\+::optional$<$ \mbox{\hyperlink{structrt_1_1UserTrace}{User\+Trace}} $>$}]{user\+Trace\+Config = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Queues a execution work into a stream. The work is identified by the kernel handler, which has been previously loaded into the device which is associated to the stream. The parameters of the kernel are given by kernel\+\_\+args and kernel\+\_\+args\+\_\+size; these parameters will be copied from the host memory to the device memory by the runtime. The firmware will load these parameters into RA register, the kernel code should cast this register to the expected types. The kernel execution is always asynchronous. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em stream} & handler indicating in which stream the kernel will be executed. The kernel code have to be registered into the device associated to the stream previously. \\
\hline
\mbox{\texttt{ in}}  & {\em kernel} & handler which indicate what code to execute in the device. \\
\hline
\mbox{\texttt{ in}}  & {\em kernel\+\_\+args} & buffer containing all the parameters to be copied to the device memory prior to the code execution \\
\hline
\mbox{\texttt{ in}}  & {\em kernel\+\_\+args\+\_\+size} & size of the kernel\+\_\+args buffer \\
\hline
\mbox{\texttt{ in}}  & {\em shire\+\_\+mask} & indicates in what shires the kernel will be executed \\
\hline
\mbox{\texttt{ in}}  & {\em barrier} & this parameter indicates if the kernel execution should be postponed till all previous works issued into this stream finish (a barrier). Usually the kernel launch must be postponed till some previous memory operations end, hence the default value is true. \\
\hline
\mbox{\texttt{ in}}  & {\em flush\+L3} & this parameter indicates if the L3 should be flushed before the kernel execution starts. \\
\hline
\mbox{\texttt{ in}}  & {\em user\+Trace\+Buffer} & this parameter can be null or point to a device buffer (previously allocated with \mbox{\hyperlink{classrt_1_1IRuntime_a40cded710ad5ed5b69107b2a72fadb2e}{malloc\+Device}}). If the pointer is not null, then the firmware will utilize this buffer to fill-\/up user trace data. This buffer must be of size 4KB $\ast$ num\+\_\+harts (4K\+B$\ast$2080). We will provide later on an A\+PI to allocate the buffer with the size required.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Event\+Id is a handler of an event which can be waited for (wait\+For\+Event\+Id) to syncrhonize when the kernel ends the execution. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_a3091bd0f4aa2efa99c93da9ea186226b}\label{classrt_1_1IRuntime_a3091bd0f4aa2efa99c93da9ea186226b}} 
\index{rt::IRuntime@{rt::IRuntime}!loadCode@{loadCode}}
\index{loadCode@{loadCode}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{loadCode()}{loadCode()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structrt_1_1LoadCodeResult}{Load\+Code\+Result}} rt\+::\+I\+Runtime\+::load\+Code (\begin{DoxyParamCaption}\item[{Stream\+Id}]{stream,  }\item[{const std\+::byte $\ast$}]{elf,  }\item[{size\+\_\+t}]{elf\+\_\+size }\end{DoxyParamCaption})}



Loads an elf into the device. The caller will provide a byte code containing the elf representation and its size. Host memory. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em stream} & handler indicating the stream used for the kernel loading. \\
\hline
\mbox{\texttt{ in}}  & {\em elf} & a pointer to host memory containing the elf bytes \\
\hline
\mbox{\texttt{ in}}  & {\em elf\+\_\+size} & the elf size\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a \mbox{\hyperlink{structrt_1_1LoadCodeResult}{Load\+Code\+Result}} with the Event\+Id to sync with (if needed), the kernel\+Id to utilize in later kernel\+Launch and the kernel load address.
\end{DoxyReturn}
N\+O\+TE\+: remember to not deallocate the elf memory
\begin{DoxyParams}{Parameters}
{\em elf} & until the Event\+Id from \mbox{\hyperlink{structrt_1_1LoadCodeResult}{Load\+Code\+Result}} is completed \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classrt_1_1IRuntime_a40cded710ad5ed5b69107b2a72fadb2e}\label{classrt_1_1IRuntime_a40cded710ad5ed5b69107b2a72fadb2e}} 
\index{rt::IRuntime@{rt::IRuntime}!mallocDevice@{mallocDevice}}
\index{mallocDevice@{mallocDevice}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{mallocDevice()}{mallocDevice()}}
{\footnotesize\ttfamily std\+::byte$\ast$ rt\+::\+I\+Runtime\+::malloc\+Device (\begin{DoxyParamCaption}\item[{Device\+Id}]{device,  }\item[{size\+\_\+t}]{size,  }\item[{uint32\+\_\+t}]{alignment = {\ttfamily kCacheLineSize} }\end{DoxyParamCaption})}



Allocates memory in the device, returns a device memory pointer. One can\textquotesingle{}t use this pointer directly from the host, this pointer is intended to be used for memory operations between the host and the device. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em device} & handler indicating in which device to allocate the memory \\
\hline
\mbox{\texttt{ in}}  & {\em size} & indicates the memory allocation size in bytes \\
\hline
\mbox{\texttt{ in}}  & {\em alignment} & indicates the required alignment for memory allocation, defaults to device cache line size\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a device memory pointer 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_a5f1038d3f71b63a7bd0d6f66c10647ff}\label{classrt_1_1IRuntime_a5f1038d3f71b63a7bd0d6f66c10647ff}} 
\index{rt::IRuntime@{rt::IRuntime}!memcpyDeviceToHost@{memcpyDeviceToHost}}
\index{memcpyDeviceToHost@{memcpyDeviceToHost}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{memcpyDeviceToHost()}{memcpyDeviceToHost()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily Event\+Id rt\+::\+I\+Runtime\+::memcpy\+Device\+To\+Host (\begin{DoxyParamCaption}\item[{Stream\+Id}]{stream,  }\item[{const std\+::byte $\ast$}]{d\+\_\+src,  }\item[{std\+::byte $\ast$}]{h\+\_\+dst,  }\item[{size\+\_\+t}]{size,  }\item[{bool}]{barrier = {\ttfamily true},  }\item[{const Cma\+Copy\+Function \&}]{cma\+Copy\+Function = {\ttfamily defaultCmaCopyFunction} }\end{DoxyParamCaption})}



Queues a memcpy operation from device memory to host memory. The device memory must be a valid region previously allocated by a malloc\+Device; the host memory must be a previously allocated memory in the host by the conventional means (for example the heap) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em stream} & handler indicating in which stream to queue the memcpy operation \\
\hline
\mbox{\texttt{ in}}  & {\em d\+\_\+src} & device memory buffer to copy from \\
\hline
\mbox{\texttt{ in}}  & {\em h\+\_\+dst} & host memory buffer to copy to \\
\hline
\mbox{\texttt{ in}}  & {\em size} & indicates the size of the memcpy \\
\hline
\mbox{\texttt{ in}}  & {\em barrier} & this parameter indicates if the memcpy operation should be postponed till all previous works issued into this stream finish (a barrier). Usually the memcpies from device to host must wait till a previous kernel execution finishes, hence the default value is true All memcpy operations are always asynchronous. \\
\hline
\mbox{\texttt{ in}}  & {\em cma\+Copy\+Function} & this parameter allows to customize the function used to copy from user-\/space virtual memory to the C\+MA buffer. Intended for internal usage, regular A\+PI user shouldn\textquotesingle{}t modify the default value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Event\+Id is a handler of an event which can be waited for (wait\+For\+Event\+Id) to synchronize when the memcpy ends.
\end{DoxyReturn}
N\+O\+TE\+: the host memory pointer must be kept alive until the operation has completely ended in device. \mbox{\Hypertarget{classrt_1_1IRuntime_ac473c3770b8cadafb406fe63534011b8}\label{classrt_1_1IRuntime_ac473c3770b8cadafb406fe63534011b8}} 
\index{rt::IRuntime@{rt::IRuntime}!memcpyDeviceToHost@{memcpyDeviceToHost}}
\index{memcpyDeviceToHost@{memcpyDeviceToHost}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{memcpyDeviceToHost()}{memcpyDeviceToHost()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Event\+Id rt\+::\+I\+Runtime\+::memcpy\+Device\+To\+Host (\begin{DoxyParamCaption}\item[{Stream\+Id}]{stream,  }\item[{\mbox{\hyperlink{structrt_1_1MemcpyList}{Memcpy\+List}}}]{memcpy\+List,  }\item[{bool}]{barrier = {\ttfamily true},  }\item[{const Cma\+Copy\+Function \&}]{cma\+Copy\+Function = {\ttfamily defaultCmaCopyFunction} }\end{DoxyParamCaption})}



Queues many memcpy operations from device memory to host memory. These operations are defined in struct \mbox{\hyperlink{structrt_1_1MemcpyList}{Memcpy\+List}}. The device memory must be a valid region previously allocated by a malloc\+Device; the host memory must be a previously allocated memory in the host by the conventional means (for example the heap). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em stream} & handler indicating in which stream to queue the memcpy operation \\
\hline
\mbox{\texttt{ in}}  & {\em memcpy\+List} & contains all the operations required. See \mbox{\hyperlink{structrt_1_1MemcpyList}{Memcpy\+List}} \\
\hline
\mbox{\texttt{ in}}  & {\em barrier} & this parameter indicates if the memcpy operation should be postponed till all previous works issued into this stream finish (a barrier). Usually the memcpies from device to host must wait till a previous kernel execution finishes, hence the default value is true All memcpy operations are always asynchronous. \\
\hline
\mbox{\texttt{ in}}  & {\em cma\+Copy\+Function} & this parameter allows to customize the function used to copy from user-\/space virtual memory to the C\+MA buffer. Intended for internal usage, regular A\+PI user shouldn\textquotesingle{}t modify the default value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Event\+Id is a handler of an event which can be waited for (wait\+For\+Event\+Id) to synchronize when the memcpy ends. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_a7501a6f2e7959b283fd801ac6aeb0f8b}\label{classrt_1_1IRuntime_a7501a6f2e7959b283fd801ac6aeb0f8b}} 
\index{rt::IRuntime@{rt::IRuntime}!memcpyHostToDevice@{memcpyHostToDevice}}
\index{memcpyHostToDevice@{memcpyHostToDevice}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{memcpyHostToDevice()}{memcpyHostToDevice()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily Event\+Id rt\+::\+I\+Runtime\+::memcpy\+Host\+To\+Device (\begin{DoxyParamCaption}\item[{Stream\+Id}]{stream,  }\item[{const std\+::byte $\ast$}]{h\+\_\+src,  }\item[{std\+::byte $\ast$}]{d\+\_\+dst,  }\item[{size\+\_\+t}]{size,  }\item[{bool}]{barrier = {\ttfamily false},  }\item[{const Cma\+Copy\+Function \&}]{cma\+Copy\+Function = {\ttfamily defaultCmaCopyFunction} }\end{DoxyParamCaption})}



Queues a memcpy operation from host memory to device memory. The device memory must be previously allocated by a malloc\+Device. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em stream} & handler indicating in which stream to queue the memcpy operation \\
\hline
\mbox{\texttt{ in}}  & {\em h\+\_\+src} & host memory buffer to copy from \\
\hline
\mbox{\texttt{ in}}  & {\em d\+\_\+dst} & device memory buffer to copy to \\
\hline
\mbox{\texttt{ in}}  & {\em size} & indicates the size of the memcpy \\
\hline
\mbox{\texttt{ in}}  & {\em barrier} & this parameter indicates if the memcpy operation should be postponed till all previous works issued into this stream finish (a barrier). Usually the memcpies from host to device can run in parallel, hence the default value is false All memcpy operations are always asynchronous. \\
\hline
\mbox{\texttt{ in}}  & {\em cma\+Copy\+Function} & this parameter allows to customize the function used to copy from user-\/space virtual memory to the C\+MA buffer. Intended for internal usage, regular A\+PI user shouldn\textquotesingle{}t modify the default value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Event\+Id is a handler of an event which can be waited for (wait\+For\+Event\+Id) to synchronize when the memcpy ends.
\end{DoxyReturn}
N\+O\+TE\+: the host memory pointer must be kept alive until the operation has completely ended in device. \mbox{\Hypertarget{classrt_1_1IRuntime_af018821132fe5309fb9e72e4e62bb25b}\label{classrt_1_1IRuntime_af018821132fe5309fb9e72e4e62bb25b}} 
\index{rt::IRuntime@{rt::IRuntime}!memcpyHostToDevice@{memcpyHostToDevice}}
\index{memcpyHostToDevice@{memcpyHostToDevice}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{memcpyHostToDevice()}{memcpyHostToDevice()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Event\+Id rt\+::\+I\+Runtime\+::memcpy\+Host\+To\+Device (\begin{DoxyParamCaption}\item[{Stream\+Id}]{stream,  }\item[{\mbox{\hyperlink{structrt_1_1MemcpyList}{Memcpy\+List}}}]{memcpy\+List,  }\item[{bool}]{barrier = {\ttfamily false},  }\item[{const Cma\+Copy\+Function \&}]{cma\+Copy\+Function = {\ttfamily defaultCmaCopyFunction} }\end{DoxyParamCaption})}



Queues many memcpy operations from host memory to device memory. These operations are defined in struct \mbox{\hyperlink{structrt_1_1MemcpyList}{Memcpy\+List}}. The device memory must be a valid region previously allocated by a malloc\+Device; the host memory must be a previously allocated memory in the host by the conventional means (for example the heap). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em stream} & handler indicating in which stream to queue the memcpy operation \\
\hline
\mbox{\texttt{ in}}  & {\em memcpy\+List} & contains all the operations required. See \mbox{\hyperlink{structrt_1_1MemcpyList}{Memcpy\+List}} \\
\hline
\mbox{\texttt{ in}}  & {\em barrier} & this parameter indicates if the memcpy operation should be postponed till all previous works issued into this stream finish (a barrier). Usually the memcpies from device to host must wait till a previous kernel execution finishes, hence the default value is false. All memcpy operations are always asynchronous. \\
\hline
\mbox{\texttt{ in}}  & {\em cma\+Copy\+Function} & this parameter allows to customize the function used to copy from user-\/space virtual memory to the C\+MA buffer. Intended for internal usage, regular A\+PI user shouldn\textquotesingle{}t modify the default value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Event\+Id is a handler of an event which can be waited for (wait\+For\+Event\+Id) to synchronize when the memcpy ends. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_a25b55dad27d716b53901b35399040ff8}\label{classrt_1_1IRuntime_a25b55dad27d716b53901b35399040ff8}} 
\index{rt::IRuntime@{rt::IRuntime}!retrieveStreamErrors@{retrieveStreamErrors}}
\index{retrieveStreamErrors@{retrieveStreamErrors}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{retrieveStreamErrors()}{retrieveStreamErrors()}}
{\footnotesize\ttfamily std\+::vector$<$\mbox{\hyperlink{structrt_1_1StreamError}{Stream\+Error}}$>$ rt\+::\+I\+Runtime\+::retrieve\+Stream\+Errors (\begin{DoxyParamCaption}\item[{Stream\+Id}]{stream }\end{DoxyParamCaption})}



This will return a list of errors and their execution context (if any) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em stream} & this is the stream to synchronize with. \\
\hline
\mbox{\texttt{ in}}  & {\em timeout} & is the number of seconds to wait till aborting the wait.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Stream\+Status contains the state of the associated stream. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_ae7d60310e5fc9b7807a964cbbaf50a2a}\label{classrt_1_1IRuntime_ae7d60310e5fc9b7807a964cbbaf50a2a}} 
\index{rt::IRuntime@{rt::IRuntime}!setOnKernelAbortedErrorCallback@{setOnKernelAbortedErrorCallback}}
\index{setOnKernelAbortedErrorCallback@{setOnKernelAbortedErrorCallback}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{setOnKernelAbortedErrorCallback()}{setOnKernelAbortedErrorCallback()}}
{\footnotesize\ttfamily void rt\+::\+I\+Runtime\+::set\+On\+Kernel\+Aborted\+Error\+Callback (\begin{DoxyParamCaption}\item[{const Kernel\+Aborted\+Callback \&}]{callback }\end{DoxyParamCaption})}



This callback (when set) will be automatically called when a kernel abort happens. This is implemented as a workaround (S\+W-\/13045). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em callback} & see Kernel\+Aborted\+Callback. This is the callback which will be called when a kernel abort happens \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classrt_1_1IRuntime_af5041e57ed0f533a32b1d12fa1bcf15d}\label{classrt_1_1IRuntime_af5041e57ed0f533a32b1d12fa1bcf15d}} 
\index{rt::IRuntime@{rt::IRuntime}!setOnStreamErrorsCallback@{setOnStreamErrorsCallback}}
\index{setOnStreamErrorsCallback@{setOnStreamErrorsCallback}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{setOnStreamErrorsCallback()}{setOnStreamErrorsCallback()}}
{\footnotesize\ttfamily void rt\+::\+I\+Runtime\+::set\+On\+Stream\+Errors\+Callback (\begin{DoxyParamCaption}\item[{Stream\+Error\+Callback}]{callback }\end{DoxyParamCaption})}



This callback (when set) will be automatically called when a new \mbox{\hyperlink{structrt_1_1StreamError}{Stream\+Error}} occurs, making the polling through retrieve\+Stream\+Errors unnecessary. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em callback} & see Stream\+Error\+Callbac. This is the callback which will be called when a \mbox{\hyperlink{structrt_1_1StreamError}{Stream\+Error}} occurs. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classrt_1_1IRuntime_a160e7929d069773d59940e8b9e50dce6}\label{classrt_1_1IRuntime_a160e7929d069773d59940e8b9e50dce6}} 
\index{rt::IRuntime@{rt::IRuntime}!unloadCode@{unloadCode}}
\index{unloadCode@{unloadCode}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{unloadCode()}{unloadCode()}}
{\footnotesize\ttfamily void rt\+::\+I\+Runtime\+::unload\+Code (\begin{DoxyParamCaption}\item[{Kernel\+Id}]{kernel }\end{DoxyParamCaption})}



Unloads a previously loaded elf code, identified by the kernel handler. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em kernel} & a handler to the code that must be unloaded \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classrt_1_1IRuntime_a51538d6474b88062aba71ff8d8c959a2}\label{classrt_1_1IRuntime_a51538d6474b88062aba71ff8d8c959a2}} 
\index{rt::IRuntime@{rt::IRuntime}!waitForEvent@{waitForEvent}}
\index{waitForEvent@{waitForEvent}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{waitForEvent()}{waitForEvent()}}
{\footnotesize\ttfamily bool rt\+::\+I\+Runtime\+::wait\+For\+Event (\begin{DoxyParamCaption}\item[{Event\+Id}]{event,  }\item[{std\+::chrono\+::seconds}]{timeout = {\ttfamily std\+:\+:chrono\+:\+:hours(24)} }\end{DoxyParamCaption})}



This will block the caller thread until the given event is dispatched or the timeout is reached. This primitive allows to synchronize with the device execution. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em event} & is the event to wait for, result of a memcpy operation or a kernel launch. \\
\hline
\mbox{\texttt{ in}}  & {\em timeout} & is the number of seconds to wait till aborting the wait. If timeout is 0 seconds, then it won\textquotesingle{}t block in any case.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if the timeout is reached, true otherwise. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrt_1_1IRuntime_a83b06e67256ef740f73b2019f78974f1}\label{classrt_1_1IRuntime_a83b06e67256ef740f73b2019f78974f1}} 
\index{rt::IRuntime@{rt::IRuntime}!waitForStream@{waitForStream}}
\index{waitForStream@{waitForStream}!rt::IRuntime@{rt::IRuntime}}
\doxysubsubsection{\texorpdfstring{waitForStream()}{waitForStream()}}
{\footnotesize\ttfamily bool rt\+::\+I\+Runtime\+::wait\+For\+Stream (\begin{DoxyParamCaption}\item[{Stream\+Id}]{stream,  }\item[{std\+::chrono\+::seconds}]{timeout = {\ttfamily std\+:\+:chrono\+:\+:hours(24)} }\end{DoxyParamCaption})}



This will block the caller thread until all commands issued to the given stream finish or if the timeout is reached. This primitive allows to synchronize with the device execution. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em stream} & this is the stream to synchronize with. \\
\hline
\mbox{\texttt{ in}}  & {\em timeout} & is the number of seconds to wait till aborting the wait. If timeout is 0 seconds, then it won\textquotesingle{}t block in any case.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if the timeout is reached, true otherwise. 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/dredok/sw-\/platform/host-\/software/esperanto-\/tools-\/libs/include/runtime/I\+Runtime.\+h\end{DoxyCompactItemize}
