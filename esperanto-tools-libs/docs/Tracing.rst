Tracing Support
===============

Execution Flow
--------------

\todo

Tracing Specification Organization
----------------------------------

As mentioned above we have a global specification file where we describe the different modules
for which we have enabled tracing and the tracing function we have enabled per module.

The spefication is located under `etrt-trace.yaml <file://@TRACING_SRC_DIR@/etrt-trace.yaml>`_

The expected schema for the specification file is under
`tracing-spec.schema <file://@TRACING_SRC_DIR@/tracing-spec.shema>`_

How to add a new Module
^^^^^^^^^^^^^^^^^^^^^^^

The top-level file looks like follows ::

  Modules:
  - !include mem-manager.yaml
  - !include device-api.yaml

To create a new module:

* Create a new YAML file that will hold the functions for the module

* Use the `!include` statement to include the other newly created YAML file. Note that the `!include`
  statement is not standard YAML directive, but a custom that that your parsing script supports, and
  allows us to break up the specification file into multiple ones.


In the new Module YAML file you need to specify the details of the module that do look as follows ::

  Name: MemoryManager
  EnablePBLogging : True
  EnableTextLogging: True
  DefaultON : True
  Functions :
    - Name: malloc
      EnablePBLogging : True
      EnableTextLogging: True
      DefaultON : True
      Arguments:
        - Name: size
          Input : True
          Type : uint64
          Required : True
          Deprecated: False

A module is comprised :

* Its name

* A set of options that enable protobuf and text logging for all its tracing functions, and if logging
  is ON by default

* A list of functions

How to add a new function
^^^^^^^^^^^^^^^^^^^^^^^^^

A function in turn can be added to the list of functions specified in the module.

The intent is that the function can easily map to the `Chrome Tracing Event <https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview>`_ specification so that we can visualize
the latency/performance overhead etc.

Out of the plethora of events that Chrome can support our goal is to currently support:

* Duration events: we are expressing start/stop events in our tracing schema.
* Complete events: Currently are not supported, and probably will not be
* Instant/Marker events: They are supported in the form of our Marker Events
* Counter events: Not currently supported, but should be added as part of SW-1483
* Async events: We have not found a mapping of those events in our usecase, we could map DeviceAPI events if
  need be.
* Flow events: No mapping in our usecase
* Object Events: Could be potentially be used for keeping the lifetime of memory objects in our system, TODO


The schema for the function is specified above and it contains:

* The function's name.

* Type of and function that can be one of: Start, Stop, Marker, Info

  The mapping between our events and "Chrome Tracing Events" is:

  +----------------+-------+
  |RT Events       | CTE   |
  +================+=======+
  | Start          |  B    |
  +----------------+-------+
  | Stop           |  E    |
  +----------------+-------+
  | Marker         |  R    |
  +----------------+-------+
  | ObjectCreate   |  N    |
  +----------------+-------+
  | ObjectDestroy  |  D    |
  +----------------+-------+
  | Snapshot       |  S    |
  +----------------+-------+


* A number of options similar to the module's for controlling the generated tracing/logging and if it is on
  by default. A function's options supercsede those of the module.

  * EnablePBLogging: Enable/disable protobuf logging. True by default
  * EnableTextLogging: Enable/Disable test logging. True by default

* A list of arguments, where we speficy:

  * The name of the argument.
  * The type of the argument that can be one of the `protobuf scalar types <https://developers.google.com/protocol-buffers/docs/proto3#scalar>`_
  * Options specifying whether the argument is required or deprecated

Code Geneneration
-----------------

We generate the following pieces of code:

* The Protobuf file, that describes all the messages that go in our trace, and from there C++ and Python
  protobuf code

* Helper C++ code that :

   * Turns on/off recording a glog trace, and populating the protobuf binary trace.
   * Helper macros that can be inserted in the code to record.

All code is generated under :ref:`namespace_et_runtime__tracing` namespace.

The user is expected to include the :ref:`file_src_Tracing_Tracing.h` header. That
header include autogenerated headers like `TracingGeh.h` that includes macros like

.. code-block:: c

  #define TRACE_MemoryManager_malloc(size, allocated_pointer)  { \
    auto& options = et_runtime::tracing::getTracingOptions(); \
    if (options.MemoryManager_malloc_enable_text_log) { \
       RTDEBUG   <<  " MemoryManager::malloc " \
        <<  " size: "  <<  size   \
        <<  " allocated_pointer: "  <<  allocated_pointer   \
       ; \
    } \
    if (options.MemoryManager_malloc_enable_pb_log) { \
      et_runtime::tracing::PBRecord_MemoryManager_malloc(size, allocated_pointer); \
    } \
  } while(0);


The above macro will check if the options are set and generate a debug text-log and insert a entry
to our binary protobuf log. From the function specification we can specify if logging will be on/off
for a specific function or module.

.. note::
   Currently not all configuration options and combinations are enabled. This should be fixed in the future.


Recoding A Trace
----------------

To record a traced we neded to pass option ``--etrt_trace`` that will enable recording any protobuf
messages we create to a file.

Dumping A Trace
---------------

Currently we do not have that many tools built around the tracing funcitonality.
To dump the protocol-buffer trace to text use the ``<RUNTIME_BUILD>/tools/trace_printer.py``
script
