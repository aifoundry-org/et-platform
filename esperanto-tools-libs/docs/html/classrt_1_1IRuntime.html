<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Host Runtime: rt::IRuntime Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Host Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>rt</b></li><li class="navelem"><a class="el" href="classrt_1_1IRuntime.html">IRuntime</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classrt_1_1IRuntime-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rt::IRuntime Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Facade Runtime interface declaration, all runtime interactions should be made using this interface. There is a static method <a class="el" href="classrt_1_1IRuntime.html#a2026e8a4e067c85cb82a52d60c2f7872">create</a> to make runtime instances (factory method)  
 <a href="classrt_1_1IRuntime.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IRuntime_8h_source.html">IRuntime.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0ccd044349fb81c6c94eafa28b977c95"><td class="memItemLeft" align="right" valign="top">std::vector&lt; DeviceId &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a0ccd044349fb81c6c94eafa28b977c95">getDevices</a> ()</td></tr>
<tr class="memdesc:a0ccd044349fb81c6c94eafa28b977c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all devices.  <a href="classrt_1_1IRuntime.html#a0ccd044349fb81c6c94eafa28b977c95">More...</a><br /></td></tr>
<tr class="separator:a0ccd044349fb81c6c94eafa28b977c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e1ef24b9d683cc0a51ef250fb8123e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrt_1_1DeviceProperties.html">DeviceProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a44e1ef24b9d683cc0a51ef250fb8123e">getDeviceProperties</a> (DeviceId device) const</td></tr>
<tr class="memdesc:a44e1ef24b9d683cc0a51ef250fb8123e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the properties of a given device.  <a href="classrt_1_1IRuntime.html#a44e1ef24b9d683cc0a51ef250fb8123e">More...</a><br /></td></tr>
<tr class="separator:a44e1ef24b9d683cc0a51ef250fb8123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cded710ad5ed5b69107b2a72fadb2e"><td class="memItemLeft" align="right" valign="top">std::byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a40cded710ad5ed5b69107b2a72fadb2e">mallocDevice</a> (DeviceId device, size_t size, uint32_t alignment=kCacheLineSize)</td></tr>
<tr class="memdesc:a40cded710ad5ed5b69107b2a72fadb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory in the device, returns a device memory pointer. One can't use this pointer directly from the host, this pointer is intended to be used for memory operations between the host and the device.  <a href="classrt_1_1IRuntime.html#a40cded710ad5ed5b69107b2a72fadb2e">More...</a><br /></td></tr>
<tr class="separator:a40cded710ad5ed5b69107b2a72fadb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114f89ceff8d1154d389404c6ec57f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a114f89ceff8d1154d389404c6ec57f39">freeDevice</a> (DeviceId device, std::byte *buffer)</td></tr>
<tr class="memdesc:a114f89ceff8d1154d389404c6ec57f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates previously allocated memory on the given device.  <a href="classrt_1_1IRuntime.html#a114f89ceff8d1154d389404c6ec57f39">More...</a><br /></td></tr>
<tr class="separator:a114f89ceff8d1154d389404c6ec57f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3a36b976e629594a7ba6e82817505b"><td class="memItemLeft" align="right" valign="top">StreamId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a0e3a36b976e629594a7ba6e82817505b">createStream</a> (DeviceId device)</td></tr>
<tr class="memdesc:a0e3a36b976e629594a7ba6e82817505b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new stream and associates it to the given device. A stream is an abstraction of a "pipeline" where you can push operations (mem copies or kernel launches) and enforce the dependencies between these operations.  <a href="classrt_1_1IRuntime.html#a0e3a36b976e629594a7ba6e82817505b">More...</a><br /></td></tr>
<tr class="separator:a0e3a36b976e629594a7ba6e82817505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5356f8b2d41f61c4d76706ec9704ee4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#ab5356f8b2d41f61c4d76706ec9704ee4">destroyStream</a> (StreamId stream)</td></tr>
<tr class="memdesc:ab5356f8b2d41f61c4d76706ec9704ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a previously created stream.  <a href="classrt_1_1IRuntime.html#ab5356f8b2d41f61c4d76706ec9704ee4">More...</a><br /></td></tr>
<tr class="separator:ab5356f8b2d41f61c4d76706ec9704ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3091bd0f4aa2efa99c93da9ea186226b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrt_1_1LoadCodeResult.html">LoadCodeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a3091bd0f4aa2efa99c93da9ea186226b">loadCode</a> (StreamId stream, const std::byte *elf, size_t elf_size)</td></tr>
<tr class="memdesc:a3091bd0f4aa2efa99c93da9ea186226b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an elf into the device. The caller will provide a byte code containing the elf representation and its size. Host memory.  <a href="classrt_1_1IRuntime.html#a3091bd0f4aa2efa99c93da9ea186226b">More...</a><br /></td></tr>
<tr class="separator:a3091bd0f4aa2efa99c93da9ea186226b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160e7929d069773d59940e8b9e50dce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a160e7929d069773d59940e8b9e50dce6">unloadCode</a> (KernelId kernel)</td></tr>
<tr class="memdesc:a160e7929d069773d59940e8b9e50dce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unloads a previously loaded elf code, identified by the kernel handler.  <a href="classrt_1_1IRuntime.html#a160e7929d069773d59940e8b9e50dce6">More...</a><br /></td></tr>
<tr class="separator:a160e7929d069773d59940e8b9e50dce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e95aab372520fc3d5e0de092562452f"><td class="memItemLeft" align="right" valign="top">EventId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a5e95aab372520fc3d5e0de092562452f">kernelLaunch</a> (StreamId stream, KernelId kernel, const std::byte *kernel_args, size_t kernel_args_size, uint64_t shire_mask, bool barrier=true, bool flushL3=false, std::optional&lt; <a class="el" href="structrt_1_1UserTrace.html">UserTrace</a> &gt; userTraceConfig=std::nullopt)</td></tr>
<tr class="memdesc:a5e95aab372520fc3d5e0de092562452f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a execution work into a stream. The work is identified by the kernel handler, which has been previously loaded into the device which is associated to the stream. The parameters of the kernel are given by kernel_args and kernel_args_size; these parameters will be copied from the host memory to the device memory by the runtime. The firmware will load these parameters into RA register, the kernel code should cast this register to the expected types. The kernel execution is always asynchronous.  <a href="classrt_1_1IRuntime.html#a5e95aab372520fc3d5e0de092562452f">More...</a><br /></td></tr>
<tr class="separator:a5e95aab372520fc3d5e0de092562452f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7501a6f2e7959b283fd801ac6aeb0f8b"><td class="memItemLeft" align="right" valign="top">EventId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a7501a6f2e7959b283fd801ac6aeb0f8b">memcpyHostToDevice</a> (StreamId stream, const std::byte *h_src, std::byte *d_dst, size_t size, bool barrier=false, const CmaCopyFunction &amp;cmaCopyFunction=defaultCmaCopyFunction)</td></tr>
<tr class="memdesc:a7501a6f2e7959b283fd801ac6aeb0f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a memcpy operation from host memory to device memory. The device memory must be previously allocated by a mallocDevice.  <a href="classrt_1_1IRuntime.html#a7501a6f2e7959b283fd801ac6aeb0f8b">More...</a><br /></td></tr>
<tr class="separator:a7501a6f2e7959b283fd801ac6aeb0f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1038d3f71b63a7bd0d6f66c10647ff"><td class="memItemLeft" align="right" valign="top">EventId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a5f1038d3f71b63a7bd0d6f66c10647ff">memcpyDeviceToHost</a> (StreamId stream, const std::byte *d_src, std::byte *h_dst, size_t size, bool barrier=true, const CmaCopyFunction &amp;cmaCopyFunction=defaultCmaCopyFunction)</td></tr>
<tr class="memdesc:a5f1038d3f71b63a7bd0d6f66c10647ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a memcpy operation from device memory to host memory. The device memory must be a valid region previously allocated by a mallocDevice; the host memory must be a previously allocated memory in the host by the conventional means (for example the heap)  <a href="classrt_1_1IRuntime.html#a5f1038d3f71b63a7bd0d6f66c10647ff">More...</a><br /></td></tr>
<tr class="separator:a5f1038d3f71b63a7bd0d6f66c10647ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af018821132fe5309fb9e72e4e62bb25b"><td class="memItemLeft" align="right" valign="top">EventId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#af018821132fe5309fb9e72e4e62bb25b">memcpyHostToDevice</a> (StreamId stream, <a class="el" href="structrt_1_1MemcpyList.html">MemcpyList</a> memcpyList, bool barrier=false, const CmaCopyFunction &amp;cmaCopyFunction=defaultCmaCopyFunction)</td></tr>
<tr class="memdesc:af018821132fe5309fb9e72e4e62bb25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues many memcpy operations from host memory to device memory. These operations are defined in struct <a class="el" href="structrt_1_1MemcpyList.html">MemcpyList</a>. The device memory must be a valid region previously allocated by a mallocDevice; the host memory must be a previously allocated memory in the host by the conventional means (for example the heap).  <a href="classrt_1_1IRuntime.html#af018821132fe5309fb9e72e4e62bb25b">More...</a><br /></td></tr>
<tr class="separator:af018821132fe5309fb9e72e4e62bb25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac473c3770b8cadafb406fe63534011b8"><td class="memItemLeft" align="right" valign="top">EventId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#ac473c3770b8cadafb406fe63534011b8">memcpyDeviceToHost</a> (StreamId stream, <a class="el" href="structrt_1_1MemcpyList.html">MemcpyList</a> memcpyList, bool barrier=true, const CmaCopyFunction &amp;cmaCopyFunction=defaultCmaCopyFunction)</td></tr>
<tr class="memdesc:ac473c3770b8cadafb406fe63534011b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues many memcpy operations from device memory to host memory. These operations are defined in struct <a class="el" href="structrt_1_1MemcpyList.html">MemcpyList</a>. The device memory must be a valid region previously allocated by a mallocDevice; the host memory must be a previously allocated memory in the host by the conventional means (for example the heap).  <a href="classrt_1_1IRuntime.html#ac473c3770b8cadafb406fe63534011b8">More...</a><br /></td></tr>
<tr class="separator:ac473c3770b8cadafb406fe63534011b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51538d6474b88062aba71ff8d8c959a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a51538d6474b88062aba71ff8d8c959a2">waitForEvent</a> (EventId event, std::chrono::seconds timeout=std::chrono::hours(24))</td></tr>
<tr class="memdesc:a51538d6474b88062aba71ff8d8c959a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will block the caller thread until the given event is dispatched or the timeout is reached. This primitive allows to synchronize with the device execution.  <a href="classrt_1_1IRuntime.html#a51538d6474b88062aba71ff8d8c959a2">More...</a><br /></td></tr>
<tr class="separator:a51538d6474b88062aba71ff8d8c959a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b06e67256ef740f73b2019f78974f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a83b06e67256ef740f73b2019f78974f1">waitForStream</a> (StreamId stream, std::chrono::seconds timeout=std::chrono::hours(24))</td></tr>
<tr class="memdesc:a83b06e67256ef740f73b2019f78974f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will block the caller thread until all commands issued to the given stream finish or if the timeout is reached. This primitive allows to synchronize with the device execution.  <a href="classrt_1_1IRuntime.html#a83b06e67256ef740f73b2019f78974f1">More...</a><br /></td></tr>
<tr class="separator:a83b06e67256ef740f73b2019f78974f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b55dad27d716b53901b35399040ff8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structrt_1_1StreamError.html">StreamError</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a25b55dad27d716b53901b35399040ff8">retrieveStreamErrors</a> (StreamId stream)</td></tr>
<tr class="memdesc:a25b55dad27d716b53901b35399040ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will return a list of errors and their execution context (if any)  <a href="classrt_1_1IRuntime.html#a25b55dad27d716b53901b35399040ff8">More...</a><br /></td></tr>
<tr class="separator:a25b55dad27d716b53901b35399040ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d60310e5fc9b7807a964cbbaf50a2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#ae7d60310e5fc9b7807a964cbbaf50a2a">setOnKernelAbortedErrorCallback</a> (const KernelAbortedCallback &amp;callback)</td></tr>
<tr class="memdesc:ae7d60310e5fc9b7807a964cbbaf50a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback (when set) will be automatically called when a kernel abort happens. This is implemented as a workaround (SW-13045).  <a href="classrt_1_1IRuntime.html#ae7d60310e5fc9b7807a964cbbaf50a2a">More...</a><br /></td></tr>
<tr class="separator:ae7d60310e5fc9b7807a964cbbaf50a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5041e57ed0f533a32b1d12fa1bcf15d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#af5041e57ed0f533a32b1d12fa1bcf15d">setOnStreamErrorsCallback</a> (StreamErrorCallback callback)</td></tr>
<tr class="memdesc:af5041e57ed0f533a32b1d12fa1bcf15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback (when set) will be automatically called when a new <a class="el" href="structrt_1_1StreamError.html" title="This struct contains the errorCode given by de device when some command fail and the associated Error...">StreamError</a> occurs, making the polling through retrieveStreamErrors unnecessary.  <a href="classrt_1_1IRuntime.html#af5041e57ed0f533a32b1d12fa1bcf15d">More...</a><br /></td></tr>
<tr class="separator:af5041e57ed0f533a32b1d12fa1bcf15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea977b0f35ff1a0e7d43b7cf5dc1303b"><td class="memItemLeft" align="right" valign="top"><a id="aea977b0f35ff1a0e7d43b7cf5dc1303b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#aea977b0f35ff1a0e7d43b7cf5dc1303b">setProfiler</a> (std::unique_ptr&lt; <a class="el" href="classrt_1_1profiling_1_1IProfilerRecorder.html">profiling::IProfilerRecorder</a> &gt; profiler)</td></tr>
<tr class="memdesc:aea977b0f35ff1a0e7d43b7cf5dc1303b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a profiler to be used by runtime. <br /></td></tr>
<tr class="separator:aea977b0f35ff1a0e7d43b7cf5dc1303b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145044ba3d9ed62b320a296b0e1f143c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1profiling_1_1IProfilerRecorder.html">profiling::IProfilerRecorder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a145044ba3d9ed62b320a296b0e1f143c">getProfiler</a> () const</td></tr>
<tr class="memdesc:a145044ba3d9ed62b320a296b0e1f143c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the profiler interface; don't delete/free this pointer since this is owned by the runtime itself.  <a href="classrt_1_1IRuntime.html#a145044ba3d9ed62b320a296b0e1f143c">More...</a><br /></td></tr>
<tr class="separator:a145044ba3d9ed62b320a296b0e1f143c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cee724ef99f41ffc5830851f7633237"><td class="memItemLeft" align="right" valign="top">EventId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a7cee724ef99f41ffc5830851f7633237">abortCommand</a> (EventId commandId, std::chrono::milliseconds timeout=std::chrono::milliseconds(5000))</td></tr>
<tr class="memdesc:a7cee724ef99f41ffc5830851f7633237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instructs the device to abort given command. NOTE: as per current firmware implementation, aborting a command will have undesirable side effects on the rest of the submitted commands to the same virtual queue. So, after aborting a command it could potentially affect the rest of the executions BUG: individual memcpyHostToDevice and memcpyDeviceToHost commands can not be aborted individually right now. The could be aborted through <a class="el" href="classrt_1_1IRuntime.html#aeb8243996204585371f98baedd98a9a2">abortStream</a>.  <a href="classrt_1_1IRuntime.html#a7cee724ef99f41ffc5830851f7633237">More...</a><br /></td></tr>
<tr class="separator:a7cee724ef99f41ffc5830851f7633237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8243996204585371f98baedd98a9a2"><td class="memItemLeft" align="right" valign="top">EventId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#aeb8243996204585371f98baedd98a9a2">abortStream</a> (StreamId streamId)</td></tr>
<tr class="memdesc:aeb8243996204585371f98baedd98a9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instructs the device to abort all outstanding commands on a given stream. This will affect to all commands previously issued to given stream, later commands will execute normally. NOTE: as per current firmware implementation, aborting a command will have undesirable side effects on the rest of the submitted commands to the same virtual queue. So, after aborting a command it could potentially affect the rest of the executions.  <a href="classrt_1_1IRuntime.html#aeb8243996204585371f98baedd98a9a2">More...</a><br /></td></tr>
<tr class="separator:aeb8243996204585371f98baedd98a9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16570e7e5c31f16be7b377b14ace61b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrt_1_1DmaInfo.html">DmaInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#ab16570e7e5c31f16be7b377b14ace61b">getDmaInfo</a> (DeviceId deviceId) const</td></tr>
<tr class="memdesc:ab16570e7e5c31f16be7b377b14ace61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="structrt_1_1DmaInfo.html">DmaInfo</a> of given device (see <a class="el" href="structrt_1_1DmaInfo.html">DmaInfo</a>). This <a class="el" href="structrt_1_1DmaInfo.html">DmaInfo</a> contains max size for each operation in a memcpy list command and max number of operations allowed in a single memcpy list command.  <a href="classrt_1_1IRuntime.html#ab16570e7e5c31f16be7b377b14ace61b">More...</a><br /></td></tr>
<tr class="separator:ab16570e7e5c31f16be7b377b14ace61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5a0b9c8f1ffef2c946bf63c3323940"><td class="memItemLeft" align="right" valign="top"><a id="ace5a0b9c8f1ffef2c946bf63c3323940"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#ace5a0b9c8f1ffef2c946bf63c3323940">~IRuntime</a> ()=default</td></tr>
<tr class="memdesc:ace5a0b9c8f1ffef2c946bf63c3323940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Destructor to enable polymorphic release of the runtime instances. <br /></td></tr>
<tr class="separator:ace5a0b9c8f1ffef2c946bf63c3323940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c12e62c1b46e2c1d6d899f8ca63969"><td class="memItemLeft" align="right" valign="top"><a id="a32c12e62c1b46e2c1d6d899f8ca63969"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a32c12e62c1b46e2c1d6d899f8ca63969">IRuntime</a> ()</td></tr>
<tr class="memdesc:a32c12e62c1b46e2c1d6d899f8ca63969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to initialize with a dummy profiler. <br /></td></tr>
<tr class="separator:a32c12e62c1b46e2c1d6d899f8ca63969"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2026e8a4e067c85cb82a52d60c2f7872"><td class="memItemLeft" align="right" valign="top">static RuntimePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#a2026e8a4e067c85cb82a52d60c2f7872">create</a> (dev::IDeviceLayer *deviceLayer, <a class="el" href="structrt_1_1Options.html">Options</a> options=getDefaultOptions())</td></tr>
<tr class="memdesc:a2026e8a4e067c85cb82a52d60c2f7872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to instantiate a standalone <a class="el" href="classrt_1_1IRuntime.html" title="Facade Runtime interface declaration, all runtime interactions should be made using this interface....">IRuntime</a> implementation.  <a href="classrt_1_1IRuntime.html#a2026e8a4e067c85cb82a52d60c2f7872">More...</a><br /></td></tr>
<tr class="separator:a2026e8a4e067c85cb82a52d60c2f7872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2a650983154b987478145777b7bb6b"><td class="memItemLeft" align="right" valign="top">static RuntimePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1IRuntime.html#aae2a650983154b987478145777b7bb6b">create</a> (const std::string &amp;socketPath)</td></tr>
<tr class="memdesc:aae2a650983154b987478145777b7bb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to instantiate a client <a class="el" href="classrt_1_1IRuntime.html" title="Facade Runtime interface declaration, all runtime interactions should be made using this interface....">IRuntime</a> implementation.  <a href="classrt_1_1IRuntime.html#aae2a650983154b987478145777b7bb6b">More...</a><br /></td></tr>
<tr class="separator:aae2a650983154b987478145777b7bb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Facade Runtime interface declaration, all runtime interactions should be made using this interface. There is a static method <a class="el" href="classrt_1_1IRuntime.html#a2026e8a4e067c85cb82a52d60c2f7872">create</a> to make runtime instances (factory method) </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7cee724ef99f41ffc5830851f7633237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cee724ef99f41ffc5830851f7633237">&#9670;&nbsp;</a></span>abortCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EventId rt::IRuntime::abortCommand </td>
          <td>(</td>
          <td class="paramtype">EventId&#160;</td>
          <td class="paramname"><em>commandId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(5000)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instructs the device to abort given command. NOTE: as per current firmware implementation, aborting a command will have undesirable side effects on the rest of the submitted commands to the same virtual queue. So, after aborting a command it could potentially affect the rest of the executions BUG: individual memcpyHostToDevice and memcpyDeviceToHost commands can not be aborted individually right now. The could be aborted through <a class="el" href="classrt_1_1IRuntime.html#aeb8243996204585371f98baedd98a9a2">abortStream</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandId</td><td>indicates the command's eventId to abort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>indicates the maximum time trying to QUEUE an abort command into the device. If the timeout is reached and the runtime was not able to push the command into the device, an <a class="el" href="classrt_1_1Exception.html" title="The error handling in the runtime is trough exceptions. This is the only exception kind that the runt...">Exception</a> will be thrown</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EventId is a handler of the abort command itself which can be waited for (waitForEventId) to synchronize. </dd></dl>

</div>
</div>
<a id="aeb8243996204585371f98baedd98a9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8243996204585371f98baedd98a9a2">&#9670;&nbsp;</a></span>abortStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EventId rt::IRuntime::abortStream </td>
          <td>(</td>
          <td class="paramtype">StreamId&#160;</td>
          <td class="paramname"><em>streamId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instructs the device to abort all outstanding commands on a given stream. This will affect to all commands previously issued to given stream, later commands will execute normally. NOTE: as per current firmware implementation, aborting a command will have undesirable side effects on the rest of the submitted commands to the same virtual queue. So, after aborting a command it could potentially affect the rest of the executions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">streamId</td><td>indicates the stream to abort commands</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EventId is a handler of the abortStream which can be waited for (waitForEventId) to synchronize. </dd></dl>

</div>
</div>
<a id="aae2a650983154b987478145777b7bb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2a650983154b987478145777b7bb6b">&#9670;&nbsp;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static RuntimePtr rt::IRuntime::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>socketPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to instantiate a client <a class="el" href="classrt_1_1IRuntime.html" title="Facade Runtime interface declaration, all runtime interactions should be made using this interface....">IRuntime</a> implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socketPath</td><td>indicates which socket the Client will connect to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RuntimePtr an <a class="el" href="classrt_1_1IRuntime.html" title="Facade Runtime interface declaration, all runtime interactions should be made using this interface....">IRuntime</a> instance. See dev::IDeviceLayer </dd></dl>

</div>
</div>
<a id="a2026e8a4e067c85cb82a52d60c2f7872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2026e8a4e067c85cb82a52d60c2f7872">&#9670;&nbsp;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static RuntimePtr rt::IRuntime::create </td>
          <td>(</td>
          <td class="paramtype">dev::IDeviceLayer *&#160;</td>
          <td class="paramname"><em>deviceLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt_1_1Options.html">Options</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>getDefaultOptions()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to instantiate a standalone <a class="el" href="classrt_1_1IRuntime.html" title="Facade Runtime interface declaration, all runtime interactions should be made using this interface....">IRuntime</a> implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="structrt_1_1Options.html" title="This struct will hold parametrization options for Runtime instantiation.">Options</a></td><td>can set some runtime parameters. See <a class="el" href="structrt_1_1Options.html">Options</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RuntimePtr an <a class="el" href="classrt_1_1IRuntime.html" title="Facade Runtime interface declaration, all runtime interactions should be made using this interface....">IRuntime</a> instance. See dev::IDeviceLayer </dd></dl>

</div>
</div>
<a id="a0e3a36b976e629594a7ba6e82817505b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3a36b976e629594a7ba6e82817505b">&#9670;&nbsp;</a></span>createStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StreamId rt::IRuntime::createStream </td>
          <td>(</td>
          <td class="paramtype">DeviceId&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new stream and associates it to the given device. A stream is an abstraction of a "pipeline" where you can push operations (mem copies or kernel launches) and enforce the dependencies between these operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>handler indicating in which device to associate the stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a stream handler </dd></dl>

</div>
</div>
<a id="ab5356f8b2d41f61c4d76706ec9704ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5356f8b2d41f61c4d76706ec9704ee4">&#9670;&nbsp;</a></span>destroyStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt::IRuntime::destroyStream </td>
          <td>(</td>
          <td class="paramtype">StreamId&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a previously created stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>handler to the stream to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a114f89ceff8d1154d389404c6ec57f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114f89ceff8d1154d389404c6ec57f39">&#9670;&nbsp;</a></span>freeDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt::IRuntime::freeDevice </td>
          <td>(</td>
          <td class="paramtype">DeviceId&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::byte *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates previously allocated memory on the given device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>handler indicating in which device to deallocate the memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>device memory pointer previously allocated with mallocDevice to be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44e1ef24b9d683cc0a51ef250fb8123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e1ef24b9d683cc0a51ef250fb8123e">&#9670;&nbsp;</a></span>getDeviceProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrt_1_1DeviceProperties.html">DeviceProperties</a> rt::IRuntime::getDeviceProperties </td>
          <td>(</td>
          <td class="paramtype">DeviceId&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the properties of a given device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>handler indicating the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the properties for the requested device </dd></dl>

</div>
</div>
<a id="a0ccd044349fb81c6c94eafa28b977c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccd044349fb81c6c94eafa28b977c95">&#9670;&nbsp;</a></span>getDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;DeviceId&gt; rt::IRuntime::getDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all devices. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing all device handlers </dd></dl>

</div>
</div>
<a id="ab16570e7e5c31f16be7b377b14ace61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16570e7e5c31f16be7b377b14ace61b">&#9670;&nbsp;</a></span>getDmaInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrt_1_1DmaInfo.html">DmaInfo</a> rt::IRuntime::getDmaInfo </td>
          <td>(</td>
          <td class="paramtype">DeviceId&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="structrt_1_1DmaInfo.html">DmaInfo</a> of given device (see <a class="el" href="structrt_1_1DmaInfo.html">DmaInfo</a>). This <a class="el" href="structrt_1_1DmaInfo.html">DmaInfo</a> contains max size for each operation in a memcpy list command and max number of operations allowed in a single memcpy list command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>indicates the device to get the DMA configuration from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structrt_1_1DmaInfo.html">DmaInfo</a> contains max number of operations allowed in a single memcpy list command and max size for each operation. </dd></dl>

</div>
</div>
<a id="a145044ba3d9ed62b320a296b0e1f143c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145044ba3d9ed62b320a296b0e1f143c">&#9670;&nbsp;</a></span>getProfiler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1profiling_1_1IProfilerRecorder.html">profiling::IProfilerRecorder</a>* rt::IRuntime::getProfiler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the profiler interface; don't delete/free this pointer since this is owned by the runtime itself. </p>
<dl class="section return"><dt>Returns</dt><dd>IProfilerRecorder an interface to the profiler. See IProfilerRecorder </dd></dl>

</div>
</div>
<a id="a5e95aab372520fc3d5e0de092562452f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e95aab372520fc3d5e0de092562452f">&#9670;&nbsp;</a></span>kernelLaunch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EventId rt::IRuntime::kernelLaunch </td>
          <td>(</td>
          <td class="paramtype">StreamId&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelId&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::byte *&#160;</td>
          <td class="paramname"><em>kernel_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>kernel_args_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>shire_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>barrier</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flushL3</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structrt_1_1UserTrace.html">UserTrace</a> &gt;&#160;</td>
          <td class="paramname"><em>userTraceConfig</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues a execution work into a stream. The work is identified by the kernel handler, which has been previously loaded into the device which is associated to the stream. The parameters of the kernel are given by kernel_args and kernel_args_size; these parameters will be copied from the host memory to the device memory by the runtime. The firmware will load these parameters into RA register, the kernel code should cast this register to the expected types. The kernel execution is always asynchronous. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>handler indicating in which stream the kernel will be executed. The kernel code have to be registered into the device associated to the stream previously. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel</td><td>handler which indicate what code to execute in the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_args</td><td>buffer containing all the parameters to be copied to the device memory prior to the code execution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_args_size</td><td>size of the kernel_args buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shire_mask</td><td>indicates in what shires the kernel will be executed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barrier</td><td>this parameter indicates if the kernel execution should be postponed till all previous works issued into this stream finish (a barrier). Usually the kernel launch must be postponed till some previous memory operations end, hence the default value is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flushL3</td><td>this parameter indicates if the L3 should be flushed before the kernel execution starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userTraceBuffer</td><td>this parameter can be null or point to a device buffer (previously allocated with <a class="el" href="classrt_1_1IRuntime.html#a40cded710ad5ed5b69107b2a72fadb2e">mallocDevice</a>). If the pointer is not null, then the firmware will utilize this buffer to fill-up user trace data. This buffer must be of size 4KB * num_harts (4KB*2080). We will provide later on an API to allocate the buffer with the size required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EventId is a handler of an event which can be waited for (waitForEventId) to syncrhonize when the kernel ends the execution. </dd></dl>

</div>
</div>
<a id="a3091bd0f4aa2efa99c93da9ea186226b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3091bd0f4aa2efa99c93da9ea186226b">&#9670;&nbsp;</a></span>loadCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrt_1_1LoadCodeResult.html">LoadCodeResult</a> rt::IRuntime::loadCode </td>
          <td>(</td>
          <td class="paramtype">StreamId&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::byte *&#160;</td>
          <td class="paramname"><em>elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads an elf into the device. The caller will provide a byte code containing the elf representation and its size. Host memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>handler indicating the stream used for the kernel loading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elf</td><td>a pointer to host memory containing the elf bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elf_size</td><td>the elf size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structrt_1_1LoadCodeResult.html">LoadCodeResult</a> with the EventId to sync with (if needed), the kernelId to utilize in later kernelLaunch and the kernel load address.</dd></dl>
<p>NOTE: remember to not deallocate the elf memory</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elf</td><td>until the EventId from <a class="el" href="structrt_1_1LoadCodeResult.html">LoadCodeResult</a> is completed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40cded710ad5ed5b69107b2a72fadb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cded710ad5ed5b69107b2a72fadb2e">&#9670;&nbsp;</a></span>mallocDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::byte* rt::IRuntime::mallocDevice </td>
          <td>(</td>
          <td class="paramtype">DeviceId&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>kCacheLineSize</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory in the device, returns a device memory pointer. One can't use this pointer directly from the host, this pointer is intended to be used for memory operations between the host and the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>handler indicating in which device to allocate the memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>indicates the memory allocation size in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>indicates the required alignment for memory allocation, defaults to device cache line size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a device memory pointer </dd></dl>

</div>
</div>
<a id="a5f1038d3f71b63a7bd0d6f66c10647ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1038d3f71b63a7bd0d6f66c10647ff">&#9670;&nbsp;</a></span>memcpyDeviceToHost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EventId rt::IRuntime::memcpyDeviceToHost </td>
          <td>(</td>
          <td class="paramtype">StreamId&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::byte *&#160;</td>
          <td class="paramname"><em>d_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::byte *&#160;</td>
          <td class="paramname"><em>h_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>barrier</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CmaCopyFunction &amp;&#160;</td>
          <td class="paramname"><em>cmaCopyFunction</em> = <code>defaultCmaCopyFunction</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues a memcpy operation from device memory to host memory. The device memory must be a valid region previously allocated by a mallocDevice; the host memory must be a previously allocated memory in the host by the conventional means (for example the heap) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>handler indicating in which stream to queue the memcpy operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_src</td><td>device memory buffer to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_dst</td><td>host memory buffer to copy to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>indicates the size of the memcpy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barrier</td><td>this parameter indicates if the memcpy operation should be postponed till all previous works issued into this stream finish (a barrier). Usually the memcpies from device to host must wait till a previous kernel execution finishes, hence the default value is true All memcpy operations are always asynchronous. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmaCopyFunction</td><td>this parameter allows to customize the function used to copy from user-space virtual memory to the CMA buffer. Intended for internal usage, regular API user shouldn't modify the default value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EventId is a handler of an event which can be waited for (waitForEventId) to synchronize when the memcpy ends.</dd></dl>
<p>NOTE: the host memory pointer must be kept alive until the operation has completely ended in device. </p>

</div>
</div>
<a id="ac473c3770b8cadafb406fe63534011b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac473c3770b8cadafb406fe63534011b8">&#9670;&nbsp;</a></span>memcpyDeviceToHost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EventId rt::IRuntime::memcpyDeviceToHost </td>
          <td>(</td>
          <td class="paramtype">StreamId&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt_1_1MemcpyList.html">MemcpyList</a>&#160;</td>
          <td class="paramname"><em>memcpyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>barrier</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CmaCopyFunction &amp;&#160;</td>
          <td class="paramname"><em>cmaCopyFunction</em> = <code>defaultCmaCopyFunction</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues many memcpy operations from device memory to host memory. These operations are defined in struct <a class="el" href="structrt_1_1MemcpyList.html">MemcpyList</a>. The device memory must be a valid region previously allocated by a mallocDevice; the host memory must be a previously allocated memory in the host by the conventional means (for example the heap). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>handler indicating in which stream to queue the memcpy operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memcpyList</td><td>contains all the operations required. See <a class="el" href="structrt_1_1MemcpyList.html">MemcpyList</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barrier</td><td>this parameter indicates if the memcpy operation should be postponed till all previous works issued into this stream finish (a barrier). Usually the memcpies from device to host must wait till a previous kernel execution finishes, hence the default value is true All memcpy operations are always asynchronous. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmaCopyFunction</td><td>this parameter allows to customize the function used to copy from user-space virtual memory to the CMA buffer. Intended for internal usage, regular API user shouldn't modify the default value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EventId is a handler of an event which can be waited for (waitForEventId) to synchronize when the memcpy ends. </dd></dl>

</div>
</div>
<a id="a7501a6f2e7959b283fd801ac6aeb0f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7501a6f2e7959b283fd801ac6aeb0f8b">&#9670;&nbsp;</a></span>memcpyHostToDevice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EventId rt::IRuntime::memcpyHostToDevice </td>
          <td>(</td>
          <td class="paramtype">StreamId&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::byte *&#160;</td>
          <td class="paramname"><em>h_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::byte *&#160;</td>
          <td class="paramname"><em>d_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>barrier</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CmaCopyFunction &amp;&#160;</td>
          <td class="paramname"><em>cmaCopyFunction</em> = <code>defaultCmaCopyFunction</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues a memcpy operation from host memory to device memory. The device memory must be previously allocated by a mallocDevice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>handler indicating in which stream to queue the memcpy operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_src</td><td>host memory buffer to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_dst</td><td>device memory buffer to copy to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>indicates the size of the memcpy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barrier</td><td>this parameter indicates if the memcpy operation should be postponed till all previous works issued into this stream finish (a barrier). Usually the memcpies from host to device can run in parallel, hence the default value is false All memcpy operations are always asynchronous. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmaCopyFunction</td><td>this parameter allows to customize the function used to copy from user-space virtual memory to the CMA buffer. Intended for internal usage, regular API user shouldn't modify the default value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EventId is a handler of an event which can be waited for (waitForEventId) to synchronize when the memcpy ends.</dd></dl>
<p>NOTE: the host memory pointer must be kept alive until the operation has completely ended in device. </p>

</div>
</div>
<a id="af018821132fe5309fb9e72e4e62bb25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af018821132fe5309fb9e72e4e62bb25b">&#9670;&nbsp;</a></span>memcpyHostToDevice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EventId rt::IRuntime::memcpyHostToDevice </td>
          <td>(</td>
          <td class="paramtype">StreamId&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt_1_1MemcpyList.html">MemcpyList</a>&#160;</td>
          <td class="paramname"><em>memcpyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>barrier</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CmaCopyFunction &amp;&#160;</td>
          <td class="paramname"><em>cmaCopyFunction</em> = <code>defaultCmaCopyFunction</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues many memcpy operations from host memory to device memory. These operations are defined in struct <a class="el" href="structrt_1_1MemcpyList.html">MemcpyList</a>. The device memory must be a valid region previously allocated by a mallocDevice; the host memory must be a previously allocated memory in the host by the conventional means (for example the heap). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>handler indicating in which stream to queue the memcpy operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memcpyList</td><td>contains all the operations required. See <a class="el" href="structrt_1_1MemcpyList.html">MemcpyList</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barrier</td><td>this parameter indicates if the memcpy operation should be postponed till all previous works issued into this stream finish (a barrier). Usually the memcpies from device to host must wait till a previous kernel execution finishes, hence the default value is false. All memcpy operations are always asynchronous. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmaCopyFunction</td><td>this parameter allows to customize the function used to copy from user-space virtual memory to the CMA buffer. Intended for internal usage, regular API user shouldn't modify the default value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EventId is a handler of an event which can be waited for (waitForEventId) to synchronize when the memcpy ends. </dd></dl>

</div>
</div>
<a id="a25b55dad27d716b53901b35399040ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b55dad27d716b53901b35399040ff8">&#9670;&nbsp;</a></span>retrieveStreamErrors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structrt_1_1StreamError.html">StreamError</a>&gt; rt::IRuntime::retrieveStreamErrors </td>
          <td>(</td>
          <td class="paramtype">StreamId&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This will return a list of errors and their execution context (if any) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>this is the stream to synchronize with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>is the number of seconds to wait till aborting the wait.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StreamStatus contains the state of the associated stream. </dd></dl>

</div>
</div>
<a id="ae7d60310e5fc9b7807a964cbbaf50a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d60310e5fc9b7807a964cbbaf50a2a">&#9670;&nbsp;</a></span>setOnKernelAbortedErrorCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt::IRuntime::setOnKernelAbortedErrorCallback </td>
          <td>(</td>
          <td class="paramtype">const KernelAbortedCallback &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This callback (when set) will be automatically called when a kernel abort happens. This is implemented as a workaround (SW-13045). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>see KernelAbortedCallback. This is the callback which will be called when a kernel abort happens </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5041e57ed0f533a32b1d12fa1bcf15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5041e57ed0f533a32b1d12fa1bcf15d">&#9670;&nbsp;</a></span>setOnStreamErrorsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt::IRuntime::setOnStreamErrorsCallback </td>
          <td>(</td>
          <td class="paramtype">StreamErrorCallback&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This callback (when set) will be automatically called when a new <a class="el" href="structrt_1_1StreamError.html" title="This struct contains the errorCode given by de device when some command fail and the associated Error...">StreamError</a> occurs, making the polling through retrieveStreamErrors unnecessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>see StreamErrorCallbac. This is the callback which will be called when a <a class="el" href="structrt_1_1StreamError.html" title="This struct contains the errorCode given by de device when some command fail and the associated Error...">StreamError</a> occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a160e7929d069773d59940e8b9e50dce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160e7929d069773d59940e8b9e50dce6">&#9670;&nbsp;</a></span>unloadCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt::IRuntime::unloadCode </td>
          <td>(</td>
          <td class="paramtype">KernelId&#160;</td>
          <td class="paramname"><em>kernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unloads a previously loaded elf code, identified by the kernel handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel</td><td>a handler to the code that must be unloaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51538d6474b88062aba71ff8d8c959a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51538d6474b88062aba71ff8d8c959a2">&#9670;&nbsp;</a></span>waitForEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rt::IRuntime::waitForEvent </td>
          <td>(</td>
          <td class="paramtype">EventId&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::seconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::hours(24)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This will block the caller thread until the given event is dispatched or the timeout is reached. This primitive allows to synchronize with the device execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>is the event to wait for, result of a memcpy operation or a kernel launch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>is the number of seconds to wait till aborting the wait. If timeout is 0 seconds, then it won't block in any case.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the timeout is reached, true otherwise. </dd></dl>

</div>
</div>
<a id="a83b06e67256ef740f73b2019f78974f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b06e67256ef740f73b2019f78974f1">&#9670;&nbsp;</a></span>waitForStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rt::IRuntime::waitForStream </td>
          <td>(</td>
          <td class="paramtype">StreamId&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::seconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::hours(24)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This will block the caller thread until all commands issued to the given stream finish or if the timeout is reached. This primitive allows to synchronize with the device execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>this is the stream to synchronize with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>is the number of seconds to wait till aborting the wait. If timeout is 0 seconds, then it won't block in any case.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the timeout is reached, true otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/dredok/sw-platform/host-software/esperanto-tools-libs/include/runtime/<a class="el" href="IRuntime_8h_source.html">IRuntime.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
