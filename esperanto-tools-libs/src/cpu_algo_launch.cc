#include <string.h>
#include <map>
#include "cpu_algo.h"
#include "utils.h"
#include "demangle.h"

// this file is autogenerated and locate in build directory
#include "kernels_offsets.h"

static const std::map<std::string, size_t> kInternalKernelMap = {
    { "MulBroadcast2Kernel_Float_Float", ETKERNEL_MulBroadcast2Kernel_Float_Float }, // used in kKernelRemapTable
    { "BinAddKernelBroadcast_False_Float_Float", ETKERNEL_BinAddKernelBroadcast_False_Float_Float }, // used in kKernelRemapTable
    { "CopyKernel_Int32", ETKERNEL_CopyKernel_Int32 },
    { "CopyKernel_Int8", ETKERNEL_CopyKernel_Int8 },
    { "SetKernel_Float", ETKERNEL_SetKernel_Float }, // used in kKernelRemapTable
    { "SetKernel_Int32", ETKERNEL_SetKernel_Int32 },
    { "SetKernel_Int8", ETKERNEL_SetKernel_Int8 },
    { "AddKernel_Float", ETKERNEL_AddKernel_Float }, // used in kKernelRemapTable
    { "SubKernel_Float", ETKERNEL_SubKernel_Float },
    { "MaxKernel_Float", ETKERNEL_MaxKernel_Float },
    { "MinKernel_Float", ETKERNEL_MinKernel_Float },
    { "MulKernel_Float", ETKERNEL_MulKernel_Float },
    { "DivKernel_Float", ETKERNEL_DivKernel_Float },
    { "CmpLTEKernel_Float", ETKERNEL_CmpLTEKernel_Float },
    { "CmpEQKernel_Float", ETKERNEL_CmpEQKernel_Float },
    { "PowKernel_Float", ETKERNEL_PowKernel_Float },
    { "SelectKernel_Float", ETKERNEL_SelectKernel_Float },
    { "LogKernel_Float", ETKERNEL_LogKernel_Float },
    { "QuantizeKernel", ETKERNEL_QuantizeKernel },
    { "DequantizeKernel", ETKERNEL_DequantizeKernel },
    { "RescaleQuantizedKernel", ETKERNEL_RescaleQuantizedKernel },
    { "SigmoidKernel_Float", ETKERNEL_SigmoidKernel_Float }, // used in kKernelRemapTable
    { "TanhKernel_Float", ETKERNEL_TanhKernel_Float },
    { "Sgemm_v2", ETKERNEL_Sgemm_v2 },
    { "MatMulTensor", ETKERNEL_MatMulTensor },
    { "MatMulTensorInt8To32", ETKERNEL_MatMulTensorInt8To32 },
    { "QuantizedMatMul", ETKERNEL_QuantizedMatMul },
    { "ConvTailNHWC_Float", ETKERNEL_ConvTailNHWC_Float },
    { "ConvTailNHWC_Int8Q", ETKERNEL_ConvTailNHWC_Int8Q },
    { "ConvolutionForward_Float", ETKERNEL_ConvolutionForward_Float },
    { "ConvolutionForward_Int8Q", ETKERNEL_ConvolutionForward_Int8Q },
    { "BatchNormalizationForwardInference_Float", ETKERNEL_BatchNormalizationForwardInference_Float },
    { "AddTensor_Float", ETKERNEL_AddTensor_Float },
    { "SoftmaxForward_Instance_Float", ETKERNEL_SoftmaxForward_Instance_Float },
    { "SoftmaxForward_Channel_Float", ETKERNEL_SoftmaxForward_Channel_Float },
    { "ActivationForward_Sigmoid_Float", ETKERNEL_ActivationForward_Sigmoid_Float },
    { "ActivationForward_Relu_Float", ETKERNEL_ActivationForward_Relu_Float },
    { "ActivationForward_Tanh_Float", ETKERNEL_ActivationForward_Tanh_Float },
    { "PoolingForward_Max_Float", ETKERNEL_PoolingForward_Max_Float },
    { "PoolingForward_AvgIn_Float", ETKERNEL_PoolingForward_AvgIn_Float },
    { "PoolingForward_AvgEx_Float", ETKERNEL_PoolingForward_AvgEx_Float },
    { "PoolingForward_Max_Int8Q", ETKERNEL_PoolingForward_Max_Int8Q },
    { "PoolingForward_AvgIn_Int8Q", ETKERNEL_PoolingForward_AvgIn_Int8Q },
    { "PoolingForward_AvgEx_Int8Q", ETKERNEL_PoolingForward_AvgEx_Int8Q },
    { "TransformTensor_Float", ETKERNEL_TransformTensor_Float },
    { "TransformTensor_Int8", ETKERNEL_TransformTensor_Int8 },
    { "Insert_Float", ETKERNEL_Insert_Float },
    { "Insert_Int64", ETKERNEL_Insert_Int64 },
    { "BatchedAdd", ETKERNEL_BatchedAdd },
    { "QuantizedBatchedAdd", ETKERNEL_QuantizedBatchedAdd },
    { "Gather_Float", ETKERNEL_Gather_Float },
    { "TopK_Float", ETKERNEL_TopK_Float },
    { "LRN_Float", ETKERNEL_LRN_Float },
    { "Splat_Float", ETKERNEL_Splat_Float },
    { "Splat_Int64", ETKERNEL_Splat_Int64 },
    { "Splat_Int32", ETKERNEL_Splat_Int32 },
    { "Splat_Int8", ETKERNEL_Splat_Int8 },
    { "AddKernel_Int8Q", ETKERNEL_AddKernel_Int8Q },
    { "SubKernel_Int8Q", ETKERNEL_SubKernel_Int8Q },
    { "MulKernel_Int8Q", ETKERNEL_MulKernel_Int8Q },
    { "DivKernel_Int8Q", ETKERNEL_DivKernel_Int8Q },
    { "MaxKernel_Int8Q", ETKERNEL_MaxKernel_Int8Q },
    { "MinKernel_Int8Q", ETKERNEL_MinKernel_Int8Q },
};

uintptr_t getBuiltinKernelPcByName(const std::string &kernel_name)
{
    auto it = kInternalKernelMap.find(kernel_name);
    if (it != kInternalKernelMap.end())
    {
        return it->second;
    }

    THROW(join("Unexpected kernel name: ", kernel_name.c_str(), " [", demangle(kernel_name).c_str(), "]"));
}

void cpuLaunch(const std::string &kernel_name, uintptr_t kernel_pc, const std::vector<uint8_t> &args_buff)
{
    switch ( kernel_pc )
    {
      case ETKERNEL_CopyKernel_Int32:
        {
            int32_t count;
            int32_t *src;
            int32_t *dst;
            assert(args_buff.size() == 24);
            memcpy(&count, &args_buff[0], 4);
            memcpy(&src, &args_buff[8], 8);
            memcpy(&dst, &args_buff[16], 8);
            for (int i = 0; i < count; i++) {
                dst[i] = src[i];
            }
        }
        break;
      case ETKERNEL_CopyKernel_Int8:
        {
            int32_t count;
            int8_t *src;
            int8_t *dst;
            assert(args_buff.size() == 24);
            memcpy(&count, &args_buff[0], 4);
            memcpy(&src, &args_buff[8], 8);
            memcpy(&dst, &args_buff[16], 8);
            for (int i = 0; i < count; i++) {
                dst[i] = src[i];
            }
        }
        break;
      case ETKERNEL_SetKernel_Float:
        {
            int len;
            float val;
            float *devPtr;
            assert(args_buff.size() == 16);
            memcpy(&len, &args_buff[0], 4);
            memcpy(&val, &args_buff[4], 4);
            memcpy(&devPtr, &args_buff[8], 8);
            for (int i = 0; i < len; i++) {
                devPtr[i] = val;
            }
        }
        break;
      case ETKERNEL_SetKernel_Int32:
        {
            int len;
            int32_t val;
            int32_t *devPtr;
            assert(args_buff.size() == 16);
            memcpy(&len, &args_buff[0], 4);
            memcpy(&val, &args_buff[4], 4);
            memcpy(&devPtr, &args_buff[8], 8);
            for (int i = 0; i < len; i++) {
                devPtr[i] = val;
            }
        }
        break;
      case ETKERNEL_SetKernel_Int8:
        {
            int len;
            int32_t val;
            int8_t *devPtr;
            assert(args_buff.size() == 16);
            memcpy(&len, &args_buff[0], 4);
            memcpy(&val, &args_buff[4], 4);
            memcpy(&devPtr, &args_buff[8], 8);
            for (int i = 0; i < len; i++) {
                devPtr[i] = (int8_t)val;
            }
        }
        break;
      case ETKERNEL_Splat_Float:
      case ETKERNEL_Splat_Int8:
      case ETKERNEL_Splat_Int32:
      case ETKERNEL_Splat_Int64:
        {
            Splat_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(Splat_KernelArgs_t));
            cpuSplat( &kernel_args);
        }
        break;
      case ETKERNEL_SigmoidKernel_Float:
        {
            int len;
            float *devPtrX;
            float *devPtrY;
            assert(args_buff.size() == 24);
            memcpy(&len, &args_buff[0], 4);
            memcpy(&devPtrX, &args_buff[8], 8);
            memcpy(&devPtrY, &args_buff[16], 8);
            for (int i = 0; i < len; i++) {
                devPtrY[i] = 1. / (1. + exp(-devPtrX[i]));
            }
        }
        break;
      case ETKERNEL_TanhKernel_Float:
        {
            int len;
            float *devPtrX;
            float *devPtrY;
            assert(args_buff.size() == 24);
            memcpy(&len, &args_buff[0], 4);
            memcpy(&devPtrX, &args_buff[8], 8);
            memcpy(&devPtrY, &args_buff[16], 8);
            for (int i = 0; i < len; i++) {
                devPtrY[i] = tanh(devPtrX[i]);
            }
        }
        break;
      case ETKERNEL_MulBroadcast2Kernel_Float_Float:
        {
            float* a;
            float* b;
            float* out;
            int pre;
            int n;
            int post;
            int len;
            assert(args_buff.size() == 36);
            memcpy(&a, &args_buff[0], 8);
            memcpy(&b, &args_buff[8], 8);
            memcpy(&out, &args_buff[16], 8);
            memcpy(&pre, &args_buff[24], 4);
            memcpy(&n, &args_buff[28], 4);
            memcpy(&post, &args_buff[32], 4);
            len = n * pre * post;
            for (int i = 0; i < len; i++) {
                out[i] = a[i] * b[(i / post) % n];
            }
        }
        break;
      case ETKERNEL_BinAddKernelBroadcast_False_Float_Float:
        {
            float* a;
            float* b;
            float* r;
            int pre;
            int n;
            int post;
            int len;
            assert(args_buff.size() == 36);
            memcpy(&a, &args_buff[0], 8);
            memcpy(&b, &args_buff[8], 8);
            memcpy(&r, &args_buff[16], 8);
            memcpy(&pre, &args_buff[24], 4);
            memcpy(&post, &args_buff[28], 4);
            memcpy(&n, &args_buff[32], 4);
            len = n * pre * post;
            for (int i = 0; i < len; i++) {
                r[i] = a[i] + b[(i / post) % n];
            }
        }
        break;
      case ETKERNEL_AddKernel_Float:
        {
            int n;
            float* a;
            float* b;
            float* y;
            assert(args_buff.size() == 32);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&a, &args_buff[8], 8);
            memcpy(&b, &args_buff[16], 8);
            memcpy(&y, &args_buff[24], 8);
            for (int i = 0; i < n; i++) {
                y[i] = a[i] + b[i];
            }
        }
        break;
      case ETKERNEL_SubKernel_Float:
        {
            int n;
            float* a;
            float* b;
            float* y;
            assert(args_buff.size() == 32);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&a, &args_buff[8], 8);
            memcpy(&b, &args_buff[16], 8);
            memcpy(&y, &args_buff[24], 8);
            for (int i = 0; i < n; i++) {
              y[i] = a[i] - b[i];
            }
        }
        break;
      case ETKERNEL_MaxKernel_Float:
        {
            int n;
            float* a;
            float* b;
            float* y;
            assert(args_buff.size() == 32);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&a, &args_buff[8], 8);
            memcpy(&b, &args_buff[16], 8);
            memcpy(&y, &args_buff[24], 8);
            for (int i = 0; i < n; i++) {
                y[i] = (a[i] >= b[i]) ? a[i] : b[i];
            }
        }
        break;
      case ETKERNEL_MinKernel_Float:
        {
            int n;
            float* a;
            float* b;
            float* y;
            assert(args_buff.size() == 32);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&a, &args_buff[8], 8);
            memcpy(&b, &args_buff[16], 8);
            memcpy(&y, &args_buff[24], 8);
            for (int i = 0; i < n; i++) {
                y[i] = (a[i] <= b[i]) ? a[i] : b[i];
            }
        }
        break;
      case ETKERNEL_MulKernel_Float:
        {
            int n;
            float* a;
            float* b;
            float* y;
            assert(args_buff.size() == 32);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&a, &args_buff[8], 8);
            memcpy(&b, &args_buff[16], 8);
            memcpy(&y, &args_buff[24], 8);
            for (int i = 0; i < n; i++) {
                y[i] = a[i] * b[i];
            }
        }
        break;
      case ETKERNEL_DivKernel_Float:
        {
            int n;
            float* a;
            float* b;
            float* y;
            assert(args_buff.size() == 32);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&a, &args_buff[8], 8);
            memcpy(&b, &args_buff[16], 8);
            memcpy(&y, &args_buff[24], 8);
            for (int i = 0; i < n; i++) {
                y[i] = a[i] / b[i];
            }
        }
        break;
      case ETKERNEL_CmpLTEKernel_Float:
        {
            int n;
            float* a;
            float* b;
            float* y;
            assert(args_buff.size() == 32);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&a, &args_buff[8], 8);
            memcpy(&b, &args_buff[16], 8);
            memcpy(&y, &args_buff[24], 8);
            for (int i = 0; i < n; i++) {
                y[i] = (a[i] <= b[i]) ? 1.0f : 0.0f;
            }
        }
        break;
      case ETKERNEL_PowKernel_Float:
        {
            int n;
            float* a;
            float* b;
            float* y;
            assert(args_buff.size() == 32);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&a, &args_buff[8], 8);
            memcpy(&b, &args_buff[16], 8);
            memcpy(&y, &args_buff[24], 8);
            for (int i = 0; i < n; i++) {
                y[i] = powf(a[i], b[i]);
            }
        }
        break;
      case ETKERNEL_SelectKernel_Float:
        {
            int n;
            float* a;
            float* b;
            float* cond;
            float* y;
            assert(args_buff.size() == 40);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&a, &args_buff[8], 8);
            memcpy(&b, &args_buff[16], 8);
            memcpy(&cond, &args_buff[24], 8);
            memcpy(&y, &args_buff[32], 8);

            for (int i = 0; i < n; i++) {
                y[i] = (cond[i] != 0.0f) ? a[i] : b[i];
            }
        }
        break;
      case ETKERNEL_LogKernel_Float:
        {
            int n;
            float* x;
            float* y;
            assert(args_buff.size() == 24);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&x, &args_buff[8], 8);
            memcpy(&y, &args_buff[16], 8);

            for (int i = 0; i < n; i++) {
                y[i] = logf(x[i]);
            }
        }
        break;
      case ETKERNEL_QuantizeKernel:
        {
            int n;
            float* x;
            int8_t* y;
            float scale;
            int32_t offset;
            assert(args_buff.size() == 32);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&x, &args_buff[8], 8);
            memcpy(&y, &args_buff[16], 8);
            memcpy(&scale, &args_buff[24], 4);
            memcpy(&offset, &args_buff[28], 4);

            for (int i = 0; i < n; i++) {
                y[i] = quantization::quantize(x[i], scale, offset);
            }
        }
        break;
      case ETKERNEL_DequantizeKernel:
        {
            int n;
            int8_t* x;
            float* y;
            float scale;
            int32_t offset;
            assert(args_buff.size() == 32);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&x, &args_buff[8], 8);
            memcpy(&y, &args_buff[16], 8);
            memcpy(&scale, &args_buff[24], 4);
            memcpy(&offset, &args_buff[28], 4);

            for (int i = 0; i < n; i++) {
                y[i] = quantization::dequantize(x[i], scale, offset);
            }
        }
        break;
      case ETKERNEL_RescaleQuantizedKernel:
        {
            int n;
            int8_t* x;
            int8_t* y;
            float xScale;
            int32_t xOffset;
            float yScale;
            int32_t yOffset;
            assert(args_buff.size() == 40);
            memcpy(&n, &args_buff[0], 4);
            memcpy(&x, &args_buff[8], 8);
            memcpy(&y, &args_buff[16], 8);
            memcpy(&xScale, &args_buff[24], 4);
            memcpy(&xOffset, &args_buff[28], 4);
            memcpy(&yScale, &args_buff[32], 4);
            memcpy(&yOffset, &args_buff[36], 4);

            for (int i = 0; i < n; i++) {
                float val = quantization::dequantize(x[i], xScale, xOffset);
                y[i] = quantization::quantize(val, yScale, yOffset);
            }
        }
        break;
      case ETKERNEL_Sgemm_v2:
        {
            Sgemm_v2_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuSgemm_v2(&kernel_args);
        }
        break;
      case ETKERNEL_MatMulTensor:
        {
            MatMulTensor_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuMatMulTensor(&kernel_args);
        }
        break;
      case ETKERNEL_MatMulTensorInt8To32:
        {
            MatMulTensorInt8To32_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuMatMulTensorInt8To32(&kernel_args);
        }
        break;
      case ETKERNEL_QuantizedMatMul:
        {
            QuantizedMatMul_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuQuantizedMatMul(&kernel_args);
        }
        break;
      case ETKERNEL_ConvTailNHWC_Float:
        {
            ConvTailNHWC_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuConvTailNHWC_Float(&kernel_args);
        }
        break;
      case ETKERNEL_ConvTailNHWC_Int8Q:
        {
            ConvTailNHWC_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuConvTailNHWC_Int8Q(&kernel_args);
        }
        break;
      case ETKERNEL_ConvolutionForward_Float:
      case ETKERNEL_ConvolutionForward_Int8Q:
        {
            ConvolutionForward_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuConvolutionForward(&kernel_args);
        }
        break;
      case ETKERNEL_BatchNormalizationForwardInference_Float:
        {
            BatchNormalizationForwardInference_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuBatchNormalizationForwardInference(&kernel_args);
        }
        break;
      case ETKERNEL_AddTensor_Float:
        {
            AddTensor_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuAddTensor(&kernel_args);
        }
        break;
      case ETKERNEL_SoftmaxForward_Instance_Float:
      case ETKERNEL_SoftmaxForward_Channel_Float:
        {
            SoftmaxForward_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuSoftmaxForward( &kernel_args);
        }
        break;
      case ETKERNEL_ActivationForward_Sigmoid_Float:
      case ETKERNEL_ActivationForward_Relu_Float:
      case ETKERNEL_ActivationForward_Tanh_Float:
        {
            ActivationForward_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuActivationForward(&kernel_args);
        }
        break;
      case ETKERNEL_PoolingForward_Max_Float:
      case ETKERNEL_PoolingForward_AvgIn_Float:
      case ETKERNEL_PoolingForward_AvgEx_Float:
      case ETKERNEL_PoolingForward_Max_Int8Q:
      case ETKERNEL_PoolingForward_AvgIn_Int8Q:
      case ETKERNEL_PoolingForward_AvgEx_Int8Q:
        {
            PoolingForward_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuPoolingForward(&kernel_args);
        }
        break;
      case ETKERNEL_TransformTensor_Float:
      case ETKERNEL_TransformTensor_Int8:
        {
            TransformTensor_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuTransformTensor( &kernel_args);
        }
        break;
      case ETKERNEL_Insert_Float:
      case ETKERNEL_Insert_Int64:
        {
            Insert_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuInsert( &kernel_args);
        }
        break;
      case ETKERNEL_BatchedAdd:
        {
            BatchedAdd_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuBatchedAdd( &kernel_args);
        }
        break;
      case ETKERNEL_QuantizedBatchedAdd:
        {
            QuantizedBatchedAdd_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuQuantizedBatchedAdd( &kernel_args);
        }
        break;
      case ETKERNEL_Gather_Float:
        {
            Gather_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuGather( &kernel_args);
        }
      break;
      case ETKERNEL_TopK_Float:
        {
            TopK_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuTopK( &kernel_args);
        }
        break;
      case ETKERNEL_LRN_Float:
        {
            LRN_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuLRN( &kernel_args);
        }
        break;
      case ETKERNEL_AddKernel_Int8Q:
      case ETKERNEL_SubKernel_Int8Q:
      case ETKERNEL_MulKernel_Int8Q:
      case ETKERNEL_DivKernel_Int8Q:
      case ETKERNEL_MaxKernel_Int8Q:
      case ETKERNEL_MinKernel_Int8Q:
        {
            QuantizedArithOp_KernelArgs_t kernel_args;
            memcpy(&kernel_args, &args_buff[0], sizeof(kernel_args));
            cpuQuantizedArithOp(&kernel_args);
        }
        break;
      default:
        THROW(join("No software implementation of kernel: ", kernel_name.c_str(), " [", demangle(kernel_name).c_str(), "]"));
    }
}
