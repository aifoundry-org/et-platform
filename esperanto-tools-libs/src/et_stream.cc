#include <memory.h>
#include <stdio.h>
#include <assert.h>
#include <math.h>
#include "et_stream.h"
#include "utils.h"
#include "demangle.h"
#include "cpu_algo.h"

#define INCLUDE_FOR_HOST
#include "../kernels/etlibdevice.h"
#include "../kernels/sys_inc.h"
#undef INCLUDE_FOR_HOST

// these files are autogenerated and locate in build directory
#include "kernels_offsets.h"
//#include "kernels_cdescr.inc"
//#include "bootrom_cdescr.inc"
#include "et_bootrom.h"

EXAPI bool static_kernels = false;

void EtActionEvent::execute(CardProxy *card_proxy)
{
    std::lock_guard<std::mutex> lk(observer_mutex);
    executed = true;
    observer_cond_var.notify_all();
}

void EtActionEvent::observerWait()
{
    std::unique_lock<std::mutex> lk(observer_mutex);
    observer_cond_var.wait(lk, [this]{return this->executed;});
    //EtAction::decRefCounter(this);
}

void EtActionConfigure::execute(CardProxy *card_proxy)
{
    if (!card_proxy) // i.e. local mode
    {
        res_is_local_mode = true;
        return;
    }

    cpDefineDevMem(card_proxy, LAUNCH_PARAMS_AREA_BASE, LAUNCH_PARAMS_AREA_SIZE, false);
    cpDefineDevMem(card_proxy, BLOCK_SHARED_REGION, BLOCK_SHARED_REGION_TOTAL_SIZE, false);

    // Stack regions in glow fw defined in fw_common.h
    // M-mode stack: 2^9 bytes/thread * 64 threads/shire * 33 shires
    cpDefineDevMem(card_proxy, 0x8000300000ULL, 0x108000, false);
    // S-mode stack: 2^9 bytes/thread * 64 threads/shire * 33 shires
    cpDefineDevMem(card_proxy, 0x8000408000ULL, 0x108000, false);

    // Contains the kernel launch parameters for both running with runtime and net_desc (FW_SCODE_KERNEL_INFO in fw_common.h)
    cpDefineDevMem(card_proxy, 0x8200000000ULL, 64, false);

    // Scratch area to share information when MM sends an IPI to Compute Minions (FW_SCODE_IPI_INFO in fw_common.h)
    cpDefineDevMem(card_proxy, 0x8000600000ULL, 64, false);

    const void *bootrom_file_p = *(etrtGetEtBootrom());
    size_t bootrom_file_size = *(etrtGetEtBootromSize());

    // Copy the bootrom/firmware
    cpDefineDevMem(card_proxy, BOOTROM_START_IP, align_up(bootrom_file_size, 0x1000), true);
    cpWriteDevMem(card_proxy, BOOTROM_START_IP, bootrom_file_size, bootrom_file_p);

    // "Wake-up" minions (init_pc and trap_pc are not used)
    cpBoot(card_proxy, 0, 0);
}

void EtActionRead::execute(CardProxy *card_proxy)
{
    if (!card_proxy) // i.e. local mode
    {
        memcpy(dstHostPtr, srcDevPtr, count);
        return;
    }

    cpReadDevMem(card_proxy, (uintptr_t)srcDevPtr, count, dstHostPtr);
}

void EtActionWrite::execute(CardProxy *card_proxy)
{
    if (!card_proxy) // i.e. local mode
    {
        memcpy(dstDevPtr, srcHostPtr, count);
        return;
    }

    cpWriteDevMem(card_proxy, (uintptr_t)dstDevPtr, count, srcHostPtr);
}

void EtActionLaunch::execute(CardProxy *card_proxy)
{
    fprintf(stderr, "Going to execute kernel {0x%lx} %s [%s] grid_dim=(%d,%d,%d) block_dim=(%d,%d,%d)\n",
            kernel_pc, kernel_name.c_str(), demangle(kernel_name).c_str(),
            gridDim.x, gridDim.y, gridDim.z, blockDim.x, blockDim.y, blockDim.z);

    if (kernel_pc == 0) {
        // this is for builtin kernels (calling kernel by name, i.e. kernel_pc == 0)
        kernel_pc = getBuiltinKernelPcByName(kernel_name);
    }

    if (!card_proxy) // i.e. local mode
    {
        cpuLaunch(kernel_name, kernel_pc, args_buff);
        return;
    }

    // Contains the kernel launch parameters for both running with runtime and net_desc (FW_SCODE_KERNEL_INFO in fw_common.h)
    cpWriteDevMem(card_proxy, 0x8200000000ULL + 2 * sizeof(uint64_t), args_buff.size(), &args_buff[0]);

    //b4c hack
    if(static_kernels)
      cpLaunch(card_proxy, ETSOC_launch); //b4c - precompiled kernels
    else
      cpLaunch(card_proxy, kernel_pc); //ETSOC backend - JIT, not covered by b4c
}

void EtStream::init()
{
    //fprintf(stderr, "Hello from EtStream::init()\n");
}
