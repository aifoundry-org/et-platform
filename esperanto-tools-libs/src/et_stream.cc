#include <memory.h>
#include <stdio.h>
#include <assert.h>
#include <math.h>
#include <inttypes.h>
#include "et_stream.h"
#include "utils.h"
#include "demangle.h"
#include "cpu_algo.h"

#define INCLUDE_FOR_HOST
#include "../kernels/etlibdevice.h"
#include "../kernels/sys_inc.h"
#undef INCLUDE_FOR_HOST

// these files are autogenerated and locate in build directory
#include "kernels_offsets.h"
//#include "kernels_cdescr.inc"
//#include "bootrom_cdescr.inc"
#include "et_bootrom.h"

// Scratch area to share information when MM sends an IPI to Compute Minions
#define FW_KERNEL_LAUNCH_IPI_INFO  0x8000600000ULL
// Address where the host will place the kernel launch information (synced with fw_common.h)
#define RT_HOST_KERNEL_LAUNCH_INFO 0x8200000000ULL

EXAPI bool static_kernels = false;

void EtActionEvent::execute(CardProxy *card_proxy)
{
    std::lock_guard<std::mutex> lk(observer_mutex);
    executed = true;
    observer_cond_var.notify_all();
}

void EtActionEvent::observerWait()
{
    std::unique_lock<std::mutex> lk(observer_mutex);
    observer_cond_var.wait(lk, [this]{return this->executed;});
    //EtAction::decRefCounter(this);
}

void EtActionConfigure::execute(CardProxy *card_proxy)
{
    if (!card_proxy) // i.e. local mode
    {
        res_is_local_mode = true;
        return;
    }

    cpDefineDevMem(card_proxy, LAUNCH_PARAMS_AREA_BASE, LAUNCH_PARAMS_AREA_SIZE, false);
    cpDefineDevMem(card_proxy, BLOCK_SHARED_REGION, BLOCK_SHARED_REGION_TOTAL_SIZE, false);

    // Stack regions in glow fw defined in fw_common.h
    // M-mode stack: 2^9 bytes/thread * 64 threads/shire * 33 shires
    cpDefineDevMem(card_proxy, 0x8000300000ULL, 0x108000, false);
    // S-mode stack: 2^9 bytes/thread * 64 threads/shire * 33 shires
    cpDefineDevMem(card_proxy, 0x8000408000ULL, 0x108000, false);

    // Contains the kernel launch parameters for both running with runtime and net_desc
    cpDefineDevMem(card_proxy, RT_HOST_KERNEL_LAUNCH_INFO, 1024, false);

    // Scratch area to share information when MM sends an IPI to Compute Minions
    cpDefineDevMem(card_proxy, FW_KERNEL_LAUNCH_IPI_INFO, 1024, false);

    const void *bootrom_file_p = *(etrtGetEtBootrom());
    size_t bootrom_file_size = *(etrtGetEtBootromSize());

    // Copy the bootrom/firmware
    cpDefineDevMem(card_proxy, BOOTROM_START_IP, align_up(bootrom_file_size, 0x1000), true);
    cpWriteDevMem(card_proxy, BOOTROM_START_IP, bootrom_file_size, bootrom_file_p);

    // "Wake-up" minions
    cpBoot(card_proxy);
}

void EtActionRead::execute(CardProxy *card_proxy)
{
    if (!card_proxy) // i.e. local mode
    {
        memcpy(dstHostPtr, srcDevPtr, count);
        return;
    }

    cpReadDevMem(card_proxy, (uintptr_t)srcDevPtr, count, dstHostPtr);
}

void EtActionWrite::execute(CardProxy *card_proxy)
{
    if (!card_proxy) // i.e. local mode
    {
        memcpy(dstDevPtr, srcHostPtr, count);
        return;
    }

    cpWriteDevMem(card_proxy, (uintptr_t)dstDevPtr, count, srcHostPtr);
}

void EtActionLaunch::execute(CardProxy *card_proxy)
{
    const layer_dynamic_info *params = (const layer_dynamic_info *)args_buff.data();

    fprintf(stderr,
            "Going to execute kernel {0x%lx} %s [%s]\n"
            "  tensor_a = 0x%" PRIx64 "\n"
            "  tensor_b = 0x%" PRIx64 "\n"
            "  tensor_c = 0x%" PRIx64 "\n"
            "  tensor_d = 0x%" PRIx64 "\n"
            "  tensor_e = 0x%" PRIx64 "\n"
            "  tensor_f = 0x%" PRIx64 "\n"
            "  tensor_g = 0x%" PRIx64 "\n"
            "  tensor_h = 0x%" PRIx64 "\n"
            "  pc/id    = 0x%" PRIx64 "\n",
            kernel_pc, kernel_name.c_str(), demangle(kernel_name).c_str(),
            params->tensor_a, params->tensor_b, params->tensor_c,
            params->tensor_d, params->tensor_e, params->tensor_f,
            params->tensor_g, params->tensor_h, params->kernel_id);

    if (kernel_pc == 0) {
        // this is for builtin kernels (calling kernel by name, i.e. kernel_pc == 0)
        kernel_pc = getBuiltinKernelPcByName(kernel_name);
    }

    if (!card_proxy) // i.e. local mode
    {
        cpuLaunch(kernel_name, kernel_pc, args_buff);
        return;
    }

    //b4c hack
    if(static_kernels)
      cpLaunch(card_proxy, ETSOC_launch, params); //b4c - precompiled kernels
    else
      cpLaunch(card_proxy, kernel_pc, params); //ETSOC backend - JIT, not covered by b4c
}

void EtStream::init()
{
    //fprintf(stderr, "Hello from EtStream::init()\n");
}
