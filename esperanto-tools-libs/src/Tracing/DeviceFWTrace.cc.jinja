/*------------------------------------------------------------------------------
 * Copyright (C) 2020, Esperanto Technologies Inc.
 * The copyright to the computer program(s) herein is the
 * property of Esperanto Technologies, Inc. All Rights Reserved.
 * The program(s) may be used and/or copied only with
 * the written permission of Esperanto Technologies and
 * in accordance with the terms and conditions stipulated in the
 * agreement/contract under which the program(s) have been supplied.
 ------------------------------------------------------------------------------ */

// WARNING: this file is auto-generated do not edit directly

#include "Tracing/Tracing.h"
#include "Tracing/TracingHelpers.h"
#include "TracingCommonGen.h"
#include "esperanto/runtime/Support/Logging.h"

#include <esperanto/device-api/device_api_cxx_non_privileged.h>
#include <memory>
#include <thread>

using namespace et_runtime::device_api;
namespace et_runtime {
namespace tracing {

int DeviceAPI_DeviceFW_process_device_traces(uint8_t *trace_buffers,
                                             size_t buffer_size,
                                             uint32_t num_of_buffers) {
  size_t tail;
  size_t head;
  uint8_t *trace_buffer;
  ::device_api::non_privileged::buffer_header_t *buffer_hdr;
  ::device_api::non_privileged::message_header_t *msg_hdr;

  for (uint32_t i = 0; i < num_of_buffers; i++) {
    trace_buffer = trace_buffers + buffer_size * i;
    buffer_hdr = (::device_api::non_privileged::buffer_header_t *)trace_buffer;
    tail = buffer_hdr->tail;
    head = buffer_hdr->head;

    while (tail != head) {
      auto trace_hdr = new DeviceAPI_trace_hdr();
      trace_hdr->set_hartid(buffer_hdr->hart_id);
      msg_hdr = (::device_api::non_privileged::message_header_t *)(&(buffer_hdr->buffer[tail]));
      trace_hdr->set_device_timestamp_mtime(msg_hdr->mtime);

      switch (msg_hdr->event_id) {
      case ::device_api::non_privileged::TRACE_EVENT_ID_NONE: {
        // Buffer overflow condition, reset tail
        tail = 0;
        break;
      }
<%- for module in spec['DeviceAPI']['Modules'] -%>
  <%- if module['Name'] == "DeviceFWTracing" %>
    <%- for group in module['TraceGroups'] %>
      <%- for trace in group.get("Events", []) %>
      case ::device_api::non_privileged::TRACE_EVENT_ID_<< group["Name"] | upper >>_<< trace["Name"] | upper >>: {
        ::device_api::non_privileged::trace_<< trace["Name"] >>_t *trace_<< trace["Name"] >> =
            (::device_api::non_privileged::trace_<< trace["Name"] >>_t *)msg_hdr;
        <%- if group["Name"] == "Text" %>
          <%- set str_name = cgh.get_field_from_type(trace, "bytes") %>
        std::vector<uint8_t> << str_name >>(trace_<< trace["Name"] >>-><< str_name >>,
            trace_<< trace["Name"] >>-><< str_name >> + trace_<< trace["Name"] >>->size);
        <%- endif %>

        TRACE_DeviceAPI_DeviceFWTracing_<< trace["Name"] >>(trace_hdr,
        <%- for field in trace.get("Fields", []) %>
          <%- if field["Type"] == "bytes" %>
            << field["Name"] >><< "," if not loop.last >>
          <%- else %>
            trace_<< trace["Name"] >>-><< field["Name"] >><< "," if not loop.last >>
          <%- endif %>
        <%- endfor %>);

        <%- if group["Name"] == "Text" %>
        tail += ALIGN(offsetof(::device_api::non_privileged::trace_<< trace["Name"] >>_t,
                << str_name >>) + trace_<< trace["Name"]>>->size, 8);
        <%- else %>
        tail += sizeof(::device_api::non_privileged::trace_<< trace["Name"] >>_t);
        <%- endif %>
        break;
      }
      <%- endfor %>
    <%- endfor %>
  <%- endif %>
<%- endfor %>
      default:
        RTERROR  <% raw %> << <% endraw %> "Invalid event id:" <% raw %> << <% endraw %> msg_hdr->event_id <% raw %> << <% endraw %> "\n";
        return ::device_api::non_privileged::TRACE_STATUS_INVALID_VAL;
      }
    }
  }
  return ::device_api::non_privileged::TRACE_STATUS_SUCCESS;
}

} // namespace tracing
} // namespace et_runtime
