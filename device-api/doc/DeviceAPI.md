Device API Infrastructure  {#device_api_infra_ref}
=========================

## Problem Statement

We need to define a high-level "DSL" that will describe the schema of the messages
that we are going to be exchanging the between the host and the device. From the schema
description we will auto-generate code that will encapsulate the message body with a predefined
message header that will allow us to de-serialize the message either on the device or the host.

The target languages that the messages need to be serialized/de-serialized from are:
* C that we are going to be running on the Device Firmware
* C++ that we will be using in the host run-time
* Python that will be used for generic tracing tooling, debugging and testing infrastructure.

## Limitations And Design Requirements:

We do have considered other other similar infrastructures, like [Protocol Buffers](https://developers.google.com/protocol-buffers/) and [FlatbBuffers](https://google.github.io/flatbuffers)

We have decided to go with a custom version of Flatbuffers where we use the Flatbuffers-DSL
for describing the message schema, but we use raw data without any schema information included
to reduce any encoding/decoding overheads.

### Required Features

Unlike ProtoBuffs which are designed to support more complicated schemas we can restrict
our use-cases to a small subset of combinations of structs, arrays etc. Also we do not need
features like compression etc

From our side we need to be able to express:
* Enums
* All basic integer types
* Records
* Static sized arrays of primitive types or records
* Dynamic sized arrays that are located only at the end of the record


### Performance Overhead

The minion-core that the device-firmware will be running has no branch predictor and is not
considered to be performant. We do not want to be spending too much time trying to decode
the commands we receive. Ideally we just want to cast the raw data to the appropriate type.

Thus we replace the original Flatbuffers format with raw-data that has no encode/decode
overhead. This format is no binary-compatible with the original Flatbuffers one. We will
create a converter to convert our raw data-traces to FlatBuffers so that the traces can be
proccesed by Python/Go and other tools.

If in the future we prove that the sustain the cost of the original Flatbuffers format we will
switch to that.

### Dynamic Memory Allocation

The original FlatBuffers does [dynamic memory allocation](https://google.github.io/flatbuffers/flatbuffers_benchmarks.html) when decoding the message.

Currently the device-firmware is bare-metal code without heap support and the raw format we
will use does not have such requirement.

### Fall Back Solution

As mentioned once we overcome in the future the performance and memory requiremes of the
original Flatbuffers implementation we will drop our custom raw format.

## Types Of Messages

We have 3 types of messages:

* __Commands__ : A command to the device, all commands are specified under \ref ETDeviceAPI::Commands

* __Responses__ : A response to a specific command \ref ETDeviceAPI::Responses

* __Events__ : A asynchronous event generated by the device \ref ETDeviceAPI::Events

## Message Format

The messages that we are going to be exchanging between the host and the device are
going to have the following header \todo reference header:

|  Field      | Size      |
|:-----------:|:---------:|
| MessageType | uint8_t   |
| MessageID   | uint16_t  |
| Stream-ID   | uint64_t  |
| TimeStamp   | uint64_t  |
| Sequence-ID | uint64_t  |
| Payload     |  ?        |


The header has to be included by the user for all message defintions in the user specified
schema of each command/response/event is appended as the Payload of the message.

The fields of the header are:

* __MessageType__ : This is the type of the that can be either a:
  * Command : A command to the device.
  * Response : Repsonse to a device command.
  * Event : Any anychronous event that the device can generate and needs to notify the Host.

* __MessageID__ : ID of the message that will be used to decode the type of Command, Repsonse
and Event.

* __Stream-ID__: This is the unique Host-Userspace Stream-ID issuing the command to the
device. The device in its response for a command should populate the corresponding context-id
so that the user space run-time can match it back to the original command. In our Device we need
to be able to support in the future having multiple different stream-IDs sending commands that
will be executing in parallel by our device.

* __TimeStamp__: RTC value from the host/device to be used as a preliminary performance
debugging mechanism in order to estimate the round-trip latency of specific commands
\todo Do we have a synchronized clock across host and device ?

* __Sequence-ID__: Unique sequence ID of the command for this specific stream. This is
provisional for handling on the host the case that the device answers commands out-of-order.
E.g. The host could be executing a kernel but also want to query the state of the device, a
which case the query of the state should not be blocked by the kernel execution.

* __Payload__: This is the body of the message as specified in the message schema.


## Message Definition DSL

The DSL we are going to use is derived from FlatBuffers and will support the following:

* Include existing headers that define primitive types to enable re-use of code
* Define Enums
* Use all primitive int types/bool/char
* Structs
* Nested Structs
* Static size arrays of primitive types and structs
* Variable arrays only at the end of the record.
* C++11 struct-field default values

Comments should start with "///" so that they are trancoded verbatim
to the code and can be picked up by Doxygen.

Example:

    /// Common header of all messages exchanged by the DeviceAPI
    struct MessageHeader {
      message_type:MessageType;
      command_id:CommandID;
      response_id:ResponseID;
      event_id:EventID;
      time_stamp:uint64;
      stread_id:uint64;
      sequence_id:uint64;
    }

    table DeviceInfoCommand {
       header:MessageHeader;
    }

## Build Flow
\todo Expand this section

------------------

\todo describe API versioning requirements
