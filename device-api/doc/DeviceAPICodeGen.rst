.. _DeviceAPICodeGen:

****************************************
Device API Code Generation Specification
****************************************


Design
=======

Problem Statement
-----------------


We need to define a high-level "DSL" that will describe the schema of the messages
that we are going to be exchanging the between the host and the device. From the schema
description we will auto-generate code that will encapsulate the message body with a predefined
message header that will allow us to de-serialize the message either on the device or the host.

The target languages that the messages need to be serialized/de-serialized from are:

* C that we are going to be running on the Device Firmware
* C++ that we will be using in the host run-time
* Python that will be used for generic tracing tooling, debugging and testing infrastructure.

Limitations And Design Requirements
------------------------------------

We do have considered other other similar infrastructures, like
`Protocol Buffers <https://developers.google.com/protocol-buffers/>`_  and `FlatbBuffers <https://google.github.io/flatbuffers>`_.

We have decided to have our own schema definition using jsonschema and yaml for the specification,
and auto-generate code directly and use plain binary data.

Required Features
^^^^^^^^^^^^^^^^^^

Unlike ProtoBuffs which are designed to support more complicated schemas we can restrict
our use-cases to a small subset of combinations of structs, arrays etc. Also we do not need
features like compression etc

From our side we need to be able to express:

* Enums
* All basic integer types
* Records
* Character strings that are located only at the end of the record


Performance Overhead
^^^^^^^^^^^^^^^^^^^^^

The minion-core that the device-firmware will be running has no branch predictor and is not
considered to be performant. We do not want to be spending too much time trying to decode
the commands we receive. Ideally we just want to cast the raw data to the appropriate type.

Thus we replace the original Flatbuffers format with raw-data that has no encode/decode
overhead. This format is no binary-compatible with the original Flatbuffers one. We will
create a converter to convert our raw data-traces to FlatBuffers so that the traces can be
proccesed by Python/Go and other tools.

If in the future we prove that the sustain the cost of the original Flatbuffers format we will
switch to that.

Dynamic Memory Allocation
"""""""""""""""""""""""""

Currently the device-firmware is bare-metal code without heap support and the raw format we
will use does not have such requirement.


High-Level description
-----------------------

API defined between Host Espernato Runtime library and the Device-Minion-Runtime that runs on Master Minion.

It contains to groups of messages:

RPC Messages
^^^^^^^^^^^^

RPC messages enables us to implement RPC calls between the host and the device in a blocking
fashion, or be able to Stream messages from the device to the host.

* Commands the host can send the the device

* Responses from the respective device to an original command

* Events (i.e. errors) that can be generated by the device to the host, those are stream messages
  from the device to the host that do not have a corresponding Command.

Tracing/Logging Messages
^^^^^^^^^^^^^^^^^^^^^^^^

This set of messages describe the binary data that we can have in the binary logs we extract from
the device in the host. The binary data are organized in messages of different types and are stored
in a ring buffer that the runtime is going to be pulling from the device.


The host will be responsible for converting the binary data to other formats (protobuf binary trace or json or text)


What is the Device-API
----------------------

The Device API infrastructure's goals currently are:

* Define the top-level schema of the messages at a high level regardless of the underlying
  target implementation (binary, protobuf, flatbuffers)

    * We need such a schema so that we can auto-generate other parts of the code beyond
      the encoding/decoding of the messages: e.g. knobs to turn on/off logging

* Version the messages and check for compatibility between host and device

* The current implementation targets a binary data-format that requires little effort to enable
  in device-fw (written in C no dynamic memory yet)

What it is not the Device-API
-----------------------------

* A generic data serialization/de-serialization mechanism
* It is not here to replace protobuf

  * The goal is to enable us to make progress and retarget the implementation in the future if we decide so

  * It has restrictions that try to simplify the implementations and any added complexity
    will need to be clearly justified. If higher complexity is required then we should re-eveluate.


.. _DeviceAPIVersioning:

Device API Versioning
---------------------

The DeviceAPI is the API between the host and the device and is versioned

* Using explicit `Sem-Versioning <https://semver.org/>`_
* Using the hash of the schema-data. This is used to validate/debug that we indeed use the same data for the API

Sem-Version Change Rules
^^^^^^^^^^^^^^^^^^^^^^^^^

Currently the underlying implementation of the API is binary, as such the SemVersion
of the DeviceAPI needs to change every time we make non-backwards compatible in the output binary format.

1. Any change that modifies the binary message format in a non backward compatible way,
   should introduce a new major version of the API

  * Re-arranging the fields of a message/embedded-struct
  * Deleting existing messages
  *  Deleting fields of a struct or a message
  *  Adding fields in the middle of a message
  *  Adding fields to a struct that itself is a field in the middle of a message
  *  Deleting members of an enumeration

2. Minor Number changes should be done 1when

   * Adding a new message, struct, enum
   * Append new fields to a message

3. Patch Number changes should be done when:
   * Bug fixes to the underlying implementation or helper code

Handling Mismatching API Versions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


.. todo::

   How should the runtime and device-fw handle a version mismatch ?


Current approach
""""""""""""""""

if the sem-version and the schema-hash do not match then raise an error
Product

In the future we should allow the runtime library to interact with a device-fw where the sem-version does not match

The rules are:

* Major Version difference should result to an error
* Minor and Patch versions should be able to be handled by the runtime library.

It is the responsibility of the host Espseranot Runtime to maintain backward compatibility for minor/patch
versions and raise an error if it does not support them.



Implementation Details
=======================

Types Of Messages
------------------

* Common header: :class:`common_header_t`
  Common header that is the same across all types of messages

* Commands header: :class:`command_header_t`
  Header of a Command

* Responses header: :class:`response_header_t`
  Header of a Response. Note that it embeds the header fo the Command that
  it corresponds to.

* Event header: :class:`event_header_t`
  Header of a Event

The headers are followed with the actual message payload that is in binary format.

The payload is auto-generated based on the API-schema

Schema Definition
------------------

The messages are currently defined in a list of YAML files whose entrypoints are the files

*  `src/device-api/rpc-calls.yaml` : Contains all the RPC calls

*  `src/device-api/tracing-events.yaml` : Contains all the  binary-logging events we can record

JSON Schema
-----------

The contents of the schema is validated using the jsonschema defined in  `src/device-api/device-api.schema.json`
to make sure that it has the contents that our code-generation scripts can consume.

Schema Rules/Limitations
^^^^^^^^^^^^^^^^^^^^^^^^

Currently we are able to express the following combinations of types in device-api

* Enums need to have be assigned a specific backing storage type (e.g. uint32)
* Bools are stored as uint8_t
* Structs can only have scalar fields and do not support further nesting of other structs , or arrays
* Arrays are not supported
* Messages can reference structs or enums, and single level nesting is supported
* Fields in structs or messages should be inserted in decreasing size order. This is to guarantee natural
  alignment order of binary structs
* Strings can be inserted only at the end of a logging message.

How To Add A New Message
------------------------

Example  Command And Response ::

   - Name: kernel_launch_cmd
       Description: Launch a kernel on the target
       Type: Command
       Fields:
         - Name: kernel_params
           Type : struct
           Struct: kernel_params_t
         - Name: kernel_info
           Type: struct
           Struct: kernel_info_t
     - Name: kernel_launch_rsp
       Description: Response and result of a kernel launch on the device
       Type: Response
       Fields:
         - Name: kernel_id
           Type: uint64_t
         - Name: error
           Type: enum
           Enum: kernel_launch_error_e

Example binary-log entry ::

  - Name: kernel_launch
    Fields:
      - Name: tensor_a
        Type: uint64_t
      - Name: tensor_b
        Type: uint64_t
      - Name: tensor_c
        Type: uint64_t
      - Name: tensor_d
        Type: uint64_t
      - Name: tensor_e
        Type: uint64_t
      - Name: tensor_f
        Type: uint64_t
      - Name: tensor_g
        Type: uint64_t
      - Name: kernel_id
        Type: uint64_t

Code Generator
--------------

The code is generated using scripts `src/device-api/device_api_codegen.py`

Example CMake invocation of the generetor from : `src/device-api/CMakeLists.txt#L33`::

    add_custom_command(
     OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${GEN_OUTPUT}
     COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/device_api_codegen.py
     ARGS  --spec ${CMAKE_CURRENT_SOURCE_DIR}/device-api.yaml
           --schema ${CMAKE_CURRENT_SOURCE_DIR}/device-api.schema.json
           --template ${CMAKE_CURRENT_SOURCE_DIR}/${TMPL}
           --output ${CMAKE_CURRENT_BINARY_DIR}/${GEN_OUTPUT}
     DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/device_api_codegen.py
             ${DEVICE_API_SCHEMA_FILES}
             ${CMAKE_CURRENT_SOURCE_DIR}/device-api.schema.json
             ${CMAKE_CURRENT_SOURCE_DIR}/${TMPL}
     )


Jinja Example
-------------

The code generator takes as input not only the schema but also a Jinja template with modified delimiters
like the following from file `src/device-api/device_api_types.h.jinja`::

  <% for struct in cgh.structs() -%>
  /// @brief << struct["Description"] >>
  struct << struct["Name"] >> {
    <% for field in struct.get("Fields", []) -%>
    << cgh.message_field_type(field) >>  << field["Name"] >>;
    <% endfor %>
  } __attribute__ ((packed));

  <% endfor %>


Note that we have modified the default Jinja syntax and instead of curly-braces ( "{", "}") used
to delineate the Jinja statents, we are using angle-brackets ("<", ">") instead, to avoid confusion
with the curly-braces used by regular C/C++ code


The above code-generation infrastructure generates :ref:`file_src_device-api_device_api_types.h`
