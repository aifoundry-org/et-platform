/*------------------------------------------------------------------------------
 * Copyright (C) 2019, Esperanto Technologies Inc.
 * The copyright to the computer program(s) herein is the
 * property of Esperanto Technologies, Inc. All Rights Reserved.
 * The program(s) may be used and/or copied only with
 * the written permission of Esperanto Technologies and
 * in accordance with the terms and conditions stipulated in the
 * agreement/contract under which the program(s) have been supplied.
 ------------------------------------------------------------------------------ */

// WARNING: this file is auto-generated do not edit directly

#ifndef ET_DEVICE_API_TRACING_TYPES_<< cgh.c_api_name | upper >>_H
#define ET_DEVICE_API_TRACING_TYPES_<< cgh.c_api_name | upper >>_H

#include "device_api_rpc_types_non_privileged.h"

#include <stdint.h>
#include <stddef.h>

/// @brief Default trace buffer size
#define DEVICE_MRT_DEFAULT_BUFFER_SIZE  4096UL

// Checks if a shire is enabled for tracing
#define SHIRE_ENABLED(shire_mask, shire_id) ((shire_mask >> shire_id) & 1UL)

// Checks if hart is enabled for tracing
#define HART_ENABLED(harts_mask, hart_id)   ((harts_mask >> (hart_id % 64)) && 1UL)

/// @brief Alignemnt requirement for trace buffer region
#define TRACE_BUFFER_REGION_ALIGNEMNT  4096UL

/// @brief Number of trace buffers in trace memory
#define NUMBER_OF_TRACE_BUFFERS         2112UL

#define ALIGN(x, a) (((x) + ((a) - 1)) & ~((a) - 1))

// Trace Enumerations
typedef uint64_t trace_events_e;

/// @brief Supported trace events Enumberation
enum TRACE_EVENTS {
  TRACE_EVENT_ID_NONE = 0, ///< Event ID zero is reserved
<%- for group in cgh.trace_groups() %>
  <%- for trace in group.get("Events", []) %>
  TRACE_EVENT_ID_<< group["Name"] | upper >>_<< trace["Name"] | upper >>, ///< << trace["Description"] >>
  <%- endfor %>
<%- endfor %>
  TRACE_EVENT_ID_LAST, ///< Last event marker
  TRACE_EVENT_ID_OVERFLOW /// Event ID OVERFLOW is reserved
};

typedef uint64_t trace_groups_e;

/// @brief Supported trace groups Enumeration
enum TRACE_GROUPS {
  TRACE_GROUP_ID_NONE = 0, ///< Group ID zero is reserved
<%- for group in cgh.trace_groups() %>
  TRACE_GROUP_ID_<< group["Name"] | upper >>, ///< << group["Description"] >>
<%- endfor %>
  TRACE_GROUP_ID_LAST ///< Last group marker
};

typedef uint32_t trace_status_e;

/// @brief Trace status Enumeration
enum TRACE_STATUS {
  TRACE_STATUS_SUCCESS = 0, ///< Operation successful
  TRACE_STATUS_BUFFER_FULL = 1, ///< Trace buffer is full
  TRACE_STATUS_INVALID_VAL = 2, ///< Invalid argument/field
  TRACE_STATUS_DISABLED = 3, ///< Trace/event/group is disabled
  TRACE_STATUS_LAST ///< Last status marker
};

/// @brief This structure represents trace control region, located at the start of the trace memory.
/// This contains all the trace control knobs used to control tracing for all the minions
struct trace_control_t {
  uint64_t group_knobs[TRACE_GROUP_ID_LAST/(sizeof(uint64_t) * 8) + 1]; ///< Bitmap used for group control knobs
  uint64_t event_knobs[TRACE_EVENT_ID_LAST/(sizeof(uint64_t) * 8) + 1]; ///< Bitmap used for event control knobs
  uint64_t harts_mask; ///< Harts bitmap to enabling tracing for. Same mask for all the harts.
  uint64_t shire_mask; ///< Shires bitmap to enable tracing for.
  log_levels_e log_level; ///< Represent threshold log level, values taken
                          ///< by this field are defined by enum LOG_LEVELS
  uint32_t buffer_size; ///< Per minion buffer size control knob
  uint8_t uart_en; ///< Represents Uart logging On/Off state
  uint8_t trace_en; ///< Represents global trace enable/disable state
};

/// @brief This structure represents buffer header, present at the start of individual trace buffer
struct buffer_header_t {
  uint16_t hart_id; ///< hart-id of the logging thread
  size_t head; ///< Head index of the ring buffer
  size_t tail; ///< Tail index of the ring buffer
  char buffer[]; ///< Flexible array to access ring buffer memory located just after the buffer_header_t
};

/// @brief This structure represents common Event header, present at the start of each trace event
struct message_header_t {
  uint64_t event_id; ///< Event id of the event
  uint64_t mtime; ///< Timestamp on the device size when the event is logged.
};

// The real structures that go into memory
<%- for group in cgh.trace_groups() %>
  <%- for trace in group.get("Events", []) %>

/// @brief The structure represents TRACE_EVENT_ID_<< group["Name"] | upper >>_<< trace["Name"] | upper >> event
struct trace_<< trace["Name"] >>_t {
  struct message_header_t header;
  <%- set dummy = cgh.validate_trace(trace) -%>
  <%- for field in trace.get("Fields", []) %>
    <%- if field["Type"] == "bytes" %>
  size_t size;  ///< Size of the character string
  char << field["Name"] >>[]; ///< << field["Description"] >>
    <%- else %>
  << cgh.message_field_type(field) >>  << field["Name"] >>; ///< << field["Description"] >>
    <%- endif %>
  <%- endfor %>
};
  <%- endfor %>
<%- endfor %>

#endif // ET_DEVICE_API_TRACING_TYPES_<< cgh.c_api_name | upper >>_H
