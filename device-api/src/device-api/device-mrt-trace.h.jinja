/*------------------------------------------------------------------------------
 * Copyright (C) 2019, Esperanto Technologies Inc.
 * The copyright to the computer program(s) herein is the
 * property of Esperanto Technologies, Inc. All Rights Reserved.
 * The program(s) may be used and/or copied only with
 * the written permission of Esperanto Technologies and
 * in accordance with the terms and conditions stipulated in the
 * agreement/contract under which the program(s) have been supplied.
 ------------------------------------------------------------------------------ */

// WARNING: this file is auto-generated do not edit directly

#ifndef ET_DEVICE_MRT_TRACE_GEN_H
#define ET_DEVICE_MRT_TRACE_GEN_H

#include <stdint.h>
#include <stddef.h>
#include "device_api_types.h"
#include "trace_config.h"

#ifdef __cplusplus

#include <ostream>

namespace device_api {
#endif

#define BITS_PER_BYTE                   8UL
#define DEVICE_MRT_DEFAULT_BUFFER_SIZE  4096UL
#define ALIGN(x, a)                     (((x)+((typeof(x))(a)-1))&~((typeof(x))a-1))
#define TRACE_CONTROL_REGION_ALIGNEMNT  4096UL
#define NUMBER_OF_TRACE_BUFFERS         (2112UL)              /* (Minion count) * (Thread count) * (Number of minion shires) */

// Trace event Enum
typedef uint32_t trace_events_e;

enum TRACE_EVENT {
    TRACE_EVENT_ID_NONE = 0,
<%- for trace in cgh.traces() %>
    TRACE_EVENT_ID_<< trace["Group"]>>_<< trace["Name"] | upper >> = << loop.index >>,
<%- endfor %>
    TRACE_EVENT_ID_MAX
};

struct trace_control_region_t {
    uint64_t group_knobs[TRACE_GROUPS_MAX/(sizeof(uint64_t) * BITS_PER_BYTE) + 1];
    struct event_knob_t {
        uint8_t log_level:4;
        uint8_t uart_en:1;
        uint8_t res:3;
    } event_knobs[TRACE_EVENT_ID_MAX];
    uint32_t buffer_size;
};

struct buffer_header_t {
    uint16_t hart_id;
    size_t head;
    size_t tail;
    char buffer[];
};

struct message_head_t {
    uint64_t event_id;
    uint64_t mtime;
};

/* TODO: we need to look into padding constraints, we can same memory here */
<%- for trace in cgh.traces() %>
// The real structure that goes into memory
struct trace_<< trace["Name"] >>_t {
    struct message_head_t header;
  <%- set dummy = cgh.validate_trace(trace) -%>
  <%- for field in trace.get("Fields", []) %>
    <%- if field["Type"] == "bytes" %>
    size_t size;
    char << field["Name"] >>[];
    <%- else %>
    << cgh.message_field_type(field) >>  << field["Name"] >>;
    <%- endif %>
  <%- endfor %>
};
<% endfor %>

#if ENABLE_DEVICEFW_TRACE

// Below logic requires modifications
int trace_init_master(void);
int trace_init_buffer(void);
void evict_trace_buffer(void);
void evict_trace_control(void);

 <%- for trace in cgh.traces() %>
int log_<< trace["Name"] >>(log_levels_e level<%- for field in trace.get("Fields", []) %> <%- if field["Type"] == "bytes" %>, char *msg<%- else %>, << cgh.message_field_type(field) >> << field["Name"] >> <%- endif %> <%- endfor %>);
<%- endfor %>

#else

#define trace_init_master() { \
} while(0);
#define trace_init_buffer() { \
} while(0);
#define evict_trace_buffer() { \
} while(0);
#define evict_trace_control() { \
} while(0);

<%- for trace in cgh.traces() %>
#define log_<< trace["Name"] >>(level<%- for field in trace.get("Fields", []) %> <%- if field["Type"] == "bytes" %>, msg<%- else %>, << field["Name"] >> <%- endif %> <%- endfor %>)  { \
} while(0);
<%- endfor %>

#endif

#ifdef __cplusplus
} // namespace device_api
#endif

#endif // ET_DEVICE_MRT_TRACE_GEN_H
