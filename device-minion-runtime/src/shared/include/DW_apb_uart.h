/*                                                                         */
/* Generated by Semifore, Inc. csrCompile                                  */
/*    Version: 2018.12 Build: release Linux 64-bit                         */
/*    C Header output                                                      */
/*                                                                         */
/* Command Line:                                                           */
/*    /home/cad/tools/semifore/csrCompile/LATEST/bin/x64_re6/csrCompile -v */
/*    -c                                                                   */
/*    /home/eng/dcrowder/esperanto-soc/dv/common/scripts/semifore_css/bitfield_enum_doc.css */
/*    -t h DW_apb_uart.csr -o gen_sw/DW_apb_uart                           */
/*                                                                         */
/* Input files:                                                            */
/*    DW_apb_uart.csr                                                      */
/*                                                                         */
/* Configuration files:                                                    */
/*    /home/eng/dcrowder/esperanto-soc/dv/common/scripts/semifore_css/bitfield_enum_doc.css */
/*                                                                         */
/* Generated on: Thu Feb 28 12:31:47 2019                                  */
/*           by: dcrowder                                                  */
/*                                                                         */

#ifndef _DW_APB_UART_H_
#define _DW_APB_UART_H_

#include <stdint.h>

/* ####################################################################### */
/*        ENUM DEFINITIONS                                                 */
/* ####################################################################### */

/* Enum : uart::CPR::ADDITIONAL_FEAT::ADDITIONAL_FEAT                      */
/* Source filename: DW_apb_uart.csr, line: 3594                            */
typedef enum _uart_CPR_ADDITIONAL_FEAT_ADDITIONAL_FEAT {
   UART_CPR_ADDITIONAL_FEAT_ADDITIONAL_FEAT_DISABLED = 0x0,
   UART_CPR_ADDITIONAL_FEAT_ADDITIONAL_FEAT_ENABLED = 0x1
} Uart_CPR_ADDITIONAL_FEAT_ADDITIONAL_FEAT;

/* Enum : uart::CPR::AFCE_MODE::AFCE_MODE                                  */
/* Source filename: DW_apb_uart.csr, line: 3521                            */
typedef enum _uart_CPR_AFCE_MODE_AFCE_MODE {
   UART_CPR_AFCE_MODE_AFCE_MODE_DISABLED = 0x0,
   UART_CPR_AFCE_MODE_AFCE_MODE_ENABLED = 0x1
} Uart_CPR_AFCE_MODE_AFCE_MODE;

/* Enum : uart::CPR::APB_DATA_WIDTH::APB_DATA_WIDTH                        */
/* Source filename: DW_apb_uart.csr, line: 3492                            */
typedef enum _uart_CPR_APB_DATA_WIDTH_APB_DATA_WIDTH {
   UART_CPR_APB_DATA_WIDTH_APB_DATA_WIDTH_APB_16BITS = 0x1,
   UART_CPR_APB_DATA_WIDTH_APB_DATA_WIDTH_APB_32BITS = 0x2,
   UART_CPR_APB_DATA_WIDTH_APB_DATA_WIDTH_APB_8BITS = 0x0
} Uart_CPR_APB_DATA_WIDTH_APB_DATA_WIDTH;

/* Enum : uart::CPR::DMA_EXTRA::DMA_EXTRA                                  */
/* Source filename: DW_apb_uart.csr, line: 3685                            */
typedef enum _uart_CPR_DMA_EXTRA_DMA_EXTRA {
   UART_CPR_DMA_EXTRA_DMA_EXTRA_DISABLED = 0x0,
   UART_CPR_DMA_EXTRA_DMA_EXTRA_ENABLED = 0x1
} Uart_CPR_DMA_EXTRA_DMA_EXTRA;

/* Enum : uart::CPR::FIFO_ACCESS::FIFO_ACCESS                              */
/* Source filename: DW_apb_uart.csr, line: 3612                            */
typedef enum _uart_CPR_FIFO_ACCESS_FIFO_ACCESS {
   UART_CPR_FIFO_ACCESS_FIFO_ACCESS_DISABLED = 0x0,
   UART_CPR_FIFO_ACCESS_FIFO_ACCESS_ENABLED = 0x1
} Uart_CPR_FIFO_ACCESS_FIFO_ACCESS;

/* Enum : uart::CPR::FIFO_MODE::FIFO_MODE                                  */
/* Source filename: DW_apb_uart.csr, line: 3710                            */
typedef enum _uart_CPR_FIFO_MODE_FIFO_MODE {
   UART_CPR_FIFO_MODE_FIFO_MODE_FIFO_MODE_0 = 0x0,
   UART_CPR_FIFO_MODE_FIFO_MODE_FIFO_MODE_1024 = 0x40,
   UART_CPR_FIFO_MODE_FIFO_MODE_FIFO_MODE_128 = 0x8,
   UART_CPR_FIFO_MODE_FIFO_MODE_FIFO_MODE_16 = 0x1,
   UART_CPR_FIFO_MODE_FIFO_MODE_FIFO_MODE_2048 = 0x80,
   UART_CPR_FIFO_MODE_FIFO_MODE_FIFO_MODE_256 = 0x10,
   UART_CPR_FIFO_MODE_FIFO_MODE_FIFO_MODE_32 = 0x2,
   UART_CPR_FIFO_MODE_FIFO_MODE_FIFO_MODE_512 = 0x20,
   UART_CPR_FIFO_MODE_FIFO_MODE_FIFO_MODE_64 = 0x4
} Uart_CPR_FIFO_MODE_FIFO_MODE;

/* Enum : uart::CPR::FIFO_STAT::FIFO_STAT                                  */
/* Source filename: DW_apb_uart.csr, line: 3630                            */
typedef enum _uart_CPR_FIFO_STAT_FIFO_STAT {
   UART_CPR_FIFO_STAT_FIFO_STAT_DISABLED = 0x0,
   UART_CPR_FIFO_STAT_FIFO_STAT_ENABLED = 0x1
} Uart_CPR_FIFO_STAT_FIFO_STAT;

/* Enum : uart::CPR::SHADOW::SHADOW                                        */
/* Source filename: DW_apb_uart.csr, line: 3648                            */
typedef enum _uart_CPR_SHADOW_SHADOW {
   UART_CPR_SHADOW_SHADOW_DISABLED = 0x0,
   UART_CPR_SHADOW_SHADOW_ENABLED = 0x1
} Uart_CPR_SHADOW_SHADOW;

/* Enum : uart::CPR::SIR_LP_MODE::SIR_LP_MODE                              */
/* Source filename: DW_apb_uart.csr, line: 3575                            */
typedef enum _uart_CPR_SIR_LP_MODE_SIR_LP_MODE {
   UART_CPR_SIR_LP_MODE_SIR_LP_MODE_DISABLED = 0x0,
   UART_CPR_SIR_LP_MODE_SIR_LP_MODE_ENABLED = 0x1
} Uart_CPR_SIR_LP_MODE_SIR_LP_MODE;

/* Enum : uart::CPR::SIR_MODE::SIR_MODE                                    */
/* Source filename: DW_apb_uart.csr, line: 3557                            */
typedef enum _uart_CPR_SIR_MODE_SIR_MODE {
   UART_CPR_SIR_MODE_SIR_MODE_DISABLED = 0x0,
   UART_CPR_SIR_MODE_SIR_MODE_ENABLED = 0x1
} Uart_CPR_SIR_MODE_SIR_MODE;

/* Enum : uart::CPR::THRE_MODE::THRE_MODE                                  */
/* Source filename: DW_apb_uart.csr, line: 3539                            */
typedef enum _uart_CPR_THRE_MODE_THRE_MODE {
   UART_CPR_THRE_MODE_THRE_MODE_DISABLED = 0x0,
   UART_CPR_THRE_MODE_THRE_MODE_ENABLED = 0x1
} Uart_CPR_THRE_MODE_THRE_MODE;

/* Enum : uart::CPR::UART_ADD_ENCODED_PARAMS::UART_ADD_ENCODED_PARAMS      */
/* Source filename: DW_apb_uart.csr, line: 3667                            */
typedef enum _uart_CPR_UART_ADD_ENCODED_PARAMS_UART_ADD_ENCODED_PARAMS {
   UART_CPR_UART_ADD_ENCODED_PARAMS_UART_ADD_ENCODED_PARAMS_DISABLED = 0x0,
   UART_CPR_UART_ADD_ENCODED_PARAMS_UART_ADD_ENCODED_PARAMS_ENABLED = 0x1
} Uart_CPR_UART_ADD_ENCODED_PARAMS_UART_ADD_ENCODED_PARAMS;

/* Enum : uart::DMASA::DMASA::DMASA                                        */
/* Source filename: DW_apb_uart.csr, line: 3397                            */
typedef enum _uart_DMASA_DMASA_DMASA {
   UART_DMASA_DMASA_DMASA_SOFT_ACK = 0x1
} Uart_DMASA_DMASA_DMASA;

/* Enum : uart::FAR::FAR::FAR                                              */
/* Source filename: DW_apb_uart.csr, line: 2530                            */
typedef enum _uart_FAR_FAR_FAR {
   UART_FAR_FAR_FAR_DISABLED = 0x0,
   UART_FAR_FAR_FAR_ENABLED = 0x1
} Uart_FAR_FAR_FAR;

/* Enum : uart::HTX::HTX::HTX                                              */
/* Source filename: DW_apb_uart.csr, line: 3351                            */
typedef enum _uart_HTX_HTX_HTX {
   UART_HTX_HTX_HTX_DISABLED = 0x0,
   UART_HTX_HTX_HTX_ENABLED = 0x1
} Uart_HTX_HTX_HTX;

/* Enum : uart::IER::IER::EDSSI::EDSSI                                     */
/* Source filename: DW_apb_uart.csr, line: 238                             */
typedef enum _uart_IER_IER_EDSSI_EDSSI {
   UART_IER_IER_EDSSI_EDSSI_DISABLED = 0x0,
   UART_IER_IER_EDSSI_EDSSI_ENABLED = 0x1
} Uart_IER_IER_EDSSI_EDSSI;

/* Enum : uart::IER::IER::ELCOLR::ELCOLR                                   */
/* Source filename: DW_apb_uart.csr, line: 268                             */
typedef enum _uart_IER_IER_ELCOLR_ELCOLR {
   UART_IER_IER_ELCOLR_ELCOLR_DISABLED = 0x0,
   UART_IER_IER_ELCOLR_ELCOLR_ENABLED = 0x1
} Uart_IER_IER_ELCOLR_ELCOLR;

/* Enum : uart::IER::IER::ELSI::ELSI                                       */
/* Source filename: DW_apb_uart.csr, line: 217                             */
typedef enum _uart_IER_IER_ELSI_ELSI {
   UART_IER_IER_ELSI_ELSI_DISABLED = 0x0,
   UART_IER_IER_ELSI_ELSI_ENABLED = 0x1
} Uart_IER_IER_ELSI_ELSI;

/* Enum : uart::IER::IER::ERBFI::ERBFI                                     */
/* Source filename: DW_apb_uart.csr, line: 176                             */
typedef enum _uart_IER_IER_ERBFI_ERBFI {
   UART_IER_IER_ERBFI_ERBFI_DISABLED = 0x0,
   UART_IER_IER_ERBFI_ERBFI_ENABLED = 0x1
} Uart_IER_IER_ERBFI_ERBFI;

/* Enum : uart::IER::IER::ETBEI::ETBEI                                     */
/* Source filename: DW_apb_uart.csr, line: 197                             */
typedef enum _uart_IER_IER_ETBEI_ETBEI {
   UART_IER_IER_ETBEI_ETBEI_DISABLED = 0x0,
   UART_IER_IER_ETBEI_ETBEI_ENABLED = 0x1
} Uart_IER_IER_ETBEI_ETBEI;

/* Enum : uart::IER::IER::PTIME::PTIME                                     */
/* Source filename: DW_apb_uart.csr, line: 296                             */
typedef enum _uart_IER_IER_PTIME_PTIME {
   UART_IER_IER_PTIME_PTIME_DISABLED = 0x0,
   UART_IER_IER_PTIME_PTIME_ENABLED = 0x1
} Uart_IER_IER_PTIME_PTIME;

/* Enum : uart::IIR::FCR::DMAM::DMAM                                       */
/* Source filename: DW_apb_uart.csr, line: 532                             */
typedef enum _uart_IIR_FCR_DMAM_DMAM {
   UART_IIR_FCR_DMAM_DMAM_MODE0 = 0x0,
   UART_IIR_FCR_DMAM_DMAM_MODE1 = 0x1
} Uart_IIR_FCR_DMAM_DMAM;

/* Enum : uart::IIR::FCR::FIFOE::FIFOE                                     */
/* Source filename: DW_apb_uart.csr, line: 467                             */
typedef enum _uart_IIR_FCR_FIFOE_FIFOE {
   UART_IIR_FCR_FIFOE_FIFOE_DISABLED = 0x0,
   UART_IIR_FCR_FIFOE_FIFOE_ENABLED = 0x1
} Uart_IIR_FCR_FIFOE_FIFOE;

/* Enum : uart::IIR::FCR::RFIFOR::RFIFOR                                   */
/* Source filename: DW_apb_uart.csr, line: 492                             */
typedef enum _uart_IIR_FCR_RFIFOR_RFIFOR {
   UART_IIR_FCR_RFIFOR_RFIFOR_RESET = 0x1
} Uart_IIR_FCR_RFIFOR_RFIFOR;

/* Enum : uart::IIR::FCR::RT::RT                                           */
/* Source filename: DW_apb_uart.csr, line: 593                             */
typedef enum _uart_IIR_FCR_RT_RT {
   UART_IIR_FCR_RT_RT_FIFO_CHAR_1 = 0x0,
   UART_IIR_FCR_RT_RT_FIFO_FULL_2 = 0x3,
   UART_IIR_FCR_RT_RT_FIFO_HALF_FULL = 0x2,
   UART_IIR_FCR_RT_RT_FIFO_QUARTER_FULL = 0x1
} Uart_IIR_FCR_RT_RT;

/* Enum : uart::IIR::FCR::TET::TET                                         */
/* Source filename: DW_apb_uart.csr, line: 558                             */
typedef enum _uart_IIR_FCR_TET_TET {
   UART_IIR_FCR_TET_TET_FIFO_CHAR_2 = 0x1,
   UART_IIR_FCR_TET_TET_FIFO_EMPTY = 0x0,
   UART_IIR_FCR_TET_TET_FIFO_HALF_FULL = 0x3,
   UART_IIR_FCR_TET_TET_FIFO_QUARTER_FULL = 0x2
} Uart_IIR_FCR_TET_TET;

/* Enum : uart::IIR::FCR::XFIFOR::XFIFOR                                   */
/* Source filename: DW_apb_uart.csr, line: 513                             */
typedef enum _uart_IIR_FCR_XFIFOR_XFIFOR {
   UART_IIR_FCR_XFIFOR_XFIFOR_RESET = 0x1
} Uart_IIR_FCR_XFIFOR_XFIFOR;

/* Enum : uart::IIR::IIR::FIFOSE::FIFOSE                                   */
/* Source filename: DW_apb_uart.csr, line: 428                             */
typedef enum _uart_IIR_IIR_FIFOSE_FIFOSE {
   UART_IIR_IIR_FIFOSE_FIFOSE_DISABLED = 0x0,
   UART_IIR_IIR_FIFOSE_FIFOSE_ENABLED = 0x3
} Uart_IIR_IIR_FIFOSE_FIFOSE;

/* Enum : uart::IIR::IIR::IID::IID                                         */
/* Source filename: DW_apb_uart.csr, line: 382                             */
typedef enum _uart_IIR_IIR_IID_IID {
   UART_IIR_IIR_IID_IID_BUSY_DETECT = 0x7,
   UART_IIR_IIR_IID_IID_CHARACTER_TIMEOUT = 0xc,
   UART_IIR_IIR_IID_IID_MODEM_STATUS = 0x0,
   UART_IIR_IIR_IID_IID_NO_INTERRUPT_PENDING = 0x1,
   UART_IIR_IIR_IID_IID_RECEIVED_DATA_AVAILABLE = 0x4,
   UART_IIR_IIR_IID_IID_RECEIVER_LINE_STATUS = 0x6,
   UART_IIR_IIR_IID_IID_THR_EMPTY = 0x2
} Uart_IIR_IIR_IID_IID;

/* Enum : uart::LCR::BC::BC                                                */
/* Source filename: DW_apb_uart.csr, line: 805                             */
typedef enum _uart_LCR_BC_BC {
   UART_LCR_BC_BC_DISABLED = 0x0,
   UART_LCR_BC_BC_ENABLED = 0x1
} Uart_LCR_BC_BC;

/* Enum : uart::LCR::DLAB::DLAB                                            */
/* Source filename: DW_apb_uart.csr, line: 833                             */
typedef enum _uart_LCR_DLAB_DLAB {
   UART_LCR_DLAB_DLAB_DISABLED = 0x0,
   UART_LCR_DLAB_DLAB_ENABLED = 0x1
} Uart_LCR_DLAB_DLAB;

/* Enum : uart::LCR::DLS::DLS                                              */
/* Source filename: DW_apb_uart.csr, line: 640                             */
typedef enum _uart_LCR_DLS_DLS {
   UART_LCR_DLS_DLS_CHAR_5BITS = 0x0,
   UART_LCR_DLS_DLS_CHAR_6BITS = 0x1,
   UART_LCR_DLS_DLS_CHAR_7BITS = 0x2,
   UART_LCR_DLS_DLS_CHAR_8BITS = 0x3
} Uart_LCR_DLS_DLS;

/* Enum : uart::LCR::EPS::EPS                                              */
/* Source filename: DW_apb_uart.csr, line: 744                             */
typedef enum _uart_LCR_EPS_EPS {
   UART_LCR_EPS_EPS_EVEN_PARITY = 0x1,
   UART_LCR_EPS_EPS_ODD_PARITY = 0x0
} Uart_LCR_EPS_EPS;

/* Enum : uart::LCR::PEN::PEN                                              */
/* Source filename: DW_apb_uart.csr, line: 716                             */
typedef enum _uart_LCR_PEN_PEN {
   UART_LCR_PEN_PEN_DISABLED = 0x0,
   UART_LCR_PEN_PEN_ENABLED = 0x1
} Uart_LCR_PEN_PEN;

/* Enum : uart::LCR::SP::SP                                                */
/* Source filename: DW_apb_uart.csr, line: 773                             */
typedef enum _uart_LCR_SP_SP {
   UART_LCR_SP_SP_DISABLED = 0x0,
   UART_LCR_SP_SP_ENABLED = 0x1
} Uart_LCR_SP_SP;

/* Enum : uart::LCR::STOP::STOP                                            */
/* Source filename: DW_apb_uart.csr, line: 689                             */
typedef enum _uart_LCR_STOP_STOP {
   UART_LCR_STOP_STOP_STOP_1BIT = 0x0,
   UART_LCR_STOP_STOP_STOP_1_5BIT_OR_2BIT = 0x1
} Uart_LCR_STOP_STOP;

/* Enum : uart::LSR::BI::BI                                                */
/* Source filename: DW_apb_uart.csr, line: 1285                            */
typedef enum _uart_LSR_BI_BI {
   UART_LSR_BI_BI_BREAK = 0x1,
   UART_LSR_BI_BI_NO_BREAK = 0x0
} Uart_LSR_BI_BI;

/* Enum : uart::LSR::DR::DR                                                */
/* Source filename: DW_apb_uart.csr, line: 1109                            */
typedef enum _uart_LSR_DR_DR {
   UART_LSR_DR_DR_NOT_READY = 0x0,
   UART_LSR_DR_DR_READY = 0x1
} Uart_LSR_DR_DR;

/* Enum : uart::LSR::FE::FE                                                */
/* Source filename: DW_apb_uart.csr, line: 1230                            */
typedef enum _uart_LSR_FE_FE {
   UART_LSR_FE_FE_FRAMING_ERROR = 0x1,
   UART_LSR_FE_FE_NO_FRAMING_ERROR = 0x0
} Uart_LSR_FE_FE;

/* Enum : uart::LSR::OE::OE                                                */
/* Source filename: DW_apb_uart.csr, line: 1145                            */
typedef enum _uart_LSR_OE_OE {
   UART_LSR_OE_OE_NO_OVER_RUN_ERROR = 0x0,
   UART_LSR_OE_OE_OVER_RUN_ERROR = 0x1
} Uart_LSR_OE_OE;

/* Enum : uart::LSR::PE::PE                                                */
/* Source filename: DW_apb_uart.csr, line: 1184                            */
typedef enum _uart_LSR_PE_PE {
   UART_LSR_PE_PE_NO_PARITY_ERROR = 0x0,
   UART_LSR_PE_PE_PARITY_ERROR = 0x1
} Uart_LSR_PE_PE;

/* Enum : uart::LSR::RFE::RFE                                              */
/* Source filename: DW_apb_uart.csr, line: 1381                            */
typedef enum _uart_LSR_RFE_RFE {
   UART_LSR_RFE_RFE_NO_RX_FIFO_ERROR = 0x0,
   UART_LSR_RFE_RFE_RX_FIFO_ERROR = 0x1
} Uart_LSR_RFE_RFE;

/* Enum : uart::LSR::TEMT::TEMT                                            */
/* Source filename: DW_apb_uart.csr, line: 1352                            */
typedef enum _uart_LSR_TEMT_TEMT {
   UART_LSR_TEMT_TEMT_DISABLED = 0x0,
   UART_LSR_TEMT_TEMT_ENABLED = 0x1
} Uart_LSR_TEMT_TEMT;

/* Enum : uart::LSR::THRE::THRE                                            */
/* Source filename: DW_apb_uart.csr, line: 1325                            */
typedef enum _uart_LSR_THRE_THRE {
   UART_LSR_THRE_THRE_DISABLED = 0x0,
   UART_LSR_THRE_THRE_ENABLED = 0x1
} Uart_LSR_THRE_THRE;

/* Enum : uart::MCR::AFCE::AFCE                                            */
/* Source filename: DW_apb_uart.csr, line: 1040                            */
typedef enum _uart_MCR_AFCE_AFCE {
   UART_MCR_AFCE_AFCE_DISABLED = 0x0,
   UART_MCR_AFCE_AFCE_ENABLED = 0x1
} Uart_MCR_AFCE_AFCE;

/* Enum : uart::MCR::DTR::DTR                                              */
/* Source filename: DW_apb_uart.csr, line: 880                             */
typedef enum _uart_MCR_DTR_DTR {
   UART_MCR_DTR_DTR_ACTIVE = 0x1,
   UART_MCR_DTR_DTR_INACTIVE = 0x0
} Uart_MCR_DTR_DTR;

/* Enum : uart::MCR::LoopBack::LoopBack                                    */
/* Source filename: DW_apb_uart.csr, line: 1013                            */
typedef enum _uart_MCR_LoopBack_LoopBack {
   UART_MCR_LOOPBACK_LOOPBACK_DISABLED = 0x0,
   UART_MCR_LOOPBACK_LOOPBACK_ENABLED = 0x1
} Uart_MCR_LoopBack_LoopBack;

/* Enum : uart::MCR::OUT1::OUT1                                            */
/* Source filename: DW_apb_uart.csr, line: 948                             */
typedef enum _uart_MCR_OUT1_OUT1 {
   UART_MCR_OUT1_OUT1_OUT1_0 = 0x0,
   UART_MCR_OUT1_OUT1_OUT1_1 = 0x1
} Uart_MCR_OUT1_OUT1;

/* Enum : uart::MCR::OUT2::OUT2                                            */
/* Source filename: DW_apb_uart.csr, line: 975                             */
typedef enum _uart_MCR_OUT2_OUT2 {
   UART_MCR_OUT2_OUT2_OUT2_0 = 0x0,
   UART_MCR_OUT2_OUT2_OUT2_1 = 0x1
} Uart_MCR_OUT2_OUT2;

/* Enum : uart::MCR::RTS::RTS                                              */
/* Source filename: DW_apb_uart.csr, line: 921                             */
typedef enum _uart_MCR_RTS_RTS {
   UART_MCR_RTS_RTS_ACTIVE = 0x1,
   UART_MCR_RTS_RTS_INACTIVE = 0x0
} Uart_MCR_RTS_RTS;

/* Enum : uart::MCR::SIRE::SIRE                                            */
/* Source filename: DW_apb_uart.csr, line: 1069                            */
typedef enum _uart_MCR_SIRE_SIRE {
   UART_MCR_SIRE_SIRE_DISABLED = 0x0,
   UART_MCR_SIRE_SIRE_ENABLED = 0x1
} Uart_MCR_SIRE_SIRE;

/* Enum : uart::MSR::CTS::CTS                                              */
/* Source filename: DW_apb_uart.csr, line: 1566                            */
typedef enum _uart_MSR_CTS_CTS {
   UART_MSR_CTS_CTS_ASSERTED = 0x1,
   UART_MSR_CTS_CTS_DEASSERTED = 0x0
} Uart_MSR_CTS_CTS;

/* Enum : uart::MSR::DCD::DCD                                              */
/* Source filename: DW_apb_uart.csr, line: 1653                            */
typedef enum _uart_MSR_DCD_DCD {
   UART_MSR_DCD_DCD_ASSERTED = 0x1,
   UART_MSR_DCD_DCD_DEASSERTED = 0x0
} Uart_MSR_DCD_DCD;

/* Enum : uart::MSR::DCTS::DCTS                                            */
/* Source filename: DW_apb_uart.csr, line: 1445                            */
typedef enum _uart_MSR_DCTS_DCTS {
   UART_MSR_DCTS_DCTS_CHANGE = 0x1,
   UART_MSR_DCTS_DCTS_NO_CHANGE = 0x0
} Uart_MSR_DCTS_DCTS;

/* Enum : uart::MSR::DDCD::DDCD                                            */
/* Source filename: DW_apb_uart.csr, line: 1537                            */
typedef enum _uart_MSR_DDCD_DDCD {
   UART_MSR_DDCD_DDCD_CHANGE = 0x1,
   UART_MSR_DDCD_DDCD_NO_CHANGE = 0x0
} Uart_MSR_DDCD_DDCD;

/* Enum : uart::MSR::DDSR::DDSR                                            */
/* Source filename: DW_apb_uart.csr, line: 1477                            */
typedef enum _uart_MSR_DDSR_DDSR {
   UART_MSR_DDSR_DDSR_CHANGE = 0x1,
   UART_MSR_DDSR_DDSR_NO_CHANGE = 0x0
} Uart_MSR_DDSR_DDSR;

/* Enum : uart::MSR::DSR::DSR                                              */
/* Source filename: DW_apb_uart.csr, line: 1595                            */
typedef enum _uart_MSR_DSR_DSR {
   UART_MSR_DSR_DSR_ASSERTED = 0x1,
   UART_MSR_DSR_DSR_DEASSERTED = 0x0
} Uart_MSR_DSR_DSR;

/* Enum : uart::MSR::RI::RI                                                */
/* Source filename: DW_apb_uart.csr, line: 1624                            */
typedef enum _uart_MSR_RI_RI {
   UART_MSR_RI_RI_ASSERTED = 0x1,
   UART_MSR_RI_RI_DEASSERTED = 0x0
} Uart_MSR_RI_RI;

/* Enum : uart::MSR::TERI::TERI                                            */
/* Source filename: DW_apb_uart.csr, line: 1505                            */
typedef enum _uart_MSR_TERI_TERI {
   UART_MSR_TERI_TERI_CHANGE = 0x1,
   UART_MSR_TERI_TERI_NO_CHANGE = 0x0
} Uart_MSR_TERI_TERI;

/* Enum : uart::RFW::RFFE::RFFE                                            */
/* Source filename: DW_apb_uart.csr, line: 2660                            */
typedef enum _uart_RFW_RFFE_RFFE {
   UART_RFW_RFFE_RFFE_DISABLED = 0x0,
   UART_RFW_RFFE_RFFE_ENABLED = 0x1
} Uart_RFW_RFFE_RFFE;

/* Enum : uart::RFW::RFPE::RFPE                                            */
/* Source filename: DW_apb_uart.csr, line: 2632                            */
typedef enum _uart_RFW_RFPE_RFPE {
   UART_RFW_RFPE_RFPE_DISABLED = 0x0,
   UART_RFW_RFPE_RFPE_ENABLED = 0x1
} Uart_RFW_RFPE_RFPE;

/* Enum : uart::SBCR::SBCB::SBCB                                           */
/* Source filename: DW_apb_uart.csr, line: 3091                            */
typedef enum _uart_SBCR_SBCB_SBCB {
   UART_SBCR_SBCB_SBCB_BREAK = 0x1,
   UART_SBCR_SBCB_SBCB_NO_BREAK = 0x0
} Uart_SBCR_SBCB_SBCB;

/* Enum : uart::SDMAM::SDMAM::SDMAM                                        */
/* Source filename: DW_apb_uart.csr, line: 3141                            */
typedef enum _uart_SDMAM_SDMAM_SDMAM {
   UART_SDMAM_SDMAM_SDMAM_MODE_0 = 0x0,
   UART_SDMAM_SDMAM_SDMAM_MODE_1 = 0x1
} Uart_SDMAM_SDMAM_SDMAM;

/* Enum : uart::SFE::SFE::SFE                                              */
/* Source filename: DW_apb_uart.csr, line: 3190                            */
typedef enum _uart_SFE_SFE_SFE {
   UART_SFE_SFE_SFE_DISABLED = 0x0,
   UART_SFE_SFE_SFE_ENABLED = 0x1
} Uart_SFE_SFE_SFE;

/* Enum : uart::SRR::UR::UR                                                */
/* Source filename: DW_apb_uart.csr, line: 2924                            */
typedef enum _uart_SRR_UR_UR {
   UART_SRR_UR_UR_NO_RESET = 0x0,
   UART_SRR_UR_UR_RESET = 0x1
} Uart_SRR_UR_UR;

/* Enum : uart::SRT::SRT::SRT                                              */
/* Source filename: DW_apb_uart.csr, line: 3241                            */
typedef enum _uart_SRT_SRT_SRT {
   UART_SRT_SRT_SRT_FIFO_CHAR_1 = 0x0,
   UART_SRT_SRT_SRT_FIFO_FULL_2 = 0x3,
   UART_SRT_SRT_SRT_FIFO_HALF_FULL = 0x2,
   UART_SRT_SRT_SRT_FIFO_QUARTER_FULL = 0x1
} Uart_SRT_SRT_SRT;

/* Enum : uart::SRTS::SRTS::SRTS                                           */
/* Source filename: DW_apb_uart.csr, line: 3039                            */
typedef enum _uart_SRTS_SRTS_SRTS {
   UART_SRTS_SRTS_SRTS_ASSERTED = 0x1,
   UART_SRTS_SRTS_SRTS_DEASSERTED = 0x0
} Uart_SRTS_SRTS_SRTS;

/* Enum : uart::STET::STET::STET                                           */
/* Source filename: DW_apb_uart.csr, line: 3301                            */
typedef enum _uart_STET_STET_STET {
   UART_STET_STET_STET_FIFO_CHAR_2 = 0x1,
   UART_STET_STET_STET_FIFO_EMPTY = 0x0,
   UART_STET_STET_STET_FIFO_HALF_FULL = 0x3,
   UART_STET_STET_STET_FIFO_QUARTER_FULL = 0x2
} Uart_STET_STET_STET;

/* Enum : uart::USR::BUSY::BUSY                                            */
/* Source filename: DW_apb_uart.csr, line: 2731                            */
typedef enum _uart_USR_BUSY_BUSY {
   UART_USR_BUSY_BUSY_BUSY = 0x1,
   UART_USR_BUSY_BUSY_IDLE = 0x0
} Uart_USR_BUSY_BUSY;

/* Enum : uart::USR::RFF::RFF                                              */
/* Source filename: DW_apb_uart.csr, line: 2823                            */
typedef enum _uart_USR_RFF_RFF {
   UART_USR_RFF_RFF_FULL = 0x1,
   UART_USR_RFF_RFF_NOT_FULL = 0x0
} Uart_USR_RFF_RFF;

/* Enum : uart::USR::RFNE::RFNE                                            */
/* Source filename: DW_apb_uart.csr, line: 2800                            */
typedef enum _uart_USR_RFNE_RFNE {
   UART_USR_RFNE_RFNE_EMPTY = 0x0,
   UART_USR_RFNE_RFNE_NOT_EMPTY = 0x1
} Uart_USR_RFNE_RFNE;

/* Enum : uart::USR::TFE::TFE                                              */
/* Source filename: DW_apb_uart.csr, line: 2777                            */
typedef enum _uart_USR_TFE_TFE {
   UART_USR_TFE_TFE_EMPTY = 0x1,
   UART_USR_TFE_TFE_NOT_EMPTY = 0x0
} Uart_USR_TFE_TFE;

/* Enum : uart::USR::TFNF::TFNF                                            */
/* Source filename: DW_apb_uart.csr, line: 2754                            */
typedef enum _uart_USR_TFNF_TFNF {
   UART_USR_TFNF_TFNF_FULL = 0x0,
   UART_USR_TFNF_TFNF_NOT_FULL = 0x1
} Uart_USR_TFNF_TFNF;

/* ####################################################################### */
/*        TYPE DEFINITIONS                                                 */
/* ####################################################################### */

/* Typedef for Register: uart::RBR::RBR                                    */
/* Source filename: DW_apb_uart.csr, line: 23                              */
/* Title: Receive Buffer Register                                          */
/* Description:                                                            */
/**
 *    Receive Buffer Register.
 *     This register can be accessed only when the DLAB bit (LCR[7]) is
 *    cleared.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 30                     */
         /* Description:                                                   */
         /**
          *    Receive Buffer Register.
          *     This register contains the data byte received on the serial
          *    input port (sin) in UART mode or the serial infrared input
          *    (sir_in) in infrared mode. The data in this register is valid
          *    only if the Data Ready (DR) bit in the Line status Register
          *    (LSR) is set.
          *     If in non-FIFO mode (FIFO_MODE == NONE) or FIFOs are disabled
          *     (FCR[0] set to 0), the data in the RBR must be read before
          *    the next data arrives, otherwise it will be overwritten,
          *    resulting in an over-run error.
          *     If in FIFO mode (FIFO_MODE != NONE) and FIFOs are enabled
          *    (FCR[0] set to 1), this register accesses the head of the
          *    receive FIFO. If the receive FIFO is full and this register is
          *     not read before the next data character arrives, then the
          *    data already in the FIFO will be preserved but any incoming
          *    data will be lost and an over-run error occurs.
          *    Note:
          *              When UART_9BIT_DATA_EN=0, this field width is 8.
          *              When UART_9BIT_DATA_EN=1, this field width is 9.
         */
         uint32_t RBR : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 60                     */
         /* Description:                                                   */
         /**
          *    RBR 31to9or8 Reserved bits and read as zero (0).
         */
         uint32_t RSVD_RBR : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_RBR_RBR_t;

/* Typedef for Register: uart::RBR::DLL                                    */
/* Source filename: DW_apb_uart.csr, line: 68                              */
/* Title: Divisor Latch (Low)                                              */
/* Description:                                                            */
/**
 *    Divisor Latch (Low).
 *     If UART_16550_COMPATIBLE = No, then this register can be accessed only
 *     when the DLAB bit (LCR[7]) is set and the UART is not busy - that is,
 *    USR[0] is 0; otherwise this register can be accessed only when the DLAB
 *     bit (LCR[7]) is set.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 79                     */
         /* Description:                                                   */
         /**
          *    Divisor Latch (Low).
          *     This register makes up the lower 8-bits of a 16-bit,
          *    read/write, Divisor Latch register that contains the baud rate
          *     divisor for the UART.
          *     The output baud rate is equal to the serial clock (pclk if
          *    one clock design, sclk if two clock design (CLOCK_MODE ==
          *    Enabled)) frequency divided by sixteen times the value of the
          *    baud rate divisor, as follows: baud rate = (serial clock freq)
          *     / (16 * divisor).
          *     Note that with the Divisor Latch Registers (DLL and DLH) set
          *    to zero, the baud clock is disabled and no serial
          *    communications will occur. Also, once the DLL is set, at least
          *     8 clock cycles of the slowest DW_apb_uart clock should be
          *    allowed to pass before transmitting or receiving data.
         */
         uint32_t DLL : 8; /* bits 7 to 0; R/W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 100                    */
         /* Description:                                                   */
         /**
          *    DLL 31to8 Reserved bits and read as zero (0).
         */
         uint32_t RSVD_DLL_31to8 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_RBR_DLL_t;

/* Typedef for Register: uart::RBR::THR                                    */
/* Source filename: DW_apb_uart.csr, line: 109                             */
/* Title: Transmit Holding Register                                        */
/* Description:                                                            */
/**
 *    Transmit Holding Register.
 *     This register can be accessed only when the DLAB bit (LCR[7]) is
 *    cleared.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 117                    */
         /* Description:                                                   */
         /**
          *    Transmit Holding Register.
          *     This register contains data to be transmitted on the serial
          *    output port (sout) in UART mode or the serial infrared output
          *    (sir_out_n) in infrared mode. Data should only be written to
          *    the THR when the THR Empty (THRE) bit (LSR[5]) is set.
          *     If in non-FIFO mode or FIFO's are disabled (FCR[0] set to
          *    zero) and THRE is set, writing a single character to the THR
          *    clears the THRE. Any additional writes to the THR before the
          *    THRE is set again causes the THR data to be overwritten.
          *     If in FIFO mode and FIFO's are enabled (FCR[0] set to one)
          *    and THRE is set, x number of characters of data may be written
          *     to the THR before the FIFO is full. The number x (default=16)
          *     is determined by the value of FIFO Depth that is set during
          *    configuration. Any attempt to write data when the FIFO is full
          *     results in the write data being lost.
          *    Note:
          *              When UART_9BIT_DATA_EN=0, this field width is 8.
          *              When UART_9BIT_DATA_EN=1, this field width is 9. The
          *     9th bit is applicable only when LCR_EXT[3]=1.
         */
         uint32_t THR : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 149                    */
         /* Description:                                                   */
         /**
          *    THR 31to9or8 Reserved bits and read as zero (0).
         */
         uint32_t RSVD_THR : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_RBR_THR_t;

/* Typedef for Union: uart::RBR                                            */
/* Source filename: DW_apb_uart.csr, line: 21                              */
typedef union {
   Uart_RBR_RBR_t RBR; /**< Offset 0x0 (R) */
   Uart_RBR_DLL_t DLL; /**< Offset 0x0 (R/W) */
   Uart_RBR_THR_t THR; /**< Offset 0x0 (R/W) */
} Uart_RBR_t;

/* Typedef for Register: uart::IER::IER                                    */
/* Source filename: DW_apb_uart.csr, line: 160                             */
/* Title: Interrupt Enable Register                                        */
/* Description:                                                            */
/**
 *    Interrupt Enable Register.
 *     This register can be accessed only when the DLAB bit (LCR[7]) is
 *    cleared.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 167                    */
         /* Description:                                                   */
         /**
          *    Enable Received Data Available Interrupt. This is used to
          *    enable/disable the generation of Received Data Available
          *    Interrupt and the Character Timeout Interrupt (if in FIFO mode
          *     and FIFO's enabled). These are the second highest priority
          *    interrupts.
         */
         uint32_t ERBFI : 1; /* bit 0; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 189                    */
         /* Description:                                                   */
         /**
          *    Enable Transmit Holding Register Empty Interrupt. This is used
          *     to enable/disable the generation of Transmitter Holding
          *    Register Empty Interrupt. This is the third highest priority
          *    interrupt.
         */
         uint32_t ETBEI : 1; /* bit 1; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 210                    */
         /* Description:                                                   */
         /**
          *    Enable Receiver Line Status Interrupt. This is used to
          *    enable/disable the generation of Receiver Line Status
          *    Interrupt. This is the highest priority interrupt.
         */
         uint32_t ELSI : 1; /* bit 2; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 230                    */
         /* Description:                                                   */
         /**
          *    Enable Modem Status Interrupt. This is used to enable/disable
          *    the generation of Modem Status Interrupt. This is the fourth
          *    highest priority interrupt.
         */
         uint32_t EDSSI : 1; /* bit 3; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 251                    */
         /* Description:                                                   */
         /**
          *    Interrupt Enable Register: ELCOLR, this bit controls the
          *    method for clearing the status in the LSR register.
          *    This is applicable only for Overrun Error, Parity Error,
          *    Framing Error, and Break Interrupt status bits.
          *    0 = LSR status bits are cleared either on reading Rx FIFO (RBR
          *     Read) or On reading LSR register.
          *    1 = LSR status bits are cleared only on reading LSR register.
          *    Writeable only when LSR_STATUS_CLEAR == Enabled, always
          *    readable.
         */
         uint32_t ELCOLR : 1; /* bit 4; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 280                    */
         /* Description:                                                   */
         /**
          *    IER 6to5 Reserved bits read as zero (0).
         */
         uint32_t RSVD_IER_6to5 : 2; /* bits 6 to 5; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 288                    */
         /* Description:                                                   */
         /**
          *    Programmable THRE Interrupt Mode Enable. Writeable only when
          *    THRE_MODE_USER == Enabled, always readable.  This is used to
          *    enable/disable the generation of THRE Interrupt.
         */
         uint32_t PTIME : 1; /* bit 7; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 309                    */
         /* Description:                                                   */
         /**
          *    IER 31to8 Reserved bits and read as zero (0).
         */
         uint32_t RSVD_IER_31to8 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_IER_IER_t;

/* Typedef for Register: uart::IER::DLH                                    */
/* Source filename: DW_apb_uart.csr, line: 318                             */
/* Title: Divisor Latch High                                               */
/* Description:                                                            */
/**
 *    Divisor Latch High (DLH) Register.
 *     If UART_16550_COMPATIBLE = No, then this register can be accessed only
 *     when the DLAB bit (LCR[7]) is set and the UART is not busy, that is,
 *    USR[0] is 0; otherwise this register can be accessed only when the DLAB
 *     bit (LCR[7]) is set.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 328                    */
         /* Description:                                                   */
         /**
          *    Upper 8-bits of a 16-bit, read/write, Divisor Latch register
          *    that contains the baud rate divisor for the UART.
          *     The output baud rate is equal to the serial clock (pclk if
          *    one clock design, sclk if two clock design (CLOCK_MODE ==
          *    Enabled)) frequency divided by sixteen times the value of the
          *    baud rate divisor, as follows: baud rate = (serial clock freq)
          *     / (16 * divisor).
          *     Note that with the Divisor Latch Registers (DLL and DLH) set
          *    to zero, the baud clock is disabled and no serial
          *    communications will occur. Also, once the DLH is set, at least
          *     8 clock cycles of the slowest DW_apb_uart clock should be
          *    allowed to pass before transmitting or receiving data.
         */
         uint32_t dlh : 8; /* bits 7 to 0; R/W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 348                    */
         /* Description:                                                   */
         /**
          *    DLH 31to8 Reserved bits and read as zero (0).
         */
         uint32_t RSVD_DLH : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_IER_DLH_t;

/* Typedef for Union: uart::IER                                            */
/* Source filename: DW_apb_uart.csr, line: 159                             */
typedef union {
   Uart_IER_IER_t IER; /**< Offset 0x0 (R/W) */
   Uart_IER_DLH_t DLH; /**< Offset 0x0 (R/W) */
} Uart_IER_t;

/* Typedef for Register: uart::IIR::IIR                                    */
/* Source filename: DW_apb_uart.csr, line: 360                             */
/* Title: Interrupt Identification Register                                */
/* Description:                                                            */
/**
 *    Interrupt Identification Register
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 365                    */
         /* Description:                                                   */
         /**
          *    Interrupt ID (or IID). This indicates the highest priority
          *    pending interrupt which can be one of the following types
          *    specified in Values. For information on several levels into
          *    which the interrupt priorities are split into, see the
          *    'Interrupts' section in the DW_apb_uart Databook.
          *    Note: an interrupt of type 0111 (busy detect) will never get
          *    indicated if UART_16550_COMPATIBLE == YES in coreConsultant.
          *    Bit 3 indicates an interrupt can only occur when the FIFOs are
          *     enabled and used to distinguish a Character Timeout condition
          *     interrupt.
         */
         uint32_t IID : 4; /* bits 3 to 0; R; 0x1 */

         /* Source filename: DW_apb_uart.csr, line: 414                    */
         /* Description:                                                   */
         /**
          *    IIR 5to4 Reserved bits read as 0.
         */
         uint32_t RSVD_IIR_5to4 : 2; /* bits 5 to 4; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 421                    */
         /* Description:                                                   */
         /**
          *    FIFOs Enabled (or FIFOSE). This is used to indicate whether
          *    the FIFOs are enabled or disabled.
         */
         uint32_t FIFOSE : 2; /* bits 7 to 6; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 440                    */
         /* Description:                                                   */
         /**
          *    IIR 31to8 Reserved bits and read as 0.
         */
         uint32_t RSVD_IIR_31to8 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_IIR_IIR_t;

/* Typedef for Register: uart::IIR::FCR                                    */
/* Source filename: DW_apb_uart.csr, line: 448                             */
/* Title: FIFO Control Register                                            */
/* Description:                                                            */
/**
 *    This register is only valid when the DW_apb_uart is configured to have
 *    FIFO's implemented (FIFO_MODE != NONE).  If FIFO's are not implemented,
 *     this register does not exist and writing to this register address will
 *     have no effect.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 458                    */
         /* Description:                                                   */
         /**
          *    FIFO Enable (or FIFOE). This enables/disables the transmit
          *    (XMIT) and receive (RCVR) FIFOs. Whenever the value of this
          *    bit is changed both the XMIT and RCVR controller portion of
          *    FIFOs is reset.
         */
         uint32_t FIFOE : 1; /* bit 0; W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 480                    */
         /* Description:                                                   */
         /**
          *    RCVR FIFO Reset (or RFIFOR). This resets the control portion
          *    of the receive FIFO and treats the FIFO as empty. This will
          *    also de-assert the DMA RX request and single signals when
          *    additional DMA handshaking signals are selected (DMA_EXTRA ==
          *    YES). Note that this bit is 'self-clearing' and it is not
          *    necessary to clear this bit.
         */
         uint32_t RFIFOR : 1; /* bit 1; W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 501                    */
         /* Description:                                                   */
         /**
          *    XMIT FIFO Reset (or XFIFOR). This resets the control portion
          *    of the transmit FIFO and treats the FIFO as empty. This will
          *    also de-assert the DMA TX request and single signals when
          *    additional DMA handshaking signals are selected (DMA_EXTRA ==
          *    YES). Note that this bit is 'self-clearing' and it is not
          *    necessary to clear this bit.
         */
         uint32_t XFIFOR : 1; /* bit 2; W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 522                    */
         /* Description:                                                   */
         /**
          *    DMA Mode (or DMAM). This determines the DMA signalling mode
          *    used for the dma_tx_req_n and dma_rx_req_n output signals when
          *     additional DMA handshaking signals are not selected
          *    (DMA_EXTRA == NO). For details on DMA support, refer to 'DMA
          *    Support' section of data book.
         */
         uint32_t DMAM : 1; /* bit 3; W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 545                    */
         /* Description:                                                   */
         /**
          *    TX Empty Trigger (or TET). Writes will have no effect when
          *    THRE_MODE_USER == Disabled. This is used to select the empty
          *    threshold level at which the THRE Interrupts will be generated
          *     when the mode is active. It also determines when the
          *    dma_tx_req_n signal will be asserted when in certain modes of
          *    operation. For details on DMA support, refer to 'DMA Support'
          *    section of data book.
         */
         uint32_t TET : 2; /* bits 5 to 4; W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 579                    */
         /* Description:                                                   */
         /**
          *    RCVR Trigger (or RT). This is used to select the trigger level
          *     in the receiver FIFO at which the Received Data Available
          *    Interrupt will be generated. In auto flow control mode, it is
          *    used to determine when the rts_n signal will be de-asserted
          *    only when RTC_FCT is disabled. It also determines when the
          *    dma_rx_req_n signal will be asserted when in certain modes of
          *    operation. For details on DMA support, refer to 'DMA Support'
          *    section of data book.
         */
         uint32_t RT : 2; /* bits 7 to 6; W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 614                    */
         /* Description:                                                   */
         /**
          *    FCR 31to8 Reserved bits and read as 0.
         */
         uint32_t RSVD_FCR_31to8 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_IIR_FCR_t;

/* Typedef for Union: uart::IIR                                            */
/* Source filename: DW_apb_uart.csr, line: 358                             */
typedef union {
   Uart_IIR_IIR_t IIR; /**< Offset 0x0 (R) */
   Uart_IIR_FCR_t FCR; /**< Offset 0x0 (R/W) */
} Uart_IIR_t;

/* Typedef for Register: uart::LCR                                         */
/* Source filename: DW_apb_uart.csr, line: 624                             */
/* Title: Line Control Register                                            */
/* Description:                                                            */
/**
 *    Line Control Register
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 629                    */
         /* Description:                                                   */
         /**
          *    Data Length Select (or CLS as used in legacy).
          *     If UART_16550_COMPATIBLE == NO then, writeable only when UART
          *     is not busy (USR[0] is zero), otherwise always writable and
          *    always readable. When DLS_E in LCR_EXT is set to 0, this
          *    register is used to select the number of data bits per
          *    character that the peripheral will transmit and receive.
         */
         uint32_t DLS : 2; /* bits 1 to 0; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 661                    */
         /* Description:                                                   */
         /**
          *    Number of stop bits.
          *    If UART_16550_COMPATIBLE == NO then, writeable only when UART
          *    is not busy (USR[0]
          *    is zero), otherwise always writable and always readable. This
          *    is used to select the number
          *    of stop bits per character that the peripheral will transmit
          *    and receive. If set to
          *    zero, one stop bit is transmitted in the serial data.
          *     If set to one and the data
          *    bits are set to 5 (LCR[1:0] set to zero) one and a half stop
          *    bits is transmitted.
          *    Otherwise, two stop bits are transmitted.
          *    Note that regardless of the number of stop bits selected the
          *    receiver will only
          *    check the first stop bit.
          *    Note: NOTE: The STOP bit duration implemented by DW_apb_uart
          *    may appear longer
          *    due to idle time inserted between characters for some
          *    configurations and baud
          *    clock divisor values in the transmit direction; for details on
          *     idle time between
          *    transmitted transfers, refer to 'Back-to-Back Character Stream
          *     Transmission' section in data book.
         */
         uint32_t STOP : 1; /* bit 2; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 703                    */
         /* Description:                                                   */
         /**
          *    Parity Enable
          *    .
          *    If UART_16550_COMPATIBLE == NO then, writeable only when UART
          *    is not busy (USR[0]
          *    is zero), otherwise always writable and always readable. This
          *    bit is used to enable
          *    and disable parity generation and detection in transmitted and
          *     received serial
          *    character respectively.
         */
         uint32_t PEN : 1; /* bit 3; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 729                    */
         /* Description:                                                   */
         /**
          *    Even Parity Select.
          *    If UART_16550_COMPATIBLE == NO then, writeable only when UART
          *    is not busy (USR[0]
          *    is zero), otherwise always writable and always readable. This
          *    is used to select
          *    between even and odd parity, when parity is enabled (PEN set
          *    to one). If set to
          *    one, an even number of logic '1's is transmitted or checked.
          *    If set to zero, an
          *    odd number of logic '1's is transmitted or checked.
         */
         uint32_t EPS : 1; /* bit 4; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 757                    */
         /* Description:                                                   */
         /**
          *    Stick Parity.
          *     If UART_16550_COMPATIBLE = NO, then writeable only when UART
          *    is
          *    not busy (USR[0] is 0); otherwise always writable and always
          *    readable. This bit is used
          *    to force parity value. When PEN, EPS and Stick Parity are set
          *    to 1, the parity bit is
          *    transmitted and checked as logic 0. If PEN and Stick Parity
          *    are set to 1 and EPS is a
          *    logic 0, then parity bit is transmitted and checked as a logic
          *     1. If this bit is set to 0,
          *    Stick Parity is disabled.
         */
         uint32_t SP : 1; /* bit 5; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 786                    */
         /* Description:                                                   */
         /**
          *    Break Control Bit.
          *    This is used to cause a break condition to be transmitted to
          *    the receiving device.
          *    If set to one the serial output is forced to the spacing
          *    (logic 0) state. When
          *    not in Loopback Mode, as determined by MCR[4], the sout line
          *    is forced low until
          *    the Break bit is cleared. If SIR_MODE == Enabled and active
          *    (MCR[6] set to one)
          *    the sir_out_n line is continuously pulsed. When in Loopback
          *    Mode, the break
          *    condition is internally looped back to the receiver and the
          *    sir_out_n line is
          *    forced low.
         */
         uint32_t BC : 1; /* bit 6; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 818                    */
         /* Description:                                                   */
         /**
          *    Divisor Latch Access Bit.
          *    If UART_16550_COMPATIBLE == NO then, writeable only when UART
          *    is not busy (USR[0]
          *    is zero), otherwise always writable and always readable. This
          *    bit is used to enable
          *    reading and writing of the Divisor Latch register (DLL and
          *    DLH/LPDLL and LPDLH) to set the baud
          *    rate of the UART. This bit must be cleared after initial baud
          *    rate setup in order
          *    to access other registers.
         */
         uint32_t DLAB : 1; /* bit 7; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 848                    */
         /* Description:                                                   */
         /**
          *    LCR 31to8 Reserved bits and read as 0.
         */
         uint32_t RSVD_LCR_31to8 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_LCR_t;

/* Typedef for Register: uart::MCR                                         */
/* Source filename: DW_apb_uart.csr, line: 857                             */
/* Title: Modem Control Register                                           */
/* Description:                                                            */
/**
 *    Modem Control Register
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 862                    */
         /* Description:                                                   */
         /**
          *    Data Terminal Ready.
          *    This is used to directly control the Data Terminal Ready
          *    (dtr_n) output. The value
          *    written to this location is inverted and driven out on dtr_n.
          *    The Data Terminal Ready output is used to inform the modem or
          *    data set that the
          *    UART is ready to establish communications. Note that in
          *    Loopback mode (MCR[4]
          *    set to one), the dtr_n output is held inactive high while the
          *    value of this
          *    location is internally looped back to an input.
         */
         uint32_t DTR : 1; /* bit 0; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 893                    */
         /* Description:                                                   */
         /**
          *    Request to Send.
          *
          *    This is used to directly control the Request to Send (rts_n)
          *    output. The Request
          *    To Send (rts_n) output is used to inform the modem or data set
          *     that the UART is
          *    ready to exchange data.
          *    When Auto RTS Flow Control is not enabled (MCR[5] set to
          *    zero), the rts_n signal
          *    is set low by programming MCR[1] (RTS) to a high.
          *    In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5]
          *    set to one) and
          *    FIFO's enable (FCR[0] set to one), the rts_n output is
          *    controlled in the same way,
          *    but is also gated with the receiver FIFO threshold trigger
          *    (rts_n is inactive high
          *    when above the threshold).
          *    The rts_n signal will be de-asserted when MCR[1] is set low.
          *    Note that in Loopback mode (MCR[4] set to one), the rts_n
          *    output is held inactive
          *    high while the value of this location is internally looped
          *    back to an input.
         */
         uint32_t RTS : 1; /* bit 1; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 934                    */
         /* Description:                                                   */
         /**
          *    OUT1
          *    .
          *    This is used to directly control the user-designated Output1
          *    (out1_n) output. The
          *    value written to this location is inverted and driven out on
          *    out1_n.
          *    Note that in Loopback mode (MCR[4] set to one), the out1_n
          *    output is held inactive high
          *    while the value of this location is internally looped back to
          *    an input.
         */
         uint32_t OUT1 : 1; /* bit 2; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 961                    */
         /* Description:                                                   */
         /**
          *    OUT2
          *    .
          *    This is used to directly control the user-designated Output2
          *    (out2_n) output. The
          *    value written to this location is inverted and driven out on
          *    out2_n.
          *    Note that in Loopback mode (MCR[4] set to one), the out2_n
          *    output is held inactive
          *    high while the value of this location is internally looped
          *    back to an input.
         */
         uint32_t OUT2 : 1; /* bit 3; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 988                    */
         /* Description:                                                   */
         /**
          *    LoopBack Bit
          *    .
          *    This is used to put the UART into a diagnostic mode for test
          *    purposes.
          *    If operating in UART mode (SIR_MODE != Enabled OR NOT active,
          *    MCR[6] set to zero),
          *    data on the sout line is held high, while serial data output
          *    is looped back to the
          *    sin line, internally. In this mode all the interrupts are
          *    fully functional. Also,
          *    in loopback mode, the modem control inputs (dsr_n, cts_n,
          *    ri_n, dcd_n) are
          *    disconnected and the modem control outputs (dtr_n, rts_n,
          *    out1_n, out2_n) are looped
          *    back to the inputs, internally.
          *    If operating in infrared mode (SIR_MODE == Enabled AND active,
          *     MCR[6] set to one),
          *    data on the sir_out_n line is held low, while serial data
          *    output is inverted and
          *    looped back to the sir_in line.
         */
         uint32_t LoopBack : 1; /* bit 4; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1026                   */
         /* Description:                                                   */
         /**
          *    Auto Flow Control Enable
          *    .
          *    Writeable only when AFCE_MODE == Enabled, always readable.
          *    When FIFOs are enabled
          *    and the Auto Flow Control Enable (AFCE) bit is set, Auto Flow
          *    Control features are
          *    enabled as described in section 'Auto Flow Control' in data
          *    book.
         */
         uint32_t AFCE : 1; /* bit 5; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1052                   */
         /* Description:                                                   */
         /**
          *    SIR Mode Enable
          *    .
          *    Writeable only when SIR_MODE == Enabled, always readable.
          *    This is used to enable/
          *    disable the IrDA SIR Mode features as described in section
          *    'IrDA 1.0 SIR Protocol' in the databook.
          *    Note: To enable SIR mode, write the appropriate value to the
          *    MCR register before writing to the LCR register.
          *    For details of the recommended programming sequence, refer to
          *    'Programing Examples' section of data book.
         */
         uint32_t SIRE : 1; /* bit 6; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1081                   */
         /* Description:                                                   */
         /**
          *    MCR 31to7 Reserved bits read as 0.
         */
         uint32_t RSVD_MCR_31to7 : 25; /* bits 31 to 7; R; 0x0000000 */
      } B;
      uint32_t R;
   } ;
} Uart_MCR_t;

/* Typedef for Register: uart::LSR                                         */
/* Source filename: DW_apb_uart.csr, line: 1090                            */
/* Title: Line Status Register                                             */
/* Description:                                                            */
/**
 *    Line Status Register
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1096                   */
         /* Description:                                                   */
         /**
          *    Data Ready bit.
          *    This is used to indicate that the receiver contains at least
          *    one character in the
          *    RBR or the receiver FIFO.
          *    This bit is cleared when the RBR is read in the non-FIFO mode,
          *     or when the receiver
          *    FIFO is empty, in the FIFO mode.
         */
         uint32_t DR : 1; /* bit 0; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1121                   */
         /* Description:                                                   */
         /**
          *    Overrun error bit.
          *    This is used to indicate the occurrence of an overrun error.
          *    This occurs if a new data
          *    character was received before the previous data was read.
          *     In the non-FIFO mode, the OE
          *    bit is set when a new character arrives in the receiver before
          *     the previous character
          *    was read from the RBR. When this happens, the data in the RBR
          *    is overwritten. In the
          *    FIFO mode, an overrun error occurs when the FIFO is full and a
          *     new character arrives at
          *    the receiver. The data in the FIFO is retained and the data in
          *     the receive shift register
          *    is lost.
          *    Reading the LSR clears the OE bit (if LSR_STATUS_CLEAR==1) Or
          *    Reading the LSR or RBR clears the OE bit (if
          *    LSR_STATUS_CLEAR==0).
         */
         uint32_t OE : 1; /* bit 1; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1157                   */
         /* Description:                                                   */
         /**
          *    Parity Error bit.
          *    This is used to indicate the occurrence of a parity error in
          *    the receiver if the
          *    Parity Enable (PEN) bit (LCR[3]) is set.
          *     In the FIFO mode, since the parity error is
          *    associated with a character received, it is revealed when the
          *    character with the parity
          *    error arrives at the top of the FIFO.
          *    It should be noted that the Parity Error (PE) bit (LSR[2])
          *    will be set if a break
          *    interrupt has occurred, as indicated by Break Interrupt (BI)
          *    bit (LSR[4]). In this situation, the Parity Error
          *    bit is set if parity generation and detection is enabled
          *    (LCR[3]=1) and the parity is set to
          *    odd (LCR[4]=0).
          *    Reading the LSR clears the PE bit (if LSR_STATUS_CLEAR==1) Or
          *    Reading the LSR or RBR clears the PE bit (if
          *    LSR_STATUS_CLEAR==0).
         */
         uint32_t PE : 1; /* bit 2; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1196                   */
         /* Description:                                                   */
         /**
          *    Framing Error bit.
          *    This is used to indicate the occurrence of a framing error in
          *    the receiver. A framing
          *    error occurs when the receiver does not detect a valid STOP
          *    bit in the received data.
          *    In the FIFO mode, since the framing error is associated with a
          *     character received, it
          *    is revealed when the character with the framing error is at
          *    the top of the FIFO. When
          *    a framing error occurs the UART will try resynchronize. It
          *    does this by assuming that
          *    the error was due to the start bit of the next character and
          *    then continues receiving
          *    the other bit i.e. data, and/or parity and stop.
          *    It should be noted that the Framing Error (FE) bit (LSR[3])
          *    will be set if a break
          *    interrupt has occurred, as indicated by Break Interrupt (BI)
          *    bit (LSR[4]). This happens because the
          *    break character implicitly generates a framing error by
          *    holding the sin input to logic 0 for
          *    longer than the duration of a character.
          *    Reading the LSR clears the FE bit (if LSR_STATUS_CLEAR==1) Or
          *    Reading the LSR or RBR clears the FE bit (if
          *    LSR_STATUS_CLEAR==0).
         */
         uint32_t FE : 1; /* bit 3; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1242                   */
         /* Description:                                                   */
         /**
          *    Break Interrupt bit.
          *    This is used to indicate the detection of a break sequence on
          *    the serial input data.
          *    If in UART mode it is set whenever the serial input, sin, is
          *    held in a logic '0'
          *    state for longer than the sum of start time + data bits +
          *    parity + stop bits.
          *    If in infrared mode  it is set whenever the serial input,
          *    sir_in, is continuously
          *    pulsed to logic '0' for longer than the sum of start time +
          *    data bits + parity + stop
          *    bits.
          *    A break condition on serial input causes one and only one
          *    character, consisting of
          *    all zeros, to be received by the UART.
          *     In the FIFO mode, the character associated
          *    with the break condition is carried through the FIFO and is
          *    revealed when the
          *    character is at the top of the FIFO.
          *    Reading the LSR clears the BI bit (if LSR_STATUS_CLEAR==1) Or
          *    Reading the LSR or RBR clears the BI bit (if
          *    LSR_STATUS_CLEAR==0).
          *    In the non-FIFO mode, the BI indication occurs immediately and
          *     persists until the LSR is
          *    read.
          *    Note: If a FIFO is full when a break condition is received, a
          *    FIFO overrun occurs. The
          *    break condition and all the information associated with
          *    it-parity and framing errors-is
          *    discarded; any information that a break character was received
          *     is lost.
         */
         uint32_t BI : 1; /* bit 4; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1297                   */
         /* Description:                                                   */
         /**
          *    Transmit Holding Register Empty bit.
          *    If THRE_MODE_USER = Disabled or THRE mode is disabled (IER[7]
          *    set to zero) and
          *    regardless of FIFO's being implemented/enabled or not, this
          *    bit indicates that
          *    the THR or TX FIFO is empty.
          *     This bit is set whenever data is transferred from
          *    the THR or TX FIFO to the transmitter shift register and no
          *    new data has been
          *    written to the THR or TX FIFO. This also causes a THRE
          *    Interrupt to occur, if the
          *    THRE Interrupt is enabled.
          *    If THRE_MODE_USER == Enabled AND FIFO_MODE != NONE and both
          *    modes are active
          *    (IER[7] set to one and FCR[0] set to one respectively), the
          *    functionality is switched
          *    to indicate the transmitter FIFO is full, and no longer
          *    controls THRE interrupts,
          *    which are then controlled by the FCR[5:4] threshold setting.
          *    Programmable THRE
          *    interrupt mode operation is described in detail in section
          *    'Programmable THRE Interrupt' in data book.
         */
         uint32_t THRE : 1; /* bit 5; R; 0x1 */

         /* Source filename: DW_apb_uart.csr, line: 1337                   */
         /* Description:                                                   */
         /**
          *    Transmitter Empty bit.
          *    If in FIFO mode (FIFO_MODE != NONE) and FIFO's enabled (FCR[0]
          *     set to one), this
          *    bit is set whenever the Transmitter Shift Register and the
          *    FIFO are both empty.
          *    If in the non-FIFO mode or FIFO's are disabled, this bit is
          *    set whenever the
          *    Transmitter Holding Register and the Transmitter Shift
          *    Register are both empty.
         */
         uint32_t TEMT : 1; /* bit 6; R; 0x1 */

         /* Source filename: DW_apb_uart.csr, line: 1364                   */
         /* Description:                                                   */
         /**
          *    Receiver FIFO Error bit.
          *    This bit is only relevant when FIFO_MODE != NONE AND FIFO's
          *    are enabled (FCR[0]
          *    set to one). This is used to indicate if there is at least one
          *     parity error, framing
          *    error, or break indication in the FIFO.
          *    This bit is cleared when the LSR is read and the character
          *    with the error is at the
          *    top of the receiver FIFO and there are no subsequent errors in
          *     the FIFO.
         */
         uint32_t RFE : 1; /* bit 7; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1393                   */
         /* Description:                                                   */
         /**
          *    lSR 8 Reserved bit for UART_9BIT_DATA_EN
         */
         uint32_t RSVD_ADDR_RCVD : 1; /* bit 8; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1400                   */
         /* Description:                                                   */
         /**
          *    LSR 31to9 Reserved bits read as zero.
         */
         uint32_t RSVD_LSR_31to9 : 23; /* bits 31 to 9; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_LSR_t;

/* Typedef for Register: uart::MSR                                         */
/* Source filename: DW_apb_uart.csr, line: 1408                            */
/* Title: Modem Status Register                                            */
/* Description:                                                            */
/**
 *    Whenever bits 0, 1, 2 or 3 is set to logic one, to indicate
 *    a change on the modem control inputs, a modem status interrupt will be
 *    generated
 *    if enabled via the IER regardless of when the change occurred. The bits
 *    (bits 0, 1, 3) can be set after a reset-even though their respective
 *    modem signals are
 *    inactive-because the synchronized version of the modem signals have a
 *    reset value of 0 and change to value 1 after reset. To
 *    prevent unwanted interrupts due to this change, a read of the MSR
 *    register can be performed after reset.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1425                   */
         /* Description:                                                   */
         /**
          *    Delta Clear to Send.
          *    This is used to indicate that the modem control line cts_n has
          *     changed since the
          *    last time the MSR was read.
          *    Reading the MSR clears the DCTS bit.
          *    In Loopback Mode (MCR[4] set to one), DCTS reflects changes on
          *     MCR[1] (RTS).
          *    Note, if the DCTS bit is not set and the cts_n signal is
          *    asserted (low) and a reset
          *    occurs (software or otherwise), then the DCTS bit will get set
          *     when the reset is
          *    removed if the cts_n signal remains asserted.
         */
         uint32_t DCTS : 1; /* bit 0; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1457                   */
         /* Description:                                                   */
         /**
          *    Delta Data Set Ready.
          *    This is used to indicate that the modem control line dsr_n has
          *     changed since
          *    the last time the MSR was read.
          *    Reading the MSR clears the DDSR bit.
          *    In Loopback Mode (MCR[4] set to one), DDSR reflects changes on
          *     MCR[0] (DTR).
          *    Note, if the DDSR bit is not set and the dsr_n signal is
          *    asserted (low) and a reset
          *    occurs (software or otherwise), then the DDSR bit will get set
          *     when the reset is
          *    removed if the dsr_n signal remains asserted.
         */
         uint32_t DDSR : 1; /* bit 1; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1489                   */
         /* Description:                                                   */
         /**
          *    Trailing Edge of Ring Indicator.
          *    This is used to indicate that a change on the input ri_n (from
          *     an active low, to
          *    an inactive high state) has occurred since the last time the
          *    MSR was read.
          *    Reading the MSR clears the TERI bit.
          *    In Loopback Mode (MCR[4] set to one), TERI reflects when
          *    MCR[2] (Out1) has changed
          *    state from a high to a low.
         */
         uint32_t TERI : 1; /* bit 2; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1517                   */
         /* Description:                                                   */
         /**
          *    Delta Data Carrier Detect.
          *    This is used to indicate that the modem control line dcd_n has
          *     changed since the last
          *    time the MSR was read.
          *    Reading the MSR clears the DDCD bit.
          *    In Loopback Mode (MCR[4] set to one), DDCD reflects changes on
          *     MCR[3] (Out2).
          *    Note, if the DDCD bit is not set and the dcd_n signal is
          *    asserted (low) and a reset
          *    occurs (software or otherwise), then the DDCD bit will get set
          *     when the reset is
          *    removed if the dcd_n signal remains asserted.
         */
         uint32_t DDCD : 1; /* bit 3; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1549                   */
         /* Description:                                                   */
         /**
          *    Clear to Send.
          *    This is used to indicate the current state of the modem
          *    control line cts_n. That is,
          *    this bit is the complement cts_n. When the Clear to Send input
          *     (cts_n) is asserted
          *    it is an indication that the modem or data set is ready to
          *    exchange data with the
          *    DW_apb_uart.
          *    In Loopback Mode (MCR[4] set to one), CTS is the same as
          *    MCR[1] (RTS).
         */
         uint32_t CTS : 1; /* bit 4; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1578                   */
         /* Description:                                                   */
         /**
          *    Data Set Ready.
          *    This is used to indicate the current state of the modem
          *    control line dsr_n. That is
          *    this bit is the complement dsr_n. When the Data Set Ready
          *    input (dsr_n) is asserted
          *    it is an indication that the modem or data set is ready to
          *    establish communications
          *    with the DW_apb_uart.
          *    In Loopback Mode (MCR[4] set to one), DSR is the same as
          *    MCR[0] (DTR).
         */
         uint32_t DSR : 1; /* bit 5; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1607                   */
         /* Description:                                                   */
         /**
          *    Ring Indicator.
          *    This is used to indicate the current state of the modem
          *    control line ri_n. That is
          *    this bit is the complement ri_n. When the Ring Indicator input
          *     (ri_n) is asserted
          *    it is an indication that a telephone ringing signal has been
          *    received by the modem
          *    or data set.
          *    In Loopback Mode (MCR[4] set to one), RI is the same as MCR[2]
          *     (Out1).
         */
         uint32_t RI : 1; /* bit 6; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1636                   */
         /* Description:                                                   */
         /**
          *    Data Carrier Detect.
          *    This is used to indicate the current state of the modem
          *    control line dcd_n. That is
          *    this bit is the complement dcd_n. When the Data Carrier Detect
          *     input (dcd_n) is
          *    asserted it is an indication that the carrier has been
          *    detected by the modem or
          *    data set.
          *    In Loopback Mode (MCR[4] set to one), DCD is the same as
          *    MCR[3] (Out2).
         */
         uint32_t DCD : 1; /* bit 7; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 1665                   */
         /* Description:                                                   */
         /**
          *    MSR 31to8 Reserved bits read as 0.
         */
         uint32_t RSVD_MSR_31to8 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_MSR_t;

/* Typedef for Register: uart::SCR                                         */
/* Source filename: DW_apb_uart.csr, line: 1673                            */
/* Title: Scratchpad Register                                              */
/* Description:                                                            */
/**
 *    Scratchpad Register
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1678                   */
         /* Description:                                                   */
         /**
          *    This register is for programmers to use as a temporary storage
          *     space. It has no
          *    defined purpose in the DW_apb_uart.
         */
         uint32_t SCR : 8; /* bits 7 to 0; R/W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 1687                   */
         /* Description:                                                   */
         /**
          *    SCR 31to8 Reserved bits read as 0.
         */
         uint32_t RSVD_SCR_31to8 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SCR_t;

/* Typedef for Register: uart::SRBR0::SRBR0                                */
/* Source filename: DW_apb_uart.csr, line: 1698                            */
/* Title: Shadow Receive Buffer Register                                   */
/* Description:                                                            */
/**
 *    This register is valid only when the DW_apb_uart is configured to have
 *    additional shadow registers
 *    implemented (SHADOW = YES). If shadow registers are not implemented,
 *    this register does not exist and
 *    reading from this register address returns 0.
 *    This register can be accessed only when the DLAB bit (LCR[7]) is
 *    cleared.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1710                   */
         /* Description:                                                   */
         /**
          *    Shadow Receive Buffer Register n.
          *    This is a shadow register for the RBR and has been allocated
          *    sixteen 32-bit locations
          *    so as to accommodate burst accesses from the master.
          *    This register contains the data byte received on the serial
          *    input port (sin) in UART
          *    mode or the serial infrared input (sir_in) in infrared mode.
          *    The data in this register
          *    is valid only if the Data Ready (DR) bit in the Line status
          *    Register (LSR) is set.
          *    If in non-FIFO mode (FIFO_MODE == NONE) or FIFOs are disabled
          *    (FCR[0] set to zero), the
          *    data in the RBR must be read before the next data arrives,
          *    otherwise it will be
          *    overwritten, resulting in an overrun error.
          *    If in FIFO mode (FIFO_MODE != NONE) and FIFOs are enabled
          *    (FCR[0] set to one), this
          *    register accesses the head of the receive FIFO. If the receive
          *     FIFO is full and this
          *    register is not read before the next data character arrives,
          *    then the data already
          *    in the FIFO will be preserved but any incoming data will be
          *    lost. An overrun error
          *    will also occur.
          *    Note:
          *     - When UART_9BIT_DATA_EN=0, this field width is 8.
          *     - When UART_9BIT_DATA_EN=1, this field width is 9.
         */
         uint32_t SRBRn : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 1746                   */
         /* Description:                                                   */
         /**
          *    SRBR0 31 to SRBRN_REG_SIZE Reserved bits read as 0.
         */
         uint32_t RSVD_SRBRn : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR0_SRBR0_t;

/* Typedef for Register: uart::SRBR0::STHR0                                */
/* Source filename: DW_apb_uart.csr, line: 1754                            */
/* Title: Shadow Transmit Holding Register                                 */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register. This register is valid only when the
 *    DW_apb_uart is configured to have additional shadow registers
 *    implemented (SHADOW = YES). If shadow registers are not implemented,
 *    this register does not exist, and
 *    reading from this register address returns 0.
 *    This register can be accessed only when the DLAB bit (LCR[7]) is
 *    cleared.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1768                   */
         /* Description:                                                   */
         /**
          *    Shadow Transmit Holding Register n.
          *    This is a shadow register for the THR and has been allocated
          *    sixteen 32-bit locations
          *    so as to accommodate burst accesses from the master.
          *    This register contains data to be transmitted on the serial
          *    output port (sout) in UART
          *    mode or the serial infrared output (sir_out_n) in infrared
          *    mode. Data should only be
          *    written to the THR when the THR Empty (THRE) bit (LSR[5]) is
          *    set.
          *    If in non-FIFO mode or FIFO's are disabled (FCR[0] set to
          *    zero) and THRE is set,
          *    writing a single character to the THR clears the THRE. Any
          *    additional writes to the
          *    THR before the THRE is set again causes the THR data to be
          *    overwritten.
          *    If in FIFO mode and FIFO's are enabled (FCR[0] set to one) and
          *     THRE is set, x number of
          *    characters of data may be written to the THR before the FIFO
          *    is full. The number x
          *    (default=16) is determined by the value of FIFO Depth that you
          *     set during configuration.
          *    Any attempt to write data when the FIFO is full results in the
          *     write data being lost.
          *    Note:
          *     - When UART_9BIT_DATA_EN=0, this field width is 8.
          *     - When UART_9BIT_DATA_EN=1, this field width is 9. The 9th
          *    bit is applicable only when LCR_EXT[3]=1.
         */
         uint32_t STHRn : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 1806                   */
         /* Description:                                                   */
         /**
          *    STHRn 31 to STHRN_REG_SIZE Reserved bits read as 0.
         */
         uint32_t RSVD_STHRn : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR0_STHR0_t;

/* Typedef for Union: uart::SRBR0                                          */
/* Source filename: DW_apb_uart.csr, line: 1696                            */
typedef union {
   Uart_SRBR0_SRBR0_t SRBR0; /**< Offset 0x0 (R) */
   Uart_SRBR0_STHR0_t STHR0; /**< Offset 0x0 (R/W) */
} Uart_SRBR0_t;

/* Typedef for Register: uart::SRBR1::SRBR1                                */
/* Source filename: DW_apb_uart.csr, line: 1818                            */
/* Title: Shadow Receive Buffer Register 1                                 */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 1
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1823                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR1 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 1830                   */
         /* Description:                                                   */
         /**
          *    SRBR1 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR1 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR1_SRBR1_t;

/* Typedef for Register: uart::SRBR1::STHR1                                */
/* Source filename: DW_apb_uart.csr, line: 1838                            */
/* Title: Shadow Transmit Holding Register 1                               */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 1
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1844                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t STHR1 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 1852                   */
         /* Description:                                                   */
         /**
          *    STHR1 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR1 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR1_STHR1_t;

/* Typedef for Union: uart::SRBR1                                          */
/* Source filename: DW_apb_uart.csr, line: 1816                            */
typedef union {
   Uart_SRBR1_SRBR1_t SRBR1; /**< Offset 0x0 (R) */
   Uart_SRBR1_STHR1_t STHR1; /**< Offset 0x0 (R/W) */
} Uart_SRBR1_t;

/* Typedef for Register: uart::SRBR2::SRBR2                                */
/* Source filename: DW_apb_uart.csr, line: 1864                            */
/* Title: Shadow Receive Buffer Register 2                                 */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 2
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1869                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR2 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 1876                   */
         /* Description:                                                   */
         /**
          *    SRBR2 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR2 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR2_SRBR2_t;

/* Typedef for Register: uart::SRBR2::STHR2                                */
/* Source filename: DW_apb_uart.csr, line: 1884                            */
/* Title: Shadow Transmit Holding Register 2                               */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 2
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1890                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr2 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 1898                   */
         /* Description:                                                   */
         /**
          *    STHR2 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR2 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR2_STHR2_t;

/* Typedef for Union: uart::SRBR2                                          */
/* Source filename: DW_apb_uart.csr, line: 1862                            */
typedef union {
   Uart_SRBR2_SRBR2_t SRBR2; /**< Offset 0x0 (R) */
   Uart_SRBR2_STHR2_t STHR2; /**< Offset 0x0 (R/W) */
} Uart_SRBR2_t;

/* Typedef for Register: uart::SRBR3::SRBR3                                */
/* Source filename: DW_apb_uart.csr, line: 1910                            */
/* Title: Shadow Receive Buffer Register 3                                 */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 3
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1915                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR3 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 1922                   */
         /* Description:                                                   */
         /**
          *    SRBR3 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR3 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR3_SRBR3_t;

/* Typedef for Register: uart::SRBR3::STHR3                                */
/* Source filename: DW_apb_uart.csr, line: 1930                            */
/* Title: Shadow Transmit Holding Register 3                               */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 3
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1936                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr3 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 1944                   */
         /* Description:                                                   */
         /**
          *    STHR3 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR3 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR3_STHR3_t;

/* Typedef for Union: uart::SRBR3                                          */
/* Source filename: DW_apb_uart.csr, line: 1908                            */
typedef union {
   Uart_SRBR3_SRBR3_t SRBR3; /**< Offset 0x0 (R) */
   Uart_SRBR3_STHR3_t STHR3; /**< Offset 0x0 (R/W) */
} Uart_SRBR3_t;

/* Typedef for Register: uart::SRBR4::SRBR4                                */
/* Source filename: DW_apb_uart.csr, line: 1956                            */
/* Title: Shadow Receive Buffer Register 4                                 */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 4
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1961                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR4 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 1968                   */
         /* Description:                                                   */
         /**
          *    SRBR4 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR4 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR4_SRBR4_t;

/* Typedef for Register: uart::SRBR4::STHR4                                */
/* Source filename: DW_apb_uart.csr, line: 1976                            */
/* Title: Shadow Transmit Holding Register 4                               */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 4
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 1982                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr4 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 1990                   */
         /* Description:                                                   */
         /**
          *    STHR4 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR4 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR4_STHR4_t;

/* Typedef for Union: uart::SRBR4                                          */
/* Source filename: DW_apb_uart.csr, line: 1954                            */
typedef union {
   Uart_SRBR4_SRBR4_t SRBR4; /**< Offset 0x0 (R) */
   Uart_SRBR4_STHR4_t STHR4; /**< Offset 0x0 (R/W) */
} Uart_SRBR4_t;

/* Typedef for Register: uart::SRBR5::SRBR5                                */
/* Source filename: DW_apb_uart.csr, line: 2002                            */
/* Title: Shadow Receive Buffer Register 5                                 */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 5
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2007                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR5 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2014                   */
         /* Description:                                                   */
         /**
          *    SRBR5 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR5 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR5_SRBR5_t;

/* Typedef for Register: uart::SRBR5::STHR5                                */
/* Source filename: DW_apb_uart.csr, line: 2022                            */
/* Title: Shadow Transmit Holding Register 5                               */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 5
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2028                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr5 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2036                   */
         /* Description:                                                   */
         /**
          *    STHR5 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR5 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR5_STHR5_t;

/* Typedef for Union: uart::SRBR5                                          */
/* Source filename: DW_apb_uart.csr, line: 2000                            */
typedef union {
   Uart_SRBR5_SRBR5_t SRBR5; /**< Offset 0x0 (R) */
   Uart_SRBR5_STHR5_t STHR5; /**< Offset 0x0 (R/W) */
} Uart_SRBR5_t;

/* Typedef for Register: uart::SRBR6::SRBR6                                */
/* Source filename: DW_apb_uart.csr, line: 2048                            */
/* Title: Shadow Receive Buffer Register 6                                 */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 6
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2053                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR6 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2060                   */
         /* Description:                                                   */
         /**
          *    SRBR6 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR6 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR6_SRBR6_t;

/* Typedef for Register: uart::SRBR6::STHR6                                */
/* Source filename: DW_apb_uart.csr, line: 2068                            */
/* Title: Shadow Transmit Holding Register 6                               */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 6
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2074                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr6 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2082                   */
         /* Description:                                                   */
         /**
          *    STHR6 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR6 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR6_STHR6_t;

/* Typedef for Union: uart::SRBR6                                          */
/* Source filename: DW_apb_uart.csr, line: 2046                            */
typedef union {
   Uart_SRBR6_SRBR6_t SRBR6; /**< Offset 0x0 (R) */
   Uart_SRBR6_STHR6_t STHR6; /**< Offset 0x0 (R/W) */
} Uart_SRBR6_t;

/* Typedef for Register: uart::SRBR7::SRBR7                                */
/* Source filename: DW_apb_uart.csr, line: 2094                            */
/* Title: Shadow Receive Buffer Register 7                                 */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 7
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2099                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR7 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2106                   */
         /* Description:                                                   */
         /**
          *    SRBR7 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR7 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR7_SRBR7_t;

/* Typedef for Register: uart::SRBR7::STHR7                                */
/* Source filename: DW_apb_uart.csr, line: 2114                            */
/* Title: Shadow Transmit Holding Register 7                               */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 7
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2120                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr7 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2128                   */
         /* Description:                                                   */
         /**
          *    STHR7 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR7 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR7_STHR7_t;

/* Typedef for Union: uart::SRBR7                                          */
/* Source filename: DW_apb_uart.csr, line: 2092                            */
typedef union {
   Uart_SRBR7_SRBR7_t SRBR7; /**< Offset 0x0 (R) */
   Uart_SRBR7_STHR7_t STHR7; /**< Offset 0x0 (R/W) */
} Uart_SRBR7_t;

/* Typedef for Register: uart::SRBR8::SRBR8                                */
/* Source filename: DW_apb_uart.csr, line: 2140                            */
/* Title: Shadow Receive Buffer Register 8                                 */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 8
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2145                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR8 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2152                   */
         /* Description:                                                   */
         /**
          *    SRBR8 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR8 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR8_SRBR8_t;

/* Typedef for Register: uart::SRBR8::STHR8                                */
/* Source filename: DW_apb_uart.csr, line: 2160                            */
/* Title: Shadow Transmit Holding Register 8                               */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 8
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2166                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr8 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2174                   */
         /* Description:                                                   */
         /**
          *    STHR8 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR8 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR8_STHR8_t;

/* Typedef for Union: uart::SRBR8                                          */
/* Source filename: DW_apb_uart.csr, line: 2138                            */
typedef union {
   Uart_SRBR8_SRBR8_t SRBR8; /**< Offset 0x0 (R) */
   Uart_SRBR8_STHR8_t STHR8; /**< Offset 0x0 (R/W) */
} Uart_SRBR8_t;

/* Typedef for Register: uart::SRBR9::SRBR9                                */
/* Source filename: DW_apb_uart.csr, line: 2186                            */
/* Title: Shadow Receive Buffer Register 9                                 */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 9
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2191                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR9 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2198                   */
         /* Description:                                                   */
         /**
          *    SRBR9 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR9 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR9_SRBR9_t;

/* Typedef for Register: uart::SRBR9::STHR9                                */
/* Source filename: DW_apb_uart.csr, line: 2206                            */
/* Title: Shadow Transmit Holding Register 9                               */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 9
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2212                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr9 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2220                   */
         /* Description:                                                   */
         /**
          *    STHR9 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR9 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR9_STHR9_t;

/* Typedef for Union: uart::SRBR9                                          */
/* Source filename: DW_apb_uart.csr, line: 2184                            */
typedef union {
   Uart_SRBR9_SRBR9_t SRBR9; /**< Offset 0x0 (R) */
   Uart_SRBR9_STHR9_t STHR9; /**< Offset 0x0 (R/W) */
} Uart_SRBR9_t;

/* Typedef for Register: uart::SRBR10::SRBR10                              */
/* Source filename: DW_apb_uart.csr, line: 2232                            */
/* Title: Shadow Receive Buffer Register 10                                */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 10
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2237                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR10 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2244                   */
         /* Description:                                                   */
         /**
          *    SRBR10 31to9or8 Reserved bi read as 0.
         */
         uint32_t RSVD_SRBR10 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR10_SRBR10_t;

/* Typedef for Register: uart::SRBR10::STHR10                              */
/* Source filename: DW_apb_uart.csr, line: 2252                            */
/* Title: Shadow Transmit Holding Register 10                              */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 10
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2258                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr10 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2266                   */
         /* Description:                                                   */
         /**
          *    STHR10 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR10 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR10_STHR10_t;

/* Typedef for Union: uart::SRBR10                                         */
/* Source filename: DW_apb_uart.csr, line: 2230                            */
typedef union {
   Uart_SRBR10_SRBR10_t SRBR10; /**< Offset 0x0 (R) */
   Uart_SRBR10_STHR10_t STHR10; /**< Offset 0x0 (R/W) */
} Uart_SRBR10_t;

/* Typedef for Register: uart::SRBR11::SRBR11                              */
/* Source filename: DW_apb_uart.csr, line: 2278                            */
/* Title: Shadow Receive Buffer Register 11                                */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 11
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2283                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR11 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2290                   */
         /* Description:                                                   */
         /**
          *    SRBR11 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR11 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR11_SRBR11_t;

/* Typedef for Register: uart::SRBR11::STHR11                              */
/* Source filename: DW_apb_uart.csr, line: 2298                            */
/* Title: Shadow Transmit Holding Register 11                              */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 11
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2304                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr11 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2312                   */
         /* Description:                                                   */
         /**
          *    STHR11 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR11 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR11_STHR11_t;

/* Typedef for Union: uart::SRBR11                                         */
/* Source filename: DW_apb_uart.csr, line: 2276                            */
typedef union {
   Uart_SRBR11_SRBR11_t SRBR11; /**< Offset 0x0 (R) */
   Uart_SRBR11_STHR11_t STHR11; /**< Offset 0x0 (R/W) */
} Uart_SRBR11_t;

/* Typedef for Register: uart::SRBR12::SRBR12                              */
/* Source filename: DW_apb_uart.csr, line: 2324                            */
/* Title: Shadow Receive Buffer Register 12                                */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 12
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2329                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR12 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2336                   */
         /* Description:                                                   */
         /**
          *    SRBR12 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR12 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR12_SRBR12_t;

/* Typedef for Register: uart::SRBR12::STHR12                              */
/* Source filename: DW_apb_uart.csr, line: 2344                            */
/* Title: Shadow Transmit Holding Register 12                              */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 12
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2350                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr12 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2358                   */
         /* Description:                                                   */
         /**
          *    STHR12 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR12 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR12_STHR12_t;

/* Typedef for Union: uart::SRBR12                                         */
/* Source filename: DW_apb_uart.csr, line: 2322                            */
typedef union {
   Uart_SRBR12_SRBR12_t SRBR12; /**< Offset 0x0 (R) */
   Uart_SRBR12_STHR12_t STHR12; /**< Offset 0x0 (R/W) */
} Uart_SRBR12_t;

/* Typedef for Register: uart::SRBR13::SRBR13                              */
/* Source filename: DW_apb_uart.csr, line: 2370                            */
/* Title: Shadow Receive Buffer Register 13                                */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 13
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2375                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR13 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2382                   */
         /* Description:                                                   */
         /**
          *    SRBR13 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR13 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR13_SRBR13_t;

/* Typedef for Register: uart::SRBR13::STHR13                              */
/* Source filename: DW_apb_uart.csr, line: 2390                            */
/* Title: Shadow Transmit Holding Register 13                              */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 13
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2396                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr13 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2404                   */
         /* Description:                                                   */
         /**
          *    STHR13 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR13 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR13_STHR13_t;

/* Typedef for Union: uart::SRBR13                                         */
/* Source filename: DW_apb_uart.csr, line: 2368                            */
typedef union {
   Uart_SRBR13_SRBR13_t SRBR13; /**< Offset 0x0 (R) */
   Uart_SRBR13_STHR13_t STHR13; /**< Offset 0x0 (R/W) */
} Uart_SRBR13_t;

/* Typedef for Register: uart::SRBR14::SRBR14                              */
/* Source filename: DW_apb_uart.csr, line: 2416                            */
/* Title: Shadow Receive Buffer Register 14                                */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 14
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2421                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR14 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2428                   */
         /* Description:                                                   */
         /**
          *    SRBR14 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR14 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR14_SRBR14_t;

/* Typedef for Register: uart::SRBR14::STHR14                              */
/* Source filename: DW_apb_uart.csr, line: 2436                            */
/* Title: Shadow Transmit Holding Register 14                              */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 14
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2442                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t sthr14 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2450                   */
         /* Description:                                                   */
         /**
          *    STHR14 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR14 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR14_STHR14_t;

/* Typedef for Union: uart::SRBR14                                         */
/* Source filename: DW_apb_uart.csr, line: 2414                            */
typedef union {
   Uart_SRBR14_SRBR14_t SRBR14; /**< Offset 0x0 (R) */
   Uart_SRBR14_STHR14_t STHR14; /**< Offset 0x0 (R/W) */
} Uart_SRBR14_t;

/* Typedef for Register: uart::SRBR15::SRBR15                              */
/* Source filename: DW_apb_uart.csr, line: 2462                            */
/* Title: Shadow Receive Buffer Register 15                                */
/* Description:                                                            */
/**
 *    Shadow Receive Buffer Register 15
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2467                   */
         /* Description:                                                   */
         /**
          *    See SRBR0 description
         */
         uint32_t SRBR15 : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2474                   */
         /* Description:                                                   */
         /**
          *    SRBR15 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_SRBR15 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR15_SRBR15_t;

/* Typedef for Register: uart::SRBR15::STHR15                              */
/* Source filename: DW_apb_uart.csr, line: 2482                            */
/* Title: Shadow Transmit Holding Register 15                              */
/* Description:                                                            */
/**
 *    Shadow Transmit Holding Register 15
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2488                   */
         /* Description:                                                   */
         /**
          *    See STHR0 description.
         */
         uint32_t STHR15 : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2496                   */
         /* Description:                                                   */
         /**
          *    STHR15 31to9or8 Reserved bits read as 0.
         */
         uint32_t RSVD_STHR15 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRBR15_STHR15_t;

/* Typedef for Union: uart::SRBR15                                         */
/* Source filename: DW_apb_uart.csr, line: 2460                            */
typedef union {
   Uart_SRBR15_SRBR15_t SRBR15; /**< Offset 0x0 (R) */
   Uart_SRBR15_STHR15_t STHR15; /**< Offset 0x0 (R/W) */
} Uart_SRBR15_t;

/* Typedef for Register: uart::FAR                                         */
/* Source filename: DW_apb_uart.csr, line: 2506                            */
/* Title: FIFO Access Register                                             */
/* Description:                                                            */
/**
 *    FIFO Access Register
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2511                   */
         /* Description:                                                   */
         /**
          *    Writes will have no effect when FIFO_ACCESS == No, always
          *    readable.  This register
          *    is use to enable a FIFO access mode for testing, so that the
          *    receive FIFO can be
          *    written by the master and the transmit FIFO can be read by the
          *     master when FIFO's
          *    are implemented and enabled. When FIFOs are not implemented or
          *     not enabled it
          *    allows the RBR to be written by the master and the THR to be
          *    read by the master.
          *    Note, that when the FIFO access mode is enabled/disabled, the
          *    control portion of
          *    the receive FIFO and transmit FIFO is reset and the FIFO's are
          *     treated as empty.
         */
         uint32_t FAR : 1; /* bit 0; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 2543                   */
         /* Description:                                                   */
         /**
          *    FAR 31to1 Reserved bits read as 0.
         */
         uint32_t RSVD_FAR_31to1 : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Uart_FAR_t;

/* Typedef for Register: uart::TFR                                         */
/* Source filename: DW_apb_uart.csr, line: 2552                            */
/* Title: Transmit FIFO Read                                               */
/* Description:                                                            */
/**
 *    This register is valid only when the DW_apb_uart is configured to have
 *    the FIFO access test mode available
 *    (FIFO_ACCESS = YES). If not configured, this register does not exist
 *    and reading from this register address
 *    returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2562                   */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Read.
          *    These bits are only valid when FIFO access mode is enabled
          *    (FAR[0] is set to one).
          *    When FIFO's are implemented and enabled, reading this register
          *     gives the data at the
          *    top of the transmit FIFO. Each consecutive read pops the
          *    transmit FIFO and gives the
          *    next data value that is currently at the top of the FIFO.
          *    When FIFO's are not implemented or not enabled, reading this
          *    register gives the data
          *    in the THR.
         */
         uint32_t TFR : 8; /* bits 7 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2582                   */
         /* Description:                                                   */
         /**
          *    TFR 31to8 Reserved bits read as 0.
         */
         uint32_t RSVD_TFR_31to8 : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_TFR_t;

/* Typedef for Register: uart::RFW                                         */
/* Source filename: DW_apb_uart.csr, line: 2590                            */
/* Title: Receive FIFO Write                                               */
/* Description:                                                            */
/**
 *    This register is valid only when the DW_apb_uart is configured to have
 *    the FIFO access test mode available
 *    (FIFO_ACCESS = YES). If not configured, this register does not exist
 *    and reading from this register address returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2598                   */
         /* Description:                                                   */
         /**
          *    Receive FIFO Write Data.
          *    These bits are only valid when FIFO access mode is enabled
          *    (FAR[0] is set to one).
          *    When FIFO's are implemented and enabled, the data that is
          *    written to the RFWD is pushed
          *    into the receive FIFO. Each consecutive write pushes the new
          *    data to the next write
          *    location in the receive FIFO.
          *    When FIFO's are not implemented or not enabled, the data that
          *    is written to the RFWD
          *    is pushed into the RBR.
         */
         uint32_t RFWD : 8; /* bits 7 to 0; W; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2617                   */
         /* Description:                                                   */
         /**
          *    Receive FIFO Parity Error.
          *    These bits are only valid when FIFO access mode is enabled
          *    (FAR[0] is set to one).
          *    When FIFO's are implemented and enabled, this bit is used to
          *    write parity error
          *    detection information to the receive FIFO.
          *    When FIFO's are not implemented or not enabled, this bit is
          *    used to write parity
          *    error detection information to the RBR.
         */
         uint32_t RFPE : 1; /* bit 8; W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 2645                   */
         /* Description:                                                   */
         /**
          *    Receive FIFO Framing Error.
          *    These bits are only valid when FIFO access mode is enabled
          *    (FAR[0] is set to one).
          *    When FIFO's are implemented and enabled, this bit is used to
          *    write framing error
          *    detection information to the receive FIFO.
          *    When FIFO's are not implemented or not enabled, this bit is
          *    used to write framing
          *    error detection information to the RBR.
         */
         uint32_t RFFE : 1; /* bit 9; W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 2673                   */
         /* Description:                                                   */
         /**
          *    RFW 31to10 Reserved bits read as 0.
         */
         uint32_t RSVD_RFW_31to10 : 22; /* bits 31 to 10; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Uart_RFW_t;

/* Typedef for Register: uart::USR                                         */
/* Source filename: DW_apb_uart.csr, line: 2682                            */
/* Title: UART Status register                                             */
/* Description:                                                            */
/**
 *    UART Status register.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2688                   */
         /* Description:                                                   */
         /**
          *    UART Busy.
          *    This bit is only valid when UART_16550_COMPATIBLE == NO. This
          *    indicates that a serial
          *    transfer is in progress, when cleared indicates that the
          *    DW_apb_uart is idle or inactive.
          *    This bit will be set to 1 (busy) under any of the following
          *    conditions:
          *    - Transmission in progress on serial interface
          *    - Transmit data present in THR, when FIFO access mode is not
          *    being used (FAR = 0) and the baud divisor is non-zero
          *    ({DLH,DLL} does not equal 0) when the divisor latch access bit
          *     is 0 (LCR.DLAB = 0)
          *    - Reception in progress on the interface
          *    - Receive data present in RBR, when FIFO access mode is not
          *    being used (FAR = 0)
          *    Note: It is possible for the UART Busy bit to be cleared even
          *    though a new
          *    character may have been sent from another device. That is, if
          *    the DW_apb_uart
          *    has no data in the THR and RBR and there is no transmission in
          *     progress and a start
          *    bit of a new character has just reached the DW_apb_uart. This
          *    is due to the fact
          *    that a valid start is not seen until the middle of the bit
          *    period and this duration
          *    is dependent on the baud divisor that has been programmed. If
          *    a second system clock
          *    has been implemented (CLOCK_MODE == Enabled), the assertion of
          *     this bit will also be
          *    delayed by several cycles of the slower clock.
         */
         uint32_t BUSY : 1; /* bit 0; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 2743                   */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Not Full.
          *    This bit is only valid when FIFO_STAT == YES. This is used to
          *    indicate that the
          *    transmit FIFO is not full.
          *    This bit is cleared when the TX FIFO is full.
         */
         uint32_t TFNF : 1; /* bit 1; R; 0x1 */

         /* Source filename: DW_apb_uart.csr, line: 2766                   */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Empty.
          *    This bit is only valid when FIFO_STAT == YES. This is used to
          *    indicate that the
          *    transmit FIFO is completely empty.
          *    This bit is cleared when the TX FIFO is no longer empty.
         */
         uint32_t TFE : 1; /* bit 2; R; 0x1 */

         /* Source filename: DW_apb_uart.csr, line: 2789                   */
         /* Description:                                                   */
         /**
          *    Receive FIFO Not Empty.
          *    This bit is only valid when FIFO_STAT == YES. This is used to
          *    indicate that the
          *    receive FIFO contains one or more entries.
          *    This bit is cleared when the RX FIFO is empty.
         */
         uint32_t RFNE : 1; /* bit 3; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 2812                   */
         /* Description:                                                   */
         /**
          *    Receive FIFO Full.
          *    This bit is only valid when FIFO_STAT == YES. This is used to
          *    indicate that the
          *    receive FIFO is completely full. That is:
          *    This bit is cleared when the RX FIFO is no longer full.
         */
         uint32_t RFF : 1; /* bit 4; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 2835                   */
         /* Description:                                                   */
         /**
          *    USR 31to5 Reserved bits read as 0.
         */
         uint32_t RSVD_USR_31to5 : 27; /* bits 31 to 5; R; 0x0000000 */
      } B;
      uint32_t R;
   } ;
} Uart_USR_t;

/* Typedef for Register: uart::TFL                                         */
/* Source filename: DW_apb_uart.csr, line: 2843                            */
/* Title: Transmit FIFO Level                                              */
/* Description:                                                            */
/**
 *    TFL register is valid only when the DW_apb_uart is configured to have
 *    additional FIFO status registers
 *    implemented (FIFO_STAT = YES). If status registers are not implemented,
 *     this register does not exist and
 *    reading from this register address returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2853                   */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Level.
          *    This indicates the number of data entries in the transmit
          *    FIFO.
         */
         uint32_t tfl : 7; /* bits 6 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2863                   */
         /* Description:                                                   */
         /**
          *    TFL 31 to ADDR_WIDTH Reserved bits read as 0.
         */
         uint32_t RSVD_TFL_31toADDR_WIDTH : 25; /* bits 31 to 7; R; 0x0000000 */
      } B;
      uint32_t R;
   } ;
} Uart_TFL_t;

/* Typedef for Register: uart::RFL                                         */
/* Source filename: DW_apb_uart.csr, line: 2871                            */
/* Title: Receive FIFO Level                                               */
/* Description:                                                            */
/**
 *    RFL register is valid only when the DW_apb_uart is configured to have
 *    additional FIFO status registers
 *    implemented (FIFO_STAT = YES). If status registers are not implemented,
 *     this register does not exist and
 *    reading from this register address returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2881                   */
         /* Description:                                                   */
         /**
          *    Receive FIFO Level.
          *    This indicates the number of data entries in the receive FIFO.
         */
         uint32_t rfl : 7; /* bits 6 to 0; R; 0x00 */

         /* Source filename: DW_apb_uart.csr, line: 2891                   */
         /* Description:                                                   */
         /**
          *    RFL 31 to ADDR_WIDTH Reserved bits read as 0.
         */
         uint32_t RSVD_RFL_31toADDR_WIDTH : 25; /* bits 31 to 7; R; 0x0000000 */
      } B;
      uint32_t R;
   } ;
} Uart_RFL_t;

/* Typedef for Register: uart::SRR                                         */
/* Source filename: DW_apb_uart.csr, line: 2899                            */
/* Title: Software Reset Register                                          */
/* Description:                                                            */
/**
 *    This register is valid only when the DW_apb_uart is configured to have
 *    additional shadow registers
 *    implemented (SHADOW = YES). If shadow registers are not implemented,
 *    this register does not exist and
 *    reading from this register address returns 0.
 *    For more information on the amount of time that serial clock modules
 *    need in order to see new register
 *    values and reset their respective state machines, refer to the 'Clock
 *    Support' subsection in the data book.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 2913                   */
         /* Description:                                                   */
         /**
          *    UART Reset.
          *    This asynchronously resets the DW_apb_uart and synchronously
          *    removes the reset
          *    assertion. For a two clock implementation both pclk and sclk
          *    domains will be reset.
         */
         uint32_t UR : 1; /* bit 0; W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 2937                   */
         /* Description:                                                   */
         /**
          *    RCVR FIFO Reset.
          *    Writes will have no effect when FIFO_MODE == NONE. This is a
          *    shadow register for
          *    the RCVR FIFO Reset bit (FCR[1]). This can be used to remove
          *    the burden on software
          *    having to store previously written FCR values (which are
          *    pretty static) just to
          *    reset the reeive FIFO.
          *    This resets the control portion of the receive FIFO and treats
          *     the FIFO as empty.
          *    This will also de-assert the DMA RX request and single signals
          *     when additional DMA
          *    handshaking signals are selected (DMA_EXTRA == YES). Note that
          *     this bit is
          *    'self-clearing' and it is not necessary to clear this bit.
         */
         uint32_t RFR : 1; /* bit 1; W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 2960                   */
         /* Description:                                                   */
         /**
          *    XMIT FIFO Reset
          *    .
          *    Writes will have no effect when FIFO_MODE == NONE. This is a
          *    shadow register for
          *    the XMIT FIFO Reset bit (FCR[2]). This can be used to remove
          *    the burden on software
          *    having to store previously written FCR values (which are
          *    pretty static) just to
          *    reset the transmit FIFO.
          *    This resets the control portion of the transmit FIFO and
          *    treats the FIFO as empty.
          *    This will also de-assert the DMA TX request and single signals
          *     when additional DMA
          *    handshaking signals are selected (DMA_EXTRA = YES). Note that
          *    this bit is 'self-clearing'. It is not necessary to clear this
          *    bit.
         */
         uint32_t XFR : 1; /* bit 2; W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 2984                   */
         /* Description:                                                   */
         /**
          *    SRR 31to3 Reserved bits read as 0.
         */
         uint32_t RSVD_SRR_31to3 : 29; /* bits 31 to 3; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRR_t;

/* Typedef for Register: uart::SRTS                                        */
/* Source filename: DW_apb_uart.csr, line: 2993                            */
/* Title: Shadow Request to Send                                           */
/* Description:                                                            */
/**
 *    SRTS register is valid only when the DW_apb_uart is configured to have
 *    additional shadow registers
 *    implemented (SHADOW = YES). If shadow registers are not implemented,
 *    this register does not exist and
 *    reading from this register address returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3002                   */
         /* Description:                                                   */
         /**
          *    Shadow Request to Send.
          *    This is a shadow register for the RTS bit (MCR[1]), this can
          *    be used to remove the
          *    burden of having to performing a read modify write on the MCR.
          *    This is used to directly control the Request to Send (rts_n)
          *    output. The Request
          *    To Send (rts_n) output is used to inform the modem or data set
          *     that the UART is ready
          *    to exchange data.
          *    When Auto RTS Flow Control is not enabled (MCR[5] set to
          *    zero), the rts_n signal is
          *    set low by programming MCR[1] (RTS) to a high.
          *    In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5]
          *    set to one) and FIFO's
          *    enable (FCR[0] set to one), the rts_n output is controlled in
          *    the same way, but is
          *    also gated with the receiver FIFO threshold trigger (rts_n is
          *    inactive high when
          *    above the threshold) only when RTC Flow Trigger is disabled;
          *    otherwise it is gated by
          *    the receiver FIFO almost-full trigger, where 'almost full'
          *    refers to two available
          *    slots in the FIFO (rts_n is inactive high when above the
          *    threshold).
          *    Note that in Loopback mode (MCR[4] set to one), the rts_n
          *    output is held inactive
          *    high while the value of this location is internally looped
          *    back to an input.
         */
         uint32_t SRTS : 1; /* bit 0; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3052                   */
         /* Description:                                                   */
         /**
          *    SRTS 31to1 Reserved bits read as 0.
         */
         uint32_t RSVD_SRTS_31to1 : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRTS_t;

/* Typedef for Register: uart::SBCR                                        */
/* Source filename: DW_apb_uart.csr, line: 3061                            */
/* Title: Shadow Break Control Register                                    */
/* Description:                                                            */
/**
 *    SBCR register is valid only when the DW_apb_uart is configured to have
 *    additional shadow registers
 *    implemented (SHADOW = YES). If shadow registers are not implemented,
 *    this register does not exist and
 *    reading from this register address returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3070                   */
         /* Description:                                                   */
         /**
          *    Shadow Break Control Bit.
          *    This is a shadow register for the Break bit (LCR[6]), this can
          *     be used to remove
          *    the burden of having to performing a read modify write on the
          *    LCR.
          *    This is used to cause a break condition to be transmitted to
          *    the receiving device.
          *    If set to one the serial output is forced to the spacing
          *    (logic 0) state. When not
          *    in Loopback Mode, as determined by MCR[4], the sout line is
          *    forced low until the
          *    Break bit is cleared.
          *     If SIR_MODE == Enabled and active (MCR[6] set to one) the
          *    sir_out_n line is continuously pulsed. When in Loopback Mode,
          *    the break condition
          *    is internally looped back to the receiver.
         */
         uint32_t SBCB : 1; /* bit 0; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3104                   */
         /* Description:                                                   */
         /**
          *    SBCR 31to1 Reserved bits read as 0.
         */
         uint32_t RSVD_SBCR_31to1 : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SBCR_t;

/* Typedef for Register: uart::SDMAM                                       */
/* Source filename: DW_apb_uart.csr, line: 3113                            */
/* Title: Shadow DMA Mode Register                                         */
/* Description:                                                            */
/**
 *    This register is valid only when the DW_apb_uart is configured to have
 *    additional FIFO registers implemented (FIFO_MODE != None) and
 *    additional shadow registers implemented (SHADOW = YES). If these
 *    registers are not implemented, this register does not exist and reading
 *     from this register address returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3123                   */
         /* Description:                                                   */
         /**
          *    Shadow DMA Mode.
          *    This is a shadow register for the DMA mode bit (FCR[3]). This
          *    can be used to remove
          *    the burden of having to store the previously written value to
          *    the FCR in memory and
          *    having to mask this value so that only the DMA Mode bit gets
          *    updated.
          *    This determines the DMA signalling mode used for the
          *    dma_tx_req_n and dma_rx_req_n
          *    output signals when additional DMA handshaking signals are not
          *     selected
          *    (DMA_EXTRA == NO). See section 5.9 on page 54 for details on
          *    DMA support.
         */
         uint32_t SDMAM : 1; /* bit 0; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3154                   */
         /* Description:                                                   */
         /**
          *    SDMAM 31to1 Reserved bits read as 0.
         */
         uint32_t RSVD_SDMAM_31to1 : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SDMAM_t;

/* Typedef for Register: uart::SFE                                         */
/* Source filename: DW_apb_uart.csr, line: 3163                            */
/* Title: Shadow FIFO Enable Register                                      */
/* Description:                                                            */
/**
 *    SFE register is valid only when the DW_apb_uart is configured to have
 *    additional FIFO registers
 *    implemented (FIFO_MODE != None) and additional shadow registers
 *    implemented (SHADOW = YES). If these registers are not implemented,
 *    this register does not exist and reading from this register address
 *    returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3173                   */
         /* Description:                                                   */
         /**
          *    Shadow FIFO Enable.
          *    This is a shadow register for the FIFO enable bit (FCR[0]).
          *    This can be used to
          *    remove the burden of having to store the previously written
          *    value to the FCR in
          *    memory and having to mask this value so that only the FIFO
          *    enable bit gets updated.
          *    This enables/disables the transmit (XMIT) and receive (RCVR)
          *    FIFO's. If this
          *    bit is set to zero (disabled) after being enabled then both
          *    the XMIT and RCVR
          *    controller portion of FIFO's will be reset.
         */
         uint32_t SFE : 1; /* bit 0; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3203                   */
         /* Description:                                                   */
         /**
          *    SFE 31to1 Reserved bits read as 0.
         */
         uint32_t RSVD_SFE_31to1 : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SFE_t;

/* Typedef for Register: uart::SRT                                         */
/* Source filename: DW_apb_uart.csr, line: 3212                            */
/* Title: Shadow RCVR Trigger Register                                     */
/* Description:                                                            */
/**
 *    SRT register is valid only when the DW_apb_uart is configured to have
 *    additional FIFO registers
 *    implemented (FIFO_MODE != None) and additional shadow registers
 *    implemented (SHADOW = YES). If these registers are not implemented,
 *    this register does not exist and reading from this register address
 *    returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3222                   */
         /* Description:                                                   */
         /**
          *    Shadow RCVR Trigger.
          *    This is a shadow register for the RCVR trigger bits
          *    (FCR[7:6]). This can be used to
          *    remove the burden of having to store the previously written
          *    value to the FCR in
          *    memory and having to mask this value so that only the RCVR
          *    trigger bit gets updated.
          *    This is used to select the trigger level in the receiver FIFO
          *    at which the Received
          *    Data Available Interrupt will be generated. It also determines
          *     when the dma_rx_req_n
          *    signal will be asserted when DMA Mode (FCR[3]) is set to one.
         */
         uint32_t SRT : 2; /* bits 1 to 0; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3262                   */
         /* Description:                                                   */
         /**
          *    SRT 31to2 Reserved bits read as 0.
         */
         uint32_t RSVD_SRT_31to2 : 30; /* bits 31 to 2; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Uart_SRT_t;

/* Typedef for Register: uart::STET                                        */
/* Source filename: DW_apb_uart.csr, line: 3271                            */
/* Title: Shadow TX Empty Trigger Register                                 */
/* Description:                                                            */
/**
 *    This register is valid only when the DW_apb_uart is configured to have
 *    FIFOs implemented
 *    (FIFO_MODE != NONE) and THRE interrupt support implemented
 *    (THRE_MODE_USER = Enabled) and
 *    additional shadow registers implemented (SHADOW = YES). If FIFOs are
 *    not implemented or THRE interrupt support is not implemented or shadow
 *    registers are not implemented, this register does not exist and reading
 *     from this register address returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3284                   */
         /* Description:                                                   */
         /**
          *    Shadow TX Empty Trigger.
          *    This is a shadow register for the TX empty trigger bits
          *    (FCR[5:4]). This can be used
          *    to remove the burden of having to store the previously written
          *     value to the FCR in
          *    memory and having to mask this value so that only the TX empty
          *     trigger bit gets updated.
          *    Writes will have no effect when THRE_MODE_USER == Disabled.
          *    This is used to select the
          *    empty threshold level at which the THRE Interrupts will be
          *    generated when the mode is
          *    active.
         */
         uint32_t STET : 2; /* bits 1 to 0; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3322                   */
         /* Description:                                                   */
         /**
          *    STET 31to2 Reserved bits read as 0.
         */
         uint32_t RSVD_STET_31to2 : 30; /* bits 31 to 2; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Uart_STET_t;

/* Typedef for Register: uart::HTX                                         */
/* Source filename: DW_apb_uart.csr, line: 3331                            */
/* Title: Halt TX                                                          */
/* Description:                                                            */
/**
 *    Halt TX
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3336                   */
         /* Description:                                                   */
         /**
          *    Halt TX.
          *    Writes will have no effect when FIFO_MODE == NONE, always
          *    readable.  This register
          *    is use to halt transmissions for testing, so that the transmit
          *     FIFO can be filled
          *    by the master when FIFO's are implemented and enabled.
          *    Note, if FIFO's are implemented and not enabled the setting of
          *     the halt TX register
          *    will have no effect on operation.
         */
         uint32_t HTX : 1; /* bit 0; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3364                   */
         /* Description:                                                   */
         /**
          *    HTX 31to1 Reserved bits read as 0.
         */
         uint32_t RSVD_HTX_31to1 : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Uart_HTX_t;

/* Typedef for Register: uart::DMASA                                       */
/* Source filename: DW_apb_uart.csr, line: 3373                            */
/* Title: DMA Software Acknowledge Register                                */
/* Description:                                                            */
/**
 *    DMA Software Acknowledge Register
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3379                   */
         /* Description:                                                   */
         /**
          *    DMA Software Acknowledge.
          *    Writes will have no effect when DMA_EXTRA == No.  This
          *    register is use to perform
          *    DMA software acknowledge if a transfer needs to be terminated
          *    due to an error
          *    condition. For example, if the DMA disables the channel, then
          *    the DW_apb_uart should
          *    clear its request. This will cause the TX request, TX single,
          *    RX request and RX
          *    single signals to de-assert.
          *    Note that this bit is 'self-clearing' and it is not necessary
          *    to clear this bit.
         */
         uint32_t DMASA : 1; /* bit 0; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3405                   */
         /* Description:                                                   */
         /**
          *    DMASA 31to1 Reserved bits read as 0.
         */
         uint32_t RSVD_DMASA_31to1 : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Uart_DMASA_t;

/* Typedef for Register: uart::DLF                                         */
/* Source filename: DW_apb_uart.csr, line: 3413                            */
/* Title: Divisor Latch Fraction Register                                  */
/* Description:                                                            */
/**
 *    This register is only valid when the DW_apb_uart is configured to have
 *    Fractional Baud rate Divisor implemented (FRACTIONAL_BAUD_DIVISOR_EN =
 *    ENABLED). If Fractional Baud rate divisor is not implemented, this
 *    register does not exist and reading from this register address will
 *    return zero.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3422                   */
         /* Description:                                                   */
         /**
          *    Fractional part of divisor.
          *     The fractional value is added to integer value set by DLH,
          *    DLL. Fractional value is determined by (Divisor Fraction
          *    value)/(2^DLF_SIZE). For information on DLF
          *    values to be programmed for DLF_SIZE=4, see the 'Fractional
          *    Baud Rate Support' section in the DW_apb_uart Databook.
         */
         uint32_t DLF : 4; /* bits 3 to 0; R/W; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3435                   */
         /* Description:                                                   */
         /**
          *    DLF 31 to DLF_SIZE Reserved bits read as 0.
         */
         uint32_t RSVD_DLF : 28; /* bits 31 to 4; R; 0x0000000 */
      } B;
      uint32_t R;
   } ;
} Uart_DLF_t;

/* Typedef for Register: uart::REG_TIMEOUT_RST                             */
/* Source filename: DW_apb_uart.csr, line: 3444                            */
/* Title: Register timeout counter reset value                             */
/* Description:                                                            */
/**
 *    Name: Register timeout counter reset register
 *    This register keeps the reset value of reg_timer counter register.
 *    The reset value of the register is REG_TIMEOUT_DEFAULT
 *    The default reset value can be further modified if HC_REG_TIMEOUT_VALUE
 *     = 0.
 *    The final programmed value (or the default reset value if not
 *    programmed)
 *    determines what value the reg_timeout counter register starts counting
 *    down
 *    from. A zero on the counter will break the hung transaction with
 *    PSLVERR high
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3460                   */
         /* Description:                                                   */
         /**
          *    This field holds reset value of REG_TIMEOUT counter register.
         */
         uint32_t REG_TIMEOUT_RST : 4; /* bits 3 to 0; R/W; 0x8 */

         /* Source filename: DW_apb_uart.csr, line: 3468                   */
         /* Description:                                                   */
         /**
          *    Reserved bits - Read Only
         */
         uint32_t RSVD_REG_TIMEOUT_RST : 28; /* bits 31 to 4; R; 0x0000000 */
      } B;
      uint32_t R;
   } ;
} Uart_REG_TIMEOUT_RST_t;

/* Typedef for Register: uart::CPR                                         */
/* Source filename: DW_apb_uart.csr, line: 3477                            */
/* Title: Component Parameter Register                                     */
/* Description:                                                            */
/**
 *    Component Parameter Register.This register is valid only when
 *    UART_ADD_ENCODED_PARAMS = 1. If the UART_ADD_ENCODED_PARAMS parameter
 *    is not set, this register does not exist and reading from this register
 *     address returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3486                   */
         /* Description:                                                   */
         /**
          *    Encoding of APB_DATA_WIDTH configuration parameter value.
         */
         uint32_t APB_DATA_WIDTH : 2; /* bits 1 to 0; R; 0x2 */

         /* Source filename: DW_apb_uart.csr, line: 3508                   */
         /* Description:                                                   */
         /**
          *    CPR 3to2 Reserved bits read as 0.
         */
         uint32_t RSVD_CPR_3to2 : 2; /* bits 3 to 2; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3515                   */
         /* Description:                                                   */
         /**
          *    Encoding of AFCE_MODE configuration parameter value.
         */
         uint32_t AFCE_MODE : 1; /* bit 4; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3533                   */
         /* Description:                                                   */
         /**
          *    Encoding of THRE_MODE configuration parameter value.
         */
         uint32_t THRE_MODE : 1; /* bit 5; R; 0x1 */

         /* Source filename: DW_apb_uart.csr, line: 3551                   */
         /* Description:                                                   */
         /**
          *    Encoding of SIR_MODE configuration parameter value.
         */
         uint32_t SIR_MODE : 1; /* bit 6; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3569                   */
         /* Description:                                                   */
         /**
          *    Encoding of SIR_LP_MODE configuration parameter value.
         */
         uint32_t SIR_LP_MODE : 1; /* bit 7; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3587                   */
         /* Description:                                                   */
         /**
          *    Encoding of ADDITIONAL_FEATURES configuration parameter value.
         */
         uint32_t ADDITIONAL_FEAT : 1; /* bit 8; R; 0x1 */

         /* Source filename: DW_apb_uart.csr, line: 3606                   */
         /* Description:                                                   */
         /**
          *    Encoding of FIFO_ACCESS configuration parameter value.
         */
         uint32_t FIFO_ACCESS : 1; /* bit 9; R; 0x1 */

         /* Source filename: DW_apb_uart.csr, line: 3624                   */
         /* Description:                                                   */
         /**
          *    Encoding of FIFO_STAT configuration parameter value.
         */
         uint32_t FIFO_STAT : 1; /* bit 10; R; 0x1 */

         /* Source filename: DW_apb_uart.csr, line: 3642                   */
         /* Description:                                                   */
         /**
          *    Encoding of SHADOW configuration parameter value.
         */
         uint32_t SHADOW : 1; /* bit 11; R; 0x1 */

         /* Source filename: DW_apb_uart.csr, line: 3660                   */
         /* Description:                                                   */
         /**
          *    Encoding of UART_ADD_ENCODED_PARAMS configuration parameter
          *    value.
         */
         uint32_t UART_ADD_ENCODED_PARAMS : 1; /* bit 12; R; 0x1 */

         /* Source filename: DW_apb_uart.csr, line: 3679                   */
         /* Description:                                                   */
         /**
          *    Encoding of DMA_EXTRA configuration parameter value.
         */
         uint32_t DMA_EXTRA : 1; /* bit 13; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3697                   */
         /* Description:                                                   */
         /**
          *    CPR 15to14 Reserved bits read as 0.
         */
         uint32_t RSVD_CPR_15to14 : 2; /* bits 15 to 14; R; 0x0 */

         /* Source filename: DW_apb_uart.csr, line: 3704                   */
         /* Description:                                                   */
         /**
          *    Encoding of FIFO_MODE configuration parameter value.
         */
         uint32_t FIFO_MODE : 8; /* bits 23 to 16; R; 0x04 */

         /* Source filename: DW_apb_uart.csr, line: 3750                   */
         /* Description:                                                   */
         /**
          *    CPR 31to24 Reserved bits read as 0.
         */
         uint32_t RSVD_CPR_31to24 : 8; /* bits 31 to 24; R; 0x00 */
      } B;
      uint32_t R;
   } ;
} Uart_CPR_t;

/* Typedef for Register: uart::UCV                                         */
/* Source filename: DW_apb_uart.csr, line: 3758                            */
/* Title: UART Component Version                                           */
/* Description:                                                            */
/**
 *    UCV register is valid only when the DW_apb_uart is configured to have
 *    additional features implemented (ADDITIONAL_FEATURES = YES). If
 *    additional features are not implemented, this register does not exist
 *    and reading from this register address returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3768                   */
         /* Description:                                                   */
         /**
          *    ASCII value for each number in the version, followed by *.
          *    For example 32_30_31_2A represents the version 2.01*
         */
         uint32_t UART_Component_Version : 32; /* bits 31 to 0; R; 0x3430322a */
      } B;
      uint32_t R;
   } ;
} Uart_UCV_t;

/* Typedef for Register: uart::CTR                                         */
/* Source filename: DW_apb_uart.csr, line: 3777                            */
/* Title: Component Type Register                                          */
/* Description:                                                            */
/**
 *    CTR is register is valid only when the DW_apb_uart is configured to
 *    have additional features implemented (ADDITIONAL_FEATURES = YES). If
 *    additional features are not implemented, this register does not exist
 *    and reading from this register address returns 0.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_uart.csr, line: 3787                   */
         /* Description:                                                   */
         /**
          *    This register contains the peripherals identification code.
         */
         uint32_t Peripheral_ID : 32; /* bits 31 to 0; R; 0x44570110 */
      } B;
      uint32_t R;
   } ;
} Uart_CTR_t;

/* Typedef for Addressmap: uart                                            */
/* Source filename: DW_apb_uart.csr, line: 3796                            */
typedef struct {
   Uart_RBR_t RBR; /**< Offset 0x0 (R/W) */
   Uart_IER_t IER; /**< Offset 0x4 (R/W) */
   Uart_IIR_t IIR; /**< Offset 0x8 (R/W) */
   Uart_LCR_t LCR; /**< Offset 0xc (R/W) */
   Uart_MCR_t MCR; /**< Offset 0x10 (R/W) */
   Uart_LSR_t LSR; /**< Offset 0x14 (R) */
   Uart_MSR_t MSR; /**< Offset 0x18 (R) */
   Uart_SCR_t SCR; /**< Offset 0x1c (R/W) */
   uint8_t _pad0[0x10];
   Uart_SRBR0_t SRBR0; /**< Offset 0x30 (R/W) */
   Uart_SRBR1_t SRBR1; /**< Offset 0x34 (R/W) */
   Uart_SRBR2_t SRBR2; /**< Offset 0x38 (R/W) */
   Uart_SRBR3_t SRBR3; /**< Offset 0x3c (R/W) */
   Uart_SRBR4_t SRBR4; /**< Offset 0x40 (R/W) */
   Uart_SRBR5_t SRBR5; /**< Offset 0x44 (R/W) */
   Uart_SRBR6_t SRBR6; /**< Offset 0x48 (R/W) */
   Uart_SRBR7_t SRBR7; /**< Offset 0x4c (R/W) */
   Uart_SRBR8_t SRBR8; /**< Offset 0x50 (R/W) */
   Uart_SRBR9_t SRBR9; /**< Offset 0x54 (R/W) */
   Uart_SRBR10_t SRBR10; /**< Offset 0x58 (R/W) */
   Uart_SRBR11_t SRBR11; /**< Offset 0x5c (R/W) */
   Uart_SRBR12_t SRBR12; /**< Offset 0x60 (R/W) */
   Uart_SRBR13_t SRBR13; /**< Offset 0x64 (R/W) */
   Uart_SRBR14_t SRBR14; /**< Offset 0x68 (R/W) */
   Uart_SRBR15_t SRBR15; /**< Offset 0x6c (R/W) */
   Uart_FAR_t FAR; /**< Offset 0x70 (R/W) */
   Uart_TFR_t TFR; /**< Offset 0x74 (R) */
   Uart_RFW_t RFW; /**< Offset 0x78 (R/W) */
   Uart_USR_t USR; /**< Offset 0x7c (R) */
   Uart_TFL_t TFL; /**< Offset 0x80 (R) */
   Uart_RFL_t RFL; /**< Offset 0x84 (R) */
   Uart_SRR_t SRR; /**< Offset 0x88 (R/W) */
   Uart_SRTS_t SRTS; /**< Offset 0x8c (R/W) */
   Uart_SBCR_t SBCR; /**< Offset 0x90 (R/W) */
   Uart_SDMAM_t SDMAM; /**< Offset 0x94 (R/W) */
   Uart_SFE_t SFE; /**< Offset 0x98 (R/W) */
   Uart_SRT_t SRT; /**< Offset 0x9c (R/W) */
   Uart_STET_t STET; /**< Offset 0xa0 (R/W) */
   Uart_HTX_t HTX; /**< Offset 0xa4 (R/W) */
   Uart_DMASA_t DMASA; /**< Offset 0xa8 (R) */
   uint8_t _pad1[0x14];
   Uart_DLF_t DLF; /**< Offset 0xc0 (R/W) */
   uint8_t _pad2[0x10];
   Uart_REG_TIMEOUT_RST_t REG_TIMEOUT_RST; /**< Offset 0xd4 (R/W) */
   uint8_t _pad3[0x1c];
   Uart_CPR_t CPR; /**< Offset 0xf4 (R) */
   Uart_UCV_t UCV; /**< Offset 0xf8 (R) */
   Uart_CTR_t CTR; /**< Offset 0xfc (R) */
} Uart_t;

#endif
