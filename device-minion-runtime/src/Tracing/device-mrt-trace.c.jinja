/*------------------------------------------------------------------------------
 * Copyright (C) 2020, Esperanto Technologies Inc.
 * The copyright to the computer program(s) herein is the
 * property of Esperanto Technologies, Inc. All Rights Reserved.
 * The program(s) may be used and/or copied only with
 * the written permission of Esperanto Technologies and
 * in accordance with the terms and conditions stipulated in the
 * agreement/contract under which the program(s) have been supplied.
 ------------------------------------------------------------------------------ */

// WARNING: this file is auto-generated do not edit directly

#include "device-mrt-trace.h"
#include "log.h"
#include "layout.h"
#include "hart.h"
#include "ring_buffer.h"

#include <string.h>

const size_t event_size_array[] =
{
    0,
<%- for group in cgh.trace_groups() %>
  <%- for trace in group.get("Events", []) %>
     <%- if group["Name"] == "Text" %>
        <%- set str_name = cgh.get_field_from_type(trace, "bytes") %>
    offsetof(struct trace_<< trace["Name"] >>_t, << str_name >>),
     <%- else %>
    sizeof(struct trace_<< trace["Name"] >>_t),
     <%- endif %>
  <%- endfor %>
<%- endfor %>
};

<%- for group in cgh.trace_groups() %>
  <%- for trace in group.get("Events", []) %>
    <%- set event_id = ["TRACE_EVENT_ID_", group["Name"]|upper, "_", trace["Name"]|upper]|join('') %>
    <%- set group_id = ["TRACE_GROUP_ID_", group["Name"]|upper]|join('') %>

int TRACE_<< trace["Name"] >>(const log_levels_e level,
                              << cgh.fields_to_arg_list(trace) >>)
{
    struct trace_control_t *trace_ctrl =
        (struct trace_control_t *)DEVICE_MRT_TRACE_BASE;
    uint64_t group_knob =
        trace_ctrl->group_knobs[<< group_id >> / (sizeof(uint64_t) <<'<<'>> 3)];
    uint64_t event_knob =
        trace_ctrl->event_knobs[<< event_id >> / (sizeof(uint64_t) <<'<<'>> 3)];
    group_knob &= (1 <<'<<'>> << group_id >> );
    event_knob &= (1 <<'<<'>> << event_id >> );

    if (trace_ctrl->trace_state.trace_en &&  group_knob &&
        event_knob && level <= trace_ctrl->trace_state.log_level)
    {
        uint16_t hartid = (uint16_t)get_hart_id();
        <%- if group["Name"] == "Text" %>
          <%- set str_name = cgh.get_field_from_type(trace, "bytes") %>
        size_t size = strlen(<< str_name >>);
        struct trace_<< trace["Name"] >>_t *e = ring_buffer_alloc_space(hartid,
            ALIGN(offsetof(struct trace_<< trace["Name"] >>_t,
                << str_name >>) + size, 8UL));
        <%- else %>
        struct trace_<< trace["Name"] >>_t *e = ring_buffer_alloc_space(hartid,
            sizeof(struct trace_<< trace["Name"] >>_t));
        <%- endif %>

        // Populate the event structure
        e->header.event_id = << event_id >>;
        asm volatile ("csrr %0, hpmcounter3" : "=r" (e->header.mtime));

        <%- for field in trace.get("Fields", []) %>
            <%- if field["Type"] == "bytes" %>
        e->size = size;
            <%- else%>
        e-><<field["Name"]>> = << field["Name"] >>;
            <%- endif %>
        <%- endfor %>

        <% if group["Name"] == "Text" %>
        // String needs to copied seperatly
        memcpy((void*)&(e-><< str_name >>[0]), << str_name >>, size);
        <%- endif %>

        // Write the log on UART interface if enabled
        if (trace_ctrl->trace_state.uart_en)
        {
            log_write(level, "Event: << event_id >>, "
            "<< cgh.fields_to_printf_format(trace) >>, Hartid: %d\r\n",
            <%- for field in trace.get("Fields", []) %>
            << field["Name"] >>,
            <%- endfor %>
            hartid);
        }

        return TRACE_STATUS_SUCCESS;
    }

    return TRACE_STATUS_DISABLED;
}

  <%- endfor %>
<%- endfor %>
