/*-------------------------------------------------------------------------
 * Copyright (C) 2020, Esperanto Technologies Inc.
 * The copyright to the computer program(s) herein is the
 * property of Esperanto Technologies, Inc. All Rights Reserved.
 * The program(s) may be used and/or copied only with
 * the written permission of Esperanto Technologies and
 * in accordance with the terms and conditions stipulated in the
 * agreement/contract under which the program(s) have been supplied.
 *-------------------------------------------------------------------------
 */

// WARNING: this file is auto-generated do not edit directly

#include "device-mrt-trace.h"
#include "hart.h"
#include "layout.h"
#include "log.h"
#include "ring_buffer.h"

#include <inttypes.h>
#include <string.h>

const size_t event_size_array[] = {
    0,
<%- for group in cgh.trace_groups() %>
  <%- for trace in group.get("Events", []) %>
     <%- if group["Name"] == "Text" %>
        <%- set str_name = cgh.get_field_from_type(trace, "bytes") %>
    offsetof(struct trace_<< trace["Name"] >>_t, << str_name >>),
     <%- else %>
    sizeof(struct trace_<< trace["Name"] >>_t),
     <%- endif %>
  <%- endfor %>
<%- endfor %>
};

<%- for group in cgh.trace_groups() %>
  <%- for trace in group.get("Events", []) %>
    <%- set event_id = ["TRACE_EVENT_ID_", group["Name"]|upper, "_", trace["Name"]|upper]|join('') %>
    <%- set group_id = ["TRACE_GROUP_ID_", group["Name"]|upper]|join('') %>

trace_status_e TRACE_<< trace["Name"] >>(const log_levels_e level,
                              << cgh.fields_to_arg_list(trace) >>)
{
    struct trace_control_t *cntrl =
        (struct trace_control_t *)DEVICE_MRT_TRACE_BASE;
    uint64_t group_knob =
        cntrl->group_knobs[<< group_id >> / (sizeof(uint64_t) <<'<<'>> 3)];
    uint64_t event_knob =
        cntrl->event_knobs[<< event_id >> / (sizeof(uint64_t) <<'<<'>> 3)];
    group_knob &= (1 <<'<<'>> << group_id >>);
    event_knob &= (1 <<'<<'>> << event_id >>);

    if (cntrl->trace_en && group_knob && event_knob &&
        level <= cntrl->log_level &&
        SHIRE_ENABLED(cntrl->shire_mask, get_shire_id()) &&
        HART_ENABLED(cntrl->harts_mask, get_hart_id())) {
        uint16_t hart_id = (uint16_t)get_hart_id();
        <%- if group["Name"] == "Text" %>
          <%- set str_name = cgh.get_field_from_type(trace, "bytes") %>
        size_t size = strlen(<< str_name >>);
        struct trace_<< trace["Name"] >>_t *e = ring_buffer_alloc_space(hart_id,
            ALIGN(offsetof(struct trace_<< trace["Name"] >>_t,
                << str_name >>) + size, 8UL));
        <%- else %>
        struct trace_<< trace["Name"] >>_t *e = ring_buffer_alloc_space(hart_id,
            sizeof(struct trace_<< trace["Name"] >>_t));
        <%- endif %>

        // Populate the event structure
        e->header.event_id = << event_id >>;
        asm volatile ("csrr %0, hpmcounter3" : "=r" (e->header.mtime));

        <%- for field in trace.get("Fields", []) %>
            <%- if field["Type"] == "bytes" %>
        e->size = size;
            <%- else%>
        e-><<field["Name"]>> = << field["Name"] >>;
            <%- endif %>
        <%- endfor %>

        <%- if group["Name"] == "Text" %>
        // String needs to copied seperatly
        memcpy((void *)&(e-><< str_name >>[0]), << str_name >>, size);
        <%- endif %>

        // Write the log on UART interface if enabled
        if (cntrl->uart_en) {
            log_write(level, "Event: << event_id >>, "
                      << cgh.fields_to_printf_format(trace) >>", Hartid: %" PRIu16 "\r\n",
                      <%- for field in trace.get("Fields", []) %>
                      << field["Name"] >>,
                      <%- endfor %>
                      hart_id);
        }

        return TRACE_STATUS_SUCCESS;
    }

    return TRACE_STATUS_DISABLED;
}

  <%- endfor %>
<%- endfor %>
