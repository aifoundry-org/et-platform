#!/usr/bin/python3.6

import time, sys 

# Import test framework 
import argparse

supported_ports = ['TCP', 'COM']
supported_buads = [19200, 38400, 57600, 115200]
tcp_port = 23456
snps_cloud_machines = { "rt001" : "10.8.32.73",
                        "rt002" : "10.8.32.74",
                        "rt003" : "10.8.32.75",
                        "rt004" : "10.8.32.76",
                        "rt005" : "10.8.32.81",
                        "rt006" : "10.8.32.82",
                        "rt007" : "10.8.32.83",
                        "rt008" : "10.8.32.84",
                        "rt009" : "10.8.32.85",
                        "rt010" : "10.8.32.86",
                        "rt011" : "10.8.32.87",
                        "rt012" : "10.8.32.88" }

parser = argparse.ArgumentParser()
parser.add_argument('-c', '--cmd', nargs='+', help="TF Command with or without payload - Example usage - -c (--cmd) <cmd0>:<payload0> <cmd1> <cmd2>:<payload2_0>:<payload2_1>:<payload2_2> <cmd3>")
parser.add_argument("-p", "--port", required=True, help="Port type - TCP or COM")
parser.add_argument("-a", "--attr", type=int, help="Port number - 0:65536 or Baud Rate - {supported_bauds}")
parser.add_argument("-m", "--machine", type=str, help="Host name or IP address of the machine to connect to for TCP port type")
parser.add_argument("-s", "--sw_platform", help="Path to the sw-platform")
args = parser.parse_args()

if args.cmd is None:
        print (f'*** Warning *** no command specified uart communicator will be skipped')
        exit()
else:
    args.port = args.port.upper()
    if not args.port in supported_ports:
        print ('\n')
        print (f'Port type "{args.port}" is not supported. Supported port types are {supported_ports}')
        print ('\n')
        parser.print_help()
        exit(1)

    if not args.machine or not args.attr:
        print ('\n')
        if 'TCP' in args.port:
            print (f'Port type "{args.port}" requires hostname with -m / --machine  and port number with --attr / -a option')
        elif 'UART' in args.port:
            print (f'Port type "{args.port}" requires com port with -m / --machine  and baud rate with --attr / -a option')
        print ('\n')
        parser.print_help()
        exit(1)

if args.sw_platform is None:
        args.sw_platform = '/project/jenkins/diag_flow/sw-platform'
args.sw_platform += f'/host-software/deviceLayer/tests/bringup-tests'
sys.path.append(args.sw_platform)
from tf_target import *
from tf_specification import *

# Instantiate TF Specification handle
global tf_spec
tf_spec = tf_specification(f"{args.sw_platform}/tf_specification.json")

# Instantiate a global dut_serial_iface handle
global dut_serial_iface

if 'TCP' in args.port:
    dut_serial_iface = Target("serial", args.port, snps_cloud_machines[args.machine], args.attr)
#elif 'UART'
# Open test interface
dut_serial_iface.open()

for cmd in args.cmd:
    payload = None
    if ':' in cmd:
        payload = [int(i, 16) for i in cmd.split(':')[1:]]
        cmd = cmd.split(':')[0]
        print (cmd, payload)
        command = tf_spec.command(cmd, payload)
    else:
        command = tf_spec.command(cmd)
    dut_serial_iface.uart_send(command)

    # Now wait for the response
    rbytes = b''
    recv_byte = dut_serial_iface.uart_receive()
    # Flush till b'$' which is the start delimiter
    while b'$' not in recv_byte:
        recv_byte = dut_serial_iface.uart_receive()
    # Ready to receive response
    while True:
        rbytes += recv_byte
        recv_byte = dut_serial_iface.uart_receive()
        # Break if end delimiter, b'#' is found
        if b'#' in recv_byte:
            break
    print (rbytes)
    # Process the response
    response = tf_spec.response(rbytes) 
    print (f'Received response: {response}')
