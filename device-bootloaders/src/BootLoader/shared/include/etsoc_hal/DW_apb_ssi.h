/*                                                                         */
/* Generated by Semifore, Inc. csrCompile                                  */
/*    Version: 2019.03.01 Build: release Linux 64-bit                      */
/*    C Header output                                                      */
/*                                                                         */
/* Command Line:                                                           */
/*    /home/cad/tools/semifore/csrCompile/LATEST/bin/x64_re6/csrCompile -v */
/*    -c                                                                   */
/*    /data/ssmith/work/repos/soc_hal/dv/common/scripts/semifore_css/bitfield_enum_doc.css */
/*    -t h DW_apb_ssi.csr -o gen_sw/DW_apb_ssi                             */
/*                                                                         */
/* Input files:                                                            */
/*    DW_apb_ssi.csr                                                       */
/*                                                                         */
/* Configuration files:                                                    */
/*    /data/ssmith/work/repos/soc_hal/dv/common/scripts/semifore_css/bitfield_enum_doc.css */
/*                                                                         */
/* Generated on: Tue May 21 15:32:29 2019                                  */
/*           by: ssmith                                                    */
/*                                                                         */

#ifndef _DW_APB_SSI_H_
#define _DW_APB_SSI_H_


/* ####################################################################### */
/*        ENUM DEFINITIONS                                                 */
/* ####################################################################### */

/* Enum : ssi::CTRLR0::CFS::CFS                                            */
/* Source filename: DW_apb_ssi.csr, line: 322                              */
typedef enum _ssi_CTRLR0_CFS_CFS {
   SSI_CTRLR0_CFS_CFS_SIZE_01_BIT = 0x0,
   SSI_CTRLR0_CFS_CFS_SIZE_02_BIT = 0x1,
   SSI_CTRLR0_CFS_CFS_SIZE_03_BIT = 0x2,
   SSI_CTRLR0_CFS_CFS_SIZE_04_BIT = 0x3,
   SSI_CTRLR0_CFS_CFS_SIZE_05_BIT = 0x4,
   SSI_CTRLR0_CFS_CFS_SIZE_06_BIT = 0x5,
   SSI_CTRLR0_CFS_CFS_SIZE_07_BIT = 0x6,
   SSI_CTRLR0_CFS_CFS_SIZE_08_BIT = 0x7,
   SSI_CTRLR0_CFS_CFS_SIZE_09_BIT = 0x8,
   SSI_CTRLR0_CFS_CFS_SIZE_10_BIT = 0x9,
   SSI_CTRLR0_CFS_CFS_SIZE_11_BIT = 0xa,
   SSI_CTRLR0_CFS_CFS_SIZE_12_BIT = 0xb,
   SSI_CTRLR0_CFS_CFS_SIZE_13_BIT = 0xc,
   SSI_CTRLR0_CFS_CFS_SIZE_14_BIT = 0xd,
   SSI_CTRLR0_CFS_CFS_SIZE_15_BIT = 0xe,
   SSI_CTRLR0_CFS_CFS_SIZE_16_BIT = 0xf
} Ssi_CTRLR0_CFS_CFS;

/* Enum : ssi::CTRLR0::DFS::DFS                                            */
/* Source filename: DW_apb_ssi.csr, line: 64                               */
typedef enum _ssi_CTRLR0_DFS_DFS {
   SSI_CTRLR0_DFS_DFS_FRAME_04BITS = 0x3,
   SSI_CTRLR0_DFS_DFS_FRAME_05BITS = 0x4,
   SSI_CTRLR0_DFS_DFS_FRAME_06BITS = 0x5,
   SSI_CTRLR0_DFS_DFS_FRAME_07BITS = 0x6,
   SSI_CTRLR0_DFS_DFS_FRAME_08BITS = 0x7,
   SSI_CTRLR0_DFS_DFS_FRAME_09BITS = 0x8,
   SSI_CTRLR0_DFS_DFS_FRAME_10BITS = 0x9,
   SSI_CTRLR0_DFS_DFS_FRAME_11BITS = 0xa,
   SSI_CTRLR0_DFS_DFS_FRAME_12BITS = 0xb,
   SSI_CTRLR0_DFS_DFS_FRAME_13BITS = 0xc,
   SSI_CTRLR0_DFS_DFS_FRAME_14BITS = 0xd,
   SSI_CTRLR0_DFS_DFS_FRAME_15BITS = 0xe,
   SSI_CTRLR0_DFS_DFS_FRAME_16BITS = 0xf
} Ssi_CTRLR0_DFS_DFS;

/* Enum : ssi::CTRLR0::DFS_32::DFS_32                                      */
/* Source filename: DW_apb_ssi.csr, line: 421                              */
typedef enum _ssi_CTRLR0_DFS_32_DFS_32 {
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_04BITS = 0x3,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_05BITS = 0x4,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_06BITS = 0x5,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_07BITS = 0x6,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_08BITS = 0x7,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_09BITS = 0x8,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_10BITS = 0x9,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_11BITS = 0xa,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_12BITS = 0xb,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_13BITS = 0xc,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_14BITS = 0xd,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_15BITS = 0xe,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_16BITS = 0xf,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_17BITS = 0x10,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_18BITS = 0x11,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_19BITS = 0x12,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_20BITS = 0x13,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_21BITS = 0x14,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_22BITS = 0x15,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_23BITS = 0x16,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_24BITS = 0x17,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_25BITS = 0x18,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_26BITS = 0x19,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_27BITS = 0x1a,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_28BITS = 0x1b,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_29BITS = 0x1c,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_30BITS = 0x1d,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_31BITS = 0x1e,
   SSI_CTRLR0_DFS_32_DFS_32_FRAME_32BITS = 0x1f
} Ssi_CTRLR0_DFS_32_DFS_32;

/* Enum : ssi::CTRLR0::FRF::FRF                                            */
/* Source filename: DW_apb_ssi.csr, line: 127                              */
typedef enum _ssi_CTRLR0_FRF_FRF {
   SSI_CTRLR0_FRF_FRF_MOTOROLA_SPI = 0x0,
   SSI_CTRLR0_FRF_FRF_NS_MICROWIRE = 0x2,
   SSI_CTRLR0_FRF_FRF_RESERVED = 0x3,
   SSI_CTRLR0_FRF_FRF_TEXAS_SSP = 0x1
} Ssi_CTRLR0_FRF_FRF;

/* Enum : ssi::CTRLR0::SCPH::SCPH                                          */
/* Source filename: DW_apb_ssi.csr, line: 166                              */
typedef enum _ssi_CTRLR0_SCPH_SCPH {
   SSI_CTRLR0_SCPH_SCPH_SCPH_MIDDLE = 0x0,
   SSI_CTRLR0_SCPH_SCPH_SCPH_START = 0x1
} Ssi_CTRLR0_SCPH_SCPH;

/* Enum : ssi::CTRLR0::SCPOL::SCPOL                                        */
/* Source filename: DW_apb_ssi.csr, line: 192                              */
typedef enum _ssi_CTRLR0_SCPOL_SCPOL {
   SSI_CTRLR0_SCPOL_SCPOL_SCLK_HIGH = 0x1,
   SSI_CTRLR0_SCPOL_SCPOL_SCLK_LOW = 0x0
} Ssi_CTRLR0_SCPOL_SCPOL;

/* Enum : ssi::CTRLR0::SPI_FRF::SPI_FRF                                    */
/* Source filename: DW_apb_ssi.csr, line: 562                              */
typedef enum _ssi_CTRLR0_SPI_FRF_SPI_FRF {
   SSI_CTRLR0_SPI_FRF_SPI_FRF_DUAL_SPI_FRF = 0x1,
   SSI_CTRLR0_SPI_FRF_SPI_FRF_OCTAL_SPI_FRF = 0x3,
   SSI_CTRLR0_SPI_FRF_SPI_FRF_QUAD_SPI_FRF = 0x2,
   SSI_CTRLR0_SPI_FRF_SPI_FRF_STD_SPI_FRF = 0x0
} Ssi_CTRLR0_SPI_FRF_SPI_FRF;

/* Enum : ssi::CTRLR0::SRL::SRL                                            */
/* Source filename: DW_apb_ssi.csr, line: 302                              */
typedef enum _ssi_CTRLR0_SRL_SRL {
   SSI_CTRLR0_SRL_SRL_NORMAL_MODE = 0x0,
   SSI_CTRLR0_SRL_SRL_TESTING_MODE = 0x1
} Ssi_CTRLR0_SRL_SRL;

/* Enum : ssi::CTRLR0::TMOD::TMOD                                          */
/* Source filename: DW_apb_ssi.csr, line: 257                              */
typedef enum _ssi_CTRLR0_TMOD_TMOD {
   SSI_CTRLR0_TMOD_TMOD_EEPROM_READ = 0x3,
   SSI_CTRLR0_TMOD_TMOD_RX_ONLY = 0x2,
   SSI_CTRLR0_TMOD_TMOD_TX_AND_RX = 0x0,
   SSI_CTRLR0_TMOD_TMOD_TX_ONLY = 0x1
} Ssi_CTRLR0_TMOD_TMOD;

/* Enum : ssi::IMR::MSTIM::MSTIM                                           */
/* Source filename: DW_apb_ssi.csr, line: 1357                             */
typedef enum _ssi_IMR_MSTIM_MSTIM {
   SSI_IMR_MSTIM_MSTIM_MASKED = 0x0,
   SSI_IMR_MSTIM_MSTIM_UNMASKED = 0x1
} Ssi_IMR_MSTIM_MSTIM;

/* Enum : ssi::IMR::RXFIM::RXFIM                                           */
/* Source filename: DW_apb_ssi.csr, line: 1337                             */
typedef enum _ssi_IMR_RXFIM_RXFIM {
   SSI_IMR_RXFIM_RXFIM_MASKED = 0x0,
   SSI_IMR_RXFIM_RXFIM_UNMASKED = 0x1
} Ssi_IMR_RXFIM_RXFIM;

/* Enum : ssi::IMR::RXOIM::RXOIM                                           */
/* Source filename: DW_apb_ssi.csr, line: 1319                             */
typedef enum _ssi_IMR_RXOIM_RXOIM {
   SSI_IMR_RXOIM_RXOIM_MASKED = 0x0,
   SSI_IMR_RXOIM_RXOIM_UNMASKED = 0x1
} Ssi_IMR_RXOIM_RXOIM;

/* Enum : ssi::IMR::RXUIM::RXUIM                                           */
/* Source filename: DW_apb_ssi.csr, line: 1301                             */
typedef enum _ssi_IMR_RXUIM_RXUIM {
   SSI_IMR_RXUIM_RXUIM_MASKED = 0x0,
   SSI_IMR_RXUIM_RXUIM_UNMASKED = 0x1
} Ssi_IMR_RXUIM_RXUIM;

/* Enum : ssi::IMR::TXEIM::TXEIM                                           */
/* Source filename: DW_apb_ssi.csr, line: 1265                             */
typedef enum _ssi_IMR_TXEIM_TXEIM {
   SSI_IMR_TXEIM_TXEIM_MASKED = 0x0,
   SSI_IMR_TXEIM_TXEIM_UNMASKED = 0x1
} Ssi_IMR_TXEIM_TXEIM;

/* Enum : ssi::IMR::TXOIM::TXOIM                                           */
/* Source filename: DW_apb_ssi.csr, line: 1283                             */
typedef enum _ssi_IMR_TXOIM_TXOIM {
   SSI_IMR_TXOIM_TXOIM_MASKED = 0x0,
   SSI_IMR_TXOIM_TXOIM_UNMASKED = 0x1
} Ssi_IMR_TXOIM_TXOIM;

/* Enum : ssi::ISR::MSTIS::MSTIS                                           */
/* Source filename: DW_apb_ssi.csr, line: 1485                             */
typedef enum _ssi_ISR_MSTIS_MSTIS {
   SSI_ISR_MSTIS_MSTIS_ACTIVE = 0x1,
   SSI_ISR_MSTIS_MSTIS_INACTIVE = 0x0
} Ssi_ISR_MSTIS_MSTIS;

/* Enum : ssi::ISR::RXFIS::RXFIS                                           */
/* Source filename: DW_apb_ssi.csr, line: 1465                             */
typedef enum _ssi_ISR_RXFIS_RXFIS {
   SSI_ISR_RXFIS_RXFIS_ACTIVE = 0x1,
   SSI_ISR_RXFIS_RXFIS_INACTIVE = 0x0
} Ssi_ISR_RXFIS_RXFIS;

/* Enum : ssi::ISR::RXOIS::RXOIS                                           */
/* Source filename: DW_apb_ssi.csr, line: 1447                             */
typedef enum _ssi_ISR_RXOIS_RXOIS {
   SSI_ISR_RXOIS_RXOIS_ACTIVE = 0x1,
   SSI_ISR_RXOIS_RXOIS_INACTIVE = 0x0
} Ssi_ISR_RXOIS_RXOIS;

/* Enum : ssi::ISR::RXUIS::RXUIS                                           */
/* Source filename: DW_apb_ssi.csr, line: 1429                             */
typedef enum _ssi_ISR_RXUIS_RXUIS {
   SSI_ISR_RXUIS_RXUIS_ACTIVE = 0x1,
   SSI_ISR_RXUIS_RXUIS_INACTIVE = 0x0
} Ssi_ISR_RXUIS_RXUIS;

/* Enum : ssi::ISR::TXEIS::TXEIS                                           */
/* Source filename: DW_apb_ssi.csr, line: 1393                             */
typedef enum _ssi_ISR_TXEIS_TXEIS {
   SSI_ISR_TXEIS_TXEIS_ACTIVE = 0x1,
   SSI_ISR_TXEIS_TXEIS_INACTIVE = 0x0
} Ssi_ISR_TXEIS_TXEIS;

/* Enum : ssi::ISR::TXOIS::TXOIS                                           */
/* Source filename: DW_apb_ssi.csr, line: 1411                             */
typedef enum _ssi_ISR_TXOIS_TXOIS {
   SSI_ISR_TXOIS_TXOIS_ACTIVE = 0x1,
   SSI_ISR_TXOIS_TXOIS_INACTIVE = 0x0
} Ssi_ISR_TXOIS_TXOIS;

/* Enum : ssi::MWCR::MDD::MDD                                              */
/* Source filename: DW_apb_ssi.csr, line: 767                              */
typedef enum _ssi_MWCR_MDD_MDD {
   SSI_MWCR_MDD_MDD_RECEIVE = 0x0,
   SSI_MWCR_MDD_MDD_TRANSMIT = 0x1
} Ssi_MWCR_MDD_MDD;

/* Enum : ssi::MWCR::MHS::MHS                                              */
/* Source filename: DW_apb_ssi.csr, line: 798                              */
typedef enum _ssi_MWCR_MHS_MHS {
   SSI_MWCR_MHS_MHS_DISABLE = 0x0,
   SSI_MWCR_MHS_MHS_ENABLED = 0x1
} Ssi_MWCR_MHS_MHS;

/* Enum : ssi::MWCR::MWMOD::MWMOD                                          */
/* Source filename: DW_apb_ssi.csr, line: 739                              */
typedef enum _ssi_MWCR_MWMOD_MWMOD {
   SSI_MWCR_MWMOD_MWMOD_NON_SEQUENTIAL = 0x0,
   SSI_MWCR_MWMOD_MWMOD_SEQUENTIAL = 0x1
} Ssi_MWCR_MWMOD_MWMOD;

/* Enum : ssi::RISR::MSTIR::MSTIR                                          */
/* Source filename: DW_apb_ssi.csr, line: 1617                             */
typedef enum _ssi_RISR_MSTIR_MSTIR {
   SSI_RISR_MSTIR_MSTIR_ACTIVE = 0x1,
   SSI_RISR_MSTIR_MSTIR_INACTIVE = 0x0
} Ssi_RISR_MSTIR_MSTIR;

/* Enum : ssi::RISR::RXFIR::RXFIR                                          */
/* Source filename: DW_apb_ssi.csr, line: 1595                             */
typedef enum _ssi_RISR_RXFIR_RXFIR {
   SSI_RISR_RXFIR_RXFIR_ACTIVE = 0x1,
   SSI_RISR_RXFIR_RXFIR_INACTIVE = 0x0
} Ssi_RISR_RXFIR_RXFIR;

/* Enum : ssi::RISR::RXOIR::RXOIR                                          */
/* Source filename: DW_apb_ssi.csr, line: 1576                             */
typedef enum _ssi_RISR_RXOIR_RXOIR {
   SSI_RISR_RXOIR_RXOIR_ACTIVE = 0x1,
   SSI_RISR_RXOIR_RXOIR_INACTIVE = 0x0
} Ssi_RISR_RXOIR_RXOIR;

/* Enum : ssi::RISR::RXUIR::RXUIR                                          */
/* Source filename: DW_apb_ssi.csr, line: 1557                             */
typedef enum _ssi_RISR_RXUIR_RXUIR {
   SSI_RISR_RXUIR_RXUIR_ACTIVE = 0x1,
   SSI_RISR_RXUIR_RXUIR_INACTIVE = 0x0
} Ssi_RISR_RXUIR_RXUIR;

/* Enum : ssi::RISR::TXEIR::TXEIR                                          */
/* Source filename: DW_apb_ssi.csr, line: 1519                             */
typedef enum _ssi_RISR_TXEIR_TXEIR {
   SSI_RISR_TXEIR_TXEIR_ACTIVE = 0x1,
   SSI_RISR_TXEIR_TXEIR_INACTIVE = 0x0
} Ssi_RISR_TXEIR_TXEIR;

/* Enum : ssi::RISR::TXOIR::TXOIR                                          */
/* Source filename: DW_apb_ssi.csr, line: 1538                             */
typedef enum _ssi_RISR_TXOIR_TXOIR {
   SSI_RISR_TXOIR_TXOIR_ACTIVE = 0x1,
   SSI_RISR_TXOIR_TXOIR_INACTIVE = 0x0
} Ssi_RISR_TXOIR_TXOIR;

/* Enum : ssi::SER::SER::SER                                               */
/* Source filename: DW_apb_ssi.csr, line: 864                              */
typedef enum _ssi_SER_SER_SER {
   SSI_SER_SER_SER_NOT_SELECTED = 0x0,
   SSI_SER_SER_SER_SELECTED = 0x1
} Ssi_SER_SER_SER;

/* Enum : ssi::SR::BUSY::BUSY                                              */
/* Source filename: DW_apb_ssi.csr, line: 1102                             */
typedef enum _ssi_SR_BUSY_BUSY {
   SSI_SR_BUSY_BUSY_ACTIVE = 0x1,
   SSI_SR_BUSY_BUSY_INACTIVE = 0x0
} Ssi_SR_BUSY_BUSY;

/* Enum : ssi::SR::DCOL::DCOL                                              */
/* Source filename: DW_apb_ssi.csr, line: 1228                             */
typedef enum _ssi_SR_DCOL_DCOL {
   SSI_SR_DCOL_DCOL_NO_ERROR_CONDITION = 0x0,
   SSI_SR_DCOL_DCOL_TX_COLLISION_ERROR = 0x1
} Ssi_SR_DCOL_DCOL;

/* Enum : ssi::SR::RFF::RFF                                                */
/* Source filename: DW_apb_ssi.csr, line: 1193                             */
typedef enum _ssi_SR_RFF_RFF {
   SSI_SR_RFF_RFF_FULL = 0x1,
   SSI_SR_RFF_RFF_NOT_FULL = 0x0
} Ssi_SR_RFF_RFF;

/* Enum : ssi::SR::RFNE::RFNE                                              */
/* Source filename: DW_apb_ssi.csr, line: 1170                             */
typedef enum _ssi_SR_RFNE_RFNE {
   SSI_SR_RFNE_RFNE_EMPTY = 0x0,
   SSI_SR_RFNE_RFNE_NOT_EMPTY = 0x1
} Ssi_SR_RFNE_RFNE;

/* Enum : ssi::SR::TFE::TFE                                                */
/* Source filename: DW_apb_ssi.csr, line: 1146                             */
typedef enum _ssi_SR_TFE_TFE {
   SSI_SR_TFE_TFE_EMPTY = 0x1,
   SSI_SR_TFE_TFE_NOT_EMPTY = 0x0
} Ssi_SR_TFE_TFE;

/* Enum : ssi::SR::TFNF::TFNF                                              */
/* Source filename: DW_apb_ssi.csr, line: 1122                             */
typedef enum _ssi_SR_TFNF_TFNF {
   SSI_SR_TFNF_TFNF_FULL = 0x0,
   SSI_SR_TFNF_TFNF_NOT_FULL = 0x1
} Ssi_SR_TFNF_TFNF;

/* Enum : ssi::SSIENR::SSI_EN::SSI_EN                                      */
/* Source filename: DW_apb_ssi.csr, line: 690                              */
typedef enum _ssi_SSIENR_SSI_EN_SSI_EN {
   SSI_SSIENR_SSI_EN_SSI_EN_DISABLE = 0x0,
   SSI_SSIENR_SSI_EN_SSI_EN_ENABLED = 0x1
} Ssi_SSIENR_SSI_EN_SSI_EN;

/* ####################################################################### */
/*        TYPE DEFINITIONS                                                 */
/* ####################################################################### */

/* Typedef for Register: ssi::CTRLR0                                       */
/* Source filename: DW_apb_ssi.csr, line: 21                               */
/* Title: Control Register 0                                               */
/* Description:                                                            */
/**
 *    This register controls the serial data transfer. It is impossible to
 *    write to this register when the DW_apb_ssi is enabled. The DW_apb_ssi
 *    is enabled and disabled by writing to the SSIENR register.
 *    Reset Value: SSI_CTRLR0_RST
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 31                      */
         /* Description:                                                   */
         /**
          *    Data Frame Size. 
          *    This register field is only valid when SSI_MAX_XFER_SIZE is
          *    configured to 16. If SSI_MAX_XFER_SIZE is configured to 32, 
          *    then writing to this field
          *    will not have any effect.
          *    Selects the data frame length. When the data frame size is 
          *    programmed to be less than
          *    16 bits, the receive data are automatically right-justified by
          *     the receive logic, with the
          *    upper bits of the receive FIFO zero-padded.
          *    You must right-justify transmit data before writing into the 
          *    transmit FIFO. The transmit
          *    logic ignores the upper unused bits when transmitting the data
          *     
          *    Note: When SSI_SPI_MODE is either set to "Dual" or "Quad" or 
          *    "Octal" mode and  SPI_FRF  is not set to 2'b00.
          *    - DFS value should be multiple of 2 if SPI_FRF = 01,
          *    - DFS value should be multiple of 4 if SPI_FRF = 10,
          *    - DFS value should be multiple of 8 if SPI_FRF = 11.
         */
         uint32_t DFS : 4; /* bits 3 to 0; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 120                     */
         /* Description:                                                   */
         /**
          *    Frame Format.
          *    Selects which serial protocol transfers the data. 
         */
         uint32_t FRF : 2; /* bits 5 to 4; R/W; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 148                     */
         /* Description:                                                   */
         /**
          *    Serial Clock Phase.
          *    Valid when the frame format (FRF) is set to Motorola SPI. The 
          *    serial
          *    clock phase selects the relationship of the serial clock with 
          *    the slave
          *    select signal. 
          *    When SCPH = 0, data are captured on the first edge of
          *    the serial clock. When SCPH = 1, the serial clock starts 
          *    toggling one
          *    cycle after the slave select line is activated, and data are 
          *    captured
          *    on the second edge of the serial clock. 
         */
         uint32_t SCPH : 1; /* bit 6; R/W; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 179                     */
         /* Description:                                                   */
         /**
          *    Serial Clock Polarity.
          *    Valid when the frame format (FRF) is set to Motorola SPI. Used
          *     to select
          *    the polarity of the inactive serial clock, which is held 
          *    inactive when
          *    the DW_apb_ssi master is not actively transferring data on the
          *     serial bus. 
         */
         uint32_t SCPOL : 1; /* bit 7; R/W; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 205                     */
         /* Description:                                                   */
         /**
          *    Transfer Mode.
          *    Selects the mode of transfer for serial communication. This 
          *    field does
          *    not affect the transfer duplicity. Only indicates whether the 
          *    receive or
          *    transmit data are valid.
          *     In transmit-only mode, data received from the
          *    external device is not valid and is not stored in the receive 
          *    FIFO memory;
          *    it is overwritten on the next transfer.
          *     In receive-only mode, transmitted
          *    data are not valid. After the first write to the transmit 
          *    FIFO, the same
          *    word is retransmitted for the duration of the transfer.
          *     In
          *    transmit-and-receive mode, both transmit and receive data are 
          *    valid.
          *    The transfer continues until the transmit FIFO is empty. Data 
          *    received
          *    from the external device are stored into the receive FIFO 
          *    memory, where
          *    it can be accessed by the host processor. 
          *     In eeprom-read mode, receive data
          *    is not valid while control data is being transmitted.  When 
          *    all control data is sent
          *    to the EEPROM, receive data becomes valid and transmit data 
          *    becomes invalid.  All 
          *    data in the transmit FIFO is considered control data in this 
          *    mode.  This transfer
          *    mode is only valid when the DW_apb_ssi is configured as master
          *     device.
          *    00 - Transmit & Receive 
          *    01 - Transmit Only 
          *    10 - Receive Only 
          *    11 - EEPROM Read 
          *    When SSI_SPI_MODE is either set to "Dual" or "Quad" or "Octal"
          *     mode and  SPI_FRF  is not set to 2'b00. 
          *    There are only two valid combinations: 
          *    10 - Read 
          *    01 - Write
         */
         uint32_t TMOD : 2; /* bits 9 to 8; R/W; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 278                     */
         /* Description:                                                   */
         /**
          *    SLV_OE Reserved field - Read-only
         */
         uint32_t RSVD_SLV_OE : 1; /* bit 10; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 286                     */
         /* Description:                                                   */
         /**
          *    Shift Register Loop.
          *    Used for testing purposes only. When internally
          *    active, connects the transmit shift register output to the 
          *    receive shift register input. 
          *    Can be used in both serial-slave and serial-master modes. 
          *    When the DW_apb_ssi is configured as a slave in loopback mode,
          *     the ss_in_n and ssi_clk signals 
          *    must be provided by an external source.  In this mode, the 
          *    slave cannot generate these signals
          *    because there is nothing to which to loop back
         */
         uint32_t SRL : 1; /* bit 11; R/W; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 315                     */
         /* Description:                                                   */
         /**
          *    Control Frame Size. Selects the length of the control word for
          *     the
          *    Microwire frame format.
         */
         uint32_t CFS : 4; /* bits 15 to 12; R/W; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 391                     */
         /* Description:                                                   */
         /**
          *    Data Frame Size in 32-bit transfer size mode.
          *    Used to select the data frame size in 32-bit transfer mode. 
          *    These bits are only valid when
          *    SSI_MAX_XFER_SIZE is configured to 32.  When the data frame 
          *    size is programmed
          *    to be less than 32 bits, the receive data are automatically
          *    right-justified by the receive logic, with the upper bits of 
          *    the receive
          *    FIFO zero-padded.  You are responsible for making sure that 
          *    transmit data is right-justified
          *    before writing into the transmit FIFO. The transmit logic 
          *    ignores the upper unused
          *    bits when transmitting the data.
          *    Note: When SSI_SPI_MODE is either set to "Dual" or "Quad" or 
          *    "Octal" mode and  SPI_FRF  is not set to 2'b00.
          *    - DFS value should be multiple of 2 if SPI_FRF = 0x01,
          *    - DFS value should be multiple of 4 if SPI_FRF = 0x10,
          *    - DFS value should be multiple of 8 if SPI_FRF = 0x11.
         */
         uint32_t DFS_32 : 5; /* bits 20 to 16; R/W; 0x07 */

         /* Source filename: DW_apb_ssi.csr, line: 542                     */
         /* Description:                                                   */
         /**
          *    SPI Frame Format: 
          *    Selects data frame format for Transmitting/Receiving the data 
          *    Bits only valid when SSI_SPI_MODE is either set to "Dual" or 
          *    "Quad" or "Octal" mode. 
          *    When SSI_SPI_MODE is configured for "Dual Mode", 10/11 
          *    combination is reserved. 
          *    When SSI_SPI_MODE is configured for "Quad Mode", 11 
          *    combination is reserved.
         */
         uint32_t SPI_FRF : 2; /* bits 22 to 21; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 582                     */
         /* Description:                                                   */
         /**
          *    CTRLR0_23 Reserved bits - Read Only
         */
         uint32_t RSVD_CTRLR0_23 : 1; /* bit 23; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 590                     */
         /* Description:                                                   */
         /**
          *    Slave Select Toggle Enable.
          *    When operating in SPI mode with clock phase (SCPH) set to 0, 
          *    this register controls the behavior of the slave select line 
          *    (ss_*_n) between data frames. If this register field is set to
          *     1 the ss_*_n line will toggle between consecutive data 
          *    frames, with the serial clock (sclk) being held to its default
          *     value while ss_*_n is high; if this register field is set to 
          *    0 the ss_*_n will stay low and sclk will run continuously for 
          *    the duration of the transfer.
          *    Note: This register is only valid when SSI_SCPH0_SSTOGGLE is 
          *    set to 1.
         */
         uint32_t SSTE : 1; /* bit 24; R/W; 0x1 */

         /* Source filename: DW_apb_ssi.csr, line: 608                     */
         /* Description:                                                   */
         /**
          *    SSTE Reserved bits - Read Only
         */
         uint32_t RSVD_CTRLR0 : 7; /* bits 31 to 25; R; 0x00 */
      } B;
      uint32_t R;
   } ;
} Ssi_CTRLR0_t;

/* Typedef for Register: ssi::CTRLR1                                       */
/* Source filename: DW_apb_ssi.csr, line: 617                              */
/* Title: Control Register 1                                               */
/* Description:                                                            */
/**
 *    This register exists only when the DW_apb_ssi is configured as a
 *    master device. When the DW_apb_ssi is configured as a serial slave,
 *    writing to this location has no effect; reading from this location
 *    returns 0. Control register 1 controls the end of serial transfers
 *    when in receive-only mode. It is impossible to write to this
 *    register when the DW_apb_ssi is enabled. The DW_apb_ssi is enabled
 *    and disabled by writing to the SSIENR register.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 634                     */
         /* Description:                                                   */
         /**
          *    Number of Data Frames.
          *    When TMOD = 10 or TMOD = 11 , this register field sets the 
          *    number of data frames to
          *    be continuously received by the DW_apb_ssi. The DW_apb_ssi 
          *    continues
          *    to receive serial data until the number of data frames 
          *    received is
          *    equal to this register value plus 1, which enables you to 
          *    receive up
          *    to 64 KB of data in a continuous transfer. 
          *    When the DW_apb_ssi is
          *    configured as a serial slave, the transfer continues for as 
          *    long as
          *    the slave is selected. Therefore, this register serves no 
          *    purpose and
          *    is not present when the DW_apb_ssi is configured as a serial 
          *    slave.
         */
         uint32_t NDF : 16; /* bits 15 to 0; R/W; 0x0000 */

         /* Source filename: DW_apb_ssi.csr, line: 658                     */
         /* Description:                                                   */
         /**
          *    CTRLR1 Reserved bits - Read Only
         */
         uint32_t RSVD_CTRLR1 : 16; /* bits 31 to 16; R; 0x0000 */
      } B;
      uint32_t R;
   } ;
} Ssi_CTRLR1_t;

/* Typedef for Register: ssi::SSIENR                                       */
/* Source filename: DW_apb_ssi.csr, line: 667                              */
/* Title: SSI Enable Register                                              */
/* Description:                                                            */
/**
 *    This register enables and disables the DW_apb_ssi.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 673                     */
         /* Description:                                                   */
         /**
          *    SSI Enable.
          *     Enables and disables all DW_apb_ssi operations. When
          *    disabled, all serial transfers are halted immediately. 
          *    Transmit and
          *    receive FIFO buffers are cleared when the device is disabled. 
          *    It is
          *    impossible to program some of the DW_apb_ssi control registers
          *     when
          *    enabled. When disabled, the ssi_sleep output is set (after 
          *    delay) to
          *    inform the system that it is safe to remove the ssi_clk, thus 
          *    saving
          *    power consumption in the system.
         */
         uint32_t SSI_EN : 1; /* bit 0; R/W; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 703                     */
         /* Description:                                                   */
         /**
          *    SSIENR Reserved bits - Read Only
         */
         uint32_t RSVD_SSIENR : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_SSIENR_t;

/* Typedef for Register: ssi::MWCR                                         */
/* Source filename: DW_apb_ssi.csr, line: 712                              */
/* Title: Microwire Control Register                                       */
/* Description:                                                            */
/**
 *    This register controls the direction of the data word for the 
 *    half-duplex
 *    Microwire serial protocol. It is impossible to write to this register
 *    when the DW_apb_ssi is enabled. The DW_apb_ssi is enabled and disabled 
 *    by
 *    writing to the SSIENR register.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 724                     */
         /* Description:                                                   */
         /**
          *    Microwire Transfer Mode.
          *    Defines whether the Microwire transfer is sequential or 
          *    non-sequential.
          *    When sequential mode is used, only one control word is needed 
          *    to
          *    transmit or receive a block of data words. When non-sequential
          *     mode is
          *    used, there must be a control word for each data word that is
          *    transmitted or received.
         */
         uint32_t MWMOD : 1; /* bit 0; R/W; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 752                     */
         /* Description:                                                   */
         /**
          *    Microwire Control.
          *    Defines the direction of the data word when the Microwire 
          *    serial protocol
          *    is used. When this bit is set to 0, the data word is received 
          *    by the
          *    DW_apb_ssi MacroCell from the external serial device. When 
          *    this bit is
          *    set to 1, the data word is transmitted from the DW_apb_ssi 
          *    MacroCell to
          *    the external serial device.
         */
         uint32_t MDD : 1; /* bit 1; R/W; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 780                     */
         /* Description:                                                   */
         /**
          *    Microwire Handshaking.
          *    Relevant only when the DW_apb_ssi is configured as a 
          *    serial-master device.
          *    When configured as a serial slave, this bit field has no 
          *    functionality.
          *    Used to enable and disable the busy/ready handshaking 
          *    interface for the
          *    Microwire protocol. When enabled, the DW_apb_ssi checks for a 
          *    ready status
          *    from the target slave, after the transfer of the last 
          *    data/control bit,
          *    before clearing the BUSY status in the SR register. 
         */
         uint32_t MHS : 1; /* bit 2; R/W; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 811                     */
         /* Description:                                                   */
         /**
          *    MWCR Reserved bits - Read Only
         */
         uint32_t RSVD_MWCR : 29; /* bits 31 to 3; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_MWCR_t;

/* Typedef for Register: ssi::SER                                          */
/* Source filename: DW_apb_ssi.csr, line: 820                              */
/* Title: Slave Enable Register                                            */
/* Description:                                                            */
/**
 *    This register is valid only when the DW_apb_ssi is configured as a 
 *    master
 *    device. When the DW_apb_ssi is configured as a serial slave, writing to
 *    this location has no effect; reading from this location returns 0. The
 *    register enables the individual slave select output lines from the
 *    DW_apb_ssi master. Up to 16 slave-select output pins are available on 
 *    the
 *    DW_apb_ssi master. Register bits can be set or cleared when SSI_EN=0. 
 *    If SSI_EN=1, then register bits can be set (to delay the slave select 
 *    assertion while TX FIFO is getting filled) but cannot be cleared.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 841                     */
         /* Description:                                                   */
         /**
          *    Slave Select Enable Flag.
          *    Each bit in this register corresponds to a slave select line 
          *    (ss_x_n)
          *    from the DW_apb_ssi master. When a bit in this register is set
          *     (1), the
          *    corresponding slave select line from the master is activated 
          *    when a
          *    serial transfer begins. It should be noted that setting or 
          *    clearing bits
          *    in this register have no effect on the corresponding slave 
          *    select outputs
          *    until a transfer is started. Before beginning a transfer, you 
          *    should
          *    enable the bit in this register that corresponds to the slave 
          *    device
          *    with which the master wants to communicate. When not operating
          *     in
          *    broadcast mode, only one bit in this field should be set.
         */
         uint32_t SER : 2; /* bits 1 to 0; R/W; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 877                     */
         /* Description:                                                   */
         /**
          *    SER Reserved bits - Read Only
         */
         uint32_t RSVD_SER : 30; /* bits 31 to 2; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_SER_t;

/* Typedef for Register: ssi::BAUDR                                        */
/* Source filename: DW_apb_ssi.csr, line: 886                              */
/* Title: Baud Rate Select                                                 */
/* Description:                                                            */
/**
 *    This register is valid only when the DW_apb_ssi is configured as a 
 *    master
 *    device. When the DW_apb_ssi is configured as a serial slave, writing to
 *    this location has no effect; reading from this location returns 0. The
 *    register derives the frequency of the serial clock that regulates the 
 *    data
 *    transfer. The 16-bit field in this register defines the ssi_clk divider
 *    value. It is impossible to write to this register when the DW_apb_ssi 
 *    is
 *    enabled. The DW_apb_ssi is enabled and disabled by writing to the 
 *    SSIENR
 *    register.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 906                     */
         /* Description:                                                   */
         /**
          *    SSI Clock Divider.
          *    The LSB for this field is always set to 0 and is unaffected by
          *     a write
          *    operation, which ensures an even value is held in this 
          *    register. If the
          *    value is 0, the serial output clock (sclk_out) is disabled. 
          *    The frequency
          *    of the sclk_out is derived from the following equation:
          *            Fsclk_out = Fssi_clk/SCKDV
          *    where SCKDV is any even value between 2 and 65534. For 
          *    example: 
          *    for Fssi_clk = 3.6864MHz and SCKDV =2
          *    Fsclk_out = 3.6864/2 = 1.8432MHz
         */
         uint32_t SCKDV : 16; /* bits 15 to 0; R/W; 0x0000 */

         /* Source filename: DW_apb_ssi.csr, line: 931                     */
         /* Description:                                                   */
         /**
          *    BAUDR Reserved bits - Read Only
         */
         uint32_t RSVD_BAUDR : 16; /* bits 31 to 16; R; 0x0000 */
      } B;
      uint32_t R;
   } ;
} Ssi_BAUDR_t;

/* Typedef for Register: ssi::TXFTLR                                       */
/* Source filename: DW_apb_ssi.csr, line: 940                              */
/* Title: Transmit FIFO Threshold Level                                    */
/* Description:                                                            */
/**
 *    This register controls the threshold value for the transmit FIFO 
 *    memory.
 *    The DW_apb_ssi is enabled and disabled by writing to the SSIENR 
 *    register.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 949                     */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Threshold.
          *    Controls the level of entries (or below) at which the transmit
          *     FIFO controller
          *    triggers an interrupt. The FIFO depth is configurable in the 
          *    range 2-256;
          *    this register is sized to the number of address bits needed to
          *     access the
          *    FIFO. If you attempt to set this value greater than or equal 
          *    to the depth
          *    of the FIFO, this field is not written and retains its current
          *     value. When
          *    the number of transmit FIFO entries is less than or equal to 
          *    this value,
          *    the transmit FIFO empty interrupt is triggered. For 
          *    information on the Transmit FIFO Threshold values, see the 
          *    "Master SPI and SSP Serial Transfers" in the DW_apb_ssi 
          *    Databook.
          *    ssi_txe_intr is asserted when TFT or less data entries are 
          *    present in transmit FIFO
         */
         uint32_t TFT : 8; /* bits 7 to 0; R/W; 0x00 */

         /* Source filename: DW_apb_ssi.csr, line: 976                     */
         /* Description:                                                   */
         /**
          *    TXFTLR Reserved bits - Read Only
         */
         uint32_t RSVD_TXFTLR : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_TXFTLR_t;

/* Typedef for Register: ssi::RXFTLR                                       */
/* Source filename: DW_apb_ssi.csr, line: 985                              */
/* Title: Receive FIFO Threshold Level                                     */
/* Description:                                                            */
/**
 *    This register controls the threshold value for the receive FIFO memory.
 *    The DW_apb_ssi is enabled and disabled by writing to the SSIENR 
 *    register.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 994                     */
         /* Description:                                                   */
         /**
          *    Receive FIFO Threshold.
          *    Controls the level of entries (or above) at which the receive 
          *    FIFO controller triggers an interrupt. The FIFO depth is 
          *    configurable in the range 2-256. This register is sized to the
          *     number of address
          *    bits needed to access the FIFO. If you attempt to set this 
          *    value greater than the depth of the FIFO, this field is not 
          *    written and retains its current value. When the number of 
          *    receive FIFO entries is
          *    greater than or equal to this value + 1, the receive FIFO full
          *     interrupt is triggered. For information on the Receive FIFO 
          *    Threshold values, see the "Master SPI and SSP Serial 
          *    Transfers" in the
          *    DW_apb_ssi Databook.
          *    ssi_rxf_intr is asserted when RFT or more data entries are 
          *    present in receive FIFO.
         */
         uint32_t RFT : 8; /* bits 7 to 0; R/W; 0x00 */

         /* Source filename: DW_apb_ssi.csr, line: 1017                    */
         /* Description:                                                   */
         /**
          *    RXFTLR Reserved bits - Read Only
         */
         uint32_t RSVD_RXFTLR : 24; /* bits 31 to 8; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_RXFTLR_t;

/* Typedef for Register: ssi::TXFLR                                        */
/* Source filename: DW_apb_ssi.csr, line: 1026                             */
/* Title: Transmit FIFO Level Register                                     */
/* Description:                                                            */
/**
 *    This register contains the number of valid data entries in the transmit
 *     FIFO memory.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1034                    */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Level.
          *    Contains the number of valid data entries in the transmit 
          *    FIFO.
         */
         uint32_t TXTFL : 9; /* bits 8 to 0; R; 0x000 */

         /* Source filename: DW_apb_ssi.csr, line: 1044                    */
         /* Description:                                                   */
         /**
          *    TXFLR Reserved bits - Read Only
         */
         uint32_t RSVD_TXFLR : 23; /* bits 31 to 9; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_TXFLR_t;

/* Typedef for Register: ssi::RXFLR                                        */
/* Source filename: DW_apb_ssi.csr, line: 1052                             */
/* Title: Receive FIFO Level Register                                      */
/* Description:                                                            */
/**
 *    This register contains the number of valid data entries in the receive 
 *    FIFO memory.  This register can be ready at any time.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1061                    */
         /* Description:                                                   */
         /**
          *    Receive FIFO Level.
          *    Contains the number of valid data entries in the receive FIFO.
         */
         uint32_t RXTFL : 9; /* bits 8 to 0; R; 0x000 */

         /* Source filename: DW_apb_ssi.csr, line: 1071                    */
         /* Description:                                                   */
         /**
          *    RXFLR Reserved bits - Read Only
         */
         uint32_t RSVD_RXFLR : 23; /* bits 31 to 9; R; 0x000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_RXFLR_t;

/* Typedef for Register: ssi::SR                                           */
/* Source filename: DW_apb_ssi.csr, line: 1079                             */
/* Title: Status Register                                                  */
/* Description:                                                            */
/**
 *    This is a read-only register used to indicate the current transfer 
 *    status,
 *    FIFO status, and any transmission/reception errors that may have 
 *    occurred.
 *    The status register may be read at any time. None of the bits in this
 *    register request an interrupt.
 *    Reset Value: 0x6
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1092                    */
         /* Description:                                                   */
         /**
          *    SSI Busy Flag.
          *    When set, indicates that a serial transfer is in progress; 
          *    when cleared
          *    indicates that the DW_apb_ssi is idle or disabled.
         */
         uint32_t BUSY : 1; /* bit 0; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1114                    */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Not Full.
          *     Set when the transmit FIFO contains one or more
          *    empty locations, and is cleared when the FIFO is full.
         */
         uint32_t TFNF : 1; /* bit 1; R; 0x1 */

         /* Source filename: DW_apb_ssi.csr, line: 1134                    */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Empty.
          *    When the transmit FIFO is completely empty, this bit is set. 
          *    When the
          *    transmit FIFO contains one or more valid entries, this bit is 
          *    cleared.
          *    This bit field does not request an interrupt.
         */
         uint32_t TFE : 1; /* bit 2; R; 0x1 */

         /* Source filename: DW_apb_ssi.csr, line: 1158                    */
         /* Description:                                                   */
         /**
          *    Receive FIFO Not Empty.
          *    Set when the receive FIFO contains one or more entries and is 
          *    cleared
          *    when the receive FIFO is empty. This bit can be polled by 
          *    software to
          *    completely empty the receive FIFO.
         */
         uint32_t RFNE : 1; /* bit 3; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1182                    */
         /* Description:                                                   */
         /**
          *    Receive FIFO Full.
          *    When the receive FIFO is completely full, this bit
          *    is set. When the receive FIFO contains one or more empty 
          *    location, this
          *    bit is cleared.
         */
         uint32_t RFF : 1; /* bit 4; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1205                    */
         /* Description:                                                   */
         /**
          *    TXE Reserved field - read-only
         */
         uint32_t RSVD_TXE : 1; /* bit 5; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1212                    */
         /* Description:                                                   */
         /**
          *    Data Collision Error.
          *    Relevant only when the DW_apb_ssi is configured as a master 
          *    device.
          *    This bit will be set if ss_in_n input is asserted by other 
          *    master,
          *    when the DW_apb_ssi master is in the middle of the transfer. 
          *    This informs the processor that the
          *    last data transfer was halted before completion. This bit is 
          *    cleared
          *    when read.
         */
         uint32_t DCOL : 1; /* bit 6; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1240                    */
         /* Description:                                                   */
         /**
          *    SR Reserved bits - Read Only
         */
         uint32_t RSVD_SR : 25; /* bits 31 to 7; R; 0x0000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_SR_t;

/* Typedef for Register: ssi::IMR                                          */
/* Source filename: DW_apb_ssi.csr, line: 1248                             */
/* Title: Interrupt Mask Register                                          */
/* Description:                                                            */
/**
 *    This read/write reigster masks or enables all interrupts generated by 
 *    the DW_apb_ssi.
 *    When the DW_apb_ssi is configured as a slave device, the MSTIM bit 
 *    field is not present. 
 *    This changes the reset value from 0x3F for serial-master configurations
 *     to 0x1F for serial-slave
 *    configurations.
 *    Reset Value: (SSI_IS_MASTER == 1) ? 0x3F : 0x1F
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1260                    */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Empty Interrupt Mask
         */
         uint32_t TXEIM : 1; /* bit 0; R/W; 0x1 */

         /* Source filename: DW_apb_ssi.csr, line: 1278                    */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Overflow Interrupt Mask
         */
         uint32_t TXOIM : 1; /* bit 1; R/W; 0x1 */

         /* Source filename: DW_apb_ssi.csr, line: 1296                    */
         /* Description:                                                   */
         /**
          *    Receive FIFO Underflow Interrupt Mask
         */
         uint32_t RXUIM : 1; /* bit 2; R/W; 0x1 */

         /* Source filename: DW_apb_ssi.csr, line: 1314                    */
         /* Description:                                                   */
         /**
          *    Receive FIFO Overflow Interrupt Mask
         */
         uint32_t RXOIM : 1; /* bit 3; R/W; 0x1 */

         /* Source filename: DW_apb_ssi.csr, line: 1332                    */
         /* Description:                                                   */
         /**
          *    Receive FIFO Full Interrupt Mask
         */
         uint32_t RXFIM : 1; /* bit 4; R/W; 0x1 */

         /* Source filename: DW_apb_ssi.csr, line: 1350                    */
         /* Description:                                                   */
         /**
          *    Multi-Master Contention Interrupt Mask. This bit field is not 
          *    present if
          *    the DW_apb_ssi is configured as a serial-slave device.
         */
         uint32_t MSTIM : 1; /* bit 5; R/W; 0x1 */

         /* Source filename: DW_apb_ssi.csr, line: 1370                    */
         /* Description:                                                   */
         /**
          *    IMR Reserved bits - Read Only
         */
         uint32_t RSVD_IMR : 26; /* bits 31 to 6; R; 0x0000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_IMR_t;

/* Typedef for Register: ssi::ISR                                          */
/* Source filename: DW_apb_ssi.csr, line: 1379                             */
/* Title: Interrupt Status Register                                        */
/* Description:                                                            */
/**
 *    This register reports the status of the DW_apb_ssi interrupts after 
 *    they have been masked.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1387                    */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Empty Interrupt Status
         */
         uint32_t TXEIS : 1; /* bit 0; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1405                    */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Overflow Interrupt Status
         */
         uint32_t TXOIS : 1; /* bit 1; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1423                    */
         /* Description:                                                   */
         /**
          *    Receive FIFO Underflow Interrupt Status
         */
         uint32_t RXUIS : 1; /* bit 2; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1441                    */
         /* Description:                                                   */
         /**
          *    Receive FIFO Overflow Interrupt Status
         */
         uint32_t RXOIS : 1; /* bit 3; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1459                    */
         /* Description:                                                   */
         /**
          *    Receive FIFO Full Interrupt Status
         */
         uint32_t RXFIS : 1; /* bit 4; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1477                    */
         /* Description:                                                   */
         /**
          *    Multi-Master Contention Interrupt Status. This bit field is 
          *    not present
          *    if the DW_apb_ssi is configured as a serial-slave device.
         */
         uint32_t MSTIS : 1; /* bit 5; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1497                    */
         /* Description:                                                   */
         /**
          *    ISR Reserved bits - Read Only
         */
         uint32_t RSVD_ISR : 26; /* bits 31 to 6; R; 0x0000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_ISR_t;

/* Typedef for Register: ssi::RISR                                         */
/* Source filename: DW_apb_ssi.csr, line: 1505                             */
/* Title: Raw Interrupt Status Register                                    */
/* Description:                                                            */
/**
 *    This read-only register reports the status of the DW_apb_ssi interrupts
 *     prior to masking.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1513                    */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Empty Raw Interrupt Status
         */
         uint32_t TXEIR : 1; /* bit 0; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1532                    */
         /* Description:                                                   */
         /**
          *    Transmit FIFO Overflow Raw Interrupt Status
         */
         uint32_t TXOIR : 1; /* bit 1; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1551                    */
         /* Description:                                                   */
         /**
          *    Receive FIFO Underflow Raw Interrupt Status
         */
         uint32_t RXUIR : 1; /* bit 2; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1570                    */
         /* Description:                                                   */
         /**
          *    Receive FIFO Overflow Raw Interrupt Status
         */
         uint32_t RXOIR : 1; /* bit 3; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1589                    */
         /* Description:                                                   */
         /**
          *    Receive FIFO Full Raw Interrupt Status
         */
         uint32_t RXFIR : 1; /* bit 4; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1608                    */
         /* Description:                                                   */
         /**
          *    Multi-Master Contention Raw Interrupt Status.
          *    This bit field is not present if the DW_apb_ssi is configured 
          *    as a
          *    serial-slave device.
         */
         uint32_t MSTIR : 1; /* bit 5; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1630                    */
         /* Description:                                                   */
         /**
          *    RISR Reserved bits - Read Only
         */
         uint32_t RSVD_RISR : 26; /* bits 31 to 6; R; 0x0000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_RISR_t;

/* Typedef for Register: ssi::TXOICR                                       */
/* Source filename: DW_apb_ssi.csr, line: 1638                             */
/* Title: Transmit FIFO Overflow Interrupt Clear Register Register         */
/* Description:                                                            */
/**
 *    Transmit FIFO Overflow Interrupt Clear Register.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1645                    */
         /* Description:                                                   */
         /**
          *    Clear Transmit FIFO Overflow Interrupt.
          *    This register reflects the status of the interrupt. A read 
          *    from this
          *    register clears the ssi_txo_intr interrupt; writing has no 
          *    effect.
         */
         uint32_t TXOICR : 1; /* bit 0; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1657                    */
         /* Description:                                                   */
         /**
          *    TXOICR Reserved bits - Read Only
         */
         uint32_t RSVD_TXOICR : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_TXOICR_t;

/* Typedef for Register: ssi::RXOICR                                       */
/* Source filename: DW_apb_ssi.csr, line: 1665                             */
/* Title: Receive FIFO Overflow Interrupt Clear Register                   */
/* Description:                                                            */
/**
 *    Receive FIFO Overflow Interrupt Clear Register.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1672                    */
         /* Description:                                                   */
         /**
          *    Clear Receive FIFO Overflow Interrupt.
          *    This register reflects the status of the interrupt. A read 
          *    from this
          *    register clears the ssi_rxo_intr interrupt; writing has no 
          *    effect.
         */
         uint32_t RXOICR : 1; /* bit 0; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1684                    */
         /* Description:                                                   */
         /**
          *    RXOICR Reserved bits - Read Only
         */
         uint32_t RSVD_RXOICR : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_RXOICR_t;

/* Typedef for Register: ssi::RXUICR                                       */
/* Source filename: DW_apb_ssi.csr, line: 1692                             */
/* Title: Receive FIFO Underflow Interrupt Clear Register                  */
/* Description:                                                            */
/**
 *    Receive FIFO Underflow Interrupt Clear Register.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1699                    */
         /* Description:                                                   */
         /**
          *    Clear Receive FIFO Underflow Interrupt.
          *    This register reflects the status of the interrupt. A read 
          *    from this
          *    register clears the ssi_rxu_intr interrupt; writing has no 
          *    effect.
         */
         uint32_t RXUICR : 1; /* bit 0; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1711                    */
         /* Description:                                                   */
         /**
          *    RXUICR Reserved bits - Read Only
         */
         uint32_t RSVD_RXUICR : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_RXUICR_t;

/* Typedef for Register: ssi::MSTICR                                       */
/* Source filename: DW_apb_ssi.csr, line: 1719                             */
/* Title: Multi-Master Interrupt Clear Register                            */
/* Description:                                                            */
/**
 *    Multi-Master Interrupt Clear Register.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1726                    */
         /* Description:                                                   */
         /**
          *    Clear Multi-Master Contention Interrupt.
          *    This register reflects the status of the interrupt. A read 
          *    from this
          *    register clears the ssi_mst_intr interrupt; writing has no 
          *    effect.
         */
         uint32_t MSTICR : 1; /* bit 0; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1738                    */
         /* Description:                                                   */
         /**
          *    MSTICR Reserved bits - Read Only
         */
         uint32_t RSVD_MSTICR : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_MSTICR_t;

/* Typedef for Register: ssi::ICR                                          */
/* Source filename: DW_apb_ssi.csr, line: 1746                             */
/* Title: Interrupt Clear Register                                         */
/* Description:                                                            */
/**
 *    Interrupt Clear Register.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1753                    */
         /* Description:                                                   */
         /**
          *    Clear Interrupts.
          *    This register is set if any of the interrupts below are 
          *    active. A read
          *    clears the ssi_txo_intr, ssi_rxu_intr, ssi_rxo_intr, and the 
          *    ssi_mst_intr
          *    interrupts. Writing to this register has no effect.
         */
         uint32_t ICR : 1; /* bit 0; R; 0x0 */

         /* Source filename: DW_apb_ssi.csr, line: 1766                    */
         /* Description:                                                   */
         /**
          *    ICR Reserved bits - Read Only
         */
         uint32_t RSVD_ICR : 31; /* bits 31 to 1; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_ICR_t;

/* Typedef for Register: ssi::IDR                                          */
/* Source filename: DW_apb_ssi.csr, line: 1774                             */
/* Title: Identification Register                                          */
/* Description:                                                            */
/**
 *    This register contains the peripherals identification code, which is
 *    written into the register at configuration time using coreConsultant.
 *    Reset Value: SSI_ID
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1784                    */
         /* Description:                                                   */
         /**
          *    Identification code.
          *     The register contains the peripheral's identification code, 
          *    which is written into the register at configuration time using
          *     CoreConsultant.
         */
         uint32_t IDCODE : 32; /* bits 31 to 0; R; 0xffffffff */
      } B;
      uint32_t R;
   } ;
} Ssi_IDR_t;

/* Typedef for Register: ssi::SSI_VERSION_ID                               */
/* Source filename: DW_apb_ssi.csr, line: 1795                             */
/* Title: coreKit version ID Register                                      */
/* Description:                                                            */
/**
 *    This read-only register stores the specific DW_apb_ssi component 
 *    version.
 *    Reset Value: SSI_VERSION_ID
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1803                    */
         /* Description:                                                   */
         /**
          *    Contains the hex representation of the Synopsys component 
          *    version. Consists of ASCII value for each number in the 
          *    version, followed by *. For example 32_30_31_2A represents the
          *     version 2.01*.
         */
         uint32_t SSI_COMP_VERSION : 32; /* bits 31 to 0; R; 0x3430322a */
      } B;
      uint32_t R;
   } ;
} Ssi_SSI_VERSION_ID_t;

/* Typedef for Register: ssi::DR0                                          */
/* Source filename: DW_apb_ssi.csr, line: 1814                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1838                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR0_t;

/* Typedef for Register: ssi::DR1                                          */
/* Source filename: DW_apb_ssi.csr, line: 1854                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1878                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR1_t;

/* Typedef for Register: ssi::DR2                                          */
/* Source filename: DW_apb_ssi.csr, line: 1894                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1918                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR2_t;

/* Typedef for Register: ssi::DR3                                          */
/* Source filename: DW_apb_ssi.csr, line: 1934                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1958                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR3_t;

/* Typedef for Register: ssi::DR4                                          */
/* Source filename: DW_apb_ssi.csr, line: 1974                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 1998                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR4_t;

/* Typedef for Register: ssi::DR5                                          */
/* Source filename: DW_apb_ssi.csr, line: 2014                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2038                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR5_t;

/* Typedef for Register: ssi::DR6                                          */
/* Source filename: DW_apb_ssi.csr, line: 2054                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2078                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR6_t;

/* Typedef for Register: ssi::DR7                                          */
/* Source filename: DW_apb_ssi.csr, line: 2094                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2118                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR7_t;

/* Typedef for Register: ssi::DR8                                          */
/* Source filename: DW_apb_ssi.csr, line: 2134                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2158                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR8_t;

/* Typedef for Register: ssi::DR9                                          */
/* Source filename: DW_apb_ssi.csr, line: 2174                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2198                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR9_t;

/* Typedef for Register: ssi::DR10                                         */
/* Source filename: DW_apb_ssi.csr, line: 2214                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2238                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR10_t;

/* Typedef for Register: ssi::DR11                                         */
/* Source filename: DW_apb_ssi.csr, line: 2254                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2278                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR11_t;

/* Typedef for Register: ssi::DR12                                         */
/* Source filename: DW_apb_ssi.csr, line: 2294                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2318                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR12_t;

/* Typedef for Register: ssi::DR13                                         */
/* Source filename: DW_apb_ssi.csr, line: 2334                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2358                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR13_t;

/* Typedef for Register: ssi::DR14                                         */
/* Source filename: DW_apb_ssi.csr, line: 2374                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2398                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR14_t;

/* Typedef for Register: ssi::DR15                                         */
/* Source filename: DW_apb_ssi.csr, line: 2414                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2438                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR15_t;

/* Typedef for Register: ssi::DR16                                         */
/* Source filename: DW_apb_ssi.csr, line: 2454                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2478                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR16_t;

/* Typedef for Register: ssi::DR17                                         */
/* Source filename: DW_apb_ssi.csr, line: 2494                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2518                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR17_t;

/* Typedef for Register: ssi::DR18                                         */
/* Source filename: DW_apb_ssi.csr, line: 2534                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2558                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR18_t;

/* Typedef for Register: ssi::DR19                                         */
/* Source filename: DW_apb_ssi.csr, line: 2574                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2598                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR19_t;

/* Typedef for Register: ssi::DR20                                         */
/* Source filename: DW_apb_ssi.csr, line: 2614                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2638                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR20_t;

/* Typedef for Register: ssi::DR21                                         */
/* Source filename: DW_apb_ssi.csr, line: 2654                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2678                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR21_t;

/* Typedef for Register: ssi::DR22                                         */
/* Source filename: DW_apb_ssi.csr, line: 2694                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2718                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR22_t;

/* Typedef for Register: ssi::DR23                                         */
/* Source filename: DW_apb_ssi.csr, line: 2734                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2758                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR23_t;

/* Typedef for Register: ssi::DR24                                         */
/* Source filename: DW_apb_ssi.csr, line: 2774                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2798                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR24_t;

/* Typedef for Register: ssi::DR25                                         */
/* Source filename: DW_apb_ssi.csr, line: 2814                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2838                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR25_t;

/* Typedef for Register: ssi::DR26                                         */
/* Source filename: DW_apb_ssi.csr, line: 2854                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2878                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR26_t;

/* Typedef for Register: ssi::DR27                                         */
/* Source filename: DW_apb_ssi.csr, line: 2894                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2918                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR27_t;

/* Typedef for Register: ssi::DR28                                         */
/* Source filename: DW_apb_ssi.csr, line: 2934                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2958                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR28_t;

/* Typedef for Register: ssi::DR29                                         */
/* Source filename: DW_apb_ssi.csr, line: 2974                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 2998                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR29_t;

/* Typedef for Register: ssi::DR30                                         */
/* Source filename: DW_apb_ssi.csr, line: 3014                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 3038                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR30_t;

/* Typedef for Register: ssi::DR31                                         */
/* Source filename: DW_apb_ssi.csr, line: 3054                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 3078                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR31_t;

/* Typedef for Register: ssi::DR32                                         */
/* Source filename: DW_apb_ssi.csr, line: 3094                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 3118                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR32_t;

/* Typedef for Register: ssi::DR33                                         */
/* Source filename: DW_apb_ssi.csr, line: 3134                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 3158                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR33_t;

/* Typedef for Register: ssi::DR34                                         */
/* Source filename: DW_apb_ssi.csr, line: 3174                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 3198                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR34_t;

/* Typedef for Register: ssi::DR35                                         */
/* Source filename: DW_apb_ssi.csr, line: 3214                             */
/* Title: Data Register x                                                  */
/* Description:                                                            */
/**
 *    The DW_apb_ssi data register is a 16/32-bit (depending on 
 *    SSI_MAX_XFER_SIZE) read/write buffer for
 *    the transmit/receive FIFOs. If the configuration parameter 
 *    SSI_MAX_XFER_SIZE is set to 32, then all 32 bits
 *    are valid, otherwise, only 16 bits ([15:0]) of the register are valid. 
 *    When the register is read, data in the
 *    receive FIFO buffer is accessed. When it is written to, data are moved 
 *    into the transmit FIFO buffer; a write
 *    can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0.
 *    NOTE: The DR register in the DW_apb_ssi occupies thirty-six 32-bit 
 *    address locations of the memory
 *    map to facilitate AHB burst transfers. Writing to any of these address 
 *    locations has the same
 *    effect as pushing the data from the pwdata bus into the transmit FIFO. 
 *    Reading from any of
 *    these locations has the same effect as popping data from the receive 
 *    FIFO onto the prdata
 *    bus. The FIFO buffers on the DW_apb_ssi are not addressable.
 *    Reset Value: 0x0
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 3238                    */
         /* Description:                                                   */
         /**
          *    Data Register. When writing to this register, you must 
          *    right-justify the data. Read
          *    data are automatically right-justified. If SSI_MAX_XFER_SIZE 
          *    configuration
          *    parameter is set to 32, all 32 bits are valid. Otherwise, only
          *     16 bits ([15:0]) of the
          *    register are valid.
          *    Read = Receive FIFO buffer
          *    Write = Transmit FIFO buffer.
         */
         uint32_t DR : 32; /* bits 31 to 0; R/W; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_DR35_t;

/* Typedef for Register: ssi::RSVD                                         */
/* Source filename: DW_apb_ssi.csr, line: 3254                             */
/* Title: RSVD - Reserved address location                                 */
/* Description:                                                            */
/**
 *    RSVD - Reserved address location.
*/
typedef struct {
   union {
      struct {

         /* Source filename: DW_apb_ssi.csr, line: 3260                    */
         /* Description:                                                   */
         /**
          *    RSVD 31to0 Reserved address location
         */
         uint32_t RSVD : 32; /* bits 31 to 0; R; 0x00000000 */
      } B;
      uint32_t R;
   } ;
} Ssi_RSVD_t;

/* Typedef for Addressmap: ssi                                             */
/* Source filename: DW_apb_ssi.csr, line: 3268                             */
typedef struct {
   Ssi_CTRLR0_t CTRLR0; /**< Offset 0x0 (R/W) */
   Ssi_CTRLR1_t CTRLR1; /**< Offset 0x4 (R/W) */
   Ssi_SSIENR_t SSIENR; /**< Offset 0x8 (R/W) */
   Ssi_MWCR_t MWCR; /**< Offset 0xc (R/W) */
   Ssi_SER_t SER; /**< Offset 0x10 (R/W) */
   Ssi_BAUDR_t BAUDR; /**< Offset 0x14 (R/W) */
   Ssi_TXFTLR_t TXFTLR; /**< Offset 0x18 (R/W) */
   Ssi_RXFTLR_t RXFTLR; /**< Offset 0x1c (R/W) */
   Ssi_TXFLR_t TXFLR; /**< Offset 0x20 (R) */
   Ssi_RXFLR_t RXFLR; /**< Offset 0x24 (R) */
   Ssi_SR_t SR; /**< Offset 0x28 (R) */
   Ssi_IMR_t IMR; /**< Offset 0x2c (R/W) */
   Ssi_ISR_t ISR; /**< Offset 0x30 (R) */
   Ssi_RISR_t RISR; /**< Offset 0x34 (R) */
   Ssi_TXOICR_t TXOICR; /**< Offset 0x38 (R) */
   Ssi_RXOICR_t RXOICR; /**< Offset 0x3c (R) */
   Ssi_RXUICR_t RXUICR; /**< Offset 0x40 (R) */
   Ssi_MSTICR_t MSTICR; /**< Offset 0x44 (R) */
   Ssi_ICR_t ICR; /**< Offset 0x48 (R) */
   uint8_t _pad0[0xc];
   Ssi_IDR_t IDR; /**< Offset 0x58 (R) */
   Ssi_SSI_VERSION_ID_t SSI_VERSION_ID; /**< Offset 0x5c (R) */
   Ssi_DR0_t DR0; /**< Offset 0x60 (R/W) */
   Ssi_DR1_t DR1; /**< Offset 0x64 (R/W) */
   Ssi_DR2_t DR2; /**< Offset 0x68 (R/W) */
   Ssi_DR3_t DR3; /**< Offset 0x6c (R/W) */
   Ssi_DR4_t DR4; /**< Offset 0x70 (R/W) */
   Ssi_DR5_t DR5; /**< Offset 0x74 (R/W) */
   Ssi_DR6_t DR6; /**< Offset 0x78 (R/W) */
   Ssi_DR7_t DR7; /**< Offset 0x7c (R/W) */
   Ssi_DR8_t DR8; /**< Offset 0x80 (R/W) */
   Ssi_DR9_t DR9; /**< Offset 0x84 (R/W) */
   Ssi_DR10_t DR10; /**< Offset 0x88 (R/W) */
   Ssi_DR11_t DR11; /**< Offset 0x8c (R/W) */
   Ssi_DR12_t DR12; /**< Offset 0x90 (R/W) */
   Ssi_DR13_t DR13; /**< Offset 0x94 (R/W) */
   Ssi_DR14_t DR14; /**< Offset 0x98 (R/W) */
   Ssi_DR15_t DR15; /**< Offset 0x9c (R/W) */
   Ssi_DR16_t DR16; /**< Offset 0xa0 (R/W) */
   Ssi_DR17_t DR17; /**< Offset 0xa4 (R/W) */
   Ssi_DR18_t DR18; /**< Offset 0xa8 (R/W) */
   Ssi_DR19_t DR19; /**< Offset 0xac (R/W) */
   Ssi_DR20_t DR20; /**< Offset 0xb0 (R/W) */
   Ssi_DR21_t DR21; /**< Offset 0xb4 (R/W) */
   Ssi_DR22_t DR22; /**< Offset 0xb8 (R/W) */
   Ssi_DR23_t DR23; /**< Offset 0xbc (R/W) */
   Ssi_DR24_t DR24; /**< Offset 0xc0 (R/W) */
   Ssi_DR25_t DR25; /**< Offset 0xc4 (R/W) */
   Ssi_DR26_t DR26; /**< Offset 0xc8 (R/W) */
   Ssi_DR27_t DR27; /**< Offset 0xcc (R/W) */
   Ssi_DR28_t DR28; /**< Offset 0xd0 (R/W) */
   Ssi_DR29_t DR29; /**< Offset 0xd4 (R/W) */
   Ssi_DR30_t DR30; /**< Offset 0xd8 (R/W) */
   Ssi_DR31_t DR31; /**< Offset 0xdc (R/W) */
   Ssi_DR32_t DR32; /**< Offset 0xe0 (R/W) */
   Ssi_DR33_t DR33; /**< Offset 0xe4 (R/W) */
   Ssi_DR34_t DR34; /**< Offset 0xe8 (R/W) */
   Ssi_DR35_t DR35; /**< Offset 0xec (R/W) */
   uint8_t _pad1[0xc];
   Ssi_RSVD_t RSVD; /**< Offset 0xfc (R) */
} Ssi_t;

#endif
