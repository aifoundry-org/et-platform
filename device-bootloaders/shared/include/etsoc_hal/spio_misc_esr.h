/*                                                                         */
/* Generated by Semifore, Inc. csrCompile                                  */
/*    Version: 2019.03.02 Build: release Linux 64-bit                      */
/*    C Header output                                                      */
/*                                                                         */
/* Command Line:                                                           */
/*    /home/cad/tools/semifore/csrCompile/LATEST/bin/x64_re6/csrCompile -v */
/*    -c                                                                   */
/*    /eng/ssmith/work/repos/soc_hal/dv/common/scripts/semifore_css/bitfield_enum_doc.css */
/*    -t h spio_misc_esr.csr -o gen_sw/spio_misc_esr                       */
/*                                                                         */
/* Input files:                                                            */
/*    spio_misc_esr.csr                                                    */
/*                                                                         */
/* Configuration files:                                                    */
/*    /eng/ssmith/work/repos/soc_hal/dv/common/scripts/semifore_css/bitfield_enum_doc.css */
/*                                                                         */
/* Generated on: Fri Sep 13 06:33:35 2019                                  */
/*           by: ssmith                                                    */
/*                                                                         */

#ifndef _SPIO_MISC_ESR_H_
#define _SPIO_MISC_ESR_H_


/* ####################################################################### */
/*        TYPE DEFINITIONS                                                 */
/* ####################################################################### */

/* Typedef for Register: spio_misc_esr::VAULT_DMA_R_RELOC                  */
/* Source filename: spio_misc_esr.csr, line: 12                            */
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 13                   */
         /* Description:                                                   */
         /**
          *    Sets the top 8-bits of the VauXI mas30 AXI master interface 
          *    read channel address
         */
         uint32_t Rd_Channel_Addr : 8; /* bits 7 to 0; R/W; 0x00 */
         uint32_t : 24; /* bits 31 to 8 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_VAULT_DMA_R_RELOC_t;

/* Typedef for Register: spio_misc_esr::VAULT_DMA_WR_RELOC                 */
/* Source filename: spio_misc_esr.csr, line: 19                            */
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 20                   */
         /* Description:                                                   */
         /**
          *    Sets the top 8-bits of the VaultIP-130 AXI master interface 
          *    write channel address
         */
         uint32_t Wt_Channel_Addr : 8; /* bits 7 to 0; R/W; 0x00 */
         uint32_t : 24; /* bits 31 to 8 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_VAULT_DMA_WR_RELOC_t;

/* Typedef for Register: spio_misc_esr::DMCTRL                             */
/* Source filename: spio_misc_esr.csr, line: 26                            */
/* Description:                                                            */
/**
 *    This is the DMCTRL broadcast bus. It is  it is broadcast to all Minion 
 *    shires
*/
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 28                   */
         /* Description:                                                   */
         /**
          *    Controls the dmactive signal from the DM; When low, it should 
          *    hold at reset the debug logic of the receiving harts, and of 
          *    the DM.
         */
         uint32_t dmactive : 1; /* bit 0; R/W; 0 */

         /* Source filename: spio_misc_esr.csr, line: 32                   */
         /* Description:                                                   */
         /**
          *    Controls the ndmreset signal from the DM; The signal should 
          *    reset every part of the receiving shire, except for any logic 
          *    required for debug
         */
         uint32_t ndmreset : 1; /* bit 1; R/W; 0 */

         /* Source filename: spio_misc_esr.csr, line: 36                   */
         /* Description:                                                   */
         /**
          *    Controls the clrresethaltreq signal from the DM. Writes of 
          *    this bit clear the HACTRL.resethalt bits of all currently 
          *    selected harts.
         */
         uint32_t clrresethaltreq : 1; /* bit 2; R/W; 0 */

         /* Source filename: spio_misc_esr.csr, line: 40                   */
         /* Description:                                                   */
         /**
          *    Controls the setresethaltreq signal from the DM; Writes of 
          *    this bit set the HACTRL.resethalt bits of all currently 
          *    selected harts.
         */
         uint32_t setresethaltreq : 1; /* bit 3; R/W; 0 */
         uint32_t : 22; /* bits 25 to 4 */

         /* Source filename: spio_misc_esr.csr, line: 44                   */
         /* Description:                                                   */
         /**
          *    Controls the hasel signal from the DM. If set to 0, then DM 
          *    requests, such as halt and resume apply only to the harts that
          *     are selected by HACTRL.hartmask.If set to 1, then DM requests
          *     apply to all harts selected by the union of HACTRL.hartmask 
          *    and HACTRL.hawindow. Also, if hasel is 0, the AndOrTreeL0 
          *    registers are not updated with the status of the harts.
         */
         uint32_t hasel : 1; /* bit 26; R/W; 0 */
         uint32_t : 1; /* bit 27 */

         /* Source filename: spio_misc_esr.csr, line: 50                   */
         /* Description:                                                   */
         /**
          *    Controls the ackhavereset signal from the DM. Writing 1 to 
          *    this field clears HASTATUS0.havereset for all currently 
          *    selected harts.
         */
         uint32_t ackhavereset : 1; /* bit 28; R/W; 0 */

         /* Source filename: spio_misc_esr.csr, line: 54                   */
         /* Description:                                                   */
         /**
          *    Controls the hartreset signal from the DM
         */
         uint32_t hartreset : 1; /* bit 29; R/W; 0 */

         /* Source filename: spio_misc_esr.csr, line: 58                   */
         /* Description:                                                   */
         /**
          *    Controls the resumereq signal from the DM.
         */
         uint32_t resumereq : 1; /* bit 30; R/W; 0 */

         /* Source filename: spio_misc_esr.csr, line: 62                   */
         /* Description:                                                   */
         /**
          *    Controls the haltreq signal from the DM.
         */
         uint32_t haltreq : 1; /* bit 31; R/W; 0 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_DMCTRL_t;

/* Typedef for Register: spio_misc_esr::AndOrTreeL2                        */
/* Source filename: spio_misc_esr.csr, line: 68                            */
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 71                   */
         /* Description:                                                   */
         /**
          *    Set if AndOrTreeL1.anyhalted0 or AndOrTreeL1.anyhalted1 from 
          *    any of the Minion Shires 0 to 15 is set. This corresponds to 
          *    the halted status of 1024 harts
         */
         uint32_t anyhalted0 : 1; /* bit 0; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 75                   */
         /* Description:                                                   */
         /**
          *    Set if AndOrTreeL1.anyhalted0 or AndOrTreeL1.anyhalted1 from 
          *    any of the Minion Shires 16 to 31 is set. This corresponds to 
          *    the halted status of 1024 harts
         */
         uint32_t anyhalted1 : 1; /* bit 1; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 79                   */
         /* Description:                                                   */
         /**
          *    Set if AndOrTreeL1.anyhalted0 or AndOrTreeL1.anyhalted1 from 
          *    any of the Minion Shires 32 to 34 is set. This corresponds to 
          *    the halted status of 192 harts.
         */
         uint32_t anyhalted2 : 1; /* bit 2; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 83                   */
         /* Description:                                                   */
         /**
          *    Set if AndOrTreeL1.allhalted is set for each Minion shire in 
          *    the system with AndOrTreeL1.anyselected asserted.
         */
         uint32_t allhalted : 1; /* bit 3; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 87                   */
         /* Description:                                                   */
         /**
          *    Set if AndOrTreeL1.anyrunning from any of the Minion shires in
          *     the system is set
         */
         uint32_t anyrunning : 1; /* bit 4; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 91                   */
         /* Description:                                                   */
         /**
          *    Set if AndOrTreeL1.anyrunning from any of the Minion shires in
          *     the system is set
         */
         uint32_t allrunning : 1; /* bit 5; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 95                   */
         /* Description:                                                   */
         /**
          *    Set if AndOrTreeL1.allrunning is set for each Minion shire in 
          *    the system with AndOrTreeL1.anyselected asserted.
         */
         uint32_t anyresumehack : 1; /* bit 6; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 99                   */
         /* Description:                                                   */
         /**
          *    Set if AndOrTreeL1.allresumeack is set for each Minion shire 
          *    in the system with AndOrTreeL1.anyselected asserted.
         */
         uint32_t allresumehack : 1; /* bit 7; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 103                  */
         /* Description:                                                   */
         /**
          *    Set if AndOrTreeL1.anyhavereset from any of the Minion shires 
          *    in the system is set.
         */
         uint32_t anyhavereset : 1; /* bit 8; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 107                  */
         /* Description:                                                   */
         /**
          *    Set if AndOrTreeL1.allhavereset is set for each Minion shire 
          *    in the system with AndOrTreeL1.anyselected asserted.
         */
         uint32_t allhavereset : 1; /* bit 9; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 111                  */
         /* Description:                                                   */
         /**
          *    Set if AndOrTreeL0.anyunavailable from any neighborhood in the
          *     shire is set
         */
         uint32_t anyunavailable : 1; /* bit 10; R; 0 */
         uint32_t : 21; /* bits 31 to 11 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_AndOrTreeL2_t;

/* Typedef for Register: spio_misc_esr::SECURITY                           */
/* Source filename: spio_misc_esr.csr, line: 117                           */
/* Description:                                                            */
/**
 *    This is a read, write 1 to set register.  Writing to this register 
 *    results in an atomic bitwise OR of the current state of theregister and
 *     the value to be written to the register.  Reading the register returns
 *     it's current value.   Bit 0 of this register is a SPIO ROM lock bit, 
 *    which when set to 1 causes reads to the SPIO ROM to return all 0s.  The
 *     rest of the 31 bits in this register have no side effects and can be 
 *    used for miscellaneous purposes.
*/
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 123                  */
         /* Description:                                                   */
         /**
          *    RW1S.  Writing to this register results in an atomic bitwise 
          *    OR of the current state of the register and the value to be 
          *    written.  Reading the register returns the current value.  
          *    When this bit is set to one, reads to the SPIO ROM return all 
          *    0s.
         */
         uint32_t SPIO_ROM_Lock : 1; /* bit 0; R/WS1; 0 */

         /* Source filename: spio_misc_esr.csr, line: 133                  */
         /* Description:                                                   */
         /**
          *    RW1S.  Writing to this register results in an atomic bitwise 
          *    OR of the current state of the register and the value to be 
          *    written.  Reading the register returns the current value.  
          *    These bits have no other side effects and can be used by 
          *    softwarefor miscellaneous purposes.
         */
         uint32_t MISC_Security_RW1S : 31; /* bits 31 to 1; R/WS1; 0 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_SECURITY_t;

/* Typedef for Register: spio_misc_esr::SP_BYPASS_CACHE                    */
/* Source filename: spio_misc_esr.csr, line: 147                           */
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 148                  */
         /* Description:                                                   */
         /**
          *    If set, SP bypasses instruction cache.  Note the reset value 
          *    of this bit is set to 1.
         */
         uint32_t Bypass_ICache : 1; /* bit 0; R/W; 1 */

         /* Source filename: spio_misc_esr.csr, line: 152                  */
         /* Description:                                                   */
         /**
          *    If set, SP bypasses data cache.  Note the reset value of this 
          *    bit is set to 1.
         */
         uint32_t Bypass_DCache : 1; /* bit 1; R/W; 1 */
         uint32_t : 30; /* bits 31 to 2 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_SP_BYPASS_CACHE_t;

/* Typedef for Register: spio_misc_esr::SP_ICACHE_ECC_INT_PEND             */
/* Source filename: spio_misc_esr.csr, line: 158                           */
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 159                  */
         /* Description:                                                   */
         /**
          *    Read only.  Service processor instruction cache ECC error 
          *    interrupt pending bit.
         */
         uint32_t Interrupt_Pending : 1; /* bit 0; R; 0 */
         uint32_t : 31; /* bits 31 to 1 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_SP_ICACHE_ECC_INT_PEND_t;

/* Typedef for Register: spio_misc_esr::SP_ICACHE_ECC_INT_CLEAR            */
/* Source filename: spio_misc_esr.csr, line: 166                           */
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 167                  */
         /* Description:                                                   */
         /**
          *    Write 1 to this bit to clear the service processor instruction
          *     cache ECC error interrupt.  Read always returns 0.
         */
         uint32_t Interrupt_Clear : 1; /* bit 0; W1C; 0 */
         uint32_t : 31; /* bits 31 to 1 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_SP_ICACHE_ECC_INT_CLEAR_t;

/* Typedef for Register: spio_misc_esr::SP_ICACHE_ECC_INT_CAUSE_LO         */
/* Source filename: spio_misc_esr.csr, line: 175                           */
/* Description:                                                            */
/**
 *    Note the contents of this register are only valid when the 
 *    SP_ICACHE_ECC_INT_PEND interrupt pending bit is set.
*/
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 178                  */
         /* Description:                                                   */
         /**
          *    Read only.  Currently pending service processor instruction 
          *    cache ECC error interrupt is due to a single bit error
         */
         uint32_t single_bit_error : 1; /* bit 0; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 183                  */
         /* Description:                                                   */
         /**
          *    Read only.  Currently pending service processor instruction 
          *    cache ECC error interrupt is due to a double bit error.
         */
         uint32_t double_bit_error : 1; /* bit 1; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 188                  */
         /* Description:                                                   */
         /**
          *    Read Only.  Which instruction cache way the currently pending 
          *    service processor instruction cache ECC error interrupt the 
          *    error occurred in.
         */
         uint32_t error_way : 2; /* bits 3 to 2; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 193                  */
         /* Description:                                                   */
         /**
          *    Read only.  Which instruction cache set the currently pending 
          *    service processor instruction cache ECC error interrupt the 
          *    error occurred in.
         */
         uint32_t error_set : 7; /* bits 10 to 4; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 198                  */
         /* Description:                                                   */
         /**
          *    Read only.  Which instruction cache ECC block the currently 
          *    pending service processor instruction cache ECC error 
          *    interrupt the single bit error occurred in
         */
         uint32_t single_bit_error_block : 8; /* bits 18 to 11; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 203                  */
         /* Description:                                                   */
         /**
          *    Read only.  Which instruction cache ECC block the currently 
          *    pending service processor instruction cache ECC error 
          *    interrupt the double bit error occurred in.
         */
         uint32_t double_bit_error_block : 8; /* bits 26 to 19; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 208                  */
         /* Description:                                                   */
         /**
          *    Read only.  The lower 5 bits of the currently pending service 
          *    processor instruction cache ECC error address
         */
         uint32_t error_adddress_lo : 5; /* bits 31 to 27; R; 0 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_SP_ICACHE_ECC_INT_CAUSE_LO_t;

/* Typedef for Register: spio_misc_esr::SP_ICACHE_ECC_INT_CAUSE_HI         */
/* Source filename: spio_misc_esr.csr, line: 215                           */
/* Description:                                                            */
/**
 *    Note the contents of this register are only valid when the 
 *    SP_ICACHE_ECC_INT_PEND interrupt pending bit is set.
*/
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 218                  */
         /* Description:                                                   */
         /**
          *    Read only.  The upper 29 bits of the currently pending service
          *     processor instruction cache ECC error address.
         */
         uint32_t error_address_hi : 29; /* bits 28 to 0; R; 0 */

         /* Source filename: spio_misc_esr.csr, line: 223                  */
         /* Description:                                                   */
         /**
          *    Read only.  Set if another service processor instruction cache
          *     ECC error occurred while a service processor instruction 
          *    cache ECC error interrupt is pending.
         */
         uint32_t interrupt_overflow : 1; /* bit 29; R; 0 */
         uint32_t : 2; /* bits 31 to 30 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_SP_ICACHE_ECC_INT_CAUSE_HI_t;

/* Typedef for Register: spio_misc_esr::MAX_RESET_BOOT_VECTOR_LO           */
/* Source filename: spio_misc_esr.csr, line: 230                           */
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 231                  */
         /* Description:                                                   */
         /**
          *    Lower 32-bits of 40-bit Maxion reset boot vector.  Sets the 
          *    location Maxion cores vector to after deasserting reset
         */
         uint32_t addr : 32; /* bits 31 to 0; R/W; 0 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_MAX_RESET_BOOT_VECTOR_LO_t;

/* Typedef for Register: spio_misc_esr::MAX_RESET_BOOT_VECTOR_HI           */
/* Source filename: spio_misc_esr.csr, line: 237                           */
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 238                  */
         /* Description:                                                   */
         /**
          *    Upper 8-bits of 40-bit Maxion reset boot vector.  Sets the 
          *    location Maxion cores vector to after deasserting reset
         */
         uint32_t addr : 8; /* bits 7 to 0; R/W; 0 */
         uint32_t : 24; /* bits 31 to 8 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_MAX_RESET_BOOT_VECTOR_HI_t;

/* Typedef for Register: spio_misc_esr::MAXSHIRE_L2HPF_CTRL                */
/* Source filename: spio_misc_esr.csr, line: 244                           */
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 245                  */
         /* Description:                                                   */
         /**
          *    If this bit is set, the Maxion Shire L2 hardware prefetcher is
          *     disabled (held in reset).
         */
         uint32_t maxshire_l2hpf_disable : 1; /* bit 0; R/W; 0 */

         /* Source filename: spio_misc_esr.csr, line: 249                  */
         /* Description:                                                   */
         /**
          *    Writing one to this bit triggers a flush of the Maxion Shire 
          *    L2 hardware prefetcher.  Read always returns 0.
         */
         uint32_t maxshire_l2hpf_flush : 1; /* bit 1; W1S; 0 */
         uint32_t : 30; /* bits 31 to 2 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_MAXSHIRE_L2HPF_CTRL_t;

/* Typedef for Register: spio_misc_esr::PU_USB20_UST_EN                    */
/* Source filename: spio_misc_esr.csr, line: 256                           */
typedef struct {
   union {
      struct {

         /* Source filename: spio_misc_esr.csr, line: 257                  */
         /* Description:                                                   */
         /**
          *    This bit controls the ust_usb2_en_ip pin on the UltraSoC USB 
          *    communicator hub.  If this bit is set to 0, the USB 
          *    communicator hub is completely bypassed and the USB PHY is 
          *    connected directly to the Synopsys USB controller.  If this 
          *    bit is set to 1, the USB communicator hub is not bypassed and 
          *    both the Synopsys USB controller and the UltraSoC USB 
          *    controller can be accessed. See the USB2 Device or UltraSoC 
          *    Debug MAS for more details.
         */
         uint32_t enable : 1; /* bit 0; R/W; 1 */
         uint32_t : 31; /* bits 31 to 1 */
      } B;
      uint32_t R;
   } ;
} Spio_misc_esr_PU_USB20_UST_EN_t;

/* Typedef for Addressmap: spio_misc_esr                                   */
/* Source filename: spio_misc_esr.csr, line: 262                           */
/* Description:                                                            */
/**
 *    SPIO Miscellaneous ESRs
*/
typedef struct {
   Spio_misc_esr_VAULT_DMA_R_RELOC_t VAULT_DMA_R_RELOC; /**< Offset 0x0 (R/W) */
   Spio_misc_esr_VAULT_DMA_WR_RELOC_t VAULT_DMA_WR_RELOC; /**< Offset 0x4 (R/W) */
   Spio_misc_esr_DMCTRL_t DMCTRL; /**< Offset 0x8 (R/W) */
   Spio_misc_esr_AndOrTreeL2_t AndOrTreeL2; /**< Offset 0xc (R) */
   Spio_misc_esr_SECURITY_t SECURITY; /**< Offset 0x10 (R/W) */
   Spio_misc_esr_SP_BYPASS_CACHE_t SP_BYPASS_CACHE; /**< Offset 0x14 (R/W) */
   Spio_misc_esr_SP_ICACHE_ECC_INT_PEND_t SP_ICACHE_ECC_INT_PEND; /**< Offset 0x18 (R) */
   Spio_misc_esr_SP_ICACHE_ECC_INT_CLEAR_t SP_ICACHE_ECC_INT_CLEAR; /**< Offset 0x1c (W) */
   Spio_misc_esr_SP_ICACHE_ECC_INT_CAUSE_LO_t SP_ICACHE_ECC_INT_CAUSE_LO; /**< Offset 0x20 (R) */
   Spio_misc_esr_SP_ICACHE_ECC_INT_CAUSE_HI_t SP_ICACHE_ECC_INT_CAUSE_HI; /**< Offset 0x24 (R) */
   Spio_misc_esr_MAX_RESET_BOOT_VECTOR_LO_t MAX_RESET_BOOT_VECTOR_LO; /**< Offset 0x28 (R/W) */
   Spio_misc_esr_MAX_RESET_BOOT_VECTOR_HI_t MAX_RESET_BOOT_VECTOR_HI; /**< Offset 0x2c (R/W) */
   Spio_misc_esr_MAXSHIRE_L2HPF_CTRL_t MAXSHIRE_L2HPF_CTRL; /**< Offset 0x30 (R/W) */
   Spio_misc_esr_PU_USB20_UST_EN_t PU_USB20_UST_EN; /**< Offset 0x34 (R/W) */
} Spio_misc_esr_t;

#endif
